<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OkHttp原理解析--网络模块 | Learn OS concepts by coding them!</title><meta name="keywords" content="开源框架,okhttp"><meta name="author" content="Jack Ou"><meta name="copyright" content="Jack Ou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="本篇主要记录Okhttp开源框架原理分析，以及常用的状态码含义。">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp原理解析--网络模块">
<meta property="og:url" content="https://oujie123.github.io/2021/07/09/OkHttp%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="Learn OS concepts by coding them!">
<meta property="og:description" content="本篇主要记录Okhttp开源框架原理分析，以及常用的状态码含义。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/13838098-e34fb51997ae33f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2021-07-09T07:55:52.000Z">
<meta property="article:modified_time" content="2021-12-14T15:22:03.245Z">
<meta property="article:author" content="Jack Ou">
<meta property="article:tag" content="开源框架">
<meta property="article:tag" content="okhttp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/13838098-e34fb51997ae33f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><link rel="shortcut icon" href="https://upload-images.jianshu.io/upload_images/13838098-8a5cd66eafd7c761.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><link rel="canonical" href="https://oujie123.github.io/2021/07/09/OkHttp%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Jack Ou","link":"链接: ","source":"来源: Learn OS concepts by coding them!","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-14 23:22:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://upload-images.jianshu.io/upload_images/13838098-a7dfe0e9d3ed649c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">106</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分栏</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://upload-images.jianshu.io/upload_images/13838098-e34fb51997ae33f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Learn OS concepts by coding them!</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分栏</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OkHttp原理解析--网络模块</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-09T07:55:52.000Z" title="发表于 2021-07-09 15:55:52">2021-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-14T15:22:03.245Z" title="更新于 2021-12-14 23:22:03">2021-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-OkHttp原理解析"><a href="#1-OkHttp原理解析" class="headerlink" title="1 OkHttp原理解析"></a>1 OkHttp原理解析</h2><blockquote>
<p>OkHttp 3.10.0版本，最新OkHttp为：4.0.1逻辑与3版本并没有太大变化，但是改为kotlin实现。</p>
</blockquote>
<h2 id="2-OkHttp介绍"><a href="#2-OkHttp介绍" class="headerlink" title="2 OkHttp介绍"></a>2 OkHttp介绍</h2><p>OkHttp是当下Android使用最频繁的网络请求框架，由Square公司开源。Google在Android4.4以后开始将源码中的HttpURLConnection底层实现替换为OKHttp，同时现在流行的Retrofit框架底层同样是使用OKHttp的。</p>
<p>优点:</p>
<ul>
<li>支持Spdy、Http1.X、Http2、Quic以及WebSocket</li>
<li>连接池复用底层TCP(Socket)，减少请求延时</li>
<li>无缝的支持GZIP减少数据流量</li>
<li>缓存响应数据减少重复的网络请求</li>
<li>请求失败自动重试主机的其他ip，自动重定向</li>
<li>…….</li>
</ul>
<h2 id="3-使用流程"><a href="#3-使用流程" class="headerlink" title="3 使用流程"></a>3 使用流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/13838098-781f8b5fd6149fff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用流程.png"></p>
<p>在使用OkHttp发起一次请求时，对于使用者最少存在<code>OkHttpClient</code>、<code>Request</code>与<code>Call</code>三个角色。其中<code>OkHttpClient</code>和<code>Request</code>的创建可以使用它为我们提供的<code>Builder</code>（建造者模式）。而<code>Call</code>则是把<code>Request</code>交给<code>OkHttpClient</code>之后返回的一个已准备好执行的请求。</p>
<blockquote>
<p>建造者模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。实例化OKHttpClient和Request的时候，因为有太多的属性需要设置，而且开发者的需求组合千变万化，使用建造者模式可以让用户不需要关心这个类的内部细节，配置好后，建造者会帮助我们按部就班的初始化表示对象</p>
</blockquote>
<p>同时OkHttp在设计时采用的门面模式，将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端OkHttpClient统一暴露出来。</p>
<p><code>OkHttpClient</code>中全是一些配置，比如代理的配置、ssl证书的配置等。而<code>Call</code>本身是一个接口，我们获得的实现为:<code>RealCall</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Call</code>的<code>execute</code>代表了同步请求，而<code>enqueue</code>则代表异步请求。两者唯一区别在于一个会直接发起网络请求，而另一个使用OkHttp内置的线程池来进行。这就涉及到OkHttp的任务分发器。</p>
<h2 id="4-分发器"><a href="#4-分发器" class="headerlink" title="4 分发器"></a>4 分发器</h2><p><code>Dispatcher</code>，分发器就是来调配请求任务的，内部会包含一个线程池。可以在创建<code>OkHttpClient</code>时，传递我们自己定义的线程池来创建分发器。</p>
<p>这个Dispatcher中的成员有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步请求同时存在的最大请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//异步请求同一域名同时存在的最大请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//闲置任务(没有请求时可执行一些任务，由使用者设置)</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步请求使用的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步请求等待执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步请求正在执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步请求正在执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">	runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为同步请求不需要线程池，也不存在任何限制。所以分发器仅做一下记录。</p>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) 	  &#123;</span><br><span class="line">		runningAsyncCalls.add(call);</span><br><span class="line">		executorService().execute(call);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		readyAsyncCalls.add(call);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当正在执行的任务未超过最大限制64，同时<code>runningCallsForHost(call) &lt; maxRequestsPerHost</code>同一Host的请求不超过5个，则会添加到正在执行队列，同时提交给线程池。否则先加入等待队列。</p>
<p>加入线程池直接执行没啥好说的，但是如果加入等待队列后，就需要等待有空闲名额才开始执行。因此每次执行完一个请求后，都会调用分发器的<code>finished</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步请求调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">	finished(runningAsyncCalls, call, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步请求调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">	finished(runningSyncCalls, call, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> runningCallsCount;</span><br><span class="line">	Runnable idleCallback;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//不管异步还是同步，执行完后都要从队列移除(runningSyncCalls/runningAsyncCalls)</span></span><br><span class="line">		<span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">        <span class="comment">//异步任务和同步任务正在执行的和</span></span><br><span class="line">		runningCallsCount = runningCallsCount();</span><br><span class="line">		idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没有任务执行，执行闲置任务</span></span><br><span class="line">	<span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">		idleCallback.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 只有异步任务才会存在限制与等待，所以在执行完了移除正在执行队列中的元素后，异步任务结束会执行<code>promoteCalls()</code>。很显然这个方法肯定会重新调配请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果任务满了直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">//没有等待执行的任务，返回</span></span><br><span class="line">	<span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">//遍历等待执行队列</span></span><br><span class="line">	<span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">		AsyncCall call = i.next();</span><br><span class="line">        <span class="comment">//等待任务想要执行，还需要满足：这个等待任务请求的Host不能已经存在5个了</span></span><br><span class="line">		<span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">			i.remove();</span><br><span class="line">			runningAsyncCalls.add(call);</span><br><span class="line">			executorService().execute(call);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在满足条件下，会把等待队列中的任务移动到<code>runningAsyncCalls</code>并交给线程池执行。所以分发器到这里就完了。逻辑上还是非常简单的。</p>
<h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p>用户是不需要直接操作任务分发器的，获得的<code>RealCall </code>中就分别提供了<code>execute</code>与<code>enqueue</code>来开始同步请求或异步请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用分发器</span></span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//执行请求</span></span><br><span class="line">      Response result = getResponseWithInterceptorChain();</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.callFailed(<span class="keyword">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//请求完成</span></span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步请求的后续同时是调用<code>getResponseWithInterceptorChain()</code>来执行请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">		executed = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	captureCallStackTrace();</span><br><span class="line">	eventListener.callStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//调用分发器</span></span><br><span class="line">	client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该<code>RealCall</code>已经执行过了，再次执行是不允许的。异步请求会把一个<code>AsyncCall</code>提交给分发器。</p>
<p><code>AsyncCall</code>实际上是一个<code>Runnable</code>的子类,使用线程启动一个<code>Runnable</code>时会执行<code>run</code>方法，在<code>AsyncCall</code>中被重定向到<code>execute</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">	AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;OkHttp %s&quot;</span>, redactedUrl());</span><br><span class="line">		<span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池执行</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">       <span class="comment">//.......</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//请求完成</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = Util.format(format, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String oldName = Thread.currentThread().getName();</span><br><span class="line">        Thread.currentThread().setName(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            execute();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(oldName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时<code>AsyncCall</code>也是<code>RealCall</code>的普通内部类，这意味着它是持有外部类<code>RealCall</code>的引用，可以获得直接调用外部类的方法。</p>
<p>可以看到无论是同步还是异步请求实际上真正执行请求的工作都在<code>getResponseWithInterceptorChain()</code>中。这个方法就是整个OkHttp的核心：拦截器责任链。但是在介绍责任链之前，我们再来回顾一下线程池的基础知识。</p>
<h3 id="分发器线程池"><a href="#分发器线程池" class="headerlink" title="分发器线程池"></a>分发器线程池</h3><p>前面我们提过，分发器就是来调配请求任务的，内部会包含一个线程池。当异步请求时，会将请求任务交给线程池来执行。那分发器中默认的线程池是如何定义的呢？为什么要这么定义？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">          					<span class="number">0</span>,   				<span class="comment">//核心线程</span></span><br><span class="line">                            Integer.MAX_VALUE,  <span class="comment">//最大线程</span></span><br><span class="line">                            <span class="number">60</span>,					<span class="comment">//空闲线程闲置时间</span></span><br><span class="line">                            TimeUnit.SECONDS,	<span class="comment">//闲置时间单位</span></span><br><span class="line">                            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), <span class="comment">//线程等待队列</span></span><br><span class="line">                            Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="keyword">false</span>) <span class="comment">//线程创建工厂</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在OkHttp的分发器中的线程池定义如上，其实就和<code>Executors.newCachedThreadPool()</code>创建的线程一样。首先核心线程为0，表示线程池不会一直为我们缓存线程，线程池中所有线程都是在60s内没有工作就会被回收。而最大线程<code>Integer.MAX_VALUE</code>与等待队列<code>SynchronousQueue</code>的组合能够得到最大的吞吐量。<strong>即当需要线程池执行任务时，如果不存在空闲线程不需要等待，马上新建线程执行任务！等待队列的不同指定了线程池的不同排队机制。</strong>一般来说，等待队列<code>BlockingQueue</code>有：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>与<code>SynchronousQueue</code>。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下：</p>
<p><code>ArrayBlockingQueue</code>：基于数组的阻塞队列，初始化需要指定固定大小。</p>
<p>​    当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p><code>LinkedBlockingQueue</code>：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p>​    当指定大小后，行为就和<code>ArrayBlockingQueu</code>一致。而如果未指定大小，则会使用默认的<code>Integer.MAX_VALUE</code>作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p><code>SynchronousQueue</code> : 无容量的队列。</p>
<p>​    <strong>使用此队列意味着希望获得最大并发量。</strong>因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合<code>Integer.MAX_VALUE</code>就实现了真正的无等待。</p>
<p>但是需要注意的时，我们都知道，进程的内存是存在限制的，而每一个线程都需要分配一定的内存。所以线程并不能无限个数。那么当设置最大线程数为<code>Integer.MAX_VALUE</code>时，OkHttp同时还有最大请求任务执行个数: 64的限制。这样即解决了这个问题同时也能获得最大吞吐。</p>
<h2 id="5-拦截器责任链"><a href="#5-拦截器责任链" class="headerlink" title="5 拦截器责任链"></a>5 拦截器责任链</h2><p>OkHttp最核心的工作是在<code>getResponseWithInterceptorChain()</code>中进行，在进入这个方法分析之前，我们先来了解什么是责任链模式，因为此方法就是利用的责任链模式完成一步步的请求。</p>
<p>责任链顾名思义就是由一系列的负责者构成的一个链条，类似于工厂流水线。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。比如：</p>
<blockquote>
<p>七夕节刚过去。周周同学（<em>我也不知道为什么第一个想到的就是周周同学</em>）在读书的时候就是单身狗一条，看到自习室每天都很多美女后，每天晚上跑去自习都干同一件事情。</p>
<p>周周每天晚上都坐到自习室最后一排，找张纸条写上：“Hi,可以做我的女朋友吗？如果不愿意请向前传”。纸条就一个接一个的传上去了，最后传给了扫地阿姨。最后和扫地阿姨过上了幸福的生活，这真是一个….令人高兴的故事。</p>
</blockquote>
<p>那整个过程是什么样子的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传送者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmit</span></span>&#123;</span><br><span class="line">    <span class="comment">//责任链中下一个传递者</span></span><br><span class="line">    <span class="keyword">protected</span> Transmit nextTransmit;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">request</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextTransmit</span><span class="params">(Transmit transmit)</span></span>&#123;</span><br><span class="line">        nextTransmit = transmit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zero</span> <span class="keyword">extends</span> <span class="title">Transmit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">request</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zero接到纸条,会心一笑&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> resp = nextTransmit.request(msg); </span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alvin</span> <span class="keyword">extends</span> <span class="title">Transmit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">request</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Alvin接到纸条,伤心欲绝”);</span></span><br><span class="line"><span class="string">        boolean resp = nextTransmit.request(); </span></span><br><span class="line"><span class="string">        return resp;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public class Lucy extends Transmit&#123;</span></span><br><span class="line"><span class="string">    public boolean request(String msg)&#123;</span></span><br><span class="line"><span class="string">	   System.out.println(&quot;</span>Lucy 王翠花阿姨接到纸条，兴高采烈<span class="string">&quot;);</span></span><br><span class="line"><span class="string">       return true;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">                           </span></span><br><span class="line"><span class="string">private static Transmit getTransmits()&#123;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">      Transmit zero = new Zero();</span></span><br><span class="line"><span class="string">      Transmit alvin = new Alvin();</span></span><br><span class="line"><span class="string">      Lucy lucy = new Lucy();</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">      zero.setNextTransmit(alvin);</span></span><br><span class="line"><span class="string">      alvin.setNextTransmit(lucy);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">      return errorLogger;  </span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">      Transmit transmit = getTransmits();</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">      transmit.request(&quot;</span>Hi,可以做我的女朋友吗？<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在责任链模式中，每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<h3 id="拦截器流程"><a href="#拦截器流程" class="headerlink" title="拦截器流程"></a>拦截器流程</h3><p>而OkHttp中的<code>getResponseWithInterceptorChain()</code>中经历的流程为</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b6679e6c472929ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拦截器责任链.png"></p>
<p>请求会被交给责任链中的一个个拦截器。默认情况下有五大拦截器：</p>
<ol>
<li><p><code>RetryAndFollowUpInterceptor</code></p>
<p>第一个接触到请求，最后接触到响应；负责判断是否需要重新发起整个请求</p>
</li>
<li><p><code>BridgeInterceptor</code></p>
<p>补全请求，并对响应进行额外处理</p>
</li>
<li><p><code>CacheInterceptor</code></p>
<p>请求前查询缓存，获得响应并判断是否需要缓存</p>
</li>
<li><p><code>ConnectInterceptor</code></p>
<p>与服务器完成TCP连接</p>
</li>
<li><p><code>CallServerInterceptor</code></p>
<p>与服务器通信；封装请求数据与解析响应数据(如：HTTP报文)</p>
</li>
</ol>
<h3 id="拦截器详情"><a href="#拦截器详情" class="headerlink" title="拦截器详情"></a>拦截器详情</h3><h4 id="一、重试及重定向拦截器"><a href="#一、重试及重定向拦截器" class="headerlink" title="一、重试及重定向拦截器"></a>一、重试及重定向拦截器</h4><p>第一个拦截器:<code>RetryAndFollowUpInterceptor</code>，主要就是完成两件事情：重试与重定向。</p>
<h5 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h5><p>请求阶段发生了 RouteException 或者 IOException会进行判断是否重新发起请求。</p>
<p>RouteException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">	<span class="comment">//todo 路由异常，连接未成功，请求还没发出去</span></span><br><span class="line">    <span class="keyword">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">    &#125;</span><br><span class="line">    releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>IOException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	<span class="comment">//todo 请求发出去了，但是和服务器通信失败了。(socket流正在读写数据的时候断开连接)</span></span><br><span class="line">    <span class="comment">// ConnectionShutdownException只对HTTP2存在。假定它就是false</span></span><br><span class="line">	<span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">	<span class="keyword">if</span> (!recover(e, streamAllocation, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">		releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>两个异常都是根据<code>recover</code> 方法判断是否能够进行重试，如果返回<code>true</code>，则表示允许重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(IOException e, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;</span><br><span class="line">	streamAllocation.streamFailed(e);</span><br><span class="line">	<span class="comment">//todo 1、在配置OkhttpClient时设置了不允许重试（默认允许），则一旦发生请求失败就不再重试</span></span><br><span class="line">	<span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//todo 2、由于requestSendStarted只在http2的io异常中为true，先不管http2</span></span><br><span class="line">	<span class="keyword">if</span> (requestSendStarted &amp;&amp; userRequest.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//todo 3、判断是不是属于重试的异常</span></span><br><span class="line">	<span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//todo 4、有没有可以用来连接的路由路线</span></span><br><span class="line">	<span class="keyword">if</span> (!streamAllocation.hasMoreRoutes()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以首先使用者在不禁止重试的前提下，如果出现了<strong>某些异常</strong>，并且存在更多的路由线路，则会尝试换条线路进行请求的重试。其中<strong>某些异常</strong>是在<code>isRecoverable</code>中进行判断:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRecoverable</span><span class="params">(IOException e, <span class="keyword">boolean</span> requestSendStarted)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 出现协议异常，不能重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ProtocolException) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// requestSendStarted认为它一直为false(不管http2),异常属于socket超时异常,直接判定可以重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedIOException) &#123;</span><br><span class="line">      <span class="keyword">return</span> e <span class="keyword">instanceof</span> SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSL握手异常中，证书出现问题，不能重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLHandshakeException) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> CertificateException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SSL握手未授权异常 不能重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、<strong>协议异常</strong>，如果是那么直接判定不能重试;（你的请求或者服务器的响应本身就存在问题，没有按照http协议来定义数据，再重试也没用）</p>
<!--比如在发起Http请求时，没有携带`Host:xxxxx`，这就是一个协议异常。 -->
<p>2、<strong>超时异常</strong>，可能由于网络波动造成了Socket管道的超时，那有什么理由不重试？(后续还会涉及到路由)</p>
<p>3、<strong>SSL证书异常/SSL验证失败异常</strong>，前者是证书验证失败，后者可能就是压根就没证书，或者证书数据不正确，那还怎么重试</p>
<p>经过了异常的判定之后，如果仍然允许进行重试，就会再检查当前有没有可用路由路线来进行连接。简单来说，比如 DNS 对域名解析后可能会返回多个 IP，在一个IP失败后，尝试另一个IP进行重试。</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>如果请求结束后没有发生异常并不代表当前获得的响应就是最终需要交给用户的，还需要进一步来判断是否需要重定向的判断。重定向的判断位于<code>followUpRequest</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">followUpRequest</span><span class="params">(Response userResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    Connection connection = streamAllocation.connection();</span><br><span class="line">    Route route = connection != <span class="keyword">null</span></span><br><span class="line">        ? connection.route()</span><br><span class="line">        : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String method = userResponse.request().method();</span><br><span class="line">    <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">      <span class="comment">// 407 客户端使用了HTTP代理服务器，在请求头中添加 “Proxy-Authorization”，让代理服务器授权</span></span><br><span class="line">      <span class="keyword">case</span> HTTP_PROXY_AUTH:</span><br><span class="line">        Proxy selectedProxy = route != <span class="keyword">null</span></span><br><span class="line">            ? route.proxy()</span><br><span class="line">            : client.proxy();</span><br><span class="line">        <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);</span><br><span class="line">      <span class="comment">// 401 需要身份验证 有些服务器接口需要验证使用者身份 在请求头中添加 “Authorization” </span></span><br><span class="line">      <span class="keyword">case</span> HTTP_UNAUTHORIZED:</span><br><span class="line">        <span class="keyword">return</span> client.authenticator().authenticate(route, userResponse);</span><br><span class="line">      <span class="comment">// 308 永久重定向 </span></span><br><span class="line">      <span class="comment">// 307 临时重定向</span></span><br><span class="line">      <span class="keyword">case</span> HTTP_PERM_REDIRECT:</span><br><span class="line">      <span class="keyword">case</span> HTTP_TEMP_REDIRECT:</span><br><span class="line">        <span class="comment">// 如果请求方式不是GET或者HEAD，框架不会自动重定向请求</span></span><br><span class="line">        <span class="keyword">if</span> (!method.equals(<span class="string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 300 301 302 303 </span></span><br><span class="line">      <span class="keyword">case</span> HTTP_MULT_CHOICE:</span><br><span class="line">      <span class="keyword">case</span> HTTP_MOVED_PERM:</span><br><span class="line">      <span class="keyword">case</span> HTTP_MOVED_TEMP:</span><br><span class="line">      <span class="keyword">case</span> HTTP_SEE_OTHER:</span><br><span class="line">        <span class="comment">// 如果用户不允许重定向，那就返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从响应头取出location </span></span><br><span class="line">        String location = userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据location 配置新的请求 url</span></span><br><span class="line">        HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line">        <span class="comment">// 如果为null，说明协议有问题，取不出来HttpUrl，那就返回null，不进行重定向</span></span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果重定向在http到https之间切换，需要检查用户是不是允许(默认允许)</span></span><br><span class="line">        <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">        <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *  重定向请求中 只要不是 PROPFIND 请求，无论是POST还是其他的方法都要改为GET请求方式，</span></span><br><span class="line"><span class="comment">		 *  即只有 PROPFIND 请求才能有请求体</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//请求不是get与head</span></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">           <span class="comment">// 除了 PROPFIND 请求之外都改成GET请求</span></span><br><span class="line">          <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">            requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="keyword">null</span>;</span><br><span class="line">            requestBuilder.method(method, requestBody);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 不是 PROPFIND 的请求，把请求头中关于请求体的数据删掉</span></span><br><span class="line">          <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在跨主机重定向时，删除身份验证请求头</span></span><br><span class="line">        <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">          requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 408 客户端请求超时 </span></span><br><span class="line">      <span class="keyword">case</span> HTTP_CLIENT_TIMEOUT:</span><br><span class="line">        <span class="comment">// 408 算是连接失败了，所以判断用户是不是允许重试</span></span><br><span class="line">       	<span class="keyword">if</span> (!client.retryOnConnectionFailure()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// UnrepeatableRequestBody实际并没发现有其他地方用到</span></span><br><span class="line">		<span class="keyword">if</span> (userResponse.request().body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是本身这次的响应就是重新请求的产物同时上一次之所以重请求还是因为408，那我们这次不再重请求了</span></span><br><span class="line">		<span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果服务器告诉我们了 Retry-After 多久后重试，那框架不管了。</span></span><br><span class="line">		<span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> userResponse.request();</span><br><span class="line">	   <span class="comment">// 503 服务不可用 和408差不多，但是只在服务器告诉你 Retry-After：0（意思就是立即重试） 才重请求</span></span><br><span class="line"> 	   <span class="keyword">case</span> HTTP_UNAVAILABLE:</span><br><span class="line">		<span class="keyword">if</span> (userResponse.priorResponse() != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">         	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">         	<span class="keyword">return</span> userResponse.request();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个是否需要重定向的判断内容很多，记不住，这很正常，关键在于理解他们的意思。如果此方法返回空，那就表示不需要再重定向了，直接返回响应；但是如果返回非空，那就要重新请求返回的<code>Request</code>，但是需要注意的是，我们的<code>followup</code>在拦截器中定义的最大次数为<strong>20</strong>次。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本拦截器是整个责任链中的第一个，这意味着它会是首次接触到<code>Request</code>与最后接收到<code>Response</code>的角色，在这个拦截器中主要功能就是判断是否需要重试与重定向。</p>
<p><strong>重试的前提是出现了<code>RouteException</code>或者<code>IOException</code>。一但在后续的拦截器执行过程中出现这两个异常，就会通过<code>recover</code>方法进行判断是否进行连接重试。</strong></p>
<p>重定向发生在重试的判定之后，如果不满足重试的条件，还需要进一步调用<code>followUpRequest</code>根据<code>Response</code> 的响应码(当然，如果直接请求失败，<code>Response</code>都不存在就会抛出异常)。<code>followup</code>最大发生20次。</p>
<h4 id="二、桥接拦截器"><a href="#二、桥接拦截器" class="headerlink" title="二、桥接拦截器"></a>二、桥接拦截器</h4><p><code>BridgeInterceptor</code>，连接应用程序和服务器的桥梁，我们发出的请求将会经过它的处理才能发给服务器，比如设置请求内容长度，编码，gzip压缩，cookie等，获取响应后保存Cookie等操作。这个拦截器相对比较简单。</p>
<p>补全请求头: </p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Content-Type</code></td>
<td>请求体类型,如：<code>application/x-www-form-urlencoded</code></td>
</tr>
<tr>
<td><code>Content-Length</code>/<code>Transfer-Encoding</code></td>
<td>请求体解析方式</td>
</tr>
<tr>
<td><code>Host</code></td>
<td>请求的主机站点</td>
</tr>
<tr>
<td><code>Connection: Keep-Alive</code></td>
<td>保持长连接</td>
</tr>
<tr>
<td><code>Accept-Encoding: gzip</code></td>
<td>接受响应支持gzip压缩</td>
</tr>
<tr>
<td><code>Cookie</code></td>
<td>cookie身份辨别</td>
</tr>
<tr>
<td><code>User-Agent</code></td>
<td>请求的用户信息，如:操作系统、浏览器等</td>
</tr>
</tbody></table>
<p>在补全了请求头后交给下一个拦截器处理，得到响应后，主要干两件事情：</p>
<p>1、保存cookie，在下次请求则会读取对应的数据设置进入请求头，默认的<code>CookieJar</code>不提供实现</p>
<p>2、如果使用gzip返回的数据，则使用<code>GzipSource</code>包装便于解析。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>桥接拦截器的执行逻辑主要就是以下几点</p>
<p>对用户构建的<code>Request</code>进行添加或者删除相关头部信息，以转化成能够真正进行网络请求的<code>Request</code><br>将符合网络请求规范的Request交给下一个拦截器处理，并获取<code>Response</code><br><strong>如果响应体经过了GZIP压缩，那就需要解压，再构建成用户可用的<code>Response</code>并返回</strong></p>
<h4 id="三、缓存拦截器"><a href="#三、缓存拦截器" class="headerlink" title="三、缓存拦截器"></a>三、缓存拦截器</h4><p><code>CacheInterceptor</code>，在发出请求前，判断是否命中缓存。如果命中则可以不请求，直接使用缓存的响应。 (<strong>只会存在Get请求的缓存</strong>)</p>
<p>步骤为:</p>
<p>1、从缓存中获得对应请求的响应缓存</p>
<p>2、创建<code>CacheStrategy</code> ,创建时会判断是否能够使用缓存，在<code>CacheStrategy</code> 中存在两个成员:<code>networkRequest</code>与<code>cacheResponse</code>。他们的组合如下:</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Null</td>
<td>Not Null</td>
<td>直接使用缓存</td>
</tr>
<tr>
<td>Not Null</td>
<td>Null</td>
<td>向服务器发起请求</td>
</tr>
<tr>
<td>Null</td>
<td>Null</td>
<td>直接gg，okhttp直接返回504</td>
</tr>
<tr>
<td>Not Null</td>
<td>Not Null</td>
<td>发起请求，若得到响应为304(无修改)，则更新缓存响应并返回</td>
</tr>
</tbody></table>
<p>3、交给下一个责任链继续处理</p>
<p>4、后续工作，返回304则用缓存的响应；否则使用网络响应并缓存本次响应（只缓存Get请求的响应）</p>
<p>缓存拦截器的工作说起来比较简单，但是具体的实现，需要处理的内容很多。在缓存拦截器中判断是否可以使用缓存，或是请求服务器都是通过<code>CacheStrategy</code>判断。</p>
<h5 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h5><p><code>CacheStrategy</code>。首先需要认识几个请求头与响应头</p>
<table>
<thead>
<tr>
<th>响应头</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Date</td>
<td>消息发送的时间</td>
<td>Date: Sat, 18 Nov 2028 06:17:41 GMT</td>
</tr>
<tr>
<td>Expires</td>
<td>资源过期的时间</td>
<td>Expires: Sat, 18 Nov 2028 06:17:41 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源最后修改时间</td>
<td>Last-Modified: Fri, 22 Jul 2016 02:57:17 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>资源在服务器的唯一标识</td>
<td>ETag: “16df0-5383097a03d40”</td>
</tr>
<tr>
<td>Age</td>
<td>服务器用缓存响应请求，该缓存从产生到现在经过多长时间(秒)</td>
<td>Age: 3825683</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>If-Modified-Since</code></td>
<td>服务器没有在指定的时间后修改请求对应资源,返回304(无修改)</td>
<td>If-Modified-Since: Fri, 22 Jul 2016 02:57:17 GMT</td>
</tr>
<tr>
<td><code>If-None-Match</code></td>
<td>服务器将其与请求对应资源的<code>Etag</code>值进行比较，匹配返回304</td>
<td>If-None-Match: “16df0-5383097a03d40”</td>
</tr>
<tr>
<td><code>Cache-Control</code></td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>其中<code>Cache-Control</code>可以在请求头存在，也能在响应头存在，对应的value可以设置多种组合：</p>
<ol>
<li><code>max-age=[秒]</code> ：资源最大有效时间;</li>
<li><code>public</code> ：表明该资源可以被任何用户缓存，比如客户端，代理服务器等都可以缓存资源;</li>
<li><code>private</code>：表明该资源只能被单个用户缓存，默认是private。</li>
<li><code>no-store</code>：资源不允许被缓存</li>
<li><code>no-cache</code>：(请求)不使用缓存</li>
<li><code>immutable</code>：(响应)资源不会改变</li>
<li> <code> min-fresh=[秒]</code>：(请求)缓存最小新鲜度(用户认为这个缓存有效的时长)</li>
<li><code>must-revalidate</code>：(响应)不允许使用过期缓存</li>
<li><code>max-stale=[秒]</code>：(请求)缓存过期后多久内仍然有效</li>
</ol>
<blockquote>
<p>假设存在max-age=100，min-fresh=20。这代表了用户认为这个缓存的响应，从服务器创建响应 到 能够缓存使用的时间为100-20=80s。但是如果max-stale=100。这代表了缓存有效时间80s过后，仍然允许使用100s，可以看成缓存有效时长为180s。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6bd4de0c3fbd807e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存控制.png"></p>
<h5 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h5><p>如果从缓存中获得了本次请求URL对应的<code>Response</code>，首先会从响应中获得以上数据备用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">long</span> nowMillis, Request request, Response cacheResponse)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nowMillis = nowMillis;</span><br><span class="line">            <span class="keyword">this</span>.request = request;</span><br><span class="line">            <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//对应响应的请求发出的本地时间 和 接收到响应的本地时间</span></span><br><span class="line">                <span class="keyword">this</span>.sentRequestMillis = cacheResponse.sentRequestAtMillis();</span><br><span class="line">                <span class="keyword">this</span>.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();</span><br><span class="line">                Headers headers = cacheResponse.headers();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">                    String fieldName = headers.name(i);</span><br><span class="line">                    String value = headers.value(i);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;Date&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        servedDate = HttpDate.parse(value);</span><br><span class="line">                        servedDateString = value;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Expires&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        expires = HttpDate.parse(value);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Last-Modified&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        lastModified = HttpDate.parse(value);</span><br><span class="line">                        lastModifiedString = value;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ETag&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        etag = value;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Age&quot;</span>.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">                        ageSeconds = HttpHeaders.parseSeconds(value, -<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>判断缓存的命中会使用<code>get()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CacheStrategy candidate = getCandidate();</span><br><span class="line">	<span class="comment">//todo 如果可以使用缓存，那networkRequest必定为null；指定了只使用缓存但是networkRequest又不为null，冲突。那就gg(拦截器返回504)</span></span><br><span class="line">	<span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">		<span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中调用<code>getCandidate()</code>方法来完成真正的缓存判断。</p>
<h6 id="1、缓存是否存在"><a href="#1、缓存是否存在" class="headerlink" title="1、缓存是否存在"></a>1、缓存是否存在</h6><p>整个方法中的第一个判断是缓存是不是存在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cacheResponse</code>是从缓存中找到的响应，如果为null，那就表示没有找到对应的缓存，创建的<code>CacheStrategy</code>实例对象只存在<code>networkRequest</code>，这代表了需要发起网络请求。</p>
<h6 id="2、https请求的缓存"><a href="#2、https请求的缓存" class="headerlink" title="2、https请求的缓存"></a>2、https请求的缓存</h6><p>继续往下走意味着<code>cacheResponse</code>必定存在，但是它不一定能用。后续进行有效性的一系列判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果本次请求是HTTPS，但是缓存中没有对应的握手信息，那么缓存无效。</p>
<h6 id="3、响应码以及响应头"><a href="#3、响应码以及响应头" class="headerlink" title="3、响应码以及响应头"></a>3、响应码以及响应头</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个逻辑都在<code>isCacheable</code>中，他的内容是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCacheable</span><span class="params">(Response response, Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Always go to network for uncacheable response codes (RFC 7231 section 6.1),</span></span><br><span class="line">        <span class="comment">// This implementation doesn&#x27;t support caching partial content.</span></span><br><span class="line">        <span class="keyword">switch</span> (response.code()) &#123;</span><br><span class="line">            <span class="keyword">case</span> HTTP_OK:</span><br><span class="line">            <span class="keyword">case</span> HTTP_NOT_AUTHORITATIVE:</span><br><span class="line">            <span class="keyword">case</span> HTTP_NO_CONTENT:</span><br><span class="line">            <span class="keyword">case</span> HTTP_MULT_CHOICE:</span><br><span class="line">            <span class="keyword">case</span> HTTP_MOVED_PERM:</span><br><span class="line">            <span class="keyword">case</span> HTTP_NOT_FOUND:</span><br><span class="line">            <span class="keyword">case</span> HTTP_BAD_METHOD:</span><br><span class="line">            <span class="keyword">case</span> HTTP_GONE:</span><br><span class="line">            <span class="keyword">case</span> HTTP_REQ_TOO_LONG:</span><br><span class="line">            <span class="keyword">case</span> HTTP_NOT_IMPLEMENTED:</span><br><span class="line">            <span class="keyword">case</span> StatusLine.HTTP_PERM_REDIRECT:</span><br><span class="line">                <span class="comment">// These codes can be cached unless headers forbid it.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> HTTP_MOVED_TEMP:</span><br><span class="line">            <span class="keyword">case</span> StatusLine.HTTP_TEMP_REDIRECT:</span><br><span class="line">                <span class="comment">// These codes can only be cached with the right response headers.</span></span><br><span class="line">                <span class="comment">// http://tools.ietf.org/html/rfc7234#section-3</span></span><br><span class="line">                <span class="comment">// s-maxage is not checked because OkHttp is a private cache that should ignore</span></span><br><span class="line">                <span class="comment">// s-maxage.</span></span><br><span class="line">                <span class="keyword">if</span> (response.header(<span class="string">&quot;Expires&quot;</span>) != <span class="keyword">null</span></span><br><span class="line">                        || response.cacheControl().maxAgeSeconds() != -<span class="number">1</span></span><br><span class="line">                        || response.cacheControl().isPublic()</span><br><span class="line">                        || response.cacheControl().isPrivate()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Fall-through.</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// All other codes cannot be cached.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A &#x27;no-store&#x27; directive on request or response prevents the response from being cached.</span></span><br><span class="line">        <span class="keyword">return</span> !response.cacheControl().noStore() &amp;&amp; !request.cacheControl().noStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存响应中的响应码为 200, 203, 204, 300, 301, 404, 405, 410, 414, 501, 308 的情况下,只判断服务器是不是给了<code>Cache-Control: no-store</code> (资源不能被缓存)，所以如果服务器给到了这个响应头，那就和前面两个判定一致(缓存不可用)。否则继续进一步判断缓存是否可用</p>
<p>而如果响应码是302/307(重定向)，则需要进一步判断是不是存在一些允许缓存的响应头。根据注解中的给到的文档<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc7234#section-3%E4%B8%AD%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AD%98%E5%9C%A8%60Expires%60%E6%88%96%E8%80%85%60Cache-Control%60%E7%9A%84%E5%80%BC%E4%B8%BA%EF%BC%9A">http://tools.ietf.org/html/rfc7234#section-3中的描述，如果存在`Expires`或者`Cache-Control`的值为：</a></p>
<ol>
<li><code>max-age=[秒]</code> ：资源最大有效时间;</li>
<li><code>public</code> ：表明该资源可以被任何用户缓存，比如客户端，代理服务器等都可以缓存资源;</li>
<li><code>private</code>：表明该资源只能被单个用户缓存，默认是private。</li>
</ol>
<p>同时不存在<code>Cache-Control: no-store</code>，那就可以继续进一步判断缓存是否可用。</p>
<p>所以综合来看判定优先级如下：</p>
<p>1、响应码不为 200, 203, 204, 300, 301, 404, 405, 410, 414, 501, 308，<strong>302</strong>，<strong>307</strong> 缓存不可用;</p>
<p>2、当响应码为302或者307时，未包含某些响应头，则缓存不可用;</p>
<p>3、当存在<code>Cache-Control: no-store</code>响应头则缓存不可用。</p>
<p>如果响应缓存可用，进一步再判断缓存有效性</p>
<h6 id="4、用户的请求配置"><a href="#4、用户的请求配置" class="headerlink" title="4、用户的请求配置"></a>4、用户的请求配置</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CacheControl requestCaching = request.cacheControl();</span><br><span class="line"><span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasConditions</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> request.header(<span class="string">&quot;If-Modified-Since&quot;</span>) != <span class="keyword">null</span> || request.header(<span class="string">&quot;If-None-Match&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>走到这一步，OkHttp需要先对用户本次发起的<code>Request</code>进行判定，如果用户指定了<code>Cache-Control: no-cache</code>(不使用缓存)的请求头或者请求头包含 <code>If-Modified-Since</code>或<code>If-None-Match</code>(请求验证)，那么就不允许使用缓存。</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Cache-Control: no-cache</code></td>
<td>忽略缓存</td>
</tr>
<tr>
<td><code>If-Modified-Since: 时间</code></td>
<td>值一般为<code>Data</code>或<code>lastModified</code>，服务器没有在指定的时间后修改请求对应资源,返回304(无修改)</td>
</tr>
<tr>
<td><code>If-None-Match：标记</code></td>
<td>值一般为<code>Etag</code>,将其与请求对应资源的<code>Etag</code>值进行比较；如果匹配，返回304</td>
</tr>
</tbody></table>
<p>这意味着如果用户请求头中包含了这些内容，那就必须向服务器发起请求。但是需要注意的是，OkHttp并不会缓存304的响应，如果是此种情况，即用户主动要求与服务器发起请求，服务器返回的304(无响应体)，则直接把304的响应返回给用户：<strong>“既然你主动要求，我就只告知你本次请求结果”</strong>。而如果不包含这些请求头，那继续判定缓存有效性。</p>
<h6 id="5、资源是否不变"><a href="#5、资源是否不变" class="headerlink" title="5、资源是否不变"></a>5、资源是否不变</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line"><span class="keyword">if</span> (responseCaching.immutable()) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果缓存的响应中包含<code>Cache-Control: immutable</code>，这意味着对应请求的响应内容将一直不会改变。此时就可以直接使用缓存。否则继续判断缓存是否可用</p>
<h6 id="6、响应的缓存有效期"><a href="#6、响应的缓存有效期" class="headerlink" title="6、响应的缓存有效期"></a>6、响应的缓存有效期</h6><p>这一步为进一步根据缓存响应中的一些信息判定缓存是否处于有效期内。如果满足：</p>
<blockquote>
<p><strong>缓存存活时间 &lt; 缓存新鲜度 - 缓存最小新鲜度 + 过期后继续使用时长</strong></p>
</blockquote>
<p>代表可以使用缓存。其中新鲜度可以理解为有效时间，而这里的 <strong>“缓存新鲜度-缓存最小新鲜度”</strong> 就代表了缓存真正有效的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.1、获得缓存的响应从创建到现在的时间</span></span><br><span class="line"><span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line"><span class="comment">//todo</span></span><br><span class="line"><span class="comment">// 6.2、获取这个响应有效缓存的时长</span></span><br><span class="line"><span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"><span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//todo 如果请求中指定了 max-age 表示指定了能拿的缓存有效时长，就需要综合响应有效缓存时长与请求能拿缓存的时长，获得最小的能够使用响应缓存的时长</span></span><br><span class="line">		freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6.3 请求包含  Cache-Control:min-fresh=[秒]  能够使用还未过指定时间的缓存 （请求认为的缓存有效时间）</span></span><br><span class="line"><span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">	minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6.4</span></span><br><span class="line"><span class="comment">//  6.4.1、Cache-Control:must-revalidate 可缓存但必须再向源服务器进行确认</span></span><br><span class="line"><span class="comment">//  6.4.2、Cache-Control:max-stale=[秒] 缓存过期后还能使用指定的时长  如果未指定多少秒，则表示无论过期多长时间都可以；如果指定了，则只要是指定时间内就能使用缓存</span></span><br><span class="line">	<span class="comment">// 前者会忽略后者，所以判断了不必须向服务器确认，再获得请求头中的max-stale</span></span><br><span class="line"><span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">	maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.5 不需要与服务器验证有效性 &amp;&amp; 响应存在的时间+请求认为的缓存有效时间 小于 缓存有效时长+过期后还可以使用的时间</span></span><br><span class="line"><span class="comment">// 允许使用缓存</span></span><br><span class="line"><span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">	Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">	<span class="comment">//todo 如果已过期，但未超过 过期后继续使用时长，那还可以继续使用，只用添加相应的头部字段</span></span><br><span class="line">	<span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">		builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//todo 如果缓存已超过一天并且响应中没有设置过期时间也需要添加警告</span></span><br><span class="line">	<span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">	<span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">		builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>6.1、缓存到现在存活的时间：ageMillis</strong></p>
<p>首先<code>cacheResponseAge()</code>方法获得了响应大概存在了多久:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">cacheResponseAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> apparentReceivedAge = servedDate != <span class="keyword">null</span></span><br><span class="line">                    ? Math.max(<span class="number">0</span>, receivedResponseMillis - servedDate.getTime())</span><br><span class="line">                    : <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> receivedAge = ageSeconds != -<span class="number">1</span></span><br><span class="line">                    ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))</span><br><span class="line">                    : apparentReceivedAge;</span><br><span class="line">	<span class="keyword">long</span> responseDuration = receivedResponseMillis - sentRequestMillis;</span><br><span class="line">	<span class="keyword">long</span> residentDuration = nowMillis - receivedResponseMillis;</span><br><span class="line">	<span class="keyword">return</span> receivedAge + responseDuration + residentDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、<code>apparentReceivedAge</code>代表了客户端收到响应到服务器发出响应的一个时间差</p>
<blockquote>
<p><code>seredData</code>是从缓存中获得的<code>Data</code>响应头对应的时间（服务器发出本响应的时间）；<br><code>receivedResponseMillis</code>为本次响应对应的客户端发出请求的时间</p>
</blockquote>
<p>2、<code>receivedAge</code>是代表了客户端的缓存，在收到时就已经存在多久了</p>
<blockquote>
<p><code>ageSeconds</code>是从缓存中获得的<code>Age</code>响应头对应的秒数 (本地缓存的响应是由服务器的缓存返回，这个缓存在服务器存在的时间)</p>
<p><code>ageSeconds</code>与上一步计算结果<code>apparentReceivedAge</code>的最大值为收到响应时，<strong>这个响应数据已经存在多久</strong>。</p>
<p>假设我们发出请求时，服务器存在一个缓存，其中 <code>Data: 0点</code>。<br>此时，客户端在1小时候发起请求，此时由服务器在缓存中插入<code>Age: 1小时</code>并返回给客户端，此时客户端计算的<code>receivedAge</code>就是1小时，这就代表了客户端的缓存在收到时就已经存在多久了。（不代表到本次请求时存在多久了）</p>
</blockquote>
<p>3、<code>responseDuration</code>是缓存对应的请求，在发送请求与接收请求之间的时间差</p>
<p>4、<code>residentDuration</code>是这个缓存接收到的时间到现在的一个时间差</p>
<p><code>receivedAge + responseDuration + residentDuration</code>所代表的意义就是：</p>
<p>缓存在客户端收到时就已经存在的时间 +  请求过程中花费的时间 + 本次请求距离缓存获得的时间，就是缓存真正存在了多久。</p>
<p><strong>6.2、缓存新鲜度(有效时间)：freshMillis</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeFreshnessLifetime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">if</span> (responseCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> SECONDS.toMillis(responseCaching.maxAgeSeconds());</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expires != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">long</span> servedMillis = servedDate != <span class="keyword">null</span> ? servedDate.getTime() : receivedResponseMillis;</span><br><span class="line">		<span class="keyword">long</span> delta = expires.getTime() - servedMillis;</span><br><span class="line">		<span class="keyword">return</span> delta &gt; <span class="number">0</span> ? delta : <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span> &amp;&amp; cacheResponse.request().url().query() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// As recommended by the HTTP RFC and implemented in Firefox, the</span></span><br><span class="line">		<span class="comment">// max age of a document should be defaulted to 10% of the</span></span><br><span class="line">		<span class="comment">// document&#x27;s age at the time it was served. Default expiration</span></span><br><span class="line">		<span class="comment">// dates aren&#x27;t used for URIs containing a query.</span></span><br><span class="line">		<span class="keyword">long</span> servedMillis = servedDate != <span class="keyword">null</span> ? servedDate.getTime() : sentRequestMillis;</span><br><span class="line">		<span class="keyword">long</span> delta = servedMillis - lastModified.getTime();</span><br><span class="line">		<span class="keyword">return</span> delta &gt; <span class="number">0</span> ? (delta / <span class="number">10</span>) : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存新鲜度(有效时长)的判定会有几种情况，按优先级排列如下:</p>
<p>1、缓存响应包含<code>Cache-Control: max-age=[秒] </code>资源最大有效时间</p>
<p>2、缓存响应包含<code>Expires: 时间</code>，则通过<code>Data</code>或接收该响应时间计算资源有效时间</p>
<p>3、缓存响应包含<code>Last-Modified: 时间</code>，则通过<code>Data</code>或发送该响应对应请求的时间计算资源有效时间；并且根据建议以及在Firefox浏览器的实现，使用得到结果的10%来作为资源的有效时间。</p>
<p><strong>6.3、缓存最小新鲜度：minFreshMillis</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">	minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户的请求头中包含<code>Cache-Control: min-fresh=[秒]</code>，代表用户认为这个缓存有效的时长。假设本身缓存新鲜度为: 100毫秒，而缓存最小新鲜度为：10毫秒，那么缓存真正有效时间为90毫秒。</p>
<p><strong>6.4、缓存过期后仍有效时长：maxStaleMillis</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">	maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个判断中第一个条件为缓存的响应中没有包含<code>Cache-Control: must-revalidate</code>(不可用过期资源)，获得用户请求头中包含<code>Cache-Control: max-stale=[秒]</code>缓存过期后仍有效的时长。</p>
<p><strong>6.5、判定缓存是否有效</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">	Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">	<span class="comment">//todo 如果已过期，但未超过 过期后继续使用时长，那还可以继续使用，只用添加相应的头部字段</span></span><br><span class="line">	<span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">		builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//todo 如果缓存已超过一天并且响应中没有设置过期时间也需要添加警告</span></span><br><span class="line">	<span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">	<span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">		builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后利用上4步产生的值，只要缓存的响应未指定<code>no-cache</code>忽略缓存，如果：</p>
<p>缓存存活时间+缓存最小新鲜度 &lt; 缓存新鲜度+过期后继续使用时长，代表可以使用缓存。</p>
<blockquote>
<p>假设 缓存到现在存活了：100 毫秒;<br>用户认为缓存有效时间(缓存最小新鲜度)为：10 毫秒;<br>缓存新鲜度为: 100 毫秒;<br>缓存过期后仍能使用: 0 毫秒;<br>这些条件下，首先缓存的真实有效时间为: 90毫秒，而缓存已经过了这个时间，所以无法使用缓存。</p>
<p>不等式可以转换为:  缓存存活时间 &lt; 缓存新鲜度 - 缓存最小新鲜度 + 过期后继续使用时长，即<br>存活时间 &lt; 缓存有效时间 + 过期后继续使用时间</p>
</blockquote>
<p>总体来说，只要不忽略缓存并且缓存未过期，则使用缓存。</p>
<p><strong>7、缓存过期处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String conditionName;</span><br><span class="line">String conditionValue;</span><br><span class="line"><span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">	conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">	conditionValue = etag;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">	conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">	conditionValue = lastModifiedString;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">	conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">	conditionValue = servedDateString;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//意味着无法与服务器发起比较，只能重新请求</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加请求头</span></span><br><span class="line">Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line">Request conditionalRequest = request.newBuilder()</span><br><span class="line">	.headers(conditionalRequestHeaders.build())</span><br><span class="line">	.build();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br></pre></td></tr></table></figure>
<p>如果继续执行，表示缓存已经过期无法使用。此时我们判定缓存的响应中如果存在<code>Etag</code>，则使用<code>If-None-Match</code>交给服务器进行验证；如果存在<code>Last-Modified</code>或者<code>Data</code>，则使用<code>If-Modified-Since</code>交给服务器验证。服务器如果无修改则会返回304，这时候注意：</p>
<p><strong>由于是缓存过期而发起的请求(与第4个判断用户的主动设置不同)，如果服务器返回304，那框架会自动更新缓存，所以此时<code>CacheStrategy</code>既包含<code>networkRequest</code>也包含<code>cacheResponse</code></strong></p>
<h6 id="8、收尾"><a href="#8、收尾" class="headerlink" title="8、收尾"></a>8、收尾</h6><p>至此，缓存的判定结束，拦截器中只需要判断<code>CacheStrategy</code>中<code>networkRequest</code>与<code>cacheResponse</code>的不同组合就能够判断是否允许使用缓存。</p>
<p>但是需要注意的是，如果用户在创建请求时，配置了<code>onlyIfCached</code>这意味着用户这次希望这个请求只从缓存获得，不需要发起请求。那如果生成的<code>CacheStrategy</code>存在<code>networkRequest</code>这意味着肯定会发起请求，此时出现冲突！那会直接给到拦截器一个既没有<code>networkRequest</code>又没有<code>cacheResponse</code>的对象。拦截器直接返回用户<code>504</code>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存策略 get 方法</span></span><br><span class="line"><span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">	<span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存拦截器</span></span><br><span class="line"><span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">                    .request(chain.request())</span><br><span class="line">                    .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                    .code(<span class="number">504</span>)</span><br><span class="line">                    .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h6><p>1、如果从缓存获取的<code>Response</code>是null，那就需要使用网络请求获取响应；<br>2、如果是Https请求，但是又丢失了握手信息，那也不能使用缓存，需要进行网络请求；<br>3、如果判断响应码不能缓存且响应头有<code>no-store</code>标识，那就需要进行网络请求；<br>4、如果请求头有<code>no-cache</code>标识或者有<code>If-Modified-Since/If-None-Match</code>，那么需要进行网络请求；<br>5、如果响应头没有<code>no-cache</code>标识，且缓存时间没有超过极限时间，那么可以使用缓存，不需要进行网络请求；<br>6、如果缓存过期了，判断响应头是否设置<code>Etag/Last-Modified/Date</code>，没有那就直接使用网络请求否则需要考虑服务器返回304；</p>
<p>并且，只要需要进行网络请求，请求头中就不能包含<code>only-if-cached</code>，否则框架直接返回504！</p>
<blockquote>
<p>缓存拦截器本身主要逻辑其实都在缓存策略中，拦截器本身逻辑非常简单，如果确定需要发起网络请求，则下一个拦截器为<code>ConnectInterceptor</code></p>
</blockquote>
<h5 id="四、连接拦截器"><a href="#四、连接拦截器" class="headerlink" title="四、连接拦截器"></a>四、连接拦截器</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-2b97e6ea4edae15d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连接流程.png"></p>
<p><code>ConnectInterceptor</code>，打开与目标服务器的连接，并执行下一个拦截器。它简短的可以直接完整贴在这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然代码量很少，实际上大部分功能都封装到其它类去了，这里只是调用而已。</p>
<p>首先我们看到的<code>StreamAllocation</code>这个对象是在第一个拦截器：重定向拦截器创建的，但是真正使用的地方却在这里。</p>
<p>*”当一个请求发出，需要建立连接，连接建立后需要使用流用来读写数据”*；而这个StreamAllocation就是协调请求、连接与数据流三者之间的关系，它负责为一次请求寻找连接，然后获得流来实现网络通信。</p>
<p>这里使用的<code>newStream</code>方法实际上就是去查找或者建立一个与请求主机有效的连接，返回的<code>HttpCodec</code>中包含了输入输出流，并且封装了对HTTP请求报文的编码与解码，直接使用它就能够与请求主机完成HTTP通信。</p>
<p><code>StreamAllocation</code>中简单来说就是维护连接：<code>RealConnection</code>——封装了Socket与一个Socket连接池。可复用的<code>RealConnection</code>需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligible</span><span class="params">(Address address, <span class="meta">@Nullable</span> Route route)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this connection is not accepting new streams, we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (allocations.size() &gt;= allocationLimit || noNewStreams) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the non-host fields of the address don&#x27;t overlap, we&#x27;re done.</span></span><br><span class="line">    <span class="keyword">if</span> (!Internal.instance.equalsNonHost(<span class="keyword">this</span>.route.address(), address)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the host exactly matches, we&#x27;re done: this connection can carry the address.</span></span><br><span class="line">    <span class="keyword">if</span> (address.url().host().equals(<span class="keyword">this</span>.route().address().url().host())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// This connection is a perfect match.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we don&#x27;t have a hostname match. But we still be able to carry the request if</span></span><br><span class="line">    <span class="comment">// our connection coalescing requirements are met. See also:</span></span><br><span class="line">    <span class="comment">// https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</span></span><br><span class="line">    <span class="comment">// https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. This connection must be HTTP/2.</span></span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. The routes must share an IP address. This requires us to have a DNS address for both</span></span><br><span class="line">    <span class="comment">// hosts, which only happens after route planning. We can&#x27;t coalesce connections that use a</span></span><br><span class="line">    <span class="comment">// proxy, since proxies don&#x27;t tell us the origin server&#x27;s IP address.</span></span><br><span class="line">    <span class="keyword">if</span> (route == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.route.socketAddress().equals(route.socketAddress())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. This connection&#x27;s server certificate&#x27;s must cover the new host.</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Certificate pinning must match the host.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SSLPeerUnverifiedException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// The caller&#x27;s address can be carried by this connection.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>1、<code> if (allocations.size() &gt;= allocationLimit || noNewStreams) return false;</code> </p>
<p>​      连接到达最大并发流或者连接不允许建立新的流；如http1.x正在使用的连接不能给其他人用(最大并发流为:1)或者连接被关闭；那就不允许复用；</p>
<p>2、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Internal.instance.equalsNonHost(<span class="keyword">this</span>.route.address(), address)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (address.url().host().equals(<span class="keyword">this</span>.route().address().url().host())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// This connection is a perfect match.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DNS、代理、SSL证书、服务器域名、端口完全相同则可复用；</p>
<p>如果上述条件都不满足，在HTTP/2的某些场景下可能仍可以复用(http2先不管)。</p>
<p>所以综上，如果在连接池中找到个连接参数一致并且未被关闭没被占用的连接，则可以复用。</p>
<h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><p>这个拦截器中的所有实现都是为了获得一份与目标服务器的连接，在这个连接上进行HTTP数据的收发。</p>
<h5 id="五、请求服务器拦截器"><a href="#五、请求服务器拦截器" class="headerlink" title="五、请求服务器拦截器"></a>五、请求服务器拦截器</h5><p><code>CallServerInterceptor</code>，利用<code>HttpCodec</code>发出请求到服务器并且解析生成<code>Response</code>。</p>
<p>首先调用<code>httpCodec.writeRequestHeaders(request);</code> 将请求头写入到缓存中(直到调用<code>flushRequest()</code>才真正发送给服务器)。然后马上进行第一个逻辑判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line"><span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line"><span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">		httpCodec.flushRequest();</span><br><span class="line">		realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">		responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">		realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">		<span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">		CountingSink requestBodyOut =</span><br><span class="line">                        <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">		BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">		request.body().writeTo(bufferedRequestBody);</span><br><span class="line">		bufferedRequestBody.close();</span><br><span class="line">		realChain.eventListener().requestBodyEnd(realChain.call(),requestBodyOut.successfulCount);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123; </span><br><span class="line">        <span class="comment">//HTTP2多路复用，不需要关闭socket，不管！</span></span><br><span class="line">		<span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1</span></span><br><span class="line">		<span class="comment">// connection</span></span><br><span class="line">		<span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request</span></span><br><span class="line">		<span class="comment">// body to</span></span><br><span class="line">		<span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">		streamAllocation.noNewStreams();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">httpCodec.finishRequest();</span><br></pre></td></tr></table></figure>
<p>整个if都和一个请求头有关： <code>Expect: 100-continue</code>。这个请求头代表了在发送请求体之前需要和服务器确定是否愿意接受客户端发送的请求体。所以<code>permitsRequestBody</code>判断为是否会携带请求体的方式(POST)，如果命中if，则会先给服务器发起一次查询是否愿意接收请求体，这时候如果服务器愿意会响应100(没有响应体，responseBuilder 即为nul)。这时候才能够继续发送剩余请求数据。</p>
<p>但是如果服务器不同意接受请求体，那么我们就需要标记该连接不能再被复用，调用<code>noNewStreams()</code>关闭相关的Socket。</p>
<p>后续代码为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">	realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">	responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response response = responseBuilder</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
<p>这时<code>responseBuilder</code>的情况即为：</p>
<p>1、POST方式请求，请求头中包含<code>Expect</code>，服务器允许接受请求体，并且已经发出了请求体，<code>responseBuilder</code>为null;</p>
<p>2、POST方式请求，请求头中包含<code>Expect</code>，服务器不允许接受请求体，<code>responseBuilder</code>不为null</p>
<p>3、POST方式请求，未包含<code>Expect</code>，直接发出请求体，<code>responseBuilder</code>为null;</p>
<p>4、POST方式请求，没有请求体，<code>responseBuilder</code>为null;</p>
<p>5、GET方式请求，<code>responseBuilder</code>为null;</p>
<p>对应上面的5种情况，读取响应头并且组成响应<code>Response</code>，注意：此<code>Response</code>没有响应体。同时需要注意的是，如果服务器接受 <code>Expect: 100-continue</code>这是不是意味着我们发起了两次<code>Request</code>？那此时的响应头是第一次查询服务器是否支持接受请求体的，而不是真正的请求对应的结果响应。所以紧接着:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = response.code();</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">	<span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">	<span class="comment">// try again to read the actual response</span></span><br><span class="line">	responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	response = responseBuilder</span><br><span class="line">                    .request(request)</span><br><span class="line">                    .handshake(streamAllocation.connection().handshake())</span><br><span class="line">                    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">	code = response.code();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果响应是100，这代表了是请求<code>Expect: 100-continue</code>成功的响应，需要马上再次读取一份响应头，这才是真正的请求对应结果响应头。</p>
<p>然后收尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line"><span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null</span></span><br><span class="line"><span class="comment">// response body.</span></span><br><span class="line">	response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">                || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">	streamAllocation.noNewStreams();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">		<span class="string">&quot;HTTP &quot;</span> + code + <span class="string">&quot; had non-zero Content-Length: &quot;</span> +  response.body().contentLength());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response；</span><br></pre></td></tr></table></figure>
<p><code>forWebSocket</code>代表websocket的请求，我们直接进入else，这里就是读取响应体数据。然后判断请求和服务器是不是都希望长连接，一旦有一方指明<code>close</code>，那么就需要关闭<code>socket</code>。而如果服务器返回204/205，一般情况而言不会存在这些返回码，但是一旦出现这意味着没有响应体，但是解析到的响应头中包含<code>Content-Lenght</code>且不为0，这表响应体的数据字节长度。此时出现了冲突，直接抛出协议异常！</p>
<h6 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h6><p>在这个拦截器中就是完成HTTP协议报文的封装与解析。</p>
<h2 id="OkHttp总结"><a href="#OkHttp总结" class="headerlink" title="OkHttp总结"></a>OkHttp总结</h2><p>整个OkHttp功能的实现就在这五个默认的拦截器中，所以先理解拦截器模式的工作机制是先决条件。这五个拦截器分别为: 重试拦截器、桥接拦截器、缓存拦截器、连接拦截器、请求服务拦截器。每一个拦截器负责的工作不一样，就好像工厂流水线，最终经过这五道工序，就完成了最终的产品。</p>
<p>但是与流水线不同的是，OkHttp中的拦截器每次发起请求都会在交给下一个拦截器之前干一些事情，在获得了结果之后又干一些事情。整个过程在请求向是顺序的，而响应向则是逆序。</p>
<p>当用户发起一个请求后，会由任务分发起<code>Dispatcher</code>将请求包装并交给重试拦截器处理。</p>
<p>1、重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。</p>
<p>2、桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)；在获得了结果后，调用保存cookie接口并解析GZIP数据。</p>
<p>3、缓存拦截器顾名思义，交出之前读取并判断是否使用缓存；获得结果后判断是否缓存。</p>
<p>4、连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流；在获得结果后不进行额外的处理。</p>
<p>5、请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据，解析读取的响应数据。</p>
<p>在经过了这一系列的流程后，就完成了一次HTTP请求！</p>
<h2 id="补充-代理"><a href="#补充-代理" class="headerlink" title="补充: 代理"></a>补充: 代理</h2><p>在使用OkHttp时，如果用户在创建<code>OkHttpClient</code>时，配置了<code>proxy</code>或者<code>proxySelector</code>，则会使用配置的代理，并且<code>proxy</code>优先级高于<code>proxySelector</code>。而如果未配置，则会获取机器配置的代理并使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK : ProxySelector</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	URI uri = <span class="keyword">new</span> URI(<span class="string">&quot;http://restapi.amap.com&quot;</span>);</span><br><span class="line">	List&lt;Proxy&gt; proxyList = ProxySelector.getDefault().select(uri);</span><br><span class="line">	System.out.println(proxyList.get(<span class="number">0</span>).address());</span><br><span class="line">	System.out.println(proxyList.get(<span class="number">0</span>).type());</span><br><span class="line">&#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果我们不需要自己的App中的请求走代理，则可以配置一个<code>proxy(Proxy.NO_PROXY)</code>，这样也可以避免被抓包。<code>NO_PROXY</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Proxy NO_PROXY = <span class="keyword">new</span> Proxy();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.type = Proxy.Type.DIRECT;</span><br><span class="line">	<span class="keyword">this</span>.sa = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理在Java中对应的抽象类有三种类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">        DIRECT,</span><br><span class="line">        HTTP,</span><br><span class="line">        SOCKS;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DIRECT</code>：无代理，<code>HTTP</code>：http代理，<code>SOCKS</code>：socks代理。第一种自然不用多说，而Http代理与Socks代理有什么区别？</p>
<p>对于Socks代理，在HTTP的场景下，代理服务器完成TCP数据包的转发工作;<br>而Http代理服务器，在转发数据之外，还会解析HTTP的请求及响应，并根据请求及响应的内容做一些处理。</p>
<blockquote>
<p><code>RealConnection</code>的<code>connectSocket</code>方法:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是Socks代理则 new Socket(proxy); 否则相当于直接:new Socket()</span></span><br><span class="line">rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">                ? address.socketFactory().createSocket()</span><br><span class="line">                : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"><span class="comment">//connect方法</span></span><br><span class="line">socket.connect(address);</span><br></pre></td></tr></table></figure>
<p>设置了SOCKS代理的情况下，创建Socket时，为其传入proxy，连接时还是以HTTP服务器为目标地址；但是如果设置的是Http代理，创建Socket是与Http代理服务器建立连接。</p>
<blockquote>
<p>在<code>connect</code>方法时传递的<code>address</code>来自于下面的集合<code>inetSocketAddresses</code><br><code>RouteSelector</code>的<code>resetNextInetSocketAddress</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetNextInetSocketAddress</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//无代理和socks代理，使用http服务器域名与端口</span></span><br><span class="line">      socketHost = address.url().host();</span><br><span class="line">      socketPort = address.url().port();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SocketAddress proxyAddress = proxy.address();</span><br><span class="line">      <span class="keyword">if</span> (!(proxyAddress <span class="keyword">instanceof</span> InetSocketAddress)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">&quot;Proxy.address() is not an &quot;</span> + <span class="string">&quot;InetSocketAddress: &quot;</span> + proxyAddress.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;</span><br><span class="line">      socketHost = getHostString(proxySocketAddress);</span><br><span class="line">      socketPort = proxySocketAddress.getPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">        <span class="comment">//socks代理 connect http服务器 （DNS没用，由代理服务器解析域名）</span></span><br><span class="line">      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无代理，dns解析http服务器</span></span><br><span class="line">        <span class="comment">//http代理,dns解析http代理服务器</span></span><br><span class="line">      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">        InetAddress inetAddress = addresses.get(i);</span><br><span class="line">        inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置代理时，Http服务器的域名解析会被交给代理服务器执行。但是如果是设置了Http代理，会对Http代理服务器的域名使用<code>OkhttpClient</code>配置的dns解析代理服务器，Http服务器的域名解析被交给代理服务器解析。</p>
<p>上述代码就是代理与DNS在OkHttp中的使用，但是还有一点需要注意，Http代理也分成两种类型：普通代理与隧道代理。</p>
<p>其中普通代理不需要额外的操作，扮演「中间人」的角色，在两端之间来回传递报文。这个“中间人”在收到客户端发送的请求报文时，需要正确的处理请求和连接状态，同时向服务器发送新的请求，在收到响应后，将响应结果包装成一个响应体返回给客户端。在普通代理的流程中，代理两端都是有可能察觉不到”中间人“的存在。</p>
<p>但是隧道代理不再作为中间人，无法改写客户端的请求，而仅仅是在建立连接后，将客户端的请求，通过建立好的隧道，无脑的转发给终端服务器。隧道代理需要发起Http <strong>CONNECT</strong>请求，这种请求方式没有请求体，仅供代理服务器使用，并不会传递给终端服务器。请求头 部分一旦结束，后面的所有数据，都被视为应该转发给终端服务器的数据，代理需要把他们无脑的直接转发，直到从客户端的 TCP 读通道关闭。<strong>CONNECT</strong> 的响应报文，在代理服务器和终端服务器建立连接后，可以向客户端返回一个 <code>200 Connect established</code> 的状态码，以此表示和终端服务器的连接，建立成功。</p>
<blockquote>
<p>RealConnection的connect方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;         </span><br><span class="line">	connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">	<span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// We were unable to connect the tunnel but properly closed down our</span></span><br><span class="line">		<span class="comment">// resources.</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>requiresTunnel</code>方法的判定为：当前请求为https并且存在http代理，这时候<code>connectTunnel</code>中会发起:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">xxxx</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xxxx</span><br><span class="line"><span class="attribute">Proxy-Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>okhttp/$&#123;version&#125;</span><br></pre></td></tr></table></figure>
<p>的请求，连接成功代理服务器会返回200；如果返回407表示代理服务器需要鉴权(如：付费代理)，这时需要在请求头中加入<code>Proxy-Authorization</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Authenticator authenticator = <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(response.code == <span class="number">407</span>)&#123;</span><br><span class="line">            <span class="comment">//代理鉴权</span></span><br><span class="line">            String credential = Credentials.basic(<span class="string">&quot;代理服务用户名&quot;</span>, <span class="string">&quot;代理服务密码&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">                    .header(<span class="string">&quot;Proxy-Authorization&quot;</span>, credential)</span><br><span class="line">                    .build();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="keyword">new</span> OkHttpClient.Builder().proxyAuthenticator(authenticator);</span><br></pre></td></tr></table></figure>




<h2 id="补充：状态码"><a href="#补充：状态码" class="headerlink" title="补充：状态码"></a>补充：状态码</h2><p><img src="https://upload-images.jianshu.io/upload_images/13838098-30503ce74c9e7dfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态码分类.png"></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>继续。客户端应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h2 id="补充：Http头"><a href="#补充：Http头" class="headerlink" title="补充：Http头"></a>补充：Http头</h2><p><img src="https://upload-images.jianshu.io/upload_images/13838098-e79cdb6f5a3fface.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Http Headers.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/10058d760200">Jack Ou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/10058d760200">https://www.jianshu.com/u/10058d760200</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Jack Ou所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">开源框架</a><a class="post-meta__tags" href="/tags/okhttp/">okhttp</a></div><div class="post_share"><div class="social-share" data-image="https://upload-images.jianshu.io/upload_images/13838098-e34fb51997ae33f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://upload-images.jianshu.io/upload_images/13838098-2431fc1f0eb1b702.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank"><img class="post-qr-code-img" src="https://upload-images.jianshu.io/upload_images/13838098-2431fc1f0eb1b702.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://upload-images.jianshu.io/upload_images/13838098-ea2cb9b10bc2f743.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank"><img class="post-qr-code-img" src="https://upload-images.jianshu.io/upload_images/13838098-ea2cb9b10bc2f743.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/10/Ubunt%E4%B8%8BNDK%E7%BC%96%E8%AF%91%E6%89%8B%E9%A1%BA/"><img class="prev-cover" src="https://upload-images.jianshu.io/upload_images/13838098-dd17b53777a91fd0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ubunt下NDK编译手顺</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/09/%E8%B0%83%E6%9F%A5Launcher%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E5%8E%9F%E5%9B%A0/"><img class="next-cover" src="https://upload-images.jianshu.io/upload_images/13838098-1cd12a1be7c1f1a4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">调查Launcher无法启动原因</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/13/Retrofit原理解析-网络模块/" title="Retrofit原理解析-网络模块"><img class="cover" src="https://upload-images.jianshu.io/upload_images/13838098-e34fb51997ae33f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="title">Retrofit原理解析-网络模块</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://upload-images.jianshu.io/upload_images/13838098-a7dfe0e9d3ed649c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Jack Ou</div><div class="author-info__description">努力成为靠谱之人：凡事有交代，件件有着落，事事有回音</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">106</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://www.jianshu.com/u/10058d760200"><i class="fad fa-sheep"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/oujie123" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.jianshu.com/u/10058d760200" target="_blank" title="简书"><i class="fas fa-book-open"></i></a><a class="social-icon" href="https://blog.csdn.net/u010248147" target="_blank" title="CSDN"><i class="fab fa-microblog"></i></a><a class="social-icon" href="mailto:jackou4work@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎收看我的博客，很高兴与您一同成长！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-OkHttp%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">1 OkHttp原理解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-OkHttp%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">2 OkHttp介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3 使用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">4 分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">4.1.</span> <span class="toc-text">同步请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">4.2.</span> <span class="toc-text">异步请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">请求流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E5%99%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.4.</span> <span class="toc-text">分发器线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="toc-number">5.</span> <span class="toc-text">5 拦截器责任链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">拦截器流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E6%83%85"><span class="toc-number">5.3.</span> <span class="toc-text">拦截器详情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%87%8D%E8%AF%95%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">一、重试及重定向拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%AF%95"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">重试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">二、桥接拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">三、缓存拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">缓存策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">详细流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E7%BC%93%E5%AD%98%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">5.3.3.2.1.</span> <span class="toc-text">1、缓存是否存在</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81https%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">5.3.3.2.2.</span> <span class="toc-text">2、https请求的缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E5%93%8D%E5%BA%94%E7%A0%81%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">5.3.3.2.3.</span> <span class="toc-text">3、响应码以及响应头</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E7%94%A8%E6%88%B7%E7%9A%84%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE"><span class="toc-number">5.3.3.2.4.</span> <span class="toc-text">4、用户的请求配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E3%80%81%E8%B5%84%E6%BA%90%E6%98%AF%E5%90%A6%E4%B8%8D%E5%8F%98"><span class="toc-number">5.3.3.2.5.</span> <span class="toc-text">5、资源是否不变</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E3%80%81%E5%93%8D%E5%BA%94%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%89%E6%95%88%E6%9C%9F"><span class="toc-number">5.3.3.2.6.</span> <span class="toc-text">6、响应的缓存有效期</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8%E3%80%81%E6%94%B6%E5%B0%BE"><span class="toc-number">5.3.3.2.7.</span> <span class="toc-text">8、收尾</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.3.2.8.</span> <span class="toc-text">9、总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.3.3.3.</span> <span class="toc-text">四、连接拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.3.3.3.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">5.3.3.4.</span> <span class="toc-text">五、请求服务器拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.3.3.4.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OkHttp%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">OkHttp总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-%E4%BB%A3%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">补充: 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">8.</span> <span class="toc-text">补充：状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AHttp%E5%A4%B4"><span class="toc-number">9.</span> <span class="toc-text">补充：Http头</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/08/%E8%B0%83%E6%9F%A5PKMS%E6%97%A0%E6%B3%95%E6%89%AB%E6%8F%8F%E7%B3%BB%E7%BB%9Fapk%E9%97%AE%E9%A2%98/" title="调查PKMS无法扫描系统apk问题"><img src="https://upload-images.jianshu.io/upload_images/13838098-b6f3785088cd2731.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="调查PKMS无法扫描系统apk问题"/></a><div class="content"><a class="title" href="/2021/12/08/%E8%B0%83%E6%9F%A5PKMS%E6%97%A0%E6%B3%95%E6%89%AB%E6%8F%8F%E7%B3%BB%E7%BB%9Fapk%E9%97%AE%E9%A2%98/" title="调查PKMS无法扫描系统apk问题">调查PKMS无法扫描系统apk问题</a><time datetime="2021-12-08T13:00:59.000Z" title="发表于 2021-12-08 21:00:59">2021-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/08/20211208%E8%BD%A6%E6%9C%BA%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD%E6%8A%A5%E5%91%8A/" title="20211208车机整体性能报告"><img src="https://upload-images.jianshu.io/upload_images/13838098-68e128c62e879dbb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="20211208车机整体性能报告"/></a><div class="content"><a class="title" href="/2021/12/08/20211208%E8%BD%A6%E6%9C%BA%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD%E6%8A%A5%E5%91%8A/" title="20211208车机整体性能报告">20211208车机整体性能报告</a><time datetime="2021-12-08T03:10:35.000Z" title="发表于 2021-12-08 11:10:35">2021-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%903-%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0/" title="Linux进程调度分析3-调度函数"><img src="https://upload-images.jianshu.io/upload_images/13838098-5d55fd74e9c304b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux进程调度分析3-调度函数"/></a><div class="content"><a class="title" href="/2021/12/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%903-%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0/" title="Linux进程调度分析3-调度函数">Linux进程调度分析3-调度函数</a><time datetime="2021-12-07T15:58:48.000Z" title="发表于 2021-12-07 23:58:48">2021-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%902-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" title="Linux进程调度分析2-调度算法"><img src="https://upload-images.jianshu.io/upload_images/13838098-5d55fd74e9c304b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux进程调度分析2-调度算法"/></a><div class="content"><a class="title" href="/2021/12/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%902-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" title="Linux进程调度分析2-调度算法">Linux进程调度分析2-调度算法</a><time datetime="2021-12-07T15:24:48.000Z" title="发表于 2021-12-07 23:24:48">2021-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%901-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" title="Linux进程调度分析1-调度策略"><img src="https://upload-images.jianshu.io/upload_images/13838098-5d55fd74e9c304b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux进程调度分析1-调度策略"/></a><div class="content"><a class="title" href="/2021/12/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%86%E6%9E%901-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" title="Linux进程调度分析1-调度策略">Linux进程调度分析1-调度策略</a><time datetime="2021-12-07T14:40:04.000Z" title="发表于 2021-12-07 22:40:04">2021-12-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://upload-images.jianshu.io/upload_images/13838098-e34fb51997ae33f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jack Ou</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://oujie123.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.spacingElementById('content-inner')
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script></div></body></html>