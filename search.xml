<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM内存管理(一)</title>
    <url>/2021/01/27/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="JVM与操作系统的关系"><a href="#JVM与操作系统的关系" class="headerlink" title="JVM与操作系统的关系"></a>JVM与操作系统的关系</h3><h4 id="1-JVM-基础"><a href="#1-JVM-基础" class="headerlink" title="1.JVM 基础"></a>1.JVM 基础</h4><h5 id="1-1-Java-Virtual-Machine是什么"><a href="#1-1-Java-Virtual-Machine是什么" class="headerlink" title="1.1 Java Virtual Machine是什么"></a>1.1 Java Virtual Machine是什么</h5><p>​    JVM 全称 Java Virtual Machine，也就是我们耳熟能详的 Java 虚拟机。它能识别 .class后缀的文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作。</p>
<h5 id="1-2-JVM的作用是什么"><a href="#1-2-JVM的作用是什么" class="headerlink" title="1.2 JVM的作用是什么"></a>1.2 JVM的作用是什么</h5><p>​    JVM是一个抽象层，有了JVM，java代码就可以跨平台运行。JVM的作用主要是将字节码”翻译”成操作系统可以执行的指令代码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ee64fa579a5df769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM的作用.png"></p>
<h5 id="1-3-JVM、JRE、JDK的关系"><a href="#1-3-JVM、JRE、JDK的关系" class="headerlink" title="1.3 JVM、JRE、JDK的关系"></a>1.3 JVM、JRE、JDK的关系</h5><p>​    <strong>JVM</strong>只是一个翻译，把Class翻译成机器识别的代码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到JRE。</p>
<p>​    <strong>JRE</strong>是Java 运行环境(Java Runtime Environment)，它除了包含JVM之外，提供了很多的类库（就是我们说的jar包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用I/O等等之类的）这些东西就是JRE提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境。</p>
<p>​    但对于程序员来说，JRE还不够。我写完要编译代码，还需要调试代码，还需要打包代码、有时候还需要反编译代码。所以我们会使用JDK，因为JDK还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译&lt;反汇编&gt;）等。这个就是<strong>JDK</strong>。</p>
<h4 id="2-JVM的结构"><a href="#2-JVM的结构" class="headerlink" title="2. JVM的结构"></a>2. JVM的结构</h4><h5 id="2-1-整体结构"><a href="#2-1-整体结构" class="headerlink" title="2.1 整体结构"></a>2.1 整体结构</h5><p>​    一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到方法区，执行引擎将会执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的翻译存在，输入字节码，调用操作系统函数。</p>
<p>​    代码被处理的过程如下：<strong>Java 文件-&gt;编译器-&gt;字节码-&gt;JVM-&gt;机器码。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-36f3d8a67016dd32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序执行过程.png"></p>
<h5 id="2-2-JVM运行时数据区域"><a href="#2-2-JVM运行时数据区域" class="headerlink" title="2.2  JVM运行时数据区域"></a>2.2  JVM运行时数据区域</h5><p>​    Java 引以为豪的就是它的自动内存管理机制。相比于 C++的手动内存管理、复杂难以理解的指针等，Java 程序写起来就方便的多。</p>
<p>​    在 Java 中，JVM 内存主要分为<strong>堆、程序计数器、方法区、虚拟机栈和本地方法栈</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f1662d8307302609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时数据区组成.png"></p>
<h5 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h5><p>​    较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。</p>
<p>​    程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如：分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>
<p>​    由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p>
<p>​    程序计数器也是JVM中唯一不会OOM(OutOfMemory)的内存区域</p>
<h5 id="2-2-2-虚拟机栈"><a href="#2-2-2-虚拟机栈" class="headerlink" title="2.2.2 虚拟机栈"></a>2.2.2 虚拟机栈</h5><p>​    虚拟机栈在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址<strong>。</strong></p>
<p>​    Java 虚拟机栈是基于线程的。哪怕只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。</p>
<p>​    栈里的每条数据，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。</p>
<p>​    每个栈帧，都包含四个区域：(<strong>局部变量表、操作数栈、动态链接、返回地址</strong>)</p>
<ul>
<li><strong>局部变量表:**用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个</strong>引用地址**即可，实体对象在堆中存放。</li>
<li><strong>操作数据栈</strong>：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法就是JVM一直运行入栈/出栈的操作。</li>
<li><strong>动态链接:</strong> Java语言特性多态（需要类运行时才能确定具体的方法）。</li>
<li><strong>返回地址:</strong> 正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）</li>
</ul>
<p>​    栈的大小调节：缺省为1M，可用参数 <strong>–Xss调整大小，例如-Xss256k</strong></p>
<p>​    </p>
<h5 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3 本地方法栈"></a>2.2.3 本地方法栈</h5><p>​    本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p>
<p>​    本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。</p>
<p>​    虚拟机规范无强制规定，各版本虚拟机自由实现 ，HotSpot直接把本地方法栈和虚拟机栈合二为一 。</p>
<h5 id="2-2-4-方法区-永久代-线程共享区"><a href="#2-2-4-方法区-永久代-线程共享区" class="headerlink" title="2.2.4 方法区(永久代) (线程共享区)"></a>2.2.4 方法区(永久代) (线程共享区)</h5><p>​    方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、静态变量、常量、运行时常量池、字符串常量池。</p>
<p>​    JVM 在执行某个类的时候，必须先加载。在加载类（加载、验证、准备、解析、初始化）的时候，JVM 会先加载 class 文件，而在 class 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用。</p>
<p>​    字面量包括字符串（String a=“b”）、基本类型的常量（final 修饰的变量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。</p>
<p>​    而当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时的常量池中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。</p>
<p>​    <strong>元空间大小参数：</strong> </p>
<ul>
<li>jdk1.7及以前（初始和最大值）：-XX:PermSize；-XX:MaxPermSize；</li>
<li>jdk1.8以后（初始和最大值）：-XX:MetaspaceSize； -XX:MaxMetaspaceSize</li>
<li>jdk1.8以后大小就只受本机总内存的限制（如果不设置参数的话）</li>
</ul>
<p>​    <strong>Java8 为什么使用元空间替代永久代，这样做有什么好处呢？</strong></p>
<p>​    移除永久代是为了融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，所以不需要配置永久代。</p>
<p>​    永久代内存经常不够用或发生内存溢出，抛出异常 java.lang.OutOfMemoryError: PermGen。这是因为在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于 PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有，为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。</p>
<h5 id="2-2-5-堆区-线程共享区"><a href="#2-2-5-堆区-线程共享区" class="headerlink" title="2.2.5 堆区(线程共享区)"></a>2.2.5 堆区(线程共享区)</h5><p>​    堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。<br>​    堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。<br>​    随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。<br>​    那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。<br>​    Java 的对象可以分为基本数据类型和普通对象。<br>​    对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。<br>​    对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配</p>
<p><strong>堆大小参数：</strong> </p>
<ul>
<li><p>-Xms：堆的最小值；</p>
</li>
<li><p>-Xmx：堆的最大值；</p>
</li>
<li><p>-Xmn：新生代的大小；</p>
</li>
<li><p>-XX:NewSize；新生代最小值；</p>
</li>
<li><p>-XX:MaxNewSize：新生代最大值；</p>
<p>例如- Xmx256m</p>
</li>
</ul>
<h5 id="2-3-直接内存"><a href="#2-3-直接内存" class="headerlink" title="2.3 直接内存"></a>2.3 直接内存</h5><p>​    不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；</p>
<p>​    这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。</p>
<h4 id="3-深入理解运行时数据区"><a href="#3-深入理解运行时数据区" class="headerlink" title="3.深入理解运行时数据区"></a>3.深入理解运行时数据区</h4><h5 id="3-1-测试代码"><a href="#3-1-测试代码" class="headerlink" title="3.1 测试代码"></a>3.1 测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> k = (i + j) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.calculate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    使用javac工具编译Test.java类生成Test.class，并且使用javap工具反编译Test.class字节码可以看到calculate()方法字节码如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-746ab13e44623df7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="calculate字节码.png"></p>
<p>​    从图中可以看到calculate()方法被反编结果包含两个部分: 一个是“行号”，用于程序计数器指引下一行机器需要执行的指令；另一个是字节码指令，用于虚拟机翻译成机器码执行的指令代码。</p>
<p>​    因此，java代码执行是基于字节码指令；而C代码执行是基于寄存器。虽然基于寄存器的代码执行效率会高一点，但是可移植性会很差，不同平台不容易移植；而基于字节码指令的java代码，基于不同平台，只要虚拟机支持，java代码可以无缝移植。</p>
<h5 id="3-2-运行时数据区执行过程"><a href="#3-2-运行时数据区执行过程" class="headerlink" title="3.2 运行时数据区执行过程"></a>3.2 运行时数据区执行过程</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-c847ec8dfa478c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时数据区.png"></p>
<p><strong>对应的执行过程说明如下</strong>：</p>
<p>0: iconst_1  -&gt; 将int型 1 入操作数栈<br>1: istore_1  -&gt; 将操作数栈栈顶int型值存入局部变量表(下标为1的位置)<br>2: iconst_2 -&gt; 将int型 2 入操作数栈<br>3: istore_2 -&gt; 将操作数栈栈顶int型值存入局部变量表(下标为2的位置)<br>4: iload_1 -&gt; 将局部变量表中下标为1位置的值压入操作数栈<br>5: iload_2 -&gt; 将局部变量表中下标为2位置的值压入操作数栈<br>6: iadd      -&gt; (1)将栈顶两个元素出栈 (2)执行相加 (3)将结果压入操作数栈<br>7: bipush  10 -&gt; 将int型 10压入操作数栈<br>9: imul       -&gt; (1)将栈顶两个元素出栈 (2)执行相乘 (3)将结果压入操作数栈<br>10: istore_3   -&gt; 将操作数栈顶int型数值压入局部变量表(下标为3的位置)<br>11: iload_3   -&gt; 将局部变量表中下标为3位置的值压入操作数栈<br>12: ireturn   -&gt;  返回调用calculate方法的下一行地址继续执行</p>
<p><strong>参考资料</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">JVM参数参考说明</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava原理(一) -- 响应式编程核心思想的实现</title>
    <url>/2021/01/27/Rxjava%E5%8E%9F%E7%90%86-%E4%B8%80-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="1-Rxjava的使用"><a href="#1-Rxjava的使用" class="headerlink" title="1.Rxjava的使用"></a>1.Rxjava的使用</h4><p>​    关于Rxjava的使用，网上有太多太多，我这里把所有操作符汇总出来，大家有需要了解的自行查找用法，当然我也写了一点点使用方法，在文后的github链接中，这篇文章主要是想写写自己在学习Rxjava中做的笔记，希望能理解得更深刻。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ff7af6f6bb4f9d6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rxjava操作符汇总.png"></p>
<p>详细的使用方法文档传送门：<a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#109;">&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#109;</a>:oujie123/UnderstandingOfRxJava.git</p>
<h4 id="2-Rxjava思想"><a href="#2-Rxjava思想" class="headerlink" title="2.Rxjava思想"></a>2.Rxjava思想</h4><p>​    任何需求只有一个起点和一个终点，起点开始流向一个”事件”，”事件”经过处理之后最终流向终点，期间事件的处理可以分为很多步骤，处理的过程和终点只关心上一个过程的结果。在订阅之前的流程称之为<strong>上游</strong>，在订阅之后的流程称之为<strong>下游</strong>。</p>
<h4 id="3-Rxjava的hook点"><a href="#3-Rxjava的hook点" class="headerlink" title="3.Rxjava的hook点"></a>3.Rxjava的hook点</h4><p>​    在看源码之前，多看几个api，细心的朋友都会看到在<strong>每个API返回</strong>的之后都会有RxJavaPlugins.onAssembly()方法。他的作用是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//io.reactivex.plugins.RxJavaPlugins类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(<span class="meta">@NonNull</span> Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下onObservableAssembly为null，导致if语句不起作用。那么Rxjava设计这个有什么用呢？他的主要用途就是用于hook每一次调用。注意，这个方法会在<strong>每一个API</strong>最后中调用，意味着每一个Rxjava的方法都会经历这个方法。所以就可以通过这个方法来hook开发者的每一次调用。那么使用方法是怎样的呢？、</p>
<p>可以通过一下方法设置一个处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setOnObservableAssembly</span><span class="params">(<span class="meta">@Nullable</span> Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; onObservableAssembly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockdown) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Plugins can&#x27;t be changed anymore&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RxJavaPlugins.onObservableAssembly = onObservableAssembly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply中可以加入自己想实现的代码</span></span><br><span class="line">RxJavaPlugins.setOnObservableAssembly(<span class="keyword">new</span> Function&lt;io.reactivex.Observable, io.reactivex.Observable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> io.reactivex.<span class="function">Observable <span class="title">apply</span><span class="params">(io.reactivex.Observable observable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;api of rxjava is invoked ！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> observable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>


<h4 id="4-Rxjava核心实现"><a href="#4-Rxjava核心实现" class="headerlink" title="4.Rxjava核心实现"></a>4.Rxjava核心实现</h4><p>首先列出基本代码，其他的操作符都是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回Observable&lt;String&gt;  真实的是ObservaleCreate&lt;String&gt;()</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ObservaleCreate.map</span></span><br><span class="line">.map(<span class="keyword">new</span> Function&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Bitmap <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ObservableMap.subscribe()</span></span><br><span class="line"> .subscribe(<span class="keyword">new</span> Observer&lt;Bitmap&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>分析分为3步：</strong></p>
<ul>
<li>创建Observer，就是new一个接口 自定义观察者 </li>
<li>创建Observable</li>
<li>subscribe订阅过程</li>
</ul>
<h5 id="4-1-创建观察者"><a href="#4-1-创建观察者" class="headerlink" title="4.1 创建观察者"></a>4.1 创建观察者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当订阅成功后回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发者调用onNext回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> T t)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通知观察者发生异常时回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理结束回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察者的创建就是创建一个回调实现，用于接收上游传下来的事件结果。</p>
<h5 id="4-2-创建Observable"><a href="#4-2-创建Observable" class="headerlink" title="4.2 创建Observable"></a>4.2 创建Observable</h5><p>调用流程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e4471d4f36c96294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建Observable.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步调用create方法，传入自定义source</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;novel1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//创建ObservableCreate封装自定义source</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">&quot;source is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="comment">//最终用ObservableCreate包裹了自定义source（ObservableOnSubscribe接口）</span></span><br></pre></td></tr></table></figure>


<h5 id="4-3-subscribe订阅过程"><a href="#4-3-subscribe订阅过程" class="headerlink" title="4.3 subscribe订阅过程"></a>4.3 subscribe订阅过程</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-d181dee45f600e7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="订阅过程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.当subscribe()一被调用，Observable的subscribe()方法会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">		<span class="comment">// 调入子类</span></span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.调用子类ObservaleCreate的subscribeActual方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 创建发射器包裹自定义的观察者</span></span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">    	<span class="comment">// 调用观察者的onSubscribe订阅回调</span></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 上述创建的自定义source，即ObservableOnSubscribe</span></span><br><span class="line">            <span class="comment">// 调用ObservableOnSubscribe的subscribe传入自定义观察者</span></span><br><span class="line">            <span class="comment">// 开发者调用发射器的onNext()就会调到自定义观察者的onNext()中</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-4-原理图"><a href="#4-4-原理图" class="headerlink" title="4.4 原理图"></a>4.4 原理图</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-1800bb5ccf2c82e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rxjava原理图.png"></p>
<h4 id="5-标准观察者模式和Rxjava的变异观察者模式有哪些区别"><a href="#5-标准观察者模式和Rxjava的变异观察者模式有哪些区别" class="headerlink" title="5.标准观察者模式和Rxjava的变异观察者模式有哪些区别"></a>5.标准观察者模式和Rxjava的变异观察者模式有哪些区别</h4><p>​    <strong>在标准的观察者模式</strong>，是一个“被观察者”，多个“观察者”，当被观察者有事件通知的时候，所有观察者都会收到；在标准的观察者设计模式中：当发出通知改变时，会遍历Observable里面的容器，此容器里面有10个Observer，就会通知10个Observer<br>​    <strong>rxjava的观察者模式</strong>是多个“被观察者”，一个“观察者”，需要起点和终点订阅一次之后，但发出改变通知，观察者才能看到。在RxJava观察者设计模式中：分发事件时，会拿到发射器，通过发射器关联到我们自定义的Observer，发射器调用到我们自定义的Observer</p>
<h4 id="6-在创建类操作符中create和just的区别"><a href="#6-在创建类操作符中create和just的区别" class="headerlink" title="6.在创建类操作符中create和just的区别"></a>6.在创建类操作符中create和just的区别</h4><p>​    just内部封装了一个run方法，自动执行了，observer.onNext()</p>
<p>​    create需要程序员去调用createEmitter.onNext（）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava原理(二) -- 线程调度</title>
    <url>/2021/01/27/Rxjava%E5%8E%9F%E7%90%86-%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="1-创建线程池和线程管理策略分析"><a href="#1-创建线程池和线程管理策略分析" class="headerlink" title="1. 创建线程池和线程管理策略分析"></a>1. 创建线程池和线程管理策略分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在开发中使用Rxjava来完成线程切换会调用到以下方法(还有几个就不一一列举了，原理一样的)，那么就从这里开始分析</span></span><br><span class="line">Schedulers.io()</span><br><span class="line">Schedulers.computation()</span><br><span class="line">Schedulers.newThread()</span><br><span class="line">AndroidSchedulers.mainThread()</span><br></pre></td></tr></table></figure>
<p>当我们调用以上方法中的任意一个，都会调到Schedulers类中，Schedulers使用策略模式封装了所有线程切换策略(因此后面以io()分析)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Schedulers类中，静态创建IOTask(),当调用Schedulers.io()的时候，就是返回这个Callable.</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SINGLE = RxJavaPlugins.initSingleScheduler(<span class="keyword">new</span> SingleTask());</span><br><span class="line"></span><br><span class="line">    COMPUTATION = RxJavaPlugins.initComputationScheduler(<span class="keyword">new</span> ComputationTask());</span><br><span class="line"></span><br><span class="line">    IO = RxJavaPlugins.initIoScheduler(<span class="keyword">new</span> IOTask());</span><br><span class="line"></span><br><span class="line">    TRAMPOLINE = TrampolineScheduler.instance();</span><br><span class="line"></span><br><span class="line">    NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(<span class="keyword">new</span> NewThreadTask());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建IoScheduler</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Scheduler</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Scheduler <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> IoHolder.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IoHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> IoScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IoScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.pool = <span class="keyword">new</span> AtomicReference&lt;CachedWorkerPool&gt;(NONE);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// CachedWorkerPool任务池，里面持有任务队列和线程池</span></span><br><span class="line">        CachedWorkerPool update = <span class="keyword">new</span> CachedWorkerPool(KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT, threadFactory);</span><br><span class="line">        <span class="keyword">if</span> (!pool.compareAndSet(NONE, update)) &#123;</span><br><span class="line">            update.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. CachedWorkerPool构造方法中创建线程池，并且暴露get()提供需要执行的任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedWorkerPool</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;ThreadWorker&gt; expiringWorkerQueue;</span><br><span class="line">        <span class="keyword">final</span> CompositeDisposable allWorkers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService evictorService;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;?&gt; evictorTask;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">       CachedWorkerPool(<span class="keyword">long</span> keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (unit != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建线程池</span></span><br><span class="line">                evictor = Executors.newScheduledThreadPool(<span class="number">1</span>, EVICTOR_THREAD_FACTORY);</span><br><span class="line">                task = evictor.scheduleWithFixedDelay(<span class="keyword">this</span>, <span class="keyword">this</span>.keepAliveTime, <span class="keyword">this</span>.keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="function">ThreadWorker <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            .....</span><br><span class="line">            <span class="keyword">while</span> (!expiringWorkerQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 任务队列不为空，从队列中取一个并返回</span></span><br><span class="line">                ThreadWorker threadWorker = expiringWorkerQueue.poll();</span><br><span class="line">                <span class="keyword">if</span> (threadWorker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> threadWorker;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果任务队列是空的，就创建一个并返回</span></span><br><span class="line">            ThreadWorker w = <span class="keyword">new</span> ThreadWorker(threadFactory);</span><br><span class="line">            allWorkers.add(w);</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>用一张图可能说明得比较清楚一些。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2ef68b88cc6ebe82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Schedulers调度过程.png"></p>
<h4 id="2-Rxjava上游任务在子线程中执行分析"><a href="#2-Rxjava上游任务在子线程中执行分析" class="headerlink" title="2. Rxjava上游任务在子线程中执行分析"></a>2. Rxjava上游任务在子线程中执行分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上游线程切换使用过程</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="comment">// ObservableCreate.subscribeOn</span></span><br><span class="line">  .subscribeOn(Schedulers.io())</span><br><span class="line">  <span class="comment">// ObservableSubscribeOn.subscribe</span></span><br><span class="line">  .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">		......</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>从上面使用过程的代码看下面的图，分析Rxjava封装任务和抛任务到线程池的过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-02cfb7c0fb8d2e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上游任务在线程池执行流程图.png"></p>
<p>当我们一订阅(调用subscribe(Observer)方法)的时候，Rxjava将会把上游需要执行的任务和下游的观察者经过层层包裹，包裹好之后，就会得到一个<strong>Scheduler.Worker任务对象</strong>。当调用发射器的onNext的方式的时候，结合第一小节的图片，ObservableSubscribeOn就会将任务抛到线程池执行，在子线程中执行任务并且返回，从而完成线程切换功能。</p>
<h4 id="3-Rxjava下游任务在主线程中执行分析"><a href="#3-Rxjava下游任务在主线程中执行分析" class="headerlink" title="3. Rxjava下游任务在主线程中执行分析"></a>3. Rxjava下游任务在主线程中执行分析</h4><h5 id="3-1-创建AndroidSchedulers-mainThread的过程"><a href="#3-1-创建AndroidSchedulers-mainThread的过程" class="headerlink" title="3.1 创建AndroidSchedulers.mainThread的过程"></a>3.1 创建AndroidSchedulers.mainThread的过程</h5><p>如第一节Schedulers的创建流程一样，当调用AndroidSchedulers.mainThread()之后，最终会创建HandlerScheduler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建HandlerScheduler，并且传入MainLooper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建HandlerScheduler</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(</span><br><span class="line">            <span class="keyword">new</span> Callable&lt;Scheduler&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Scheduler <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> MainHolder.DEFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">mainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.当创建任务的时候，创建HandlerWorker</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    HandlerScheduler(Handler handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HandlerWorker(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.当执行任务的时候</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line">    </span><br><span class="line">        HandlerWorker(Handler handler) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">			<span class="comment">// 包装任务</span></span><br><span class="line">            run = RxJavaPlugins.onSchedule(run);</span><br><span class="line">            ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 创建Message包装任务</span></span><br><span class="line">            Message message = Message.obtain(handler, scheduled);</span><br><span class="line">            message.obj = <span class="keyword">this</span>; </span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 发送任务到MainLooper中，该任务就在主线程中执行了</span></span><br><span class="line">            handler.sendMessageDelayed(message, Math.max(<span class="number">0L</span>, unit.toMillis(delay)));</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> scheduled;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实真正将任务放在主线程中执行就是上面三个步骤，但是Rxjava增加了很多其他功能，例如解除订阅(将任务包装在Disposable中)，增加hook功能(在任务外面在包装了ScheduledRunnable)等等，其最内层的本质就是我们需要执行的任务。细化的包裹情况如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7cbfa0616acdf0ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程执行任务.png"></p>
<h4 id="4-多个线程切换，以哪个为准"><a href="#4-多个线程切换，以哪个为准" class="headerlink" title="4.多个线程切换，以哪个为准"></a>4.多个线程切换，以哪个为准</h4><p>如下面代码，我们作死得切换线程，那么哪些线程会最终执行我们的任务呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .subscribeOn(Schedulers.io())    <span class="comment">// 上游切换，靠近上游的生效</span></span><br><span class="line">  .subscribeOn(Schedulers.newThread())</span><br><span class="line">  .subscribeOn(Schedulers.computation())</span><br><span class="line">  </span><br><span class="line">  .observeOn(Schedulers.io())</span><br><span class="line">  .observeOn(Schedulers.computation())</span><br><span class="line">  .observeOn(AndroidSchedulers.mainThread())  <span class="comment">// 下游切换，靠近下游的生效</span></span><br><span class="line">  .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">	  ......</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以从第二节和第三节看出，当我们<strong>每调用一次subscribeOn方法</strong>，<strong>上游</strong>就会多包装一层Scheduler，在订阅之后，解包裹的时候越靠近“待执行任务”的subscribeOn越后解包，所以最靠近任务的subscribeOn调用会是最终被执行，也就是最终被执行的线程。</p>
<p>因此我们可以总结得到：</p>
<p><strong>总结一： 在多次调用线程切换的时候，第一次调用subscribeOn的线程切换会是最后执行任务的线程；最后调用observeOn切换的线程会是最后执行的线程。</strong></p>
<p><strong>总结二：从调用关系来看，越靠近上游的线程切换，将是最终执行任务的线程；越靠近下游的线程切换，将是最终执行任务的线程。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>WARNING: API &#39;variant.getPackageApplication()&#39; is obsolete and has been replaced with &#39;variant.ge...</title>
    <url>/2021/01/27/WARNING-API-variant-getPackageApplication-is-obsolete-and-has-been-replaced-with-variant-ge/</url>
    <content><![CDATA[<p>相信大家在使用gradle定制自己打包出来的apk名字时，都遇到过这个问题吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WARNING: API <span class="string">&#x27;variant.getPackageApplication()&#x27;</span> is obsolete and has been replaced with <span class="string">&#x27;variant.getPackageApplicationProvider()&#x27;</span>.</span><br><span class="line">It will be removed at the end of <span class="number">2019.</span></span><br><span class="line"></span><br><span class="line">For more information, see https:<span class="comment">//d.android.com/r/tools/task-configuration-avoidance.</span></span><br><span class="line"></span><br><span class="line">To determine what is calling variant.getPackageApplication(), use -Pandroid.debug.obsoleteApi=<span class="keyword">true</span> on the command line to display more information.</span><br><span class="line"></span><br><span class="line">Affected Modules: app</span><br></pre></td></tr></table></figure>


<p><strong>原因就是：</strong></p>
<p>在app模块下的build.gradle中，我们在android{}闭包中写了:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line"></span><br><span class="line">    variant.outputs.all &#123; output -&gt;</span><br><span class="line">        <span class="comment">//自定义目录，我这里把apk包输出路径定义到：/工程根目录/output/项目代号</span></span><br><span class="line">        variant.getPackageApplication().outputDirectory =<span class="keyword">new</span> File(project.rootDir.absolutePath +<span class="string">&quot;/output/$&#123;projectId&#125;/&quot;</span>)</span><br><span class="line">        <span class="comment">//apk名字定义为：自己想取的名字_版本名.apk</span></span><br><span class="line">        outputFileName =<span class="string">&quot;自己想取的名字_$&#123;variant.versionName&#125;.apk&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在使用了这段代码修改路径和apk名字的时候，AndroidStudio就会报以上警告，其实原因很简单，就是api过时了，需要修改一下api，修改如下即可</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.all &#123; output -&gt;</span><br><span class="line">        	<span class="comment">//把getPackageApplication()改成getPackageApplicationProvider().get()即可</span></span><br><span class="line">            variant.getPackageApplicationProvider().get().outputDirectory = <span class="keyword">new</span> File(project.rootDir.absolutePath + <span class="string">&quot;/output/$&#123;projectId&#125;/&quot;</span>)</span><br><span class="line">            outputFileName = <span class="string">&quot;自己想取的名字_$&#123;variant.versionName&#125;.apk&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>API过时</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>dex2jar 报错 com.googlecode.d2j.DexException: not support version</title>
    <url>/2021/01/27/dex2jar-%E6%8A%A5%E9%94%99-com-googlecode-d2j-DexException-not-support-version/</url>
    <content><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p>​    在日常开发中，有时候想做一点羞羞的事情(ps: 学习一下别人的代码)，但是一用dex2jar工具反编就报com.googlecode.d2j.DexException: not support version异常，在我高涨的学习热情上直接浇了一盆冷水。(后面有工具下载地址)</p>
<h4 id="2-反编手顺："><a href="#2-反编手顺：" class="headerlink" title="2. 反编手顺："></a>2. 反编手顺：</h4><p>​    反编其实很简单，先简单叙述一下：</p>
<ul>
<li><p>Step 1：将apk用任意解压工具直接解压(我用的zip)得到classes.dex，你可能会得到很多dex，不要紧，一个一个反编就行。</p>
</li>
<li><p>Step 2 : 使用dex2jar工具将每一个dex文件反编成jar包</p>
<ul>
<li>将dex2jar工具解压到任意目录(我暂时解压到桌面)</li>
<li>进入解压目录并且按(shift+右键，选择在此处打开命令行窗口)进入cmd命令行</li>
<li>将classes.dex拷贝到dex2jar工具目录，使用指令:d2j-dex2jar.bat classes.dex   即可得到反编后的jar包</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5ffef9ea3d119c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dex2jar正常结果.png"></p>
<ul>
<li>Step 3 : 使用JD-GUI工具尽情学习就行了。</li>
</ul>
<h4 id="3-问题发现："><a href="#3-问题发现：" class="headerlink" title="3. 问题发现："></a>3. 问题发现：</h4><p>​    使用dex2jar工具反编的时候，一输入指令，结果报com.googlecode.d2j.DexException: not support version错误(如下图)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ae9293474acef122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常情况.png"></p>
<h4 id="4-1-调查原因："><a href="#4-1-调查原因：" class="headerlink" title="4.1 调查原因："></a>4.1 调查原因：</h4><blockquote>
<p><a href="https://source.android.com/devices/tech/dalvik/dex-format#dex-file-magic">谷歌对dex文件的介绍</a>：常量数组/字符串 <code>DEX_FILE_MAGIC</code> 是字节列表，这类字节必须出现在 <code>.dex</code> 文件的开头，以便系统将其原样识别。该值会特意包含一个换行符（<code>&quot;\n&quot;</code> 或 <code>0x0a</code>）和空字节（<code>&quot;\0&quot;</code> 或 <code>0x00</code>），以便协助检测某些形式的损坏问题。该值还可以将格式版本号编码为 3 个十进制数字；随着格式的演变，预计该值会单调递增。</p>
<p><strong>注意</strong>：Android 9.0 版本中新增了对 <code>039</code> 版格式的支持，其中引入了两个新字节码 <code>const-method-handle</code> 和 <code>const-method-type</code>。（<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions">字节码集合的总结</a>表中介绍了这些字节码。）在 Android 10 中，版本 <code>039</code> 扩展了 DEX 文件格式，以包含仅适用于启动类路径上的 DEX 文件的隐藏 API 信息。</p>
<p><strong>注意</strong>：Android 8.0 版本中新增了对 <code>038</code> 版格式的支持。<code>038</code> 版本中添加了新字节码（<code>invoke-polymorphic</code> 和 <code>invoke-custom</code>）和用于方法句柄的数据。</p>
<p><strong>注意</strong>：Android 7.0 版本中新增了对 <code>037</code> 版格式的支持。在 <code>037</code> 版本之前，大多数 Android 版本都使用过 <code>035</code> 版格式。<code>035</code> 版与 <code>037</code> 版之间的唯一区别是，是否添加默认方法以及是否调整 <code>invoke</code>。</p>
</blockquote>
<p><strong>简单地说：</strong>就是Android Studio中配置的minSdkVersion参数对应的系统版本是多少，dex文件头就会是多少</p>
<p><strong>例如：minSdkVersion配置成24(对应7.0的系统)，编译出来的dex头为037版本</strong>（使用notepad++打开dex文件就可以看到）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   	......</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ......</span><br><span class="line">        minSdkVersion <span class="number">24</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-488655bee26a00b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译出来的dex文件.png"></p>
<h4 id="4-2-根本原因调查："><a href="#4-2-根本原因调查：" class="headerlink" title="4.2 根本原因调查："></a>4.2 根本原因调查：</h4><p>​    其实看了<strong>调查4.1</strong>就已经有方案了，就是修改dex文件中的版本信息就可以。但是不知道根本原因心里不甘心，继续调查。</p>
<p>​    根据报错信息看：com.googlecode.d2j.reader.DexFileReader.<init>(DexFileReader.java:151) </init></p>
<p>​    猜测是<code>reader.DexFileReader</code>的构造方法中报出来的错误，打开dex2jar-2.0\lib目录，将**<code>dex-reader-2.0.jar</code>或者<code>dex-reader-api-2.0.jar</code>**丢进jd-gui工具中看看源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法中找到报错点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexFileReader</span><span class="params">(ByteBuffer in)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> version = in.getInt() &amp; <span class="number">0xFFFFFF</span>;</span><br><span class="line">        <span class="keyword">if</span> ((version != <span class="number">3486512</span>) &amp;&amp; (version != <span class="number">3552048</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">&quot;not support version.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        skip(in, <span class="number">32</span>);</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持的版本定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_035 = <span class="number">3486512</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_036 = <span class="number">3552048</span>;</span><br></pre></td></tr></table></figure>
<p> <strong>意味着dex2jar-2.0工具只支持035和036版本协议！！！</strong></p>
<h4 id="5-解决问题"><a href="#5-解决问题" class="headerlink" title="5.解决问题"></a>5.解决问题</h4><p>​    使用notepad++文件浏览工具(任何能打开文件的工具都可以，例如记事本…)打开dex文件，<strong>修改版本信息037为036或者035</strong>，然后保存文件即可，再使用反编指令：d2j-dex2jar.bat classes.dex  反编即可成功。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-059b4ebc8e57c790.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改dex版本信息后.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-eec242e2e84b7c6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正常获得jar包.png"></p>
<h4 id="6-参考文档："><a href="#6-参考文档：" class="headerlink" title="6.参考文档："></a>6.参考文档：</h4><p><a href="https://source.android.com/devices/tech/dalvik/dex-format#dex-file-magic">谷歌对dex文件的介绍</a></p>
<p><a href="git@github.com:oujie123/Tools.git">反编译工具下载传送门</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>dex2jar</tag>
        <tag>反编译</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>垃圾回收机制(四)</title>
    <url>/2021/01/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E5%9B%9B/</url>
    <content><![CDATA[<h4 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1. 垃圾回收算法"></a>1. 垃圾回收算法</h4><h5 id="1-1-复制算法-Copying"><a href="#1-1-复制算法-Copying" class="headerlink" title="1.1 复制算法(Copying)"></a>1.1 复制算法(Copying)</h5><p>​    将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p>
<p>​    专家经过大量实验发现：新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>​    HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<h5 id="1-2-标记-清除算法-Mark-Sweep"><a href="#1-2-标记-清除算法-Mark-Sweep" class="headerlink" title="1.2 标记-清除算法(Mark-Sweep)"></a>1.2 标记-清除算法(Mark-Sweep)</h5><p>​    标记-清除算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>​    它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h5 id="1-3-标记-整理算法-Mark-Compact"><a href="#1-3-标记-整理算法-Mark-Compact" class="headerlink" title="1.3 标记-整理算法(Mark-Compact)"></a>1.3 标记-整理算法(Mark-Compact)</h5><p>​    首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法虽然没有内存碎片，但是效率偏低。</p>
<h4 id="2-JVM垃圾回收器"><a href="#2-JVM垃圾回收器" class="headerlink" title="2. JVM垃圾回收器"></a>2. JVM垃圾回收器</h4><p>​    在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，因此在新生代通常使用的是复制算法。</p>
<p>​    而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<h5 id="2-1-垃圾回收器分类"><a href="#2-1-垃圾回收器分类" class="headerlink" title="2.1 垃圾回收器分类"></a>2.1 垃圾回收器分类</h5><p>​    JVM常见的垃圾回收器分为三类：单线程垃圾回收器、多线程<strong>并行</strong>垃圾回收器和多线程<strong>并发</strong>垃圾回收器。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7b5dc78164b2a636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垃圾回收器.png"></p>
<h4 id="3-各类垃圾收集器的介绍"><a href="#3-各类垃圾收集器的介绍" class="headerlink" title="3 各类垃圾收集器的介绍"></a>3 各类垃圾收集器的介绍</h4><h5 id="3-1-单线程垃圾回收器"><a href="#3-1-单线程垃圾回收器" class="headerlink" title="3.1 单线程垃圾回收器"></a>3.1 单线程垃圾回收器</h5><p>​    在JDK1.3.1之前，单线程回收器是唯一的选择。它的单线程意义不仅仅是说它只会使用一个CPU或一个收集线程去完成垃圾收集工作。而且它进行垃圾回收的时候，必须暂停其他所有的工作线程（Stop The World,STW），直到它收集完成。它适合Client模式的应用，在单CPU环境下，它简单高效，由于没有线程交互的开销，专心垃圾收集自然可以获得最高的单线程效率。</p>
<p>​    串行的垃圾收集器有两种，Serial与Serial Old，一般两者搭配使用。新生代采用Serial，是利用复制算法；老年代使用Serial Old采用标记-整理算法。Client应用或者命令行程序可以，通过-XX:+UseSerialGC可以开启上述回收模式。下图是其运行过程示意图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-163d08fcb16ad6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单线程垃圾回收器.png"></p>
<h5 id="3-2-多线程并行垃圾回收器"><a href="#3-2-多线程并行垃圾回收器" class="headerlink" title="3.2 多线程并行垃圾回收器"></a>3.2 多线程并行垃圾回收器</h5><p>​    ParNew和Parallel Scavenge都属于并行垃圾回收器，使用多线程并行处理的方式来减少垃圾收集时间，让用户代码获得更长的运行时间。并行垃圾回收器最终的关注点是<strong>高吞吐量</strong>。</p>
<p>​    ParNew和Parallel Scavenge都是新生代的回收器，采用的是复制算法来多线程回收对象。</p>
<p>​    垃圾回收过程和单线程回收比较类似，只是在上图<strong>回收阶段</strong>JVM开启多线程来收集待回收的对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cfaa49d757b17323.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程并行垃圾回收器.png"></p>
<h5 id="3-3-多线程并发垃圾回收器"><a href="#3-3-多线程并发垃圾回收器" class="headerlink" title="3.3 多线程并发垃圾回收器"></a>3.3 多线程并发垃圾回收器</h5><p>​    CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。通过垃圾回收线程和用户线程并发的方式，来实现及时响应的需求。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-aad651e97ff53aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CMS.png"></p>
<p>​    从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对复杂一些，整个过程分为4个步骤，包含：</p>
<ul>
<li><strong>初始标记</strong>：耗时短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</li>
<li><strong>并发标记</strong>：和用户的应用程序同时进行，进行GC Roots追踪的过程。</li>
<li><strong>重新标记</strong>：短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li>
<li><strong>并发清除</strong>：和用户线程一起请求待回收对象。</li>
</ul>
<p>​    由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>​    <strong>浮动垃圾：</strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<h5 id="3-4-G1回收器"><a href="#3-4-G1回收器" class="headerlink" title="3.4 G1回收器"></a>3.4 G1回收器</h5><p>​    G1垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器。G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<h5 id="3-4-1-G1回收器的内存分块"><a href="#3-4-1-G1回收器的内存分块" class="headerlink" title="3.4.1 G1回收器的内存分块"></a>3.4.1 G1回收器的内存分块</h5><p>本质上来说，G1垃圾回收器依然是一个分代垃圾回收器。但是它与一般的回收器所不同的是，它引入了额外的概念-Region。G1垃圾回收器把堆划分成一个个大小相同的Region。在HotSpot的实现中，整个堆被划分成2048左右个Region。每个Region的大小在1-32MB之间，具体多大取决于堆的大小。</p>
<p>G1垃圾回收器的分代也是建立在这些Region的基础上的。对于Region来说，它会有一个分代的类型，并且是唯一一个。即每一个Region，它要么是young的，要么是old的。</p>
<p>还有一类十分特殊的Humongous。所谓的Humongous，就是一个对象的大小超过了某一个阈值——HotSpot中是Region的1/2，那么它会被标记为Humongous。如果我们审视HotSpot的其余的垃圾回收器，可以发现这种对象以前被称为大对象，会被直接分配老年代。而在G1回收器中，则是做了特殊的处理。<br> G1并不要求相同类型的region要相邻。换言之，就是G1回收器不要求它们连续。当然在逻辑上，分代依旧是连续的。因此，G1回收器的堆区内存划分如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f1d742d27c4a079c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="G1内存划分.png"></p>
<p><strong>注：</strong>其中E代表的是Eden，S代表的是Survivor，H代表的是Humongous，剩余的深蓝色代表的是Old（或者Tenured），灰色的代表的是空闲的region</p>
<p>一个Region是G1回收器一次回收的最小单元。即每一次回收都是回收N个Region。这个N是多少，主要受到G1回收的效率和用户设置的软实时目标有关。每一次的回收，G1会选择可能回收最多垃圾的Region进行回收。与此同时，G1回收器会维护一个空间Region的链表。每次回收之后的Region都会被加入到这个链表中。</p>
<h5 id="3-4-2-G1的回收流程"><a href="#3-4-2-G1的回收流程" class="headerlink" title="3.4.2 G1的回收流程"></a>3.4.2 G1的回收流程</h5><p>​    G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p>
<p>​    在初始标记阶段，G1会STW标记GC-Roots，在程序运行期间不断监控GC-Roots，并且标记要回收的对象。在最终标记阶段，会多线程并行标记新产生的待回收对象，最后根据用户配置，筛选可能回收最多垃圾的Region进行回收。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e37fc78f778c4969.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="G1处理流程.png"></p>
<h5 id="3-5-垃圾回收器对比"><a href="#3-5-垃圾回收器对比" class="headerlink" title="3.5 垃圾回收器对比"></a>3.5 垃圾回收器对比</h5><p><strong>新生代垃圾回收器对比：</strong></p>
<table>
<thead>
<tr>
<th>回收器</th>
<th>回收算法</th>
<th>回收器类型</th>
<th>回收对象</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>复制算法</td>
<td>单线程</td>
<td>新生代</td>
</tr>
<tr>
<td>ParNew</td>
<td>复制算法</td>
<td>并行的多线程收集器</td>
<td>新生代</td>
</tr>
<tr>
<td>Parallel  Scavenge (侧重吞吐量)</td>
<td>复制算法</td>
<td>并行的多线程收集器</td>
<td>新生代</td>
</tr>
</tbody></table>
<p><strong>老年代垃圾回收器对比：</strong></p>
<table>
<thead>
<tr>
<th>回收器</th>
<th>回收算法</th>
<th>收集器类型</th>
<th>回收对象</th>
</tr>
</thead>
<tbody><tr>
<td>Serial  Old</td>
<td>标记整理算法</td>
<td>单线程</td>
<td>老年代</td>
</tr>
<tr>
<td>Parallel  Old</td>
<td>标记整理算法</td>
<td>并行的多线程收集器</td>
<td>老年代</td>
</tr>
<tr>
<td>CMS (侧重及时响应)</td>
<td>标记清除算法</td>
<td>并行与并发收集器</td>
<td>老年代</td>
</tr>
<tr>
<td>G1</td>
<td>标记整理 + 化整为零</td>
<td>并行与并发收集器</td>
<td>跨新生代和老年代</td>
</tr>
</tbody></table>
<p>注：吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)</p>
<p>垃圾收集时间= 垃圾回收频率 * 单次垃圾回收时间</p>
<h4 id="4-垃圾回收器的配合使用场景"><a href="#4-垃圾回收器的配合使用场景" class="headerlink" title="4. 垃圾回收器的配合使用场景"></a>4. 垃圾回收器的配合使用场景</h4><ul>
<li>场景1：服务器在client模式下，限定单个CPU的环境中使用Serial收集器<ul>
<li>指令：-XX:+UseSerialGC</li>
</ul>
</li>
<li>场景2：服务器在Server模式多核处理器，对用户响应速度有要求的情况下，使用ParNew+CMS组合<ul>
<li>指令：-XX:+UseConcMarkSweepGC 指定使用CMS后，会默认使用ParNew作为新生代收集器</li>
</ul>
</li>
<li>场景3：服务器在高吞吐量为目标，应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互的场景中，使用Parallel Scavenge收集器。<ul>
<li>指令：-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间，大于0的毫秒数</li>
<li>指令：-XX:GCTimeRatio 设置垃圾收集时间占总时间的比率，0&lt;n&lt;100的整数，默认值是1%–1/(1+99)，即n=99</li>
<li>指令：-XX:+UseParallelGC强制使用该收集器，打开该收集器后，将使用Parallel Scavenge（年轻代）+Serial Old(老年代)的组合进行GC</li>
<li>指令：-XX:+UseParallelOldGC，打开该收集器后，将使用Parallel Scavenge（年轻代）+Parallel Old（老年代）的组合进行GC</li>
</ul>
</li>
<li>场景4：面向服务端应用，针对具有大内存、多处理器的机器的情况，可以考虑使用G1垃圾回收器。<ul>
<li>指令：-XX:+UseG1GC 指定使用G1收集器；</li>
<li>指令：-XX:InitiatingHeapOccupancyPercent 当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；</li>
<li>指令：-XX:MaxGCPauseMillis 为G1设置暂停时间目标，默认值为200毫秒；</li>
<li>指令：-XX:G1HeapRegionSize 设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region</li>
</ul>
</li>
</ul>
<h4 id="5-常量池与String"><a href="#5-常量池与String" class="headerlink" title="5. 常量池与String"></a>5. 常量池与String</h4><p>常量池有很多概念，包括运行时常量池、class常量池、字符串常量池。虚拟机规范只规定以上区域属于方法区，并没有规定虚拟机厂商的实现。</p>
<p>严格来说是<strong>静态常量池和运行时常量池</strong>，静态常量池是存放字符串字面量、符号引用以及类和方法的信息，而运行时常量池存放的是运行时一些直接引用。</p>
<ul>
<li>运行时常量池是在类加载完成之后，将静态常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用。这两个常量池在JDK1.7版本之后，就移到堆内存中了，这里指的是物理空间，而逻辑上还是属于方法区（方法区是逻辑分区）。</li>
</ul>
<p><strong>字面量</strong><br>给基本类型变量赋值的方式就叫做字面量或者字面值。比如：int i=120; long j=10L;</p>
<p><strong>符号引用</strong>：包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。</p>
<p><strong>直接引用：</strong>具体对象的索引值。</p>
<h4 id="6-String类的实现"><a href="#6-String类的实现" class="headerlink" title="6.String类的实现"></a>6.String类的实现</h4><p>​    String 类被 final 关键字修饰，而且变量 char 数组也被 final 修饰。我们知道类被 final 修饰代表该类不可继承，而 char[]被 private+final 修饰，代表了 String 对象不可被更改。Java 实现的这个特性叫作 String 对象的不可变性，即 String 对象一旦创建成功，就不能再对它进行改变。</p>
<p>​    在 Java 中，通常有两种创建字符串对象的方式，</p>
<ul>
<li><p>一种是通过字符串常量的方式创建，如 String str=“abc”；</p>
<ul>
<li>这种方式首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</li>
</ul>
</li>
<li><p>另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。</p>
<ul>
<li>这种方式，首先在编译类文件时，”abc”常量字符串将会放入到常量结构中，在类加载时，“abc”将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的”abc” 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。</li>
</ul>
</li>
</ul>
<p>​    如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串的引用，如果没有会把首次遇到的字符串的引用添加到常量池中；如果有，就返回常量池中的字符串引用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化JVM理解运行时数据区(二)</title>
    <url>/2021/01/27/%E5%8F%AF%E8%A7%86%E5%8C%96JVM%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="1-工具以及配置"><a href="#1-工具以及配置" class="headerlink" title="1. 工具以及配置"></a>1. 工具以及配置</h4><p>​    要可视化代码在内存中的位置，以及虚拟机是如何划分运行时数据区的，我们需要使用到<strong>HSDB工具</strong>，该工具位于JDK\lib目录下。</p>
<p>​    我们需要的工具如下：</p>
<ul>
<li>JDK\lib目录下的sa-jdi.jar</li>
<li>JDK\jre\bin目录下的sawindbg.dll动态库 （<strong>注意！！需要把这个动态库copy到JDK\lib</strong>）</li>
</ul>
<p>​    </p>
<p>​    工具准备好了，那就行动吧。</p>
<ul>
<li><p>Step1： 进入到JDK\lib，我的目录是：F:\Java\JDK\lib</p>
</li>
<li><p>Step2：打开命令行控制台</p>
</li>
<li><p>Step3：运行指令: java -cp .\sa-jdi.jar sun.jvm.hotspot.HSDB</p>
<p> 如果出现以下界面说明配置完成了。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-534277fcff41ea0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HSDB启动界面.png"></p>
<h4 id="2-测试代码以及开始分析"><a href="#2-测试代码以及开始分析" class="headerlink" title="2.测试代码以及开始分析"></a>2.测试代码以及开始分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInJvm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String MAN_TYPE = <span class="string">&quot;man&quot;</span>;	<span class="comment">//常量  存方法区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String WOMAN_TYPE = <span class="string">&quot;woman&quot;</span>;	<span class="comment">//静态变量  存方法区</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student T1 = <span class="keyword">new</span> Student();	<span class="comment">// Student对象  存堆区   T1放在栈帧的局部变量表中</span></span><br><span class="line">        T1.setName(<span class="string">&quot;DY&quot;</span>);</span><br><span class="line">        T1.setSexType(WOMAN_TYPE);</span><br><span class="line">        T1.setAge(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            System.gc();	<span class="comment">// 经历15次GC，进入老年代</span></span><br><span class="line">        &#125;</span><br><span class="line">        Student T2 = <span class="keyword">new</span> Student();	<span class="comment">// Student对象  存堆区   T2放在栈帧的局部变量表中</span></span><br><span class="line">        T2.setName(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">        T2.setSexType(MAN_TYPE);</span><br><span class="line">        T2.setAge(<span class="number">29</span>);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE); <span class="comment">//本地方法栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    String sexType;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//get,set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-1-介绍工具"><a href="#2-1-介绍工具" class="headerlink" title="2.1 介绍工具"></a>2.1 介绍工具</h5><ul>
<li>使用javac和java工具将代码编译后运行起来如下：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c588b7d801a98b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行demo.png"></p>
<ul>
<li>使用指令：jps   查看进程号，我们demo进程号是：12328</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b115e69f472b9b31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo运行进程号查看.png"></p>
<ul>
<li>打开HSDB，点击file-&gt; attach to hotspot process-&gt; 输入进程号，即可看到demo的线程信息如图</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2737761b39e4db04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo进程的线程信息.png"></p>
<ul>
<li>选中main线程，点击第三个按钮（show java stack trace）,显示main线程栈帧信息如下</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-41ba6cb87cb79593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="main线程栈帧信息.png"></p>
<ul>
<li>选中main线程，点击第二个按钮（show the stack memory）,显示当前线程栈区的内存地址如下，下一小节会基于此图分析程序</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e4f239c4ce87b2f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈区内存.png"></p>
<h4 id="3-程序运行时内存变化分析"><a href="#3-程序运行时内存变化分析" class="headerlink" title="3. 程序运行时内存变化分析"></a>3. 程序运行时内存变化分析</h4><h5 id="3-1-JVM运行java代码处理过程"><a href="#3-1-JVM运行java代码处理过程" class="headerlink" title="3.1 JVM运行java代码处理过程"></a>3.1 JVM运行java代码处理过程</h5><ul>
<li><p>JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间。</p>
</li>
<li><p>JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p>
</li>
<li><p>完成上一个步骤后， JVM 首先会执行构造器，编译器会在.java 文件被编译成.class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，静态变量和常量放入方法区。</p>
</li>
<li><p>执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 Student对象，对象引用 student 就存放在栈中。执行过程参照上一篇文章《JVM内存管理》中的“运行时数据区执行过程”小节。</p>
</li>
</ul>
<h5 id="3-2-运行时数据区分析"><a href="#3-2-运行时数据区分析" class="headerlink" title="3.2 运行时数据区分析"></a>3.2 运行时数据区分析</h5><ul>
<li>从第二节中运行代码可以在HSDB中看到栈区的内存分布，如下图是每块内存的介绍：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e4cc6abbc8e5ad37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈区内存地址分析.png"></p>
<p>​    </p>
<ul>
<li>在HSDB中选择Heap Parameters可以看到运行时数据区堆区的分配情况</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-28addc06d3987d15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆区地址分配.png"></p>
<h3 id="注意：准备放大招了，前方大招预警"><a href="#注意：准备放大招了，前方大招预警" class="headerlink" title="注意：准备放大招了，前方大招预警!!!!"></a>注意：准备放大招了，前方大招预警!!!!</h3><p>​    因此我们把以上从HSDB中看到的内存地址和各个区放在同一张图中，就可以很清晰得看清楚代码在运行时，对象在各个区中的运动轨迹。如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4fa414b7c814f179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时数据区结合HSDB分析.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始认真分析！！！</span></span><br><span class="line"><span class="comment">//=============第1步=================</span></span><br><span class="line"><span class="comment">//new Student()在堆区创建一个对象，并且在栈区的局部变量表中引用这个新对象的地址</span></span><br><span class="line">Student T1 = <span class="keyword">new</span> Student();   </span><br><span class="line"><span class="comment">// 在堆区内存空间中找到对应位置并赋值</span></span><br><span class="line">T1.setName(<span class="string">&quot;DY&quot;</span>);  </span><br><span class="line">T1.setSexType(WOMAN_TYPE);</span><br><span class="line">T1.setAge(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============第2步=================</span></span><br><span class="line"><span class="comment">// 因为T1是强引用，系统无法回收T1所指的对象，因此T1被挪到了老年代，从地址也可以看到</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=============第3步=================</span></span><br><span class="line"><span class="comment">//new Student()在堆区创建一个对象，并且在栈区的局部变量表中引用这个新对象的地址</span></span><br><span class="line"><span class="comment">//由于是才创建的，从地址可以看到T2所指向的对象被分配在Eden区</span></span><br><span class="line">Student T2 = <span class="keyword">new</span> Student();</span><br><span class="line">T2.setName(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">T2.setSexType(MAN_TYPE);</span><br><span class="line">T2.setAge(<span class="number">29</span>);</span><br></pre></td></tr></table></figure>


<h4 id="4-总结对JVM堆和栈的认识"><a href="#4-总结对JVM堆和栈的认识" class="headerlink" title="4. 总结对JVM堆和栈的认识"></a>4. 总结对JVM堆和栈的认识</h4><ul>
<li><p><strong>功能角度</strong></p>
<p>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；</p>
<p>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；</p>
</li>
<li><p><strong>线程独享还是共享</strong></p>
<p>  栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。</p>
<p>  堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>
</li>
<li><p><strong>空间大小</strong></p>
<p>栈的内存要远远小于堆内存</p>
</li>
</ul>
<p>​    谈到内存空间大小，在开发中经常遇到OOM，要么是内存泄漏导致堆溢出，要么是递归调用没有选好结束条件导致栈溢出等等，那么下面我们再来看看OOM包括些什么。</p>
<h5 id="4-1-堆溢出"><a href="#4-1-堆溢出" class="headerlink" title="4.1 堆溢出"></a>4.1 堆溢出</h5><p>堆内存溢出：创建对象时申请内存空间,超出最大堆内存空间。</p>
<p><strong>解决方案：</strong>如果不是内存泄漏，就是说内存中的对象却是都是必须存活的，那么久应该检查JVM的堆参数设置，与机器的内存对比，看是否还有可以调整的空间，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行时的内存消耗。Android开发中常见的是因为内存泄漏和Bitmap管理不当造成堆溢出。</p>
<h5 id="4-2-栈溢出"><a href="#4-2-栈溢出" class="headerlink" title="4.2 栈溢出"></a>4.2 栈溢出</h5><p>栈溢出：因为每个方法的执行都需要打包成栈帧，一般的方法调用是很难出现的，如果出现了可能会是无限递归。另一种可能是大量创建线程，JVM不断申请栈内存，导致机器没有足够的内存报OOM，因此一般在开发中，最好用线程池来管理线程。</p>
<h5 id="4-3-方法区溢出"><a href="#4-3-方法区溢出" class="headerlink" title="4.3 方法区溢出"></a>4.3 方法区溢出</h5><ul>
<li>运行时常量池溢出</li>
<li>方法区中保存的Class对象没有被及时回收掉或者Class信息占用的内存超过了我们配置。</li>
</ul>
<h4 id="5-虚拟机优化技术"><a href="#5-虚拟机优化技术" class="headerlink" title="5. 虚拟机优化技术"></a>5. 虚拟机优化技术</h4><h5 id="5-1-对内存的优化"><a href="#5-1-对内存的优化" class="headerlink" title="5.1 对内存的优化"></a>5.1 对内存的优化</h5><p>​    在一般的模型中，两个不同的栈帧的内存区域是独立的，但是大部分的JVM在实现中会进行一些优化，使得两个栈帧出现一部分重叠。（主要体现在方法中有参数传递的情况），让下面栈帧的操作数栈和上面栈帧的部分局部变量重叠在一起，这样做不但节约了一部分空间，更加重要的是在进行方法调用时就可以直接公用一部分数据，无需进行额外的参数复制传递了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-168cea95a7c79716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM栈空间优化.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmStackOpt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z =(x+<span class="number">5</span>)*<span class="number">10</span>;</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">return</span>  z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JvmStackOpt jvmStack = <span class="keyword">new</span> JvmStackOpt();</span><br><span class="line">        jvmStack.work(<span class="number">10</span>);  <span class="comment">// 变量10的内存空间被共享了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a962becc0817ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM栈空间优化取证.png"></p>
<h5 id="5-2-编译优化技术——方法内联"><a href="#5-2-编译优化技术——方法内联" class="headerlink" title="5.2 编译优化技术——方法内联"></a>5.2 编译优化技术——方法内联</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// boolean i1 = max(1,2);</span></span><br><span class="line">    <span class="comment">//调用max方法：  虚拟机栈 --入栈（max 栈帧）</span></span><br><span class="line">    <span class="keyword">boolean</span> i1 = <span class="number">1</span>&gt;<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//方法的执行入栈帧。</span></span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>关于viewmodel创建</title>
    <url>/2021/01/27/%E5%85%B3%E4%BA%8Eviewmodel%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="1-ViewModelProviders-of-被弃用了"><a href="#1-ViewModelProviders-of-被弃用了" class="headerlink" title="1.ViewModelProviders.of()被弃用了"></a><strong>1.ViewModelProviders.of()被弃用了</strong></h4><p>从Android官网可以看到创建ViewModel的方法ViewModelProviders.of()已经被弃用了，我们需要创建ViewModel，只用使用new ViewModelProvider的方式。那么我们应该如何使用呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-beb51a7b1131762e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h4 id="2-使用new-ViewModelProvider方法创建ViewModel"><a href="#2-使用new-ViewModelProvider方法创建ViewModel" class="headerlink" title="2.使用new ViewModelProvider方法创建ViewModel"></a><strong>2.使用new ViewModelProvider方法创建ViewModel</strong></h4><p>从官方给的文档来看，ViewModelProvider有两个构造方法，如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5dc186e405e56f5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>这两个构造方法区别在于: </p>
<p>(1) 第一个构造方法的第一个参数ViewModelStoreOwner是<strong>viewmodel的持有者</strong>，在activity中传入this即可，如果在fragment中，传入requireActivity()即可</p>
<p>(2) 第二个构造方法的第一个参数ViewModelStore是viewmodel的保存容器，工厂创建viewmodel之后，将放入这个容器。</p>
<p>两个构造方法的第二个参数是Factory参数，用于创建viewmodel对象。如果我们需要创建的是<strong>viewmodel</strong>则使用new ViewModelProvider.NewInstanceFactory()即可；如果需要创建的是AndroidViewModel则使用new ViewModelProvider.AndroidViewModelFactory(this.getApplication())。</p>
<blockquote>
<p><strong>//1. WordViewModel继承AndroidViewModel</strong></p>
<p>public class WordViewModel extends AndroidViewModel{</p>
<p>   public WordViewModel(@NonNull Application application) {</p>
<p>​     super(application);</p>
<p>​    }</p>
<p>}</p>
<p><strong>//ViewModel创建方法</strong></p>
<p>WordsViewModel wordsViewModel = new ViewModelProvider(this, new ViewModelProvider.AndroidViewModelFactory(this.getApplication())).get(WordViewModel.class);</p>
<p><strong>//2.WordViewModel继承ViewModel</strong></p>
<p>public class WordViewModel extends ViewModel {}</p>
<p><strong>//ViewModel创建方法</strong></p>
<p>WordsViewModel wordsViewModel = new ViewModelProvider(this, new ViewModelProvider.NewInstanceFactory()).get(WordViewModel.class);</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>viewmodel</tag>
        <tag>jetpack</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(七) -- AQS</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E4%B8%83-AQS/</url>
    <content><![CDATA[<h4 id="1-AQS是什么"><a href="#1-AQS是什么" class="headerlink" title="1. AQS是什么"></a>1. AQS是什么</h4><p>​    队列同步器(AbstractQueuedSynchronizer,AQS)，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<h4 id="2-AQS使用方式和其中的设计模式"><a href="#2-AQS使用方式和其中的设计模式" class="headerlink" title="2.AQS使用方式和其中的设计模式"></a>2.AQS使用方式和其中的设计模式</h4><p>​    AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p>
<p>​    同步器使用的设计模式：<strong>模板方法</strong>的设计模式。</p>
<p>​    在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p>
<p>​    <strong>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器</strong>。可以这样理解二者之间的关系：</p>
<p>​    <strong>锁是面向使用者的</strong>，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；</p>
<p>​    <strong>同步器面向的是锁的实现者</strong>，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<p>​    <strong>实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</strong></p>
<h4 id="3-AQS中的方法"><a href="#3-AQS中的方法" class="headerlink" title="3.AQS中的方法"></a>3.AQS中的方法</h4><p>​    在AQS抽象类中定义了以下模板方法，分为三类：<strong>独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-43425442cd07b3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS模板方法.png"></p>
<p>可供子类重写的方法如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-59cc20b24965de2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS独占式可重写方法.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cecc3ff6a0d1fb79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS共享式可重写方法.png"></p>
<h5 id="3-2-AQS和synchronznized底层实现区别"><a href="#3-2-AQS和synchronznized底层实现区别" class="headerlink" title="3.2 AQS和synchronznized底层实现区别"></a>3.2 AQS和synchronznized底层实现区别</h5><p>​    AQS是基于LockSupport等待超时来实现锁机制，底层实现是基于volatile和cas实现。</p>
<p>​    synchronznized映射成字节码指令就是增加两个指令：monitorenter、monitorexit；</p>
<p>​    当一条线程执行时遇到monitorenter指令时，它会尝试去获得锁，如果获得锁，那么所计数器+1（为什么要加1，因为它是可重入锁，可根据这个琐计数器判断锁状态），如果没有获得锁，那么阻塞；当它遇到一个monitoerexit时，琐计数器会-1，当计数器为0时，就释放锁。</p>
<h5 id="3-3-如何自定义一个锁"><a href="#3-3-如何自定义一个锁" class="headerlink" title="3.3 如何自定义一个锁"></a>3.3 如何自定义一个锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line">    <span class="comment">// 用静态代理的方法，包装同步器方法，修改同步器state状态值</span></span><br><span class="line">    <span class="comment">// 实现可重入锁，state不为0，就是有一个或者多个线程持有锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*判断处于占用状态*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*获得锁*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*释放锁*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(getState()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//compareAndSetState(1,0);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ready get lock&quot;</span>);</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; already got lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ready release lock&quot;</span>);</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; already released lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-AQS基本思想-CLH队列锁"><a href="#4-AQS基本思想-CLH队列锁" class="headerlink" title="4.AQS基本思想 CLH队列锁"></a>4.AQS基本思想 CLH队列锁</h4><p>​    CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。</p>
<p>​    CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p>
<p>​    AQS是CLH队列锁的一种变体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看等待队列中是否</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 遍历CLH队列</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// 获得前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">//如果是等待队列头节点并且拿到锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   </span><br><span class="line">                parkAndCheckInterrupt())    <span class="comment">// 拿锁失败，将线程阻塞</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-AQS原理"><a href="#5-AQS原理" class="headerlink" title="5.AQS原理"></a>5.AQS原理</h4><p>​    AQS内部有一个关键的成员变量state，用于记录当前的同步状态；第二需要实现自己的同步类的话，需要采用AQS的模板设计模式，实现模板方法；AQS内部本质上是一个CLH队列锁，每一个等待的线程都会被包装成一个节点，节点内容是：当前线程，前一个节点和是否需要获取锁状态。然后将该节点挂到一个链表上去。然后线程会检测前一个线程是否释放了锁，即locked标志位是否变成了false，如果变成了false自己就可以拿到这把锁。AQS在检查锁的时候，不会一直自旋的去查看locked的状态，会尝试去检查几次，如果前一个线程都没有释放，则自己进入block状态。</p>
<h4 id="6-公平锁和非公平锁"><a href="#6-公平锁和非公平锁" class="headerlink" title="6.公平锁和非公平锁"></a>6.公平锁和非公平锁</h4><p>​    公平锁：所有需要拿锁的线程都会被挂到队列锁的最后面。</p>
<p>​    非公平锁：在一个线程拿锁的时候，一个线程也同时来抢锁，这就形成了非公平锁。</p>
<p>​    ReentrantLock实现了公平锁和非公平锁，实现的具体差异在于hasQueuedPredecessors()的调用。上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 公平锁的实现有调用hasQueuedPredecessors()判断对待队列是否是有线程等待</span></span><br><span class="line">        <span class="comment">// 非公平锁没有调用该方法，所有等待队列线程和当前线程竞争拿锁。</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;   </span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;	</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-ReentrantLock锁的可重入-递归拿自己锁"><a href="#7-ReentrantLock锁的可重入-递归拿自己锁" class="headerlink" title="7.ReentrantLock锁的可重入(递归拿自己锁)"></a>7.ReentrantLock锁的可重入(递归拿自己锁)</h4><p>​    可以递归拿锁。每次拿锁之后，多记录一下同步的状态。<br>​    例如：如果锁不能重入，则会发生死锁，自己把自己锁死了。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void reenter(int x)&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;:递归层级:&quot;+x);</span><br><span class="line">        int y &#x3D; x - 1;</span><br><span class="line">        if (y&#x3D;&#x3D;0) return;</span><br><span class="line">        else&#123;</span><br><span class="line">            reenter(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    实现可重入锁方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否处于占用状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getExclusiveOwnerThread()==Thread.currentThread())&#123;</span><br><span class="line">            <span class="comment">// 如果自己线程拿到锁，将AQS中state状态值+1，为了释放使用</span></span><br><span class="line">            setState(getState()+<span class="number">1</span>);   </span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(getExclusiveOwnerThread()!=Thread.currentThread())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">        setState(getState()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(getState()==<span class="number">0</span>)&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试用例代码见： <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;">&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(五) -- 并发编程</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E4%BA%94-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h4><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>​    死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
<h5 id="1-2-产生死锁的必要条件"><a href="#1-2-产生死锁的必要条件" class="headerlink" title="1.2 产生死锁的必要条件"></a>1.2 产生死锁的必要条件</h5><ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<h5 id="1-3-如何解决死锁"><a href="#1-3-如何解决死锁" class="headerlink" title="1.3 如何解决死锁"></a>1.3 如何解决死锁</h5><p>​    知道死锁发生的原因，解决死锁的方法也有四种：</p>
<ul>
<li><p>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</p>
</li>
<li><p>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</p>
</li>
<li><p>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</p>
</li>
<li><p>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</p>
<p>避免死锁常见的算法有<strong>有序资源分配法、银行家算法</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产生死锁案例</span></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>具体手段</strong>：(1)  内部确认拿锁顺序，修改拿锁和释放锁顺序；(2) 采用尝试拿锁的机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用手段1解决死锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用tryLock尝试拿锁的机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock No13 = <span class="keyword">new</span> ReentrantLock();<span class="comment">//第一个锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock No14 = <span class="keyword">new</span> ReentrantLock();<span class="comment">//第二个锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先尝试拿No13 锁，再尝试拿No14锁，No14锁没拿到，连同No13 锁一起释放掉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fisrtToSecond</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (No13.tryLock()) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; get 13&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (No14.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(threadName + <span class="string">&quot; get 14&quot;</span>);</span><br><span class="line">                            System.out.println(<span class="string">&quot;fisrtToSecond do work------------&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            No14.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    No13.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Thread.sleep(r.nextInt(3));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先尝试拿No14锁，再尝试拿No13锁，No13锁没拿到，连同No14锁一起释放掉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SecondToFisrt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (No14.tryLock()) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; get 14&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (No13.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(threadName + <span class="string">&quot; get 13&quot;</span>);</span><br><span class="line">                            System.out.println(<span class="string">&quot;SecondToFisrt do work------------&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            No13.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    No14.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 休眠是为了方式两个线程一直同时去抢锁，导致活锁现象</span></span><br><span class="line">            <span class="comment">//Thread.sleep(r.nextInt(3));  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.currentThread().setName(name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SecondToFisrt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;TestDeadLock&quot;</span>);</span><br><span class="line">        TestThread testThread = <span class="keyword">new</span> TestThread(<span class="string">&quot;SubTestThread&quot;</span>);</span><br><span class="line">        testThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fisrtToSecond();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="1-4-死锁的危害"><a href="#1-4-死锁的危害" class="headerlink" title="1.4 死锁的危害"></a>1.4 死锁的危害</h5><ul>
<li>线程不工作了，但是整个程序还是活着的</li>
<li>没有任何的异常信息可以供我们检查。</li>
<li>一旦程序发生了发生了死锁，是没有任何的办法恢复的，只能重启程序。</li>
<li>自身程序死锁了，还可能导致其他程序拿不到资源，导致其他程序crash。</li>
</ul>
<h4 id="2-活锁"><a href="#2-活锁" class="headerlink" title="2.活锁"></a>2.活锁</h4><p>​    两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。</p>
<blockquote>
<p>线程A B      锁1,2</p>
<p>拿锁顺序</p>
<p>A(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;</p>
<p>B(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;</p>
<p>以上现象会拉长拿锁周期，因为A拿到锁1，尝试拿锁2，但是拿不到锁2。B线程先拿到锁2，尝试拿锁1。就会导致活锁现象，线程也没有死，但是不能执行期望的代码。</p>
<p>解决办法：每个线程休眠随机数，错开拿锁的时间。</p>
</blockquote>
<h4 id="3-线程饥饿"><a href="#3-线程饥饿" class="headerlink" title="3.线程饥饿"></a>3.线程饥饿</h4><p>​    低优先级的线程，总是拿不到执行时间片。</p>
<h4 id="4-前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。"><a href="#4-前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。" class="headerlink" title="4.前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。"></a>4.前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。</h4><p>下面从what，how，why三个方面来引出CAS。</p>
<h5 id="4-1什么是原子操作？"><a href="#4-1什么是原子操作？" class="headerlink" title="4. 1什么是原子操作？"></a>4. 1什么是原子操作？</h5><p>​    有两个任务A,B，每个任务需要很多步骤执行；但是对于每个线程来说，要么任务执行并且执行完成，要么不执行。这样的操作就叫原子操作。</p>
<h5 id="4-2-如何实现原子操作？"><a href="#4-2-如何实现原子操作？" class="headerlink" title="4.2 如何实现原子操作？"></a>4.2 如何实现原子操作？</h5><p>​    实现原子操作可以使用锁，锁机制就可以满足基本需求了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁。</p>
<p>​    使用synchronized来实现会有以下几个问题：</p>
<ul>
<li>被阻塞的线程优先级很高很重要，可能会导致低优先级线程饥饿。</li>
<li>持锁线程一直不释放锁，可能会导致其他线程拿不到锁，一直无法执行(之前项目联调阶段遇到语音助理一直拿着音频焦点不释放，导致其他应用请求焦点一直拿不到焦点)</li>
<li>存在死锁的可能性</li>
<li>上下文切换比较耗时，对于简单的原子操作有些不划算</li>
</ul>
<p>​    基于以上使用synchronized来实现原子操作的缺点，CAS就应运而生了。</p>
<h5 id="4-3-CAS是什么？"><a href="#4-3-CAS是什么？" class="headerlink" title="4.3 CAS是什么？"></a>4.3 CAS是什么？</h5><p>​    CAS(Compare and Swap) ，通俗地讲：如果某个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿。</p>
<p>​    每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ai.getAndIncrement()); <span class="comment">//100   相当于i++;</span></span><br><span class="line">        System.out.println(ai.incrementAndGet()); <span class="comment">//102   相当于++i;</span></span><br><span class="line">        System.out.println(ai.addAndGet(<span class="number">20</span>)); <span class="comment">// 122      相当于 i+=20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-4-CAS实现原子操作的三大问题"><a href="#4-4-CAS实现原子操作的三大问题" class="headerlink" title="4.4 CAS实现原子操作的三大问题"></a>4.4 CAS实现原子操作的三大问题</h5><h5 id="4-4-1-ABA问题"><a href="#4-4-1-ABA问题" class="headerlink" title="4.4.1 ABA问题"></a>4.4.1 ABA问题</h5><p>​    因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>​    解决方案：在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用AtomicStampedReference或者AtomicMarkableReference来解决ABA问题，给每次修改打标签。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAtomicStampedReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; asr</span><br><span class="line">            = <span class="keyword">new</span> AtomicStampedReference(<span class="string">&quot;Jack&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//拿到当前的版本号(旧)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldStamp = asr.getStamp();</span><br><span class="line">        <span class="keyword">final</span> String oldReference = asr.getReference();</span><br><span class="line">        System.out.println(oldReference + <span class="string">&quot;current stamp --&gt;&quot;</span> + oldStamp);</span><br><span class="line"></span><br><span class="line">        Thread rightStampThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:当前变量值：&quot;</span></span><br><span class="line">                        + oldReference + <span class="string">&quot;-当前版本戳：&quot;</span> + oldStamp + <span class="string">&quot;-&quot;</span></span><br><span class="line">                        + asr.compareAndSet(oldReference,</span><br><span class="line">                        oldReference + <span class="string">&quot;+Java&quot;</span>, oldStamp,</span><br><span class="line">                        oldStamp + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread errorStampThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String reference = asr.getReference();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;:当前变量值：&quot;</span></span><br><span class="line">                        + reference + <span class="string">&quot;-当前版本戳：&quot;</span> + asr.getStamp() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                        + asr.compareAndSet(reference,</span><br><span class="line">                        reference + <span class="string">&quot; + Java&quot;</span>, oldStamp,</span><br><span class="line">                        oldStamp + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        rightStampThread.start();</span><br><span class="line">        rightStampThread.join();</span><br><span class="line">        errorStampThread.start();</span><br><span class="line">        errorStampThread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(asr.getReference() + <span class="string">&quot;current stamp --&gt;&quot;</span> + asr.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>AtomicStampedReference和AtomicMarkableReference区别</p>
<p>相同点都是为了解决CAS原子操作中给每次修改做标记。</p>
<p>不同点是AtomicStampedReference有版本管理的概念，每次操作之后，给stamp值加1；而AtomicMarkableReference只是在每次修改之后，把mark标志位置位。</p>
</blockquote>
<h5 id="4-4-2-循环时间长开销大"><a href="#4-4-2-循环时间长开销大" class="headerlink" title="4.4.2 循环时间长开销大"></a>4.4.2 循环时间长开销大</h5><p>​    自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<h5 id="4-4-3只能保证一个共享变量的原子操作。"><a href="#4-4-3只能保证一个共享变量的原子操作。" class="headerlink" title="4.4.3只能保证一个共享变量的原子操作。"></a>4.4.3只能保证一个共享变量的原子操作。</h5><p>​    当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<p>​    还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用AtomicReference来解决CAS原子操作中对多个变量的修改，但是修改的变量太多，还是建议用锁的机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAtomicReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;UserInfo&gt; atomicUserRef;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserInfo user = <span class="keyword">new</span> UserInfo(<span class="string">&quot;DY&quot;</span>, <span class="number">10</span>);<span class="comment">//要修改的实体的实例</span></span><br><span class="line">        atomicUserRef = <span class="keyword">new</span> AtomicReference(user);</span><br><span class="line">        UserInfo updateUser = <span class="keyword">new</span> UserInfo(<span class="string">&quot;Jack&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        atomicUserRef.compareAndSet(user,updateUser);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicUserRef.get());</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个实体类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-5-悲观锁和乐观锁"><a href="#4-5-悲观锁和乐观锁" class="headerlink" title="4.5 悲观锁和乐观锁"></a>4.5 悲观锁和乐观锁</h5><p>synchronized属于悲观锁：</p>
<ul>
<li>始终感觉有“贼”想谋害朕，一拿到时间片就想办法去抢“锁”</li>
</ul>
<p>CAS属于乐观锁：</p>
<ul>
<li>每次尝试去修改，一次不行下次再来，知道修改成功为止。</li>
</ul>
<p><strong>测试用例代码见： <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(三) -- 线程间协作</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95-%E4%B8%89-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="1-线程间通知等待机制是什么？"><a href="#1-线程间通知等待机制是什么？" class="headerlink" title="1.线程间通知等待机制是什么？"></a>1.线程间通知等待机制是什么？</h4><p>​    通知等待机制是指一个线程A 调用了对象O 的wait()方法进入等待状态，而另一个线程B调用了对象O 的notify()或者notifyAll()方法，线程A 收到通知后从对象O 的wait()方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>​    <strong>notify()：</strong><br>​    通知一个在对象上等待的线程,使其从wait 方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING 状态。<br>​    <strong>notifyAll()：</strong><br>​    通知所有等待在该对象上的线程<br>​    <strong>wait():</strong><br>​    调用该方法的线程进入WAITING 状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁<br>​    <strong>wait(long)</strong><br>​    超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n 毫秒,如果没有通知就超时返回<br>​    <strong>wait (long,int)</strong><br>​    对于超时时间更细粒度的控制,可以达到纳秒</p>
<h4 id="2-线程协作机制如何使用？"><a href="#2-线程协作机制如何使用？" class="headerlink" title="2.线程协作机制如何使用？"></a>2.线程协作机制如何使用？</h4><p>等待方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）获取对象的锁。</span><br><span class="line"><span class="number">2</span>）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</span><br><span class="line"><span class="number">3</span>）条件满足则执行对应的逻辑。</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	<span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        lock.wait();  <span class="comment">// 释放持有的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行期待的程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）获得对象的锁。</span><br><span class="line"><span class="number">2</span>）改变条件。</span><br><span class="line"><span class="number">3</span>）通知所有等待在对象上的线程。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	<span class="comment">// 执行前置程序，修改条件</span></span><br><span class="line">    lock.notifyAll(); </span><br><span class="line">    <span class="comment">// notify()和notifAll()都不会对锁进行操作，所以一般会在synchronized最后一行才调用notify()或者notifyAll()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-等待超时模式实现一个连接池-Handler从消息队列拿消息也是这个原理"><a href="#3-等待超时模式实现一个连接池-Handler从消息队列拿消息也是这个原理" class="headerlink" title="3.等待超时模式实现一个连接池(Handler从消息队列拿消息也是这个原理)"></a>3.等待超时模式实现一个连接池(Handler从消息队列拿消息也是这个原理)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*容器，存放连接*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*限制了池的大小=20*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(SqlConnectImpl.fetchConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*释放连接,通知其他的等待连接的线程*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                <span class="comment">//通知其他等待连接的线程</span></span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取*/</span></span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null 1S</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">            <span class="comment">//永不超时</span></span><br><span class="line">            <span class="keyword">if</span>(mills&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pool.isEmpty())&#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/*超时时刻*/</span></span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis()+mills;</span><br><span class="line">                <span class="comment">/*等待时长*/</span></span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span>(pool.isEmpty()&amp;&amp;remaining&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    <span class="comment">/*唤醒一次，重新计算等待时长*/</span></span><br><span class="line">                    remaining = future-System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection connection = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 超时的情况下pool可能是空</span></span><br><span class="line">                <span class="keyword">if</span>(!pool.isEmpty())&#123;</span><br><span class="line">                    connection = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-调用yield-、sleep-、wait-、notify-等方法对锁有何影响？"><a href="#4-调用yield-、sleep-、wait-、notify-等方法对锁有何影响？" class="headerlink" title="4.调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？"></a>4.调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？</h4><ul>
<li>yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。</li>
<li>调用wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行wait 方法后面的代码。</li>
<li>调用notify()系列方法后，对锁无影响，线程只有在syn 同步代码执行完后才会自然而然的释放锁，所以notify()系列方法一般都是synchronized 同步代码的最后一行。</li>
</ul>
<p><strong>测试用例代码见： <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(二)--线程间共享</title>
    <url>/2021/01/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95-%E4%BA%8C-20-20%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="内置锁Synchronized"><a href="#内置锁Synchronized" class="headerlink" title="内置锁Synchronized"></a>内置锁Synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java 支持多个线程同时访问一个对象或者对象的成员变量，关键字<span class="keyword">synchronized</span> 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</span><br></pre></td></tr></table></figure>
<h4 id="Synchronized的用法和用处"><a href="#Synchronized的用法和用处" class="headerlink" title="Synchronized的用法和用处"></a>Synchronized的用法和用处</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用处：有多个线程会修改到某个属性的地方，需要对修改处加锁，保证每次只有一个线程可以修改。</span><br></pre></td></tr></table></figure>
<h4 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象锁是用于对象实例方法，或者一个对象实例上的。但是需要注意的是，被锁的对象不能发生改变，更不能创建对象，因为这会导致锁失效。不同对象的锁可以同时操作同一属性。</span><br></pre></td></tr></table></figure>
<h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类锁其实锁的是每个类对应的<span class="class"><span class="keyword">class</span> 对象，类锁是用于类的静态方法或者一个类的<span class="title">class</span> 对象上的</span></span><br></pre></td></tr></table></figure>


<h3 id="轻量级锁volatile的用法和使用场景"><a href="#轻量级锁volatile的用法和使用场景" class="headerlink" title="轻量级锁volatile的用法和使用场景"></a>轻量级锁volatile的用法和使用场景</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span>关键字可以保证不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>虽然保证了操作可见性，但是不能保证变量在多线程操作下的线程安全。所以<span class="keyword">volatile</span>的使用场景是：只有一个线程写，多个线程读的场景。</span><br></pre></td></tr></table></figure>


<h3 id="ThreadLocal的辨析"><a href="#ThreadLocal的辨析" class="headerlink" title="ThreadLocal的辨析"></a>ThreadLocal的辨析</h3><h4 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行3个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartThreadArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread[] runs = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;runs.length;i++)&#123;</span><br><span class="line">            runs[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;runs.length;i++)&#123;</span><br><span class="line">            runs[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *类说明：测试线程，线程的工作是将ThreadLocal变量的值变化，并写回，看看线程之间是否会互相影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;线程&quot;</span>+id);</span><br><span class="line">            <span class="keyword">if</span>(id==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 只有当是线程1的时候才会执行</span></span><br><span class="line">                threadLocal2.set(id);</span><br><span class="line">                System.out.println(threadName+<span class="string">&quot;:&quot;</span>+threadLocal2.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadName+<span class="string">&quot;:&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       ThreadLocalTest test = <span class="keyword">new</span> ThreadLocalTest();</span><br><span class="line">        test.StartThreadArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">Thread-<span class="number">0</span>:线程<span class="number">0</span></span><br><span class="line">Thread-<span class="number">2</span>:线程<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>:线程<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，threadLocal在每个线程中都完成了安全的赋值，threadLocal2在线程1完成了线程安全的赋值。</p>
<p><strong>究竟ThreadLocal是如何保证线程安全的呢？</strong></p>
<p><strong>先说说结论：</strong>通过每个线程使用ThreadLocal的副本数据才保证线程安全的。意思是每个线程都会拿到threadLocal的初始值，然后在自己线程中备份一个这个值，当对这个值进行操作的时候，各自线程使用各自备份的这个值，其他线程无法修改自己线程的值，所以保证了线程安全。</p>
<h4 id="ThreadLocal实现解析"><a href="#ThreadLocal实现解析" class="headerlink" title="ThreadLocal实现解析"></a>ThreadLocal实现解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.lang.ThreadLocal中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到当前线程类中的threadLocals变量</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从map中拿到Entry， key是当前的threadlocal对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 从entry中拿到值</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.lang.Thread中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>从以上代码和如下ThreadLocal图解可知道，每一个线程都持有一个**ThreadLocalMap**对象，ThreadLocalMap中保存Entry对象，其中每一个Entry都包括&lt;Key，Value&gt;键值对，键是用户建的ThreadLocal对象，值是初始化值。然后当线程需要处理到ThreadLocal中的值时，每一个线程会将值拷贝一份到线程中进程独自操作这个值，从而实现了线程安全。</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-723ea1e3913372d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal图解.png"></p>
<h4 id="ThreadLocal引发的泄露问题"><a href="#ThreadLocal引发的泄露问题" class="headerlink" title="ThreadLocal引发的泄露问题"></a>ThreadLocal引发的泄露问题</h4><pre><code>(坚持三个原则：发现问题，定位问题，解决问题)</code></pre>
<p><strong>发现问题：</strong></p>
<pre><code>运行一下代码(别释放remove注释)，设置一下堆区大小，很快就会发现OOM了。</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Executor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;LocalValue&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalValue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    threadLocal.set(<span class="keyword">new</span> LocalValue());</span><br><span class="line">                    System.out.println(<span class="string">&quot;use thread local&quot;</span>);</span><br><span class="line">                    <span class="comment">// threadLocal.get(); 以下是使用threadlocal</span></span><br><span class="line">                    <span class="comment">// ....使用代码</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// threadLocal.remove();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>定位问题：</strong></p>
<pre><code>结合下图和从3.2分析可以看到，当前线程是会持有ThreadLocalMap对象，虽然map中key持有的threadlocal对象，他是弱引用，在GC的时候会被回收，但是Value值是强应用，在GC的时候，只要线程没有运行结束，value对象不会被释放。所以在线程里一直创建对象，就会导致内存泄漏。</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6cc6d4f54f52655d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal内存泄漏问题.png"></p>
<pre><code>其实我们在测试的过程中会发现只会泄漏一部分内存，原因是什么呢？

查看ThreadLocal中方法调用栈：

get() -&gt; replaceStaleEntry() -&gt; expungeStaleEntry()

set() -&gt; replaceStaleEntry() -&gt; expungeStaleEntry()

remove() -&gt; expungeStaleEntry()

**结论：从调用来看，get、set、remove最终都会调用到expungeStaleEntry()，expungeStaleEntry()会删除map中key为null的节点。但是每次get和set不会立马调用，所以才会导致泄漏一部分。**</code></pre>
<p><strong>解决问题：</strong></p>
<pre><code>因为remove()方法会立马调用到expungeStaleEntry()来清除key为空的过时条目。所以在使用完成之后，最好调用一下remove()方法，尽快回收不用内存空间(如上面代码屏蔽掉的代码)。</code></pre>
<h4 id="ThreadLocal的线程不安全"><a href="#ThreadLocal的线程不安全" class="headerlink" title="ThreadLocal的线程不安全"></a>ThreadLocal的线程不安全</h4><pre><code>运行如下代码可以发现如果Number声明成**静态对象**，到导致线程不安全。因为静态对象在堆空间中只有一份，每次修改之后ThreadLocal在每个线程中备份的那份都是随线程修改这个值一直改变的，所以会存在线程不安全。正确做法：**声明放在threadlocal中的对象不能是静态的即可。**</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUnsafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal使用静态的对象作value，会导致线程不安全</span></span><br><span class="line">    <span class="comment">// public static Number number = new Number(0);</span></span><br><span class="line">    <span class="keyword">public</span> Number number = <span class="keyword">new</span> Number(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个线程计数加一</span></span><br><span class="line">        number.setNum(number.getNum()+<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//将其存储到ThreadLocal中</span></span><br><span class="line">        value.set(number);</span><br><span class="line">        <span class="comment">//输出num值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&quot;</span>+value.get().getNum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Number&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Number&gt;() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalUnsafe()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Number [num=&quot;</span> + num + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Synchronized和ThreadLocal的区别"><a href="#Synchronized和ThreadLocal的区别" class="headerlink" title="Synchronized和ThreadLocal的区别"></a>Synchronized和ThreadLocal的区别</h4><pre><code>ThreadLocal是一个线程隔离的变量存储的管理实体（注意：不是存储用的），它以Java类方式表现；
synchronized是Java的一个保留字，只是一个代码标识符，它依靠JVM的锁机制来实现临界区的函数、变量在CPU运行访问中的原子性。

虽然两个实现线程安全的手段不同，设计初衷也不同，没有可比性。

但是我还是想简单的总结一下：**synchronized实现线程安全的方案是 时间换空间的方案；而ThreadLocal实现线程安全的方式是空间换时间的方案**</code></pre>
<p><strong>测试用例代码见： <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(四) -- 并发工具类</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95-%E5%9B%9B-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="1-Fork-Join介绍"><a href="#1-Fork-Join介绍" class="headerlink" title="1 Fork/Join介绍"></a>1 Fork/Join介绍</h4><p>​    ForkJoin是实现多线程”分而治之”思想的框架，将一个大任务分成多个一个个小任务，然后对每个小任务执行并行计算，最后将结果合并起来。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cba18902f0674182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fork_Join分治思想.png"></p>
<h4 id="1-2-Fork-Join使用"><a href="#1-2-Fork-Join使用" class="headerlink" title="1.2 Fork/Join使用"></a>1.2 Fork/Join使用</h4><p>​    在使用方面必须首先创建一个ForkJoin 任务。它提供在任务中执行fork 和join 的操作机制，通常不直接继承ForkjoinTask 类，只需要直接继承其子类。</p>
<ul>
<li><p>RecursiveAction，用于没有返回结果的任务</p>
</li>
<li><p>RecursiveTask，用于有返回值的任务</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承RecursiveAction的方式，不用返回值的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDirsFiles</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindDirsFiles</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;FindDirsFiles&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File[] files = path.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">// 对每个子目录都新建一个子任务。</span></span><br><span class="line">                    subTasks.add(<span class="keyword">new</span> FindDirsFiles(file));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 遇到文件，检查。</span></span><br><span class="line">                    <span class="keyword">if</span> (file.getAbsolutePath().endsWith(<span class="string">&quot;txt&quot;</span>))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;文件:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!subTasks.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 在当前的 ForkJoinPool 上调度所有的子任务。</span></span><br><span class="line">                <span class="keyword">for</span> (FindDirsFiles subTask : invokeAll(subTasks)) &#123;</span><br><span class="line">                    subTask.join();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用一个 ForkJoinPool 实例调度总任务</span></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        FindDirsFiles task = <span class="keyword">new</span> FindDirsFiles(<span class="keyword">new</span> File(<span class="string">&quot;F:/&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步提交</span></span><br><span class="line">        pool.execute(task);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Task is Running......&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> otherWork = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            otherWork = otherWork+i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main Thread done sth......,otherWork=&quot;</span>+otherWork);</span><br><span class="line">        <span class="comment">// 阻塞方法，</span></span><br><span class="line">        task.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task end&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承RecursiveTask有返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = MakeArray.ARRAY_LENGTH / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] src;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecursiveTask</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断任务位置是否合适。</span></span><br><span class="line">        <span class="comment">// 如果合适就就直接运算返回结果，否则就细分任务</span></span><br><span class="line">        <span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;start work! fromIndex:&quot;</span> + from + <span class="string">&quot;,toIndex:&quot;</span> + to);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt;= to; i++) &#123;</span><br><span class="line">                sum += src[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (from + to) / <span class="number">2</span>;</span><br><span class="line">            MyRecursiveTask left = <span class="keyword">new</span> MyRecursiveTask(src, from, mid);</span><br><span class="line">            MyRecursiveTask right = <span class="keyword">new</span> MyRecursiveTask(src, mid + <span class="number">1</span>, to);</span><br><span class="line">            invokeAll(left, right);</span><br><span class="line">            <span class="keyword">return</span> left.join() + left.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建运算数组</span></span><br><span class="line">    <span class="keyword">int</span>[] src = MakeArray.makeArray();</span><br><span class="line">    <span class="comment">// 创建ForkJoin池</span></span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    MyRecursiveTask task = <span class="keyword">new</span> MyRecursiveTask(src, <span class="number">0</span>, src.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 执行任务得到结果</span></span><br><span class="line">    Integer invoke = pool.invoke(task);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;comsume: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="2. CountDownLatch"></a>2. CountDownLatch</h4><h5 id="2-1-CountDownLatch是什么？"><a href="#2-1-CountDownLatch是什么？" class="headerlink" title="2.1 CountDownLatch是什么？"></a>2.1 CountDownLatch是什么？</h5><p>​    CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</p>
<p>​    它是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p>
<p>​    如图所示，一个程序初始化需要五步，那就初始化CountDownLatch为5，每个线程初始化结束就对其进行”减一”操作，直到值减为零之后，等待线程被唤醒，继续执行主流程代码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7d2e42e180f0399b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CountDownLatch.png"></p>
<h5 id="2-2-CountDownLatch使用场景"><a href="#2-2-CountDownLatch使用场景" class="headerlink" title="2.2 CountDownLatch使用场景"></a>2.2 CountDownLatch使用场景</h5><p>​    一个APP初始化引入很多框架的时候，需要初始化，为了加快初始化速度，可以使用多线程来对各个框架进行初始化，当各个模块初始化结束之后，CountDownLatch值减成0后，说明所有线程初始化结束，可以开始主流程任务。 </p>
<h5 id="2-3-使用案例"><a href="#2-3-使用案例" class="headerlink" title="2.3 使用案例"></a>2.3 使用案例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InitThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                    + <span class="string">&quot; ready init work......&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; ........continue do its work&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusiThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BusiThread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; do business-----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; ready init work step 1st......&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;begin step 2nd.......&quot;</span>);</span><br><span class="line">                SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; ready init work step 2nd......&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusiThread()).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InitThread());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多少时间之后，没有执行就不阻塞，继续执行下去</span></span><br><span class="line">        latch.await(<span class="number">10</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;Main do ites work........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试用例代码见： <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java反射</title>
    <url>/2021/01/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h4><p>​    主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>
<h4 id="2-Java反射提供了什么能力？"><a href="#2-Java反射提供了什么能力？" class="headerlink" title="2. Java反射提供了什么能力？"></a>2. Java反射提供了什么能力？</h4><p>​    在Java运行时环境中，对于任意一个类，都知道这个类有哪些属性和方法，对于任意一个对象都能调用它的任意一个方法。具体的能力如下：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类。</li>
<li>2.在运行时构造任意一个类的对象。</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>4.在运行时调用任意一个对象的方法。 </li>
</ul>
<h4 id="3-反射的作用是什么？"><a href="#3-反射的作用是什么？" class="headerlink" title="3.反射的作用是什么？"></a>3.反射的作用是什么？</h4><p>​    反射可以在程序运行的时候，动态修改程序的某些属性，使得程序按照我们设计的流程运行。大量开源框架都会用到反射机制，例如：</p>
<ul>
<li>腾讯的Tinker热修复框架会反射DexPathList类拿到dexElements变量，将补丁dex文件放入到dexElements数组的第一个，让ClassLoader首先加载已修复的类。</li>
<li>360的DroidPlugin等插件化框架会反射AMS偷梁换柱intent，来绕过AMS对待启动的Activity是否注册Mainifest的验证。</li>
<li>ARouter、ButterKnife、Retrofit、Dagger2等等开源框架都会通过反射拿到用户使用注解的类，然后完成参数注入或者获取。</li>
</ul>
<p><strong>下面用一张图来解释一下反射来实现Hook的原理：</strong></p>
<p>​    横轴是程序正常运行的时间轴，我们通过反射机制在编译期或者运行时拿到程序中的某个类，动态修改该类中的一些属性，使程序按照我们期望的点运行。该机制主要还是用于我们无法修改到别人的代码，又要借助别人的代码实现自己期望的逻辑的场景。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-84550dadd657939a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反射图解.png"></p>
<h4 id="4-反射有什么缺点？"><a href="#4-反射有什么缺点？" class="headerlink" title="4. 反射有什么缺点？"></a>4. 反射有什么缺点？</h4><p>​    大量运用反射会导致程序变慢，但是经过测试，一般使用反射的数量级在1000以下，几乎可以忽略影响。那么为什么反射会导致程序性能变差呢：</p>
<ul>
<li>在使用反射的过程中会产生大量的临时对象</li>
<li>虚拟机在检查对象可见性的时候是会消耗CPU资源</li>
<li>反射会生成没有优化的字节码</li>
<li>进行拆箱、装箱、类型转换的时候会消耗资源</li>
</ul>
<h4 id="5-如何使用反射？"><a href="#5-如何使用反射？" class="headerlink" title="5. 如何使用反射？"></a>5. 如何使用反射？</h4><p>​    在JDK中主要有以下类来实现反射机制，这些（除了第一个）都位于rt.jar的java.lang.reflect包中</p>
<ul>
<li>Class类：代表一个类，位于java.lang包下。</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）。</li>
<li>Method类：代表类的方法。</li>
<li>Constructor类：代表类的构造方法。</li>
<li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法。</li>
</ul>
<p>详细API我先用一张图展示出来，然后一个一个阐述用法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a7fa332bd1fc472e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反射.png"></p>
<h5 id="5-1-Class类的6种获取方式"><a href="#5-1-Class类的6种获取方式" class="headerlink" title="5.1 Class类的6种获取方式"></a>5.1 Class类的6种获取方式</h5><ul>
<li><p>类名.class。  例如: MainActivity.class;</p>
</li>
<li><p>对象.getClass()。  例如: View view; view.getClass();</p>
</li>
<li><p>Class.forName(“全限定名”)。  例如: Class.forName(“java.lang.String”);</p>
</li>
<li><p>类.class.getClassLoader().loadClass(“全限定名”)。 </p>
<p>例如: MainActivity.class.getClassLoader().loadClass(“java.lang.String”);</p>
</li>
<li><p>子类.class.getSuperClass()。  例如: MainActivity.class.getSuperclass();</p>
</li>
<li><p>包装类.class。  例如: Integer.class、ContextThemeWrapper.class</p>
</li>
</ul>
<h5 id="5-2-根据类获取类名、全限定名和包名"><a href="#5-2-根据类获取类名、全限定名和包名" class="headerlink" title="5.2 根据类获取类名、全限定名和包名"></a>5.2 根据类获取类名、全限定名和包名</h5><ul>
<li>getName() 获取全限定名。  例如: MainActivity.class.getName()</li>
<li>getSimpleName() 获得类名。例如: MainActivity.class.getSimpleName()</li>
<li>getPackage().getName()包名。 例如: MainActivity.class.getPackage().getName()</li>
</ul>
<h5 id="5-3-获取变量、属性"><a href="#5-3-获取变量、属性" class="headerlink" title="5.3 获取变量、属性"></a>5.3 获取变量、属性</h5><ul>
<li>getField(“属性名”) 获取public公共属性，包括可以获取父类的</li>
<li>getName() 属性名</li>
<li>getModifiers() 修饰符</li>
<li>getType() 数据类型</li>
<li>set(对象名，属性值)  给属性赋值。相当于 对象名.set属性名   </li>
<li>get(对象名) 获取属性。相当于 对象名.get属性名  </li>
<li>getDeclearedField(“属性名”)  获取指定属性</li>
<li>setAccessible(true) 放开private属性访问权</li>
<li>getDeclearedFields()  获取类的全部属性</li>
</ul>
<h5 id="5-4-获取类中的方法"><a href="#5-4-获取类中的方法" class="headerlink" title="5.4 获取类中的方法"></a>5.4 获取类中的方法</h5><ul>
<li>getMethod(方法名，参数数据类型(没有参数传null))  获取public方法</li>
<li>getDeclearedMethod(方法名，参数数据类型(没有参数传null))  获取类中所有方法</li>
<li>invoke(对象名，参数列表) 执行方法。相当于  对象名.方法名    如果是静态方法对象名传入<strong>null</strong></li>
<li>getParameterTypes() 得到返回参数列表</li>
<li>getDeclearedMethods() 得到类的所有的方法</li>
<li>getReturnType() 获取返回值的数据类型</li>
</ul>
<h5 id="5-5-获取和调用构造方法"><a href="#5-5-获取和调用构造方法" class="headerlink" title="5.5 获取和调用构造方法"></a>5.5 获取和调用构造方法</h5><ul>
<li>Class对象.getConstructor() 得到构造方法</li>
<li>Class对象.getConstructors() 得到所有构造方法</li>
<li>Class对象.getDeclaredConstructor 获取Class类中的构造方法</li>
<li>newInstance(参数) 调用构造方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>对泛型深入浅出的认识</title>
    <url>/2021/01/26/%E5%AF%B9%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>​    最近终于开始总结自己理解的东西，终于有时间写写自己对一些知识的认识。文笔不好，还望各位包含。以下知识点是我看了享学课堂的资料，对其中的内容进行汇总。</p>
<blockquote>
<p>本预先资料来源于Oracle官方文档Java™ 教程-Java Tutorials</p>
<p>官方文档:<a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">https://docs.oracle.com/javase/tutorial/java/generics/index.html</a></p>
<p>中文翻译:<a href="https://pingfangx.github.io/java-tutorials/java/generics/types.html">https://pingfangx.github.io/java-tutorials/java/generics/types.html</a></p>
</blockquote>
<p>下面我以问题的方式，阐明对泛型深入浅出的认识：</p>
<h4 id="1-泛型是什么？"><a href="#1-泛型是什么？" class="headerlink" title="1.泛型是什么？"></a>1.泛型是什么？</h4><p>​    泛型是JDK5引入的一种<strong>参数化类型</strong>特性。JDK7及以上，泛型的菱形可以推断参数化类型：把类型当参数一样传递。数据类型只能是引用类型。</p>
<p>举个栗子：Plate<T>中的T是类型参数；Plate<Banana>的Banana是实际类型参数；</Banana></T></p>
<p>​                   Plate<T>整个称为泛型类型；Plate<Banana>整个称为参数化的类型；</Banana></T></p>
<h4 id="2-为什么使用泛型，使用泛型的好处？"><a href="#2-为什么使用泛型，使用泛型的好处？" class="headerlink" title="2.为什么使用泛型，使用泛型的好处？"></a>2.为什么使用泛型，使用泛型的好处？</h4><ul>
<li>1.代码更健壮（只要在编译器没有警告，运行期就不会出现ClassCastException）；</li>
<li>2.代码更简洁(不用强转)</li>
<li>3.代码更灵活，可复用。</li>
</ul>
<h4 id="3-泛型包含哪些？"><a href="#3-泛型包含哪些？" class="headerlink" title="3.泛型包含哪些？"></a>3.泛型包含哪些？</h4><p>​    泛型只有三种情况：<strong>泛型接口，泛型类，泛型方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AiPlate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AiPlate</span><span class="params">(T t)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function"><span class="keyword">void</span> <span class="title">addFruit</span><span class="params">(U u)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-泛型限定有哪些？"><a href="#4-泛型限定有哪些？" class="headerlink" title="4.泛型限定有哪些？"></a>4.泛型限定有哪些？</h4><p>​    <strong>？无限定 ； extends 限定上界；super 限定下界</strong>    后面会以一个通熟易懂的口诀演示记住他</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;&#125;</span><br><span class="line"></span><br><span class="line">Interface C&#123;&#125;</span><br><span class="line"></span><br><span class="line">Interface D&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">C</span> &amp; <span class="title">D</span>&gt;</span>&#123;&#125;  <span class="comment">//this is ok  可以实现多个接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">B</span> &amp; <span class="title">C</span> &amp; <span class="title">D</span>&gt; //<span class="title">error</span>,  因为<span class="title">java</span> 只支持单继承</span></span><br></pre></td></tr></table></figure>
<p><strong>在这个体系中，上界通配符 “Plate&lt;？ extends Fruit&gt;” 覆盖下图中蓝色的区域。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c3bd93dc11ab8835.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><strong>Plate是Plate的基类，但是不是Plate的基类，对应上面例子，Plate覆盖的下图中红色的区域</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d124fd8e7b081274.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h4 id="5-JAVA泛型的原理？什么是泛型擦除机制？"><a href="#5-JAVA泛型的原理？什么是泛型擦除机制？" class="headerlink" title="5. JAVA泛型的原理？什么是泛型擦除机制？"></a><strong>5. JAVA泛型的原理？什么是泛型擦除机制？</strong></h4><p>​    Java的泛型是JDK5新引入的特性，为了向下兼容，虚拟机其实是不支持泛型，所以Java实现的是一种<strong>伪泛型机制</strong>，也就是说Java在编译期擦除了所有的泛型信息，这样Java就不需要产生新的类型到字节码，所有的泛型类型最终都是一种原始类型，在Java运行时根本就不存在泛型信息。</p>
<p>​    泛型的擦除机制：<strong>如果有父类被擦除成父类，否则被擦除成Object</strong>。如果有继承，擦除之后会生成<strong>桥接方法</strong>，来解决类型擦除后保留泛型类型的多态性；桥方法在调用父类方法前，会将object进行强转成父类。</p>
<p>​    从 .java文件编译到.class文件会产生泛型擦除的残留，保留了定义的格式，方便分析字节码。类的常量池保留了泛型信息，可以通过反射API拿出type类型信息。</p>
<h4 id="6-Java编译器具体是如何擦除泛型的？"><a href="#6-Java编译器具体是如何擦除泛型的？" class="headerlink" title="6. Java编译器具体是如何擦除泛型的？"></a>6. Java编译器具体是如何擦除泛型的？</h4><ul>
<li>step 1. 检查泛型类型，获取目标类型</li>
<li>step 2. 擦除类型变量，并替换为限定类型</li>
</ul>
<p>​          如果泛型类型的类型变量没有限定(<T>),则用Object作为原始类型</T></p>
<p>​          如果有限定(<T extends xclass>),则用XClass作为原始类型</T></p>
<p>​           如果有多个限定(T extends XClass1&amp;XClass2),则使用第一个边界XClass1作为原始类</p>
<ul>
<li>step 3. 在必要时插入类型转换以保持类型安全</li>
<li>step 4. 生成桥方法以在扩展时保持多态性</li>
</ul>
<h4 id="7-使用了泛型，后留下很多“后遗症”"><a href="#7-使用了泛型，后留下很多“后遗症”" class="headerlink" title="7.使用了泛型，后留下很多“后遗症”"></a>7.使用了泛型，后留下很多“后遗症”</h4><h5 id="7-1-泛型类型变量不能使用基本数据类型"><a href="#7-1-泛型类型变量不能使用基本数据类型" class="headerlink" title="7.1 泛型类型变量不能使用基本数据类型"></a>7.1 泛型类型变量不能使用基本数据类型</h5><p>​    比如没有ArrayList<int>,只有ArrayList<Integer>.当类型擦除后，ArrayList的原始类中的类型变量(T)替换成Object,但Object类型不能存放int值</Integer></int></p>
<h5 id="7-2-不能使用instanceof-运算符"><a href="#7-2-不能使用instanceof-运算符" class="headerlink" title="7.2 不能使用instanceof 运算符"></a>7.2 不能使用instanceof 运算符</h5><p>​    因为擦除后，ArrayList<String>只剩下原始类型，泛型信息String不存在了，所有没法使用instanceof。</String></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(strings <span class="keyword">instanceof</span> ArrayList&lt;?&gt;)&#123;&#125; <span class="comment">//可以  被擦除之后的ArrayList本来就是未知的，所以这个可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(strings <span class="keyword">instanceof</span> ArrayList&lt;String&gt;) <span class="comment">//不可以</span></span><br></pre></td></tr></table></figure>


<h5 id="7-3-泛型在静态方法和静态类中的问题"><a href="#7-3-泛型在静态方法和静态类中的问题" class="headerlink" title="7.3 泛型在静态方法和静态类中的问题"></a>7.3 泛型在静态方法和静态类中的问题</h5><p>​    因为泛型类中的泛型参数的实例化在定义泛型类型对象(比如ArrayList<Integer>)的时候指定的，而静态成员是不需要使用对象来调用的，所有对象都没创建，编译器不知道如何确定这个泛型参数是什么。</Integer></p>
<h5 id="7-4-泛型类型中的方法可能会冲突"><a href="#7-4-泛型类型中的方法可能会冲突" class="headerlink" title="7.4 泛型类型中的方法可能会冲突"></a>7.4 泛型类型中的方法可能会冲突</h5><p>​    因为擦除后两个equals方法变成一样的了。擦除之后T变成Object，而Object中的equals是默认被实现了的。所以重复了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">super</span> <span class="title">equals</span><span class="params">(t)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">super</span> <span class="title">equals</span><span class="params">(obj)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>


<h5 id="7-5-没法创建泛型实例"><a href="#7-5-没法创建泛型实例" class="headerlink" title="7.5 没法创建泛型实例"></a>7.5 没法创建泛型实例</h5><p>​    因为类型不确定，没法直接new对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list)</span></span>&#123;</span><br><span class="line">	E elem = <span class="keyword">new</span> E（）; <span class="comment">//不行，因为不知道E的具体类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是下面这种方式是可以的，通过反射来new对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list, Class&lt;E&gt; cls)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	E elem = cls.newInstance（）;  <span class="comment">// OK</span></span><br><span class="line">	list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-6-没有泛型数组"><a href="#7-6-没有泛型数组" class="headerlink" title="7.6 没有泛型数组"></a>7.6 没有泛型数组</h5><p>答：因为数组可以协变，擦除后就没法满足数组协变的原则。</p>
<p>T[] arr = new T[10]  //不可以  不知道T代表那个类</p>
<p><strong>另外：Apple extends Fruit</strong></p>
<p>Apple[] 的父类是Fruit[] 这个叫数组的协变。</p>
<p>其中数组协变中：父类可以持有子类，子类持有父类可能会报转化异常。</p>
<p>List<Apple> 和 List<Fruit>在擦除之后运行期不知道是什么类型了，都是不满足协变原则了；数组是可以协变的，但是list是不会协变的。</Fruit></Apple></p>
<p>另外假如：A extends B</p>
<p>Plate<B> = Plate<A>是不允许的，因为在泛型中，不管AB是什么关系，Plate<A>和Plate<B>没有任何关系。</B></A></A></B></p>
<h4 id="8-通配符和泛型的关系？"><a href="#8-通配符和泛型的关系？" class="headerlink" title="8. 通配符和泛型的关系？"></a>8. 通配符和泛型的关系？</h4><p>​    通配符可以让泛型转化更灵活。</p>
<h4 id="9-说出以下类型的区别"><a href="#9-说出以下类型的区别" class="headerlink" title="9. 说出以下类型的区别?"></a>9. 说出以下类型的区别?</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Plate 普通的盘子类，编译时不会做类型检查</span><br><span class="line">Plate&lt;Object&gt; 参数化的plate类，他在编译之后，字节码的类中的方法是Object</span><br><span class="line">Plate&lt;?&gt; 非限定通配符下的泛型类，泛型？表示类型未知，等价于Plate&lt;? extends Object&gt;</span><br><span class="line">Plate&lt;T&gt; 泛型Plate类，T是未知类型，编译后会被擦除成Object对象</span><br><span class="line">Plate&lt;? extends T&gt; 限定上界的泛型类</span><br><span class="line">Plate&lt;? <span class="keyword">super</span> T&gt; 限定下界的泛型类</span><br></pre></td></tr></table></figure>


<h4 id="10-泛型边界的熟记口诀："><a href="#10-泛型边界的熟记口诀：" class="headerlink" title="10.泛型边界的熟记口诀："></a>10.泛型边界的熟记口诀：</h4><ul>
<li><p>extends 上界；super 下界</p>
</li>
<li><p>说明：以下方便记忆的：“上”表示父类，“下”表示子类</p>
</li>
<li><p>*口诀：**</p>
</li>
</ul>
<p><strong>上界只可往上读，往上赋值；方法只能传递自己或者子类</strong></p>
<p><strong>下界只可向下写，向下赋值；方法只能传递自己或者父类</strong></p>
<h5 id="验证口诀的正确性："><a href="#验证口诀的正确性：" class="headerlink" title="验证口诀的正确性："></a>验证口诀的正确性：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * extends 上界</span></span><br><span class="line"><span class="comment">* super 下界</span></span><br><span class="line"><span class="comment">* 说明：以下方便记忆的：“上”表示父类，“下”表示子类</span></span><br><span class="line"><span class="comment">* 口诀：</span></span><br><span class="line"><span class="comment">* 上界只可往上读，往上赋值；方法只能传递自己或者子类</span></span><br><span class="line"><span class="comment">* 下界只可向下写，向下赋值；方法只能传递自己或者父类</span></span><br><span class="line"><span class="comment">* * 类关系： apple extends fruit extends food */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBoundary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//演示extends赋值的上界</span></span><br><span class="line">        List&lt;Food&gt; foods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fruits = apples; //error 往上赋值需要 extends</span></span><br><span class="line">        List&lt;? extends Fruit&gt; fruits1 = apples; <span class="comment">//向上赋值成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示向上读取</span></span><br><span class="line">        Fruit fruit = fruits1.get(<span class="number">0</span>); <span class="comment">//ok 上界修饰的可以往上读</span></span><br><span class="line">        Food food = fruits1.get(<span class="number">0</span>); <span class="comment">//ok 上界修饰的可以往上读</span></span><br><span class="line">        Object object = fruits1.get(<span class="number">0</span>); <span class="comment">//ok 上界修饰的可以往上读</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Apple apple = fruits1.get(0); //error 不能往下读</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示方法传递</span></span><br><span class="line">        eat1(fruits); <span class="comment">//ok 传递自己</span></span><br><span class="line">        eat1(apples); <span class="comment">//ok 传递子类</span></span><br><span class="line">        <span class="comment">//eat1(foods); //error 传递了父类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示Super赋值的下界</span></span><br><span class="line">        List&lt;Food&gt; foodsLower = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Apple&gt; applesLower = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Fruit&gt; fruitsLower = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//fruitsLower = foodsLower; //error 往下赋值需要super修饰</span></span><br><span class="line">        List&lt;? <span class="keyword">super</span> Fruit&gt; fruitList = foodsLower; <span class="comment">// 向下赋值ok了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示向下写</span></span><br><span class="line">        fruitList.add(<span class="keyword">new</span> Apple(<span class="number">1</span>)); <span class="comment">//用下写是ok</span></span><br><span class="line">        <span class="comment">//fruitList.add(new Food()); //error 用上写是不行的；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示下界方法只能传递自己或者父类</span></span><br><span class="line">        eat2(fruitsLower); <span class="comment">//传递自己ok</span></span><br><span class="line">        eat2(foodsLower); <span class="comment">// 传递父类ok</span></span><br><span class="line">        <span class="comment">//eat2(applesLower); //传递子类error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat1</span><span class="params">(List&lt;? extends Fruit&gt; fruits)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat2</span><span class="params">(List&lt;? <span class="keyword">super</span> Fruit&gt; fruits)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="11-最后说了半天规则，用实例演示以下泛型有什么用处"><a href="#11-最后说了半天规则，用实例演示以下泛型有什么用处" class="headerlink" title="11.最后说了半天规则，用实例演示以下泛型有什么用处"></a>11.最后说了半天规则，用实例演示以下泛型有什么用处</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 泛型的简单应用</span></span><br><span class="line"><span class="comment">* 从没用泛型慢慢演进 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通不使用泛型的方法。</span></span><br><span class="line">    <span class="comment">//有个需求需要把香蕉或者更多水果copy一下，难道需要重新写N个copy方法么？</span></span><br><span class="line">    <span class="comment">//答案不是的，出现了泛型copy2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy1</span><span class="params">(List&lt;Apple&gt; dest,List&lt;Apple&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在可以把无数多相同的水果相互copy了，但是又有一个需求了</span></span><br><span class="line">    <span class="comment">//现在苹果是确定了的，我想想找一个水果list把苹果放进去，于是就出现了copy3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy2</span><span class="params">(List&lt;T&gt; dest,List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在找到一个水果list放苹果了。但是现在还有一个需求</span></span><br><span class="line">    <span class="comment">//就是现在水果list确定了，我要放的水果不确定，于是有了copy4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy3</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest,List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个就是Collections.copy的终极用法了。</span></span><br><span class="line">    <span class="comment">//public static &lt;T&gt; void copy(@RecentlyNonNull List&lt;? super T&gt; dest, @RecentlyNonNull List&lt;? extends T&gt; src)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy4</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest,List&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//新建两个苹果list</span></span><br><span class="line">        List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple(<span class="number">1</span>));</span><br><span class="line">        List&lt;Apple&gt; apples1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        apples1.add(<span class="keyword">new</span> Apple(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建两个香蕉list</span></span><br><span class="line">        List&lt;Banana&gt; bananas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bananas.add(<span class="keyword">new</span> Banana(<span class="number">1</span>));</span><br><span class="line">        List&lt;Banana&gt; bananas1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bananas1.add(<span class="keyword">new</span> Banana(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建水果list</span></span><br><span class="line">        List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="keyword">new</span> Apple(<span class="number">10</span>)) ;   <span class="comment">// 先要告诉编译器fruit是放的苹果，否者copy3的dest参数编译器不知道放什么</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通方法</span></span><br><span class="line">        copy1(apples,apples1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用泛型方法</span></span><br><span class="line">        copy2(bananas,bananas1);    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//苹果往水果盘子放</span></span><br><span class="line">        Test.&lt;Apple&gt;copy3(fruits,apples);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里苹果是确认的了</span></span><br><span class="line">        <span class="comment">//水果list确定了放任意水果</span></span><br><span class="line">        Test.&lt;Fruit&gt;copy4(fruits,apples);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>测试代码：</strong><a href="https://github.com/oujie123/UnderstandingOfGeneric">https://github.com/oujie123/UnderstandingOfGeneric</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Android应用签名和校验方法</title>
    <url>/2021/01/27/%E8%A7%A3%E6%9E%90Android%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用keytool指令</p>
<p>在jdk的bin目录下找到keytool执行如下：</p>
<p>keytool -list -printcert -jarfile D:\GoogleNewTest\sdkgoogle.apk</p>
<p>一般结果是这样：</p>
<p>签名者 #1:</p>
<p>签名:</p>
<p>所有者: O=wildstone</p>
<p>发布者: O=wildstone</p>
<p>序列号: 5619594d</p>
<p>有效期开始日期: Tue Mar 27 11:17:06 CST 2018, 截止日期: Wed Mar 14 11:17:06 CST</p>
<p>2068</p>
<p>证书指纹:</p>
<p>MD5: B4:8A:9A:73:28:37:D0:1B:AE:3F:35:5B:25:61:66:DA</p>
<p>SHA1: 36:C7:87:8C:FC:D4:40:9E:D6:A0:B7:8B:3A:4E:AB:A2:F2:2C:7E:37</p>
<p>SHA256: C0:23:9C:9D:8C:EA:A8:50:9F:5D:27:7A:F6:C4:7D:EB:8D:39:CB:96:18:</p>
<p>45:D4:2C:3A:45:5A:F2:FF:28:FC:44</p>
<p>签名算法名称: SHA1withRSA</p>
<p>版本: 3</p>
<p>本次双签名的问题是如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-92fcebe3d0065c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>2.查看文件</p>
<p>解压apk查看META-INF的文件夹内容</p>
<p>1）正常情况，如下图3个文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ccbb502b602aa1d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>2）双签名的apk，如下图5个文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-da3d263ded5effba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>正常情况下的几个文件签名逻辑</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2b9aac9eb377022c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d6f79a4fcd9bc80e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>app签名过程</tag>
        <tag>证书内容</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler机制</title>
    <url>/2021/01/27/Handler%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="1-Handler的诞生"><a href="#1-Handler的诞生" class="headerlink" title="1.Handler的诞生"></a>1.Handler的诞生</h3><p>由于Android采用的是单线程模式，开发者无法在子线程中更新 UI，因此在Android开发中，经常会在子线程中进行一些操作，当操作完成之后，将结果发送到主线程进行显示。探索其背后的模式：子线程、Handler和主线程三者组成了生产者和消费者模式。子线程负责生产数据，主线程负责消费数据，而<strong>Handler负责将数据从子线程抛到主线程中</strong>。详细见下图</p>
<img src="/2021/01/27/Handler%E6%9C%BA%E5%88%B6/Handler%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.png" class title="[Handler生产者消费者模型]">



<h3 id="2-Handler相关的类"><a href="#2-Handler相关的类" class="headerlink" title="2.Handler相关的类"></a>2.Handler相关的类</h3><ul>
<li>Hanlder：发送和接收消息 </li>
<li>Looper：用于轮询消息队列，一个线程只能有一个Looper </li>
<li>Message： 消息实体</li>
<li>MessageQueue： 消息队列用于存储消息和管理消息。</li>
</ul>
<h4 id="2-1-Looper的创建"><a href="#2-1-Looper的创建" class="headerlink" title="2.1 Looper的创建"></a>2.1 Looper的创建</h4><blockquote>
<p>创建Looper的方法是调用Looper.prepare() 方法或者Looper.prepareMainLooper()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadlocal保证一个线程只有一个looper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123; <span class="comment">//如果prepare()被调用两次就会抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//但Thread的map中没有looper,就创建一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span> <span class="comment">//该方法被废弃的原因是:Android帮我们调用了，自己不能调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>); <span class="comment">// 调到上述方法，创建looper</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-创建MessageQueue以及与Looper和当前线程绑定"><a href="#2-2-创建MessageQueue以及与Looper和当前线程绑定" class="headerlink" title="2.2 创建MessageQueue以及与Looper和当前线程绑定"></a>2.2 创建MessageQueue以及与Looper和当前线程绑定</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">// 创建MessageQueue</span></span><br><span class="line">    mThread = Thread.currentThread();<span class="comment">//与当前线程绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quitAllowed参数子线程传入的true，主线程传入false，代表主线程不允许销毁队列</span></span><br><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-Looper-loop-方法"><a href="#2-3-Looper-loop-方法" class="headerlink" title="2.3 Looper.loop()方法"></a>2.3 Looper.loop()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();	<span class="comment">//从threadlocal中拿到调prepare()创建的looper</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//不断从消息队列取消息。</span></span><br><span class="line">        <span class="comment">//queue.next()取消息的过程利用了epoll机制，当没有消息的时候阻塞，当有消息时，向管道写入一个字节数据，唤醒线程取消息。</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//如果队列返回null,说明quit()被调用，需要退出线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 回调抛message的Handler的dispatchMessage，最终会调到handler接收到的callback.handleMessage(msg)中或者handler重写的handleMessage(msg)中。</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//回收处理完的消息(Message采用了享元模式,防止不停的new Message导致内存抖动)</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-4-Handler的创建"><a href="#2-4-Handler的创建" class="headerlink" title="2.4 Handler的创建"></a>2.4 Handler的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="comment">//处理自己抛的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方式2 传入main looper或者子线程looper,通常传MainLooper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3 传入looper和callback,消息处理在callback中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-5-Message的创建"><a href="#2-5-Message的创建" class="headerlink" title="2.5 Message的创建"></a>2.5 Message的创建</h4><p>可以直接new Message()但是不建议这么使用，因为如果有大量的new Message()然后用完了就被回收，这样会导致内存抖动。推荐的方式是使用obtain()系列方法。Message使用了享元模式，内部维护了一个对象池(最大50个)，管理者对象的创建和销毁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next; <span class="comment">//从对象池头部取一个message</span></span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Message中有一系列obtain()方法，主要是完成handler绑定或者callback绑定工作，就不全列举了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> <span class="comment">//Message和handler绑定</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span><span class="comment">//Message与handler和Runnable绑定</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what)</span> <span class="comment">//Message与handler和事件码绑定</span></span></span><br></pre></td></tr></table></figure>


<h4 id="2-6-Message和Handhler绑定"><a href="#2-6-Message和Handhler绑定" class="headerlink" title="2.6 Message和Handhler绑定"></a>2.6 Message和Handhler绑定</h4><ul>
<li><p>方式1：通过上面创建Message时绑定</p>
</li>
<li><p>方式2：在发送消息的到时候绑定(代码如下)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>; <span class="comment">//绑定handler</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-7-Handler发送消息"><a href="#2-7-Handler发送消息" class="headerlink" title="2.7 Handler发送消息"></a>2.7 Handler发送消息</h4><p>如下图调用关系，Handler发送消息的重载方法很多，但是主要只有2种。 sendMessage(Message) sendMessage方法通过一系列重载方法的调用，sendMessage调用sendMessageDelayed，继续调用sendMessageAtTime，继续调用sendMessageAtTime，继续调用enqueueMessage，继续调用MessageQueue的enqueueMessage方法，将消息保存在消息队列中。</p>
<img src="/2021/01/27/Handler%E6%9C%BA%E5%88%B6/%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" class title="[Handler发送消息调用流程]">



<h4 id="2-8-Handler消费消息"><a href="#2-8-Handler消费消息" class="headerlink" title="2.8 Handler消费消息"></a>2.8 Handler消费消息</h4><p>当Looper取出，交给Handler的dispatchMessage进行处理</p>
<p>我们可以看到在dispatchMessage方法中，message中callback是一个Runnable对象，如果callback不为空，则直接调用callback的run方法，否则判断mCallback是否为空，mCallback在Handler构造方法中初始化，在主线程通直接通过无参的构造方法new出来的为null,所以会直接执行后面的handleMessage()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//callback在message的构造方法中初始化或者使用handler.post(Runnable)时候才不为空</span></span><br><span class="line">        handleCallback(msg); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;<span class="comment">//如果callback不为空就调用callback的run()方法</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有Runnable,就回调handler重写的handleMessage()方法。</span></span><br><span class="line">        <span class="comment">//注意，不管是否设置callback都会回调handleMessage()方法</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-难点问题"><a href="#3-难点问题" class="headerlink" title="3.难点问题"></a>3.难点问题</h3><h4 id="3-1-消息加入和取出如何保证线程安全"><a href="#3-1-消息加入和取出如何保证线程安全" class="headerlink" title="3.1 消息加入和取出如何保证线程安全"></a>3.1 消息加入和取出如何保证线程安全</h4><p>MessageQueue在消息入队的时候和取消息的时候都会对队列加锁，保证要么入队消息，要么出队消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息入队</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//当入队的时候对消息队列加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息出队</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//循环等待消息</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//消息出队过程加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-2-消息机制之同步屏障"><a href="#3-2-消息机制之同步屏障" class="headerlink" title="3.2 消息机制之同步屏障"></a>3.2 消息机制之同步屏障</h4><p>通过上面分析，通常情况下Handler抛的消息会按照时间排序，然后Looper从头部开始一个一个取消息执行。但是有个需求是在一个小的时间范围内，handler抛的消息需要优先执行，那我们应该如何处理呢？例如UI需要立马重绘，而且需要优先处理这个消息，那就要用到消息同步屏障。</p>
<blockquote>
<p>MessageQueue.postSyncBarrier()    //开启同步屏障</p>
<p>MessageQueue.removeSyncBarrier() //移除同步屏障</p>
<p>Message.setAsynchronous(true)  //设置为异步消息</p>
</blockquote>
<h5 id="3-2-1-开启同步屏障"><a href="#3-2-1-开启同步屏障" class="headerlink" title="3.2.1 开启同步屏障"></a>3.2.1 开启同步屏障</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，方法调用返回一个屏障的token，到时候删除的时候会用到这个token</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="comment">//从消息池中获取Message</span></span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//就是这里！！！初始化Message对象的时候，并没有给target赋值，因此 target==null</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">             <span class="comment">//如果开启同步屏障的时间（假设记为T）T不为0，且当前的同步消息里有时间小于T，则prev也不为null</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据prev是不是为null，将 msg 按照时间顺序插入到 消息队列（链表）的合适位置</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处开启同步屏障之后，从消息池获取的Message中target==null。</p>
<h5 id="3-2-2-处理异步消息"><a href="#3-2-2-处理异步消息" class="headerlink" title="3.2.2 处理异步消息"></a>3.2.2 处理异步消息</h5><p>从下面可以看出，当消息队列开启同步屏障的时候（即标识为<code>msg.target == null</code>），消息机制在处理消息的时候，优先处理异步消息。这样，同步屏障就起到了一种过滤和优先级的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	.....<span class="comment">//省略一些代码</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//获取系统开机到现在的时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages; <span class="comment">//当前链表的头结点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关键！！！</span></span><br><span class="line">            <span class="comment">//如果target==null，那么它就是屏障，需要循环遍历，一直往后找到第一个异步的消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next; <span class="comment">//=====重新给msg赋值，达到优先返回异步消息的作用===</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//如果有异步消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果有时间到的消息就返回，否则就等待。</span></span><br><span class="line">            &#125;</span><br><span class="line">            .....<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了同步屏障，在返回的msg中会被重新赋值，所以如果开启了同步屏障，MessageQueue会遍历队列中是否有时间到了的异步消息，如果有就重新给msg赋值让他返回出去给handler处理。</p>
<p>示意图如下：</p>
<img src="/2021/01/27/Handler%E6%9C%BA%E5%88%B6/%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="[同步屏障示意图]">





<h5 id="3-2-3-同步屏障的使用场景"><a href="#3-2-3-同步屏障的使用场景" class="headerlink" title="3.2.3 同步屏障的使用场景"></a>3.2.3 同步屏障的使用场景</h5><p>在 View 更新时，draw、requestLayout、invalidate 等很多地方都调用<code>ViewRootImpl#scheduleTraversals()</code>，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//开启同步屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Choreographer.postCallback最终会调用到postCallbackDelayedInternal()，在这里面设置为异步消息并且发送到消息队列中</span></span><br><span class="line">        <span class="comment">// mTraversalRunnable中会移除同步屏障并且执行UI更新</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;PostCallback: type=&quot;</span> + callbackType</span><br><span class="line">                    + <span class="string">&quot;, action=&quot;</span> + action + <span class="string">&quot;, token=&quot;</span> + token</span><br><span class="line">                    + <span class="string">&quot;, delayMillis=&quot;</span> + delayMillis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">                msg.arg1 = callbackType;</span><br><span class="line">                <span class="comment">//将消息设置成异步消息并且发送到消息队列中，消息队列会根据target==null时取出异步消息执行</span></span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-3-同步执行消息"><a href="#3-3-同步执行消息" class="headerlink" title="3.3 同步执行消息"></a>3.3 同步执行消息</h4><h5 id="3-3-1-runWithScissors-分析"><a href="#3-3-1-runWithScissors-分析" class="headerlink" title="3.3.1 runWithScissors()分析"></a>3.3.1 runWithScissors()分析</h5><p>我们从前面的分析可以看出生产者-消费者模式其实是异步的执行操作。生产者生产好了商品向容器里面放，消费者只管从容器取就行，但是有这么一个场景，就是我生产的东西需要消费了才能继续生产下去，那么就需要考虑同步执行消息了。（可能举例不恰当）但是在framework中，WindowManagerService初始化的时候，就会出现这样的情况，WindowManagerService的初始化是放在<strong>显示子线程</strong>完成的，但是使用多线程来初始化服务虽然加快了初始化速度，但是也会出现一种情况就是某个服务没有初始化结束，导致其他服务运行异常的情况。因此系统提供了Handler.runWithScissors()这个方法来实现同步执行消息。如果任务没有执行结束，该线程不能执行其他的任务。下面我们来分析一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runWithScissors</span><span class="params">(<span class="meta">@NonNull</span> Runnable r, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="comment">// 创建一个带阻塞功能的Runnable，主要是传入待执行的任务</span></span><br><span class="line">    BlockingRunnable br = <span class="keyword">new</span> BlockingRunnable(r);</span><br><span class="line">    <span class="keyword">return</span> br.postAndWait(<span class="keyword">this</span>, timeout); <span class="comment">// 发送任务到消息队列，并且阻塞线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postAndWait</span><span class="params">(Handler handler, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!handler.post(<span class="keyword">this</span>)) &#123; <span class="comment">//发送任务到消息队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> expirationTime = SystemClock.uptimeMillis() + timeout;</span><br><span class="line">            <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait(delay); <span class="comment">//有超时时间的阻塞线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//阻塞线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BlockingRunnable的run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mTask.run();  <span class="comment">//调用传入任务的run方法执行任务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mDone = <span class="keyword">true</span>;</span><br><span class="line">            notifyAll(); <span class="comment">//通知其他线程不再休眠</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-2-runWithScissors-使用场景"><a href="#3-3-2-runWithScissors-使用场景" class="headerlink" title="3.3.2 runWithScissors()使用场景"></a>3.3.2 runWithScissors()使用场景</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,<span class="keyword">final</span> <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="keyword">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory,Supplier&lt;Surface&gt; surfaceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用显示子线程来初始化WindowManagerService</span></span><br><span class="line">    DisplayThread.getHandler().runWithScissors(() -&gt;</span><br><span class="line">            sInstance = <span class="keyword">new</span> WindowManagerService(context, im, showBootMsgs, onlyCore, policy,atm, transactionFactory, surfaceFactory, surfaceControlFactory), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>参考文章：</strong></p>
<p><a href="https://juejin.cn/post/6844903910113705998">同步屏障</a></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>Framework</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(八) -- Java内存模型</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%85%AB-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="1-计算机原理"><a href="#1-计算机原理" class="headerlink" title="1. 计算机原理"></a>1. 计算机原理</h4><p>​    Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java1.5版本对其进行了重构，现在的Java仍沿用了Java1.5的版本。</p>
<p>根据《Jeff Dean在Google全体工程大会的报告》我们可以看到</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1d49798d5a18fbd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机执行不同操作耗时.png"></p>
<p>计算机在做一些我们平时的基本操作时，需要的响应时间是不一样的。</p>
<h4 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2.  Java内存模型"></a>2.  Java内存模型</h4><p>​    从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个<strong>私有</strong>的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4bc74c29ba73c70a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JMM模型.png"></p>
<h5 id="2-1-可见性"><a href="#2-1-可见性" class="headerlink" title="2.1 可见性"></a>2.1 可见性</h5><p>​    可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>​    由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。</p>
<p>​    要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。</p>
<h5 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h5><p>​    原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>​    我们都知道CPU资源的分配都是以线程为单位的,并且是分时调用,操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。而任务的切换大多数是在时间片段结束以后,</p>
<p>​    那么线程切换为什么会带来bug呢？因为操作系统做任务切换，可以发生在任何一条CPU 指令执行完！注意，是 CPU 指令,而不是高级语言里的一条语句。比如count++，在java里就是一句话，但高级语言里一条语句往往需要多条 CPU 指令完成。其实count++包含了三个CPU指令！</p>
<h4 id="3-volatile详解"><a href="#3-volatile详解" class="headerlink" title="3.volatile详解"></a>3.volatile详解</h4><h5 id="3-1-volatile特性"><a href="#3-1-volatile特性" class="headerlink" title="3.1 volatile特性"></a>3.1 volatile特性</h5><p>​    可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>​    原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。例如：volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2。</p>
<p>​    抑制重排序：<strong>有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p>
<p>​    指令重排序：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<h5 id="3-2-volatile的实现原理"><a href="#3-2-volatile的实现原理" class="headerlink" title="3.2 volatile的实现原理"></a>3.2 volatile的实现原理</h5><p>​    为了探究Volatile的底层实现原理，我们需要先将java代码编程成字节码，然后通过java工具看汇编代码就可以知道底层原理。下面来看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap -c 文件名 或者AndroidStudio的ASM插件看字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;clinit&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ICONST_0</span><br><span class="line">    <span class="comment">// 下面这行字节码无论是否使用volatile修饰，都是一样的</span></span><br><span class="line">    PUTSTATIC com/example/threadtest/volatilesynchronized/TestVolatile.i : I</span><br><span class="line">    RETURN</span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后继续往下探索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly TestVolatile &gt; 1.txt</span><br></pre></td></tr></table></figure>
<p>查看汇编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Line 2521:   0x000000000356fecc: lock cmpxchg qword ptr [rdx],rdi</span><br><span class="line">Line 2528:   0x000000000356feed: lock cmpxchg qword ptr [rdx],rdi</span><br><span class="line">Line 2534:   0x000000000356ff0b: lock add dword ptr [rsp],0h ;*putstatic</span><br><span class="line">Line 2538:   0x000000000356ff1a: lock cmpxchg qword ptr [rdx],rsi</span><br><span class="line">Line 2816:   0x0000000003570338: lock cmpxchg qword ptr [rdi],rsi</span><br><span class="line">Line 2941:   0x0000000003570479: lock cmpxchg qword ptr [rsi],rdi</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<p>汇编指令中会有很多加“lock”前缀的指令。</p>
<p>加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。我们发现，volatile变量在字节码级别没有任何区别，在汇编级别使用了lock指令前缀。</p>
<blockquote>
<p>lock是一个指令前缀，Intel的手册上对其的解释是：</p>
<p> Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal insures that the processor has exclusive use of any shared memory while the signal is asserted.</p>
</blockquote>
<p>​    简单理解也就是说，lock后就是一个原子操作。原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>​    当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。</p>
<p>​    乍一看是不是感觉和Java的synchronized锁。但volatile底层使用多核处理器实现的lock指令，更底层，消耗代价更小。</p>
<p>​    <strong>因此有人将Java的synchronized看作重量级的锁，而volatile看作轻量级的锁 并不是全无道理。</strong></p>
<p>​    lock前缀指令其实就相当于一个内存屏障。内存屏障是一组CPU处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。</p>
<p>​    编译器和执行器 可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。</p>
<p>​    <strong>内存屏障另一个作用是强制更新一次不同CPU的缓存。</strong>例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪个CPU执行的。这正是volatile实现内存可见性的基础。</p>
<h4 id="3-3-synchronized的实现原理"><a href="#3-3-synchronized的实现原理" class="headerlink" title="3.3 synchronized的实现原理"></a>3.3 synchronized的实现原理</h4><p>​    Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>对同步块</strong>，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ......</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">    MONITORENTER      <span class="comment">// 同步块开始</span></span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 15 L0</span></span><br><span class="line"><span class="function">    GETSTATIC com/example/threadtest/volatilesynchronized/Test.i : I</span></span><br><span class="line"><span class="function">    ICONST_1</span></span><br><span class="line"><span class="function">    IADD</span></span><br><span class="line"><span class="function">    PUTSTATIC com/example/threadtest/volatilesynchronized/Test.i : I</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LINENUMBER 16 L5</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    MONITOREXIT   <span class="comment">// 同步块结束</span></span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    GOTO L6</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> 	 ......</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>对同步方法</strong>，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了<strong>ACC_SYNCHRONIZED</strong>标示符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// access flags 0x1    没有synchronized修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// access flags 0x21   synchronized修饰</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">b</span><span class="params">()</span>V</span></span><br></pre></td></tr></table></figure>


<p>​    JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<p>​    synchronized使用的锁信息是存放在Java对象头里面。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c41b9e1044e9b947.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象头.png"></p>
<p>​    具体位置是对象头里面的MarkWord，MarkWord里默认数据是存储对象的HashCode等信息，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c78ecc4cb3e78dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="markword位定义.png"></p>
<p>​    但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1fc34498389dd8f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="锁状态.png"></p>
<h4 id="3-4-各种锁"><a href="#3-4-各种锁" class="headerlink" title="3.4 各种锁"></a>3.4 各种锁</h4><p><strong>3.4.1.1 自旋锁 (轻量级锁)</strong></p>
<p>​    自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p><strong>3.4.1.2 自旋锁的优缺点</strong></p>
<p>​    自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。</p>
<p>​    但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功。</p>
<p><strong>3.4.1.3 自旋锁时间阈值</strong></p>
<p>​    JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁</p>
<p>，<strong>适应性自旋锁</strong>意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p>
<p>​    JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制</p>
<p><strong>3.4.2.1 偏向锁</strong></p>
<p>​    研究人员经过大量统计，发现一把锁总是被同一线程竞争拿到，所以就引入偏向锁概念，当在进行CAS自旋拿锁之前，先判断自己是不是在竞争这把锁，如果是就直接执行。</p>
<p>​    偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），<strong>这种情况下，就会给线程加一个偏向锁</strong>。 如果在运行过程中，<strong>遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</strong>它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</p>
<p><strong>偏向锁获取过程：</strong></p>
<ul>
<li><p>第一步，访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</p>
</li>
<li><p>第二步，如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</p>
</li>
<li><p>第三步，如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</p>
</li>
<li><p>第四步，如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</p>
</li>
<li><p>第五步，执行同步代码。</p>
</li>
</ul>
<p><strong>偏向锁的释放：</strong></p>
<p>​    偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p><strong>偏向锁的适用场景</strong></p>
<p>​    始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； </p>
<p>​    在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</p>
<p><strong>jvm开启/关闭偏向锁</strong></p>
<p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</p>
<p>关闭偏向锁：-XX:-UseBiasedLocking</p>
<p><strong>3.4.3 轻量级锁</strong></p>
<p>​    轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p>
<p><strong>轻量级锁的加锁过程：</strong></p>
<p>​    在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p>
<p>​    拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</p>
<ul>
<li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态</p>
</li>
<li><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，<strong>当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁</strong>，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
</li>
</ul>
<p><strong>3.4.4 不同锁之间的区别</strong></p>
<p>​    JVM虚拟机对synchronized关键字的优化引入了自适应性CAS锁、偏向锁和轻量级锁机制。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-06ca275216327a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对synchronized用不同锁的优化.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(六) -- 阻塞队列和线程池</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%85%AD-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="1-阻塞队列"><a href="#1-阻塞队列" class="headerlink" title="1. 阻塞队列"></a>1. 阻塞队列</h3><ul>
<li><p><strong>队列</strong>：是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。<br>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p>
</li>
<li><p><strong>阻塞队列</strong>是支持阻塞插入和支持阻塞移除的队列：</p>
<p>阻塞的插入：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>阻塞的移除：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>
</li>
</ul>
<h3 id="2-阻塞队列的用途"><a href="#2-阻塞队列的用途" class="headerlink" title="2. 阻塞队列的用途"></a>2. 阻塞队列的用途</h3><ul>
<li>阻塞队列常用于<strong>生产者和消费者</strong>的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</li>
</ul>
<h4 id="2-1-为什么有生产者消费者模式"><a href="#2-1-为什么有生产者消费者模式" class="headerlink" title="2.1 为什么有生产者消费者模式"></a>2.1 为什么有生产者消费者模式</h4><ul>
<li>在并发编程中，为了平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度，因此生产者消费者模式就有了用武之地。</li>
<li>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。</li>
</ul>
<p>​    <strong>因此就需要将生产者和消费者隔离开，并且用一个容器将产品装好。生产者生产好产品就把产品放入容器，消费者需要的时候就从容器中拿。</strong> 而这个容器就可以用队列来实现。然而有容器为空和满的两种情况导致生产者在容器满的时候无法放入队列，消费者当容器为空的时候无法从队列获取产品。所以阻塞队列就应运而生。</p>
<h4 id="2-2-阻塞队列接口-BlockingQueue"><a href="#2-2-阻塞队列接口-BlockingQueue" class="headerlink" title="2.2 阻塞队列接口(BlockingQueue)"></a>2.2 阻塞队列接口(BlockingQueue)</h4><p>​    下面看看BlockingQueue中定义的方法区别</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(E)</td>
<td>offer(E)</td>
<td>put(E)</td>
<td>offer(E, time, unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(E, time, unit)</td>
</tr>
<tr>
<td>检查队列方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li><p>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</p>
</li>
<li><p>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</p>
</li>
<li><p>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</p>
</li>
<li><p>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p>
</li>
</ul>
<h4 id="2-3-有哪些阻塞队列"><a href="#2-3-有哪些阻塞队列" class="headerlink" title="2.3 有哪些阻塞队列"></a>2.3 有哪些阻塞队列</h4><ul>
<li><p>ArrayBlockingQueue：一个由数组结构组成的<strong>有界</strong>阻塞队列。</p>
<p>是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列。在操作队列的时候使用同一把<strong>显示锁</strong>。</p>
</li>
</ul>
<ul>
<li><p>LinkedBlockingQueue：一个由链表结构组成的<strong>有界</strong>阻塞队列。</p>
<p>是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。在操作队列的时候使用三把锁实现：lock全局锁、放入时队列不满锁notFull和取出时队列不为空锁notEmpty。</p>
</li>
</ul>
<ul>
<li><p>PriorityBlockingQueue：一个支持优先级排序的<strong>无界</strong>阻塞队列。</p>
<p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
</li>
</ul>
<ul>
<li><p>DelayQueue：一个使用优先级队列实现的<strong>无界</strong>阻塞队列。</p>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p>
</li>
</ul>
<ul>
<li><p>SynchronousQueue：一个<strong>不存储元素</strong>的阻塞队列。</p>
<p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。主要可以解决生产者消费者隔离问题。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
</li>
</ul>
<ul>
<li>LinkedTransferQueue：一个由链表结构组成的<strong>无界</strong>阻塞队列。<ul>
<li><strong>(1) transfer方法</strong><pre><code>  如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</code></pre>
</li>
<li><strong>(2) tryTransfer方法</strong><br>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是<strong>tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</strong></li>
</ul>
</li>
</ul>
<ul>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p>
</li>
</ul>
<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h3><h4 id="3-1-使用线程池的好处"><a href="#3-1-使用线程池的好处" class="headerlink" title="3.1 使用线程池的好处"></a>3.1 使用线程池的好处</h4><ul>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。有时候任务执行的时间还远小于线程创建和销毁的时间。</p>
</li>
<li><p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
</li>
</ul>
<h4 id="3-2-线程池相关的类"><a href="#3-2-线程池相关的类" class="headerlink" title="3.2 线程池相关的类"></a>3.2 线程池相关的类</h4><ul>
<li><p>Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</p>
</li>
<li><p>ExecutorService接口继承了Executor，在其上做了一些shutdown()、submit()的扩展，可以说是真正的线程池接口；</p>
</li>
<li><p>AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法；</p>
</li>
<li><p>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。</p>
</li>
<li><p>ScheduledExecutorService接口继承了ExecutorService接口，提供了带”周期执行”功能ExecutorService；</p>
</li>
<li><p>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bce5aa17de1ecc42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池类关系图.png"></p>
<h4 id="3-3-线程池的创建各个参数含义"><a href="#3-3-线程池的创建各个参数含义" class="headerlink" title="3.3 线程池的创建各个参数含义"></a>3.3 线程池的创建各个参数含义</h4><blockquote>
<p>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, /*核心线程数，最大线程数*/</p>
<p>​    long keepAliveTime, TimeUnit unit,  /*空闲线程存活时间 */</p>
<p>​    BlockingQueue<Runnable> workQueue, /*阻塞队列 */</Runnable></p>
<p>   ThreadFactory threadFactory,  /*线程工厂 */</p>
<p>   RejectedExecutionHandler handler)  /*线程池拒绝策略处理器 */</p>
</blockquote>
<p>从构造方法可以看出创建线程池有五类7个参数可以配置，下面来一一阐述一下</p>
<h5 id="3-3-1-corePoolSize"><a href="#3-3-1-corePoolSize" class="headerlink" title="3.3.1 corePoolSize"></a>3.3.1 corePoolSize</h5><p>​    线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；</p>
<p>​    如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p>
<p>​    如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<h5 id="3-3-2-maximumPoolSize"><a href="#3-3-2-maximumPoolSize" class="headerlink" title="3.3.2 maximumPoolSize"></a>3.3.2 maximumPoolSize</h5><p>​    线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p>
<h5 id="3-3-3-keepAliveTime"><a href="#3-3-3-keepAliveTime" class="headerlink" title="3.3.3 keepAliveTime"></a>3.3.3 keepAliveTime</h5><p>​    线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p>
<h5 id="3-3-4-TimeUnit"><a href="#3-3-4-TimeUnit" class="headerlink" title="3.3.4 TimeUnit"></a>3.3.4 TimeUnit</h5><p>keepAliveTime的时间单位</p>
<h5 id="3-3-5-workQueue"><a href="#3-3-5-workQueue" class="headerlink" title="3.3.5 workQueue"></a>3.3.5 workQueue</h5><p>​    workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。</p>
<p>​    一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响。</p>
<ul>
<li>(1)当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li>
<li>(2)由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li>
<li>(3)由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li>
<li>(4)更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</li>
</ul>
<h5 id="3-3-6-threadFactory"><a href="#3-3-6-threadFactory" class="headerlink" title="3.3.6 threadFactory"></a>3.3.6 threadFactory</h5><p>​    创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。</p>
<p>​    Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</p>
<h5 id="3-3-7-RejectedExecutionHandler"><a href="#3-3-7-RejectedExecutionHandler" class="headerlink" title="3.3.7 RejectedExecutionHandler"></a>3.3.7 RejectedExecutionHandler</h5><p>​    线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<ul>
<li>(1) AbortPolicy：直接抛出异常，默认策略；</li>
<li>(2) CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>(3) DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>(4) DiscardPolicy：直接丢弃任务；</li>
</ul>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h4 id="3-4-线程池工作机制"><a href="#3-4-线程池工作机制" class="headerlink" title="3.4 线程池工作机制"></a>3.4 线程池工作机制</h4><ul>
<li><p>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p>
</li>
<li><p>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p>
</li>
<li><p>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</p>
</li>
<li><p>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-3a556b66a0620b99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池工作机制.png"></p>
<h4 id="3-5-提交任务"><a href="#3-5-提交任务" class="headerlink" title="3.5 提交任务"></a>3.5 提交任务</h4><h5 id="3-5-1-execute"><a href="#3-5-1-execute" class="headerlink" title="3.5.1 execute()"></a>3.5.1 execute()</h5><pre><code> execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</code></pre>
<h5 id="3-5-2-submit"><a href="#3-5-2-submit" class="headerlink" title="3.5.2 submit()"></a>3.5.2 submit()</h5><p>​    submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h4 id="3-6-关闭线程池"><a href="#3-6-关闭线程池" class="headerlink" title="3.6 关闭线程池"></a>3.6 关闭线程池</h4><p>​    可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断<strong>所有没有正在执行任务的线程</strong>。</p>
<p>​    只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);	<span class="comment">// 将线程池状态设置成SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers();    <span class="comment">// 中断空闲线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(STOP);	<span class="comment">// 将线程池状态设置成STOP</span></span><br><span class="line">            interruptWorkers();		<span class="comment">// 中断所有线程</span></span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-7-如何合理配置线程池"><a href="#3-7-如何合理配置线程池" class="headerlink" title="3.7 如何合理配置线程池"></a>3.7 如何合理配置线程池</h4><p>​    要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。</li>
<li>任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>
<p>​    <strong>针对CPU密集型任务</strong>应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。(可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数)</p>
<p>​    <strong>针对混合型的任务</strong>，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。</p>
<p>​    <strong>针对优先级不同的任务</strong>可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行</p>
<p>​    <strong>执行时间</strong>不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行</p>
<p><strong>测试用例代码见： <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(一) -- 线程进程基础</title>
    <url>/2021/01/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95(%E4%B8%80)%20--%20%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><blockquote>
<p><strong>进程概念</strong>：进程是程序运行资源分配的最小单位</p>
<blockquote>
<p>进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO 等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。</p>
</blockquote>
<p><strong>线程概念</strong>：线程是CPU 调度的最小单位,必须依赖于进程而存在</p>
<blockquote>
<p>线程是进程的一个实体,是CPU 调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</blockquote>
</blockquote>
<h3 id="CPU-核心数和线程数的关系"><a href="#CPU-核心数和线程数的关系" class="headerlink" title="CPU 核心数和线程数的关系"></a>CPU 核心数和线程数的关系</h3><blockquote>
<p><strong>多核心</strong>:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP 是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU 同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理<br><strong>多线程</strong>: Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。<br><strong>核心数、线程数</strong>:目前主流CPU 都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1 对应关系,也就是说四核CPU 一般拥有四个线程。但Intel 引入超线程技术后,使核心数与线程数形成1:2 的关系</p>
</blockquote>
<h3 id="CPU时间片轮转机制-RR-调度"><a href="#CPU时间片轮转机制-RR-调度" class="headerlink" title="CPU时间片轮转机制(RR 调度)"></a>CPU时间片轮转机制(RR 调度)</h3><p>​    时间片轮转法（Round-Robin，RR）主要用于分时系统中的进程调度。为了实现轮转调度，系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在 CPU 上运行一个时间片的时间。时间片是一个小的时间单位，通常为 10~100ms 数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把 CPU 分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。<br>​    </p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>​    采用此算法的系统，其程序就绪队列往往按进程到达的时间来排序。进程调度程序总是选择就绪队列中的第一个进程，也就是说按照先来先服务原则调度，但一旦进程占用<a href="https://link.hacpai.com/forward?goto=https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA">处理机</a>则仅使用一个时间片。在使用先一个时间片后，进程还没有完成其运行，它必须释放出处理机给下一个就绪的进程，而被抢占的进程返回到就绪队列的末尾重新排队等待再次运行。</p>
<p>处理器同一个时间只能处理一个任务。处理器在处理多任务的时候，就要看请求的时间顺序，如果时间一致，就要进行预测。挑到一个任务后，需要若干步骤才能做完，这些步骤中有些需要处理器参与，有些不需要（如磁盘控制器的存储过程）。不需要处理器处理的时候，这部分时间就要分配给其他的进程。原来的进程就要处于等待的时间段上。经过周密分配时间，宏观上就象是多个任务一起运行一样，但微观上是有先后的，就是时间片轮换。</p>
<h4 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h4><p>​    时间片轮转算法的基本思想是，系统将所有的就绪进程按先来先服务算法的原则，排成一个队列，每次调度时，系统把<a href="https://link.hacpai.com/forward?goto=https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA">处理机</a>分配给队列首进程，并让其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序根据这个请求停止该进程的运行，将它送到就绪队列的末尾，再把处理机分给就绪队列中新的队列首进程，同时让它也执行一个时间片。</p>
<h4 id="时间片设置多少合适"><a href="#时间片设置多少合适" class="headerlink" title="时间片设置多少合适"></a>时间片设置多少合适</h4><p>​    从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms 有用的工作之后,CPU 将花费5ms 来进行进程切换。CPU 时间的20%被浪费在了管理开销上了。<br>​    为了提高CPU 效率,我们可以将时间片设为500ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10 个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s 才获得运行机会。多数用户无法忍受一条简短命令要5 才能做出响应。<br>​    结论总结如下: 时间片设得太短会导致过多的进程切换,降低了CPU 效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms 通常是一个比较合理的折衷。</p>
<h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>​    <strong>并发: **指应用能够交替执行不同的任务,比如单CPU 核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.<br>​    **并行:</strong> 指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行<br>​    **两者区别: **一个是交替执行,一个是同时执行.</p>
<h3 id="多线程程序需要注意事项"><a href="#多线程程序需要注意事项" class="headerlink" title="多线程程序需要注意事项"></a>多线程程序需要注意事项</h3><h4 id="线程之间的安全性"><a href="#线程之间的安全性" class="headerlink" title="线程之间的安全性"></a>线程之间的安全性</h4><p>​    在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。</p>
<h4 id="线程之间的死锁"><a href="#线程之间的死锁" class="headerlink" title="线程之间的死锁"></a>线程之间的死锁</h4><p>​    为了解决线程之间的安全性引入了Java 的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。</p>
<h4 id="线程太多了会将服务器资源耗尽形成死机当机"><a href="#线程太多了会将服务器资源耗尽形成死机当机" class="headerlink" title="线程太多了会将服务器资源耗尽形成死机当机"></a>线程太多了会将服务器资源耗尽形成死机当机</h4><p>​    线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机。</p>
<p>​    针对多线程程序可能耗尽资源的问题，在我们的程序中应该使用线程池来管理线程、使用数据库连接池来管理数据库连接，用对象池来管理对象，防止对象经常创建和回收导致内存抖动。</p>
<h3 id="Java程序与生俱来就是多线程程序"><a href="#Java程序与生俱来就是多线程程序" class="headerlink" title="Java程序与生俱来就是多线程程序"></a>Java程序与生俱来就是多线程程序</h3><p>​    写一个最简单的demo，看看java虚拟机会为这个demo开辟多少个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Java虚拟机线程管理接口</span></span><br><span class="line">		ThreadMXBean tBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">		ThreadInfo[] threadInfos = tBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo info:threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;thread id:[&quot;</span> + info.getThreadId() </span><br><span class="line">			+ <span class="string">&quot;]; thread name:[&quot;</span> + info.getThreadName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">thread id:[<span class="number">5</span>]; thread name:[Attach Listener]  <span class="comment">//内存dump，线程dump，类信息统计，获取系统属性等</span></span><br><span class="line">thread id:[<span class="number">4</span>]; thread name:[Signal Dispatcher]<span class="comment">//分发处理发送给JVM 信号的线程</span></span><br><span class="line">thread id:[<span class="number">3</span>]; thread name:[Finalizer]         <span class="comment">//调用对象finalize 方法的线程</span></span><br><span class="line">thread id:[<span class="number">2</span>]; thread name:[Reference Handler] <span class="comment">//清除Reference 的线程</span></span><br><span class="line">thread id:[<span class="number">1</span>]; thread name:[main]		       <span class="comment">//主程序，用户程序入口</span></span><br></pre></td></tr></table></figure>


<h3 id="线程的启动和中止"><a href="#线程的启动和中止" class="headerlink" title="线程的启动和中止"></a>线程的启动和中止</h3><h4 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h4><p>​    线程的启动方式有两种：1.继承Thread类并且实现run方法的方式；2.实现Runnable接口的方式</p>
<h5 id="继承Thread类并且实现run方法的方式"><a href="#继承Thread类并且实现run方法的方式" class="headerlink" title="继承Thread类并且实现run方法的方式"></a>继承Thread类并且实现run方法的方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摘自java.lang.Thread</span></span><br><span class="line">	There are two ways to create a <span class="keyword">new</span> thread of execution. One is to declare a <span class="class"><span class="keyword">class</span> <span class="title">to</span> <span class="title">be</span> <span class="title">a</span> <span class="title">subclass</span> <span class="title">of</span> &lt;<span class="title">code</span>&gt;<span class="title">Thread</span>&lt;/<span class="title">code</span>&gt;. <span class="title">This</span> <span class="title">subclass</span> <span class="title">should</span> <span class="title">override</span> <span class="title">the</span> &lt;<span class="title">code</span>&gt;<span class="title">run</span>&lt;/<span class="title">code</span>&gt; <span class="title">method</span> <span class="title">of</span> <span class="title">class</span> &lt;<span class="title">code</span>&gt;<span class="title">Thread</span>&lt;/<span class="title">code</span>&gt;. <span class="title">An</span> <span class="title">instance</span> <span class="title">of</span> <span class="title">the</span> <span class="title">subclass</span> <span class="title">can</span> <span class="title">then</span> <span class="title">be</span> <span class="title">allocated</span> <span class="title">and</span> <span class="title">started</span>. </span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line"></span><br><span class="line">    PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>


<h5 id="实现Runnable的方法"><a href="#实现Runnable的方法" class="headerlink" title="实现Runnable的方法"></a>实现Runnable的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	The other way to create a thread is to declare a <span class="class"><span class="keyword">class</span> <span class="keyword">implements</span> <span class="title">the</span> &lt;<span class="title">code</span>&gt;<span class="title">run</span>&lt;/<span class="title">code</span>&gt; <span class="title">method</span>. <span class="title">An</span> <span class="title">instance</span> <span class="title">of</span> <span class="title">the</span> <span class="title">class</span> <span class="title">can</span> <span class="title">then</span> <span class="title">be</span> <span class="title">allocated</span>, <span class="title">passed</span> <span class="title">as</span> <span class="title">an</span> <span class="title">argument</span> <span class="title">when</span> <span class="title">creating</span> &lt;<span class="title">code</span>&gt;<span class="title">Thread</span>&lt;/<span class="title">code</span>&gt;, <span class="title">and</span> <span class="title">started</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> minPrime;        </span><br><span class="line">   PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">      <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>


<h5 id="Thread-和Runnable-的区别"><a href="#Thread-和Runnable-的区别" class="headerlink" title="Thread 和Runnable 的区别"></a>Thread 和Runnable 的区别</h5><p>​    Thread 是Java 里对线程的唯一抽象，Runnable 只是对任务（业务逻辑）的抽象。Thread 可以接受任意一个Runnable 的实例并执行。</p>
<h4 id="线程的中止"><a href="#线程的中止" class="headerlink" title="线程的中止"></a>线程的中止</h4><p>​    线程的中止有两种可能，要么是run()方法执行完毕，要么是程序人为中止执行。</p>
<p>​    这里重点讨论程序人为中止的手段。从Thread类中，可以发现中止线程执行的方法有 <strong>suspend()、resume()和stop()**，但是这些方法都是过时的，也是官方不建议使用的，因为使用以上三种方法来</strong>暴力**停止线程执行，可能会造成死锁的问题。以suspend()为例，当调用了suspend()之后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。stop()和resume()原理是一样的，可能会导致程序死锁，严重会导致自己或者其他程序ANR。所以考虑到这种严重的副作用，官方不建议使用以上三种方法停止线程执行任务。</p>
<p>​    那么如何比较优雅地中止线程呢？</p>
<p>​    因为<strong>JDK中的线程是协作式的，而不是抢占式的</strong>，否则线程发起了中断，线程可以不理会此中断。所以配合使用**interrupt()和isInterrupted()**来中断线程执行。interrupt()方法只是将中断标志位置位了，而不是强行中止线程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>那么正确的使用方法如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//和谐停止标志位</span></span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;running ! isInterrupt stats = &quot;</span> + isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; exit ! isInterrupt stats = &quot;</span> + isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    UserThread userThread = <span class="keyword">new</span> UserThread();</span><br><span class="line">    userThread.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//通知要中断，但是如果还有在执行的任务，不会真正结束</span></span><br><span class="line">    userThread.interrupt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="我们可以自定义标志位来管理线程么？"><a href="#我们可以自定义标志位来管理线程么？" class="headerlink" title="我们可以自定义标志位来管理线程么？"></a>我们可以自定义标志位来管理线程么？</h4><p>​    不建议自定义一个取消标志位来中止线程的运行。因为run 方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，</p>
<ul>
<li><p>一、一般的阻塞方法，如sleep 等本身就支持中断的检查，</p>
</li>
<li><p>二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。</p>
<p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait 等），则线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛InterruptedException 异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。</p>
</li>
</ul>
<h3 id="关于线程的其他点点滴滴"><a href="#关于线程的其他点点滴滴" class="headerlink" title="关于线程的其他点点滴滴"></a>关于线程的其他点点滴滴</h3><h4 id="run-和start-关系"><a href="#run-和start-关系" class="headerlink" title="run()和start()关系"></a>run()和start()关系</h4><p>​    Thread 类是Java 里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new 出一个Thread 的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。start()方法让一个线程进入就绪队列等待分配cpu，分到cpu 后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。而run 方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。</p>
<h4 id="Thread中的其他方法"><a href="#Thread中的其他方法" class="headerlink" title="Thread中的其他方法"></a>Thread中的其他方法</h4><h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><p>​    使当前线程让出CPU 占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield 方法。所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。</p>
<h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><p>​    (1) 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B 中调用了线程A 的Join()方法，直到线程A 执行完毕后，才会继续执行线程B。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadJoinTest threadJoinTest1 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadJoinTest threadJoinTest2 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        ThreadJoinTest threadJoinTest3 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        threadJoinTest1.start();</span><br><span class="line">        threadJoinTest1.join();</span><br><span class="line">		threadJoinTest2.start();</span><br><span class="line">        threadJoinTest2.join();</span><br><span class="line">        threadJoinTest3.start();</span><br><span class="line">        threadJoinTest3.join();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上事例把异步执行的事情，变成都在主线程执行的同步事件了，虽然这样做就相当于不开线程，主要是为了演示合并成串行执行。</p>
<p>​    (2) 从另一个角度上讲，join()可以让某个子线程执行完毕之后在执行主线程的代码。相当于“阻塞”主线程，等子线程执行完成之后，在执行主线程代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadJoinTest threadJoinTest1 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    threadJoinTest1.start();</span><br><span class="line">    threadJoinTest1.join(); <span class="comment">// 当join()执行完之后才能执行以下代码。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;我只能在join()执行完成之后才能执行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程的生命周期以及基本状态"><a href="#线程的生命周期以及基本状态" class="headerlink" title="线程的生命周期以及基本状态"></a>线程的生命周期以及基本状态</h5><p><strong>线程生命周期</strong></p>
<p>​    关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-3e8a770cf40eae95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程状态切换.png"></p>
<p><strong>线程的基本状态</strong></p>
<p><strong>新建状态（New）：</strong>当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>
<p><strong>就绪状态（Runnable）：</strong>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
<p><strong>运行状态（Running）：</strong>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就   绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
<p><strong>阻塞状态（Blocked）：</strong>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<p>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>
<p>2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
<p>3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
<p><strong>死亡状态（Dead）：</strong>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>​    在Java 线程中，通过一个整型成员变量priority 来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>​    设置线程优先级时，针对<strong>频繁阻塞（休眠或者I/O 操作）</strong>的线程需要设置较高优先级，而<strong>偏重计算（需要较多CPU 时间或者偏运算）</strong>的线程则设置较低的优先级，确保处理器不会被独占。</p>
<h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>​    Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java 虚拟机中存在Daemon 线程的时候，当主线程退出之后，守护线程也会跟着退出。比如垃圾回收线程就是Daemon 线程，但是在Java 虚拟机退出时Daemon 线程中的finally 块并不一定会执行。在构建Daemon 线程时，不能依靠finally 块中的内容来确保执行关闭或清理资源的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;-----&gt;&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//如果该线程是守护线程，那么main线程执行完毕之后，守护线程一起结束</span></span><br><span class="line">    <span class="comment">//如果不是守护线程，Main线程会等待该线程执行结束后结束。</span></span><br><span class="line">    <span class="comment">//如果是守护线程，子线程大于main的时间，main执行完了就结束，不管子线程。</span></span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置3000 6000观察守护线程内打印情况可以看出守护线程的生命周期</span></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>测试用例代码见： <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:oujie123/UnderstandingOfThread.git</strong></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6/3059054?utm_source=hacpai.com">CPU时间片轮转机制</a></p>
<p><a href="https://www.cnblogs.com/lwbqqyumidi/p/3804883.html">线程基础</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>对Java对象的深入认识(三)</title>
    <url>/2021/01/27/%E5%AF%B9Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E8%AE%A4%E8%AF%86-%E4%B8%89/</url>
    <content><![CDATA[<h4 id="1-Java对象"><a href="#1-Java对象" class="headerlink" title="1. Java对象"></a>1. Java对象</h4><h5 id="1-1-Java对象的组成"><a href="#1-1-Java对象的组成" class="headerlink" title="1.1 Java对象的组成"></a>1.1 Java对象的组成</h5><p>​    在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<ul>
<li><p><strong>对象头</strong>包括两部分信息: 对象自身的运行时数据和类型指针</p>
<ul>
<li><p>运行时数据包含哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<a href="https://www.jianshu.com/p/28cd41100193">《多线程并发总结(八)–Java内存模型》3.3小节有讲到线程运行的不同状态mark word的不同值</a></p>
</li>
<li><p>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>如果对象是一个java数组，那么在对象头中还有一块用于记录数组长度的数据。</p>
</li>
</ul>
</li>
<li><p><strong>对齐填充</strong>不是必然存在的，因为虚拟机在创建对象分配内存的时候，都是分配8个字节的整数倍，如果对象大小不是8字节的整数倍，就需要填充占位符来使内存对齐。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-9a5225534e9ab151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象组成.png"></p>
<p>​    </p>
<h5 id="1-2-对象的创建"><a href="#1-2-对象的创建" class="headerlink" title="1.2 对象的创建"></a>1.2 对象的创建</h5><p>​    当虚拟机遇到一条new指令时，首先检查是否被类加载器加载，如果没有，那必须先执行相应的类加载过程。</p>
<p>类加载就是把class加载到JVM的运行时数据区的过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5f9c2441823230b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象创建.png"></p>
<p><strong>1.2.1 检查加载</strong></p>
<p>​    检查这个指令的参数是否能在常量池中定位到一个类的符号引用（<strong>符号引用</strong> <strong>：</strong>符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。</p>
<p><strong>1.2.2 分配内存</strong></p>
<p>​    虚拟机会为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从运行时数据区的堆中划分出来。</p>
<ul>
<li><strong>指针碰撞的方式：</strong>对于规整的内存区域使用指针碰撞的形式分配内存，在内存已使用和未使用的区域之间存放一个指示器，需要分配内存时，直接在该指针后分配指定大小的空间即可。</li>
<li><strong>空闲列表：</strong>对于不规整的内存区域使用空闲列表的方式分配内存。虚拟机会维护一张列表(相当于空闲内存索引)，表中标记哪些内存已经被分配，哪些没有，当需要分配内存时，只需要在表中找到符合需求大小的位置分配即可，然后更新列表。</li>
</ul>
<p>(1) 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</p>
<p>(2) 在虚拟机中创建对象的操作是非常频繁的，仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p><strong>如何保证在创建对象过程中的线程安全呢？</strong></p>
<p><strong>CAS机制：</strong>虚拟机采用CAS失败重试的方式保证更新操作的原子性；</p>
<p><strong>分配缓存：</strong>在Eden区分配一块缓存区的方式创建对象，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），此操作有点像Threadlocal。可使用-XX:+UseTLAB来启动此选项。</p>
<p><strong>1.2.3 内存空间初始化</strong></p>
<p>​    虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>1.2.4 设置对象头</strong></p>
<p>​    虚拟机会对对象头进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes在Java hotspot VM内部表示为类元数据）、对象的哈希码、对象的GC分代年龄等信息。</p>
<p><strong>1.2.5 对象初始化</strong></p>
<p>​    调用对象的构造方法，按照程序员的意愿初始化对象。</p>
<h5 id="1-3-对对象的访问方式"><a href="#1-3-对对象的访问方式" class="headerlink" title="1.3 对对象的访问方式"></a>1.3 对对象的访问方式</h5><p>​    当对象创建出来之后，Java程序需要通过栈上引用的方式对堆上的具体对象进行操作。目前主流的访问方式有使用句柄和直接指针两种。</p>
<ul>
<li><p><strong>句柄：</strong>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
</li>
<li><p><strong>直接指针：</strong>如果使用直接指针访问， reference中存储的直接就是对象地址。</p>
</li>
</ul>
<p><strong>1.3.1 两种对象访问方式的区别</strong></p>
<p>​    使用<strong>句柄</strong>来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾回收时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>​    使用<strong>直接指针</strong>访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
<p>  对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问。<a href="https://www.jianshu.com/p/71ed22f0fab5">《可视化JVM理解运行时数据区》中可以看到验证过程</a></p>
<h5 id="1-4-对象的存活判断"><a href="#1-4-对象的存活判断" class="headerlink" title="1.4 对象的存活判断"></a>1.4 对象的存活判断</h5><p>​    在运行时数据区的堆中几乎保存着所有的对象实例，当内存不够的时候，垃圾回收器会根据对象实例的“存活”，对实例进行回收。根据不同的虚拟机，判断方式有所不同，主流的有两种方式：<strong>引用计数法和可达性分析法</strong></p>
<p><strong>1.4.1 引用计数法</strong></p>
<p>​    在对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效时，计数器减1。如果计数器为0就可以回收对象，但是这种方式存在循环引用导致对象无法被回收的情况，需要引入其他机制来保证循环引用对象的回收。</p>
<p><strong>1.4.2 可达性分析</strong></p>
<p><strong>1.4.2.1 对实例对象的回收</strong></p>
<p>​    垃圾回收器从一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，称此对象不可达。</p>
<p>​    可以被作为“GC Roots”的对象有以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性。</li>
<li>方法区中常量。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
<li>JVM的内部引用（class对象、异常对象NullPointException、OutofMemoryError，系统类加载器）。</li>
<li>所有被同步锁(synchronized关键字)持有的对象。</li>
<li>JVM内部的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
<li>JVM实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代时）</li>
</ul>
<p>以上是通过可达性分析对<strong>实例对象</strong>的回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object instance =<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//占据内存，便于判断分析GC</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">50</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GcTest objectA = <span class="keyword">new</span> GcTest();<span class="comment">//objectA 会放入局部变量表作为GCRoots</span></span><br><span class="line">    GcTest objectB = <span class="keyword">new</span> GcTest();<span class="comment">//objectB 会放入局部变量表作为GCRoots</span></span><br><span class="line">    <span class="comment">//相互引用</span></span><br><span class="line">    objectA.instance = objectB;</span><br><span class="line">    objectB.instance = objectA;</span><br><span class="line">    <span class="comment">//切断可达</span></span><br><span class="line">    objectA =<span class="keyword">null</span>;</span><br><span class="line">    objectB =<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//强制垃圾回收</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：虚拟机对objectA和objectB引用的对象进行回收</span></span><br><span class="line">[GC (System.gc())  106345K-&gt;52064K(251392K), <span class="number">0.0011209</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  52064K-&gt;708<span class="title">K</span><span class="params">(251392K)</span>, 0.0054685 secs]</span></span><br></pre></td></tr></table></figure>


<p><strong>1.4.2.2 对Class对象的回收</strong></p>
<p>​    要想对<strong>方法区中的Class对象</strong>进行回收，条件就比较苛刻了：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
<li>参数控制：-Xnoclassgc  禁止垃圾回收器对Class对象的回收。</li>
</ul>
<h4 id="2-对象的引用方式"><a href="#2-对象的引用方式" class="headerlink" title="2. 对象的引用方式"></a>2. 对象的引用方式</h4><h5 id="2-1-强引用"><a href="#2-1-强引用" class="headerlink" title="2.1 强引用"></a>2.1 强引用</h5><p>​    Object obj = new Object() ，引用通过new关键字创建的对象都属于强引用。在任何情况下，只要有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。</p>
<h5 id="2-2-软引用"><a href="#2-2-软引用" class="headerlink" title="2.2 软引用"></a>2.2 软引用</h5><p>​    通过SoftReference<GcTest> test = new SoftReference&lt;&gt;(objectA);创建软引用对象，软引用对象只有当系统发生OOM之前才会被回收。</GcTest></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数:-Xms10m  -Xmx10m -XX:+PrintGC    配置10M堆内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student jackOu = <span class="keyword">new</span> Student(<span class="string">&quot;JackOu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        SoftReference&lt;Student&gt; soft = <span class="keyword">new</span> SoftReference&lt;&gt;(jackOu); <span class="comment">// 创建软引用对象</span></span><br><span class="line">        jackOu = <span class="keyword">null</span>;<span class="comment">//切掉强引用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Gc前，我还在?  -&gt;&quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;Gc后，我还在?  -&gt;&quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 制造oom</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我还活着么？ -&gt;&quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OOM了，我还活着么？-&gt; &quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Gc前，我还在?  -&gt;<span class="keyword">true</span></span><br><span class="line">[GC (System.gc())  844K-&gt;804K(9728K), <span class="number">0.0005400</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  804K-&gt;697<span class="title">K</span><span class="params">(9728K)</span>, 0.0138756 secs]</span></span><br><span class="line"><span class="function">Gc后，我还在?  -&gt;<span class="keyword">true</span>   <span class="comment">//GC后没被回收</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span>	<span class="comment">// 打印了4次，说明OOM之前没被回收</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span>	<span class="comment">// 第5次内存分配失败发生OOM就被回收了</span></span></span><br><span class="line"><span class="function">[<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  7002K-&gt;7033<span class="title">K</span><span class="params">(9728K)</span>, 0.0021776 secs]</span></span><br><span class="line"><span class="function">[Full <span class="title">GC</span> <span class="params">(Ergonomics)</span>  7033K-&gt;6874<span class="title">K</span><span class="params">(9728K)</span>, 0.0065646 secs]</span></span><br><span class="line"><span class="function">[<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  6874K-&gt;6874<span class="title">K</span><span class="params">(9728K)</span>, 0.0003435 secs]</span></span><br><span class="line"><span class="function">[Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span>  6874K-&gt;6856<span class="title">K</span><span class="params">(9728K)</span>, 0.0084790 secs]</span></span><br><span class="line"><span class="function">OOM了，我还活着么？-&gt; <span class="keyword">false</span>  <span class="comment">// OOM之后被回收</span></span></span><br></pre></td></tr></table></figure>


<h5 id="2-3-弱引用"><a href="#2-3-弱引用" class="headerlink" title="2.3 弱引用"></a>2.3 弱引用</h5><p>​    通过WeakReference<GcTest> test = new WeakReference&lt;&gt;(objectA);创建弱引用对象，弱引用对象从程度比软引用更低，弱引用对象只能活到下一次GC之前，不管内存足不足GC的过程中就会被回收。</GcTest></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student jackOu = <span class="keyword">new</span> Student(<span class="string">&quot;JackOu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    WeakReference&lt;Student&gt; weak = <span class="keyword">new</span> WeakReference&lt;&gt;(jackOu);</span><br><span class="line">    jackOu = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;GC前，我还活着么？ -&gt;&quot;</span> + (weak.get() != <span class="keyword">null</span>));</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">&quot;GC前，我还活着么？ -&gt;&quot;</span> + (weak.get() != <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">GC前，我还活着么？ -&gt;<span class="keyword">true</span></span><br><span class="line">[GC (System.gc())  3945K-&gt;896K(251392K), <span class="number">0.0008463</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  896K-&gt;706<span class="title">K</span><span class="params">(251392K)</span>, 0.0040099 secs]</span></span><br><span class="line"><span class="function">GC前，我还活着么？ -&gt;<span class="keyword">false</span>  <span class="comment">//gc之后对象被回收了</span></span></span><br></pre></td></tr></table></figure>


<h5 id="2-4-虚引用"><a href="#2-4-虚引用" class="headerlink" title="2.4 虚引用"></a>2.4 虚引用</h5><p>程度最弱，随时可能被回收，垃圾回收的时候收到一个通知，就是为了监控垃圾回收器是否正常工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class="line">    PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Hello World!&quot;</span>), queue);</span><br><span class="line">    System.out.println(pr.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">null</span>   <span class="comment">//一创建出来就被回收了</span></span><br></pre></td></tr></table></figure>


<h4 id="3-对象分配原则"><a href="#3-对象分配原则" class="headerlink" title="3. 对象分配原则"></a>3. 对象分配原则</h4><p>​    JVM创建对象会满足以下几个原则：</p>
<ul>
<li>对象优先在Eden区分配</li>
<li>空间分配担保原则</li>
<li>大对象直接进入老年代</li>
<li>长期存活对象进入老年代</li>
<li>动态对象年龄判定</li>
</ul>
<p>其中JVM对创建对象也做了一些优化：<strong>栈中创建对象和在堆中使用TLAB技术创建对象</strong></p>
<p><strong>3.1.1 栈上创建对象</strong></p>
<p>​    Java几乎所有对象都在堆中分配，但是也有例外，可以在栈中分配的可能。如果对象没有逃逸，就会在栈中分配。</p>
<p>​    <strong>逃逸分析的原理：</strong>分析对象动态作用域，当一个对象在方法中定义后，它可能被外部方法所引用，比如：调用参数传递到其他方法中，这种称之为<strong>方法逃逸</strong>，甚至还有可能被外部线程访问到，例如：赋值给其他线程中访问的变量，这个称之为<strong>线程逃逸</strong>。</p>
<p>​    从不逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度。</p>
<p>​    <strong>总结：不逃逸的对象在栈中分配，逃逸的对象(方法逃逸和线程逃逸)在堆中分配。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-fa82c50a2f68eb21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象分配原则.png"></p>
<p><strong>3.1.2 验证栈中分配优势</strong></p>
<p>​    从测试代码中可以看到myObject对象的创建是在allocate()方法中，在其他地方没有引用，所以myObject没有发送逃逸，如果JVM开启逃逸分析的话，JVM会在栈中创建myObject对象。<br>​    如果是逃逸分析出来的对象可以在栈上分配的话，那么该对象的生命周期就跟随线程了，就不需要垃圾回收，如果是频繁的调用此方法则可以得到很大的性能提高。如果没有开启逃逸分析，对象都在堆上分配，会频繁触发垃圾回收（垃圾回收会影响系统性能），导致代码运行慢。<br>​    在虚拟机中默认是开启了栈上分配内存优化的，即默认开启了逃逸分析的，那么我们来验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -XX:-DoEscapeAnalysis 关闭逃逸分析</span></span><br><span class="line"><span class="comment">// -XX:+DoEscapeAnalysis 开启逃逸分析</span></span><br><span class="line"><span class="comment">// -XX:+PrintGC  打印GC日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;<span class="comment">//5千万的对象，为什么不会垃圾回收</span></span><br><span class="line">            allocate();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">600000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">()</span> </span>&#123;<span class="comment">//满足逃逸分析（不会逃逸出方法）</span></span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject(<span class="number">2020</span>, <span class="number">2020.6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line">        MyObject(<span class="keyword">int</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[GC (Allocation Failure)  65536K-&gt;952K(251392K), <span class="number">0.0006760</span> secs]</span><br><span class="line">[GC (Allocation Failure)  66488K-&gt;888K(251392K), <span class="number">0.0007227</span> secs]</span><br><span class="line">[GC (Allocation Failure)  66424K-&gt;904K(251392K), <span class="number">0.0006020</span> secs]</span><br><span class="line">[GC (Allocation Failure)  66440K-&gt;920K(316928K), <span class="number">0.0007311</span> secs]</span><br><span class="line">[GC (Allocation Failure)  131992K-&gt;920K(316928K), <span class="number">0.0007891</span> secs]</span><br><span class="line">[GC (Allocation Failure)  131992K-&gt;936K(438272K), <span class="number">0.0006538</span> secs]</span><br><span class="line">[GC (Allocation Failure)  263080K-&gt;775K(438272K), <span class="number">0.0016288</span> secs]</span><br><span class="line">[GC (Allocation Failure)  262919K-&gt;775K(700928K), <span class="number">0.0002895</span> secs]</span><br><span class="line"><span class="number">232</span> ms</span><br><span class="line"><span class="comment">//关闭逃逸分析,对象分配耗时：232 ms ！ 发生了8次gc</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span> ms</span><br><span class="line"><span class="comment">//开启逃逸分析,对象分配耗时：6ms！没有发生gc</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h5 id="3-2-对象优先在Eden区分配"><a href="#3-2-对象优先在Eden区分配" class="headerlink" title="3.2 对象优先在Eden区分配"></a>3.2 对象优先在Eden区分配</h5><p>​    从上图中可以看到，在堆中分配的情况，如果满足TLAB条件，就在Eden的TLAB区分配，如果不满足，也不是大对象，就Eden区非TLAB区分配。</p>
<p>​    当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。</p>
<h5 id="3-3-大对象直接进入老年代"><a href="#3-3-大对象直接进入老年代" class="headerlink" title="3.3 大对象直接进入老年代"></a>3.3 大对象直接进入老年代</h5><p>​    最典型的大对象是很长的字符串以及数组。这样做的目的：1.避免大量内存复制；2.避免提前进行垃圾回收，明明内存有空间进行分配。</p>
<h5 id="3-4-长期存活对象进入老年区"><a href="#3-4-长期存活对象进入老年区" class="headerlink" title="3.4 长期存活对象进入老年区"></a>3.4 长期存活对象进入老年区</h5><p>​    如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor(from区或者to区)容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(并发的垃圾回收器默认为15),CMS是6时，就会被晋升到老年代中。</p>
<h5 id="3-5-对象年龄动态判定"><a href="#3-5-对象年龄动态判定" class="headerlink" title="3.5 对象年龄动态判定"></a>3.5 对象年龄动态判定</h5><p>​    为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p>
<h5 id="3-6-空间分配担保"><a href="#3-6-空间分配担保" class="headerlink" title="3.6 空间分配担保"></a>3.6 空间分配担保</h5><p>​    在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理详解</title>
    <url>/2021/01/25/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h4><p><strong>1.1 定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活 中常见的中介。</p>
<p><strong>1.2 目的：</strong></p>
<ul>
<li><p>(1) 通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性；可以实现客户端和服务端解耦，方便替换真实实现的对象。（例如某项目使用了Volley网络请求，现在项目有一个特殊需求，要换成okhttp网络请求框架，使用代理模式可以很容易替换）</p>
</li>
<li><p>(2) 通过代理对象对访问进行控制；(例如在正在执行代理行为前后添加更多控制行为)</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e57ebe022ee1b88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静态代理.png"></p>
<p><strong>1.3 角色介绍：</strong></p>
<ul>
<li>抽象角色：指代理角色和真实角色对外提供的公共方法，一般为一个接口 </li>
<li>真实角色：需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业 务逻辑在此。 </li>
<li>代理角色：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理！</li>
</ul>
<p><strong>1.4 使用样例代码：</strong></p>
<p>以下是代理接口，该接口定义保存订单功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以下是真实实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下单成功，订单号： 66666666&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">66666666</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以下是代理类，代理持有真实实现类的对象，可以流程进行控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyOrder</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真实的订单服务</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService = <span class="keyword">new</span> OutOrderServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOrderTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在真实操作之前，还可以对订单进行控制，演示上叙目的2</span></span><br><span class="line">        <span class="comment">// 例如：可以在用户下单之后，给订单打上标签</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始海外下订单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setOrderTag();</span><br><span class="line">        <span class="keyword">return</span> orderService.saveOrder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h4><p><strong>2.1 定义：</strong>通过反射机制，在运行时创建代理类</p>
<p><strong>2.2 使用：</strong></p>
<p>创建代理类，持有真实实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(OrderService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke --&gt;&quot;</span>);</span><br><span class="line">        method.invoke(service, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke --&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用动态代理调用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建真实实现类</span></span><br><span class="line">    OrderService service = <span class="keyword">new</span> OutOrderServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将真实实现类交给ProxyHandler</span></span><br><span class="line">    OrderService proxy = (OrderService)Proxy.newProxyInstance(</span><br><span class="line">        	service.getClass().getClassLoader(),</span><br><span class="line">            service.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> ProxyHandler(service));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过代理调用到真实实现的方法</span></span><br><span class="line">    proxy.saveOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>2.3 动态代理原理：</strong></p>
<ul>
<li>通过用户实现的InvocationHandler接口，获得真实处理事件的对象（相当于Proxy加了个传入真实实现对象监听）；</li>
<li>通过newProxyInstance传入的ClassLoader和一组Interface来创建动态代理类；</li>
<li>通过反射获取动态代理类的构造方法，其构造函数的参数就是用户实现的InvocationHandler接口类；</li>
<li>通过构造函数创建动态代理类实例。</li>
</ul>
<p>==============================<strong>生成动态代理类</strong>=============================================</p>
<p>下面我们详细来看一下Proxy是如何生成代理对象的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从classloader中遍历接口，并且调用generateProxy()生成Class对象</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指定的InvocationHandler来调用生成class对象的构造方法</span></span><br><span class="line">    <span class="comment">// 参数constructorParams就是指定的InvocationHandler，也就是传入自定义实现InvocationHandler的类</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来看一下是如何生成这个Class对象的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 接口数不能超过65535，即单个dex里面的方法数不能超过65535个</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定接口的代理类已经存在与缓存中，则不用新创建，直接从缓存中取即可；</span></span><br><span class="line">    <span class="comment">//如果缓存中没有指定代理对象，则通过ProxyClassFactory来创建一个代理对象。</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面来看一下<strong>ProxyClassFactory</strong>是如何创建代理对象的。(在Proxy中有一个ProxyClassFactory静态内部类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//校验类加载器中加载的接口是否是定义的接口</span></span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验加载的类是否是接口</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验接口是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// 新生成类的包名</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录非公共代理接口的包，以便在同一个包中定义代理类。验证所有非公共代理接口是否在同一个包中。</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if no non-public proxy interfaces, use the default package.</span></span><br><span class="line">        proxyPkg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 收集接口中所有方法</span></span><br><span class="line">        List&lt;Method&gt; methods = getMethods(interfaces);</span><br><span class="line">        Collections.sort(methods, ORDER_BY_SIGNATURE_AND_SUBTYPE);</span><br><span class="line">        validateReturnTypes(methods);</span><br><span class="line">        List&lt;Class&lt;?&gt;[]&gt; exceptions = deduplicateAndGetExceptions(methods);</span><br><span class="line"></span><br><span class="line">        Method[] methodsArray = methods.toArray(<span class="keyword">new</span> Method[methods.size()]);</span><br><span class="line">        Class&lt;?&gt;[][] exceptionsArray = exceptions.toArray(<span class="keyword">new</span> Class&lt;?&gt;[exceptions.size()][]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 敲定生成类的类名</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用generateProxy()生成class类</span></span><br><span class="line">        <span class="keyword">return</span> generateProxy(proxyName, interfaces, loader, methodsArray,</span><br><span class="line">                exceptionsArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后通过调用native的generateProxy()方法生成class类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; generateProxy(String name, Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                             ClassLoader loader, Method[] methods,</span><br><span class="line">                                             Class&lt;?&gt;[][] exceptions);</span><br><span class="line"><span class="comment">// END Android-changed: How proxies are generated.</span></span><br></pre></td></tr></table></figure>


<p>在Android中生成class类是在navite中生成的。在java中最终是调用ProxyGenerator.generateProxyClass()生成byte数组，最后调用defineClass0()将byte数组转化成class类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="comment">// 真正用来生成代理类字节码文件的方法在这里</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">        <span class="comment">// 保存代理类的字节码文件</span></span><br><span class="line">        <span class="keyword">if</span>(saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        <span class="keyword">if</span>(var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar), <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                            Files.createDirectories(var3, <span class="keyword">new</span> FileAttribute[<span class="number">0</span>]);</span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + <span class="string">&quot;.class&quot;</span>, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;I/O exception saving generated file: &quot;</span> + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>生成代理类字节码文件的generateClassFile方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">//下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中(proxyMethod)</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">//获得接口中所有方法并添加到代理方法中</span></span><br><span class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">        List var12;</span><br><span class="line">        <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List)var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var15;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成代理类的构造函数</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line">            var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List)var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                    <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>, <span class="number">10</span>));</span><br><span class="line">                    <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;unexpected I/O Exception&quot;</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.methods.size() &gt; <span class="string">&#x27;\uffff&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method limit exceeded&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.fields.size() &gt; <span class="string">&#x27;\uffff&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;field limit exceeded&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(<span class="string">&quot;java/lang/reflect/Proxy&quot;</span>);</span><br><span class="line">            var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line">            ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                var14.writeShort(<span class="number">49</span>);</span><br><span class="line">                <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">&quot;java/lang/reflect/Proxy&quot;</span>));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">                Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">                <span class="keyword">int</span> var18 = var17.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;unexpected I/O Exception&quot;</span>, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用generateClassFile()之后，就会生成class类的byte数组。</p>
<p><strong>为了验证这个结论</strong>，写一个demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String name = OrderService.class.getName() + <span class="string">&quot;$Proxy0&quot;</span>;</span><br><span class="line">        <span class="comment">//生成代理指定接口的Class数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = ProxyGenerator.generateProxyClass(name, <span class="keyword">new</span> Class[]&#123;OrderService.class&#125;);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\gz04766\\Desktop\\&quot;</span> + name + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们分析清楚了Proxy是如何生成代理class类的。</p>
<p>================================<strong>如何完成动态调用</strong>========================================</p>
<p>当通过反射调用构造方法的时候，将用户实现的InvocationHandler传给Proxy。在生成的类中，通过反射拿到接口定义的Method方法。最后通过父类的中的InvocationHandler的invoke方法，最终调入到自定义的InvocationHandler中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span>$<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderService$Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过父类的中的InvocationHandler的invoke方法，最终调入到自定义的InvocationHandler中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过反射拿到接口定义的Method方法</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.gac.oj.OrderService&quot;</span>).getMethod(<span class="string">&quot;saveOrder&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Android IPC机制</title>
    <url>/2021/01/28/Android-IPC%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="1-Android-IPC简介"><a href="#1-Android-IPC简介" class="headerlink" title="1. Android IPC简介"></a>1. Android IPC简介</h3><p>​    IPC是Inter-Process Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程间进行数据交换的过程。关于进程和线程的区别，在我之前发过的<a href="https://www.jianshu.com/p/683d50374775">多线程并发总结录(一) – 线程进程基础</a>中有详细叙述到。在Android程序中有一个主线程叫UI线程，只有在UI线程里面才能操作界面元素。很多时候，如果在UI线程执行很多耗时操作，严重影响了用户的体验，系统就会报出ANR异常（Application Not Responding）即应用无响应。</p>
<p>​    IPC机制不是Android独有的，任何操作系统都有响应的IPC机制，比如Windows的剪切板，管道都是进程间通信机制；Linux上可以通过命名管道，共享内存，信号量等进行进程间通信。</p>
<p>​    在Android中常用的进程间通信方式有：<strong>Bundle、文件共享、AIDL、Messager、ContentProvider和Socket。</strong></p>
<h3 id="2-IPC基础概念"><a href="#2-IPC基础概念" class="headerlink" title="2. IPC基础概念"></a>2. IPC基础概念</h3><p>IPC的基础概念包含三部分内容：Serializable接口，Parcelable接口和Binder。</p>
<p>Serializable和Parcelable接口可以完成对象的序列化过程，然后通过Intent和Binder进行传输。下面我们分别来介绍一下这三者的使用。</p>
<h4 id="2-1-Serializable序列化对象"><a href="#2-1-Serializable序列化对象" class="headerlink" title="2.1 Serializable序列化对象"></a>2.1 Serializable序列化对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Serializable实现序列化，只需要实现Serializable接口，并且定义一个serialVersionUID即可。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">123456789L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    ......  <span class="comment">//get set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 Student对象</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">&quot;JackOu&quot;</span>, <span class="keyword">true</span>, <span class="number">18</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">out.writeObject(student);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化 Student对象</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">Student student1 = (Student) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>


<p><strong>注意：</strong>serialVersionUID为任意值都可以，但是序列化前的对象和反序列化对象的serialVersionUID必须一致，否则会报异常。因为序列化的时候，系统会把serialVersionUID写入到文件中，在反序列化的时候，会对比这个值，如果不一样，就说明这个对象被修改过，不是同一版本的，所以会报异常。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常如下，说serialVersionUID不一致了</span></span><br><span class="line">java.io.InvalidClassException: com.gacrnd.gcs.ipc.Student; local class incompatible: stream classdesc serialVersionUID = 123456789, local class serialVersionUID = 123789</span><br></pre></td></tr></table></figure>


<h4 id="2-2-Parcelable序列化对象"><a href="#2-2-Parcelable序列化对象" class="headerlink" title="2.2 Parcelable序列化对象"></a>2.2 Parcelable序列化对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义好对象的属性，实现writeToParcel、describeContents和创建Creator&lt;Person&gt;即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Person</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-Serializable和Parcelable区别"><a href="#2-3-Serializable和Parcelable区别" class="headerlink" title="2.3 Serializable和Parcelable区别"></a>2.3 Serializable和Parcelable区别</h4><p>Serializable和Parcelable都可以实现序列化，那么他们有什么区别呢。</p>
<ul>
<li><p>Serializable是Java中序列化接口，使用起来简单，但是开销比较大，序列化和反序列化过程需要大量I/O操作。</p>
</li>
<li><p>Parcelable是Android的序列化方式，主要用在内存序列化，因此效率比较高一些，但是使用比较麻烦。</p>
</li>
</ul>
<p>如果使用基于Binder实现的通信方式，一般选择Parcelable效率比较高；如果将序列化对象存储在设备中或者通过网络进行传输，选择Serializable比较方便。</p>
<h4 id="2-4-Binder通信"><a href="#2-4-Binder通信" class="headerlink" title="2.4 Binder通信"></a>2.4 Binder通信</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.gacrnd.gcs.ipc;</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.gacrnd.gcs.ipc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gacrnd.gcs.ipc.Book; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>服务端实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在service端内部创建一个IBookManager.Stub对象，在onBind()方法中返回。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IBookManager.Stub mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBookList) &#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBookList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mBookList.contains(book)) &#123;</span><br><span class="line">                mBookList.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>客户端实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IBookManager mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">		<span class="comment">// 绑定服务端</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">        bindService(intent,sconn, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection sconn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 拿到服务端代理之后就可以调用服务端的方法了</span></span><br><span class="line">            mService = IBookManager.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            mService = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Binder最简单的使用就是上面的代码，后面分析framework的时候会详细分析Binder的具体实现。</p>
<p>另外当客户端和服务端断开的希望接收到通知，我们可以实现一个DeathRecipient对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个死亡通知</span></span><br><span class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mService.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">        mService = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在连上服务端的时候，绑定死亡通知</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    mService = IBookManager.Stub.asInterface(service);</span><br><span class="line">    service.linkToDeath(mDeathRecipient,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>参考文档：</strong></p>
<p>《Android开发艺术探索》</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC机制</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC机制(二) -- Bundle,文件共享,Messager</title>
    <url>/2021/01/28/IPC%E6%9C%BA%E5%88%B6-%E4%BA%8C-Bundle-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB-Messager/</url>
    <content><![CDATA[<h3 id="1-Bundle"><a href="#1-Bundle" class="headerlink" title="1.Bundle"></a>1.Bundle</h3><p>我们知道，Acitivity、Service和Receiver都是通过Bundle进行通信的，所有的Intent.putExtra()方法最终都会分装到Bundle中，而Bundle实现了Parcelable接口，所以可以很方便的在进程间进行通信。</p>
<p>所以我们可以通过Intent启动进程B的一个Service组件(例如IntentService，JobService，JobIntentService)，执行后台计算，计算完成之后，由于这个Service在进程B中，所以进程B可以直接处理计算结果。</p>
<h4 id="1-1-JobIntentService用法"><a href="#1-1-JobIntentService用法" class="headerlink" title="1.1 JobIntentService用法"></a>1.1 JobIntentService用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IntentService被废弃了，就不举例了</span></span><br><span class="line"><span class="comment">// 进程内使用Bundle传输数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">JobIntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyIntentService.class.getSimpleName();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> JOB_ID = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴露给Activity发送需要执行的耗时任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enqueueWork</span><span class="params">(Context context, Intent work)</span> </span>&#123;</span><br><span class="line">        enqueueWork(context, MyIntentService.class, JOB_ID, work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理耗时任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleWork</span><span class="params">(<span class="meta">@NonNull</span> Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Executing work: &quot;</span> + intent);</span><br><span class="line">        String label = intent.getStringExtra(<span class="string">&quot;label&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (label == <span class="keyword">null</span>) &#123;</span><br><span class="line">            label = intent.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        toast(<span class="string">&quot;Executing: &quot;</span> + label);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Running service &quot;</span> + (i + <span class="number">1</span>)</span><br><span class="line">                    + <span class="string">&quot;/5 @ &quot;</span> + SystemClock.elapsedRealtime());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Completed service @ &quot;</span> + SystemClock.elapsedRealtime());</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;label: &quot;</span> + label +<span class="string">&quot;, current thread :&quot;</span> + Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MyIntentService.<span class="keyword">this</span>, (String)msg.obj, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toast</span><span class="params">(<span class="keyword">final</span> CharSequence text)</span> </span>&#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage();</span><br><span class="line">        msg.obj = text.toString();</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程发送任务</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">&quot;label&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">MyIntentService.enqueueWork(<span class="keyword">this</span>,intent);</span><br></pre></td></tr></table></figure>
<h4 id="1-2-JobService用法"><a href="#1-2-JobService用法" class="headerlink" title="1.2 JobService用法"></a>1.2 JobService用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jobService服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJobService</span> <span class="keyword">extends</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyJobService.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mActivityMessenger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        mActivityMessenger = intent.getParcelableExtra(MESSENGER_INTENT_KEY);</span><br><span class="line">        <span class="keyword">return</span> START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(<span class="keyword">final</span> JobParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        <span class="comment">// 如果还有任务没有执行完就返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        sendMessage(MSG_COLOR_STOP, params.getJobId());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> messageID, <span class="meta">@Nullable</span> Object params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把消息回送到发送者</span></span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.what = messageID;</span><br><span class="line">        m.obj = params;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mActivityMessenger.send(m);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Error passing service object back to activity.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">mServiceComponent = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, MyJobService.class);</span><br><span class="line">JobInfo.Builder builder = <span class="keyword">new</span> JobInfo.Builder(mJobId++, mServiceComponent);</span><br><span class="line"><span class="comment">// 设置策略</span></span><br><span class="line">.....</span><br><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line">PersistableBundle extras = <span class="keyword">new</span> PersistableBundle();</span><br><span class="line">String workDuration = mDurationTimeEditText.getText().toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安排执行任务</span></span><br><span class="line">JobScheduler tm = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">tm.schedule(builder.build());</span><br></pre></td></tr></table></figure>


<h3 id="2-文件共享"><a href="#2-文件共享" class="headerlink" title="2. 文件共享"></a>2. 文件共享</h3><p>文件共享的方式实现进程间通信，主要实现就是进程A通过把序列化的对象写入到文件中，在进程B通过ObjectInputStream来将对象读取出来。具体实现demo将上一讲的序列化和反序列化的测试代码。<a href="https://www.jianshu.com/p/f2ea2793090c">2.1 Serializable序列化对象</a></p>
<h3 id="3-Messager"><a href="#3-Messager" class="headerlink" title="3. Messager"></a>3. Messager</h3><p>Messager是一种轻量级的IPC方案，其底层实现也是基于AIDL。从如下代码可以证明Messager是基于AIDL实现的，通过传入的IBinder对象拿到服务端代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端初始化用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端初始化用</span></span><br><span class="line"><span class="comment">//Handler实现了Messager的服务端IMessenger.Stub</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_FROM_CLIENT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_TO_CLIENT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger messager = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessagerHandler());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessagerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_FROM_CLIENT:</span><br><span class="line">                    Log.i(<span class="string">&quot;JackOu&quot;</span>,msg.getData().getString(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">                    <span class="comment">// 如果要回复，拿到客户端的Messager代理在发送回去</span></span><br><span class="line">                    Messenger messenger = msg.replyTo;</span><br><span class="line">                    Message message = Message.obtain(<span class="keyword">null</span>, MESSAGE_TO_CLIENT);</span><br><span class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                    bundle.putString(<span class="string">&quot;reply&quot;</span>, <span class="string">&quot;hello client&quot;</span>);</span><br><span class="line">                    message.setData(bundle);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        messenger.send(message);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messager.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>客户端实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection messengerSconn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">        Message msg = Message.obtain(<span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        msg.setData(bundle);</span><br><span class="line">        msg.replyTo = clientMessenger; <span class="comment">// 如果需要服务端回复需要把自己的处理器发过去</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMessenger.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定服务端</span></span><br><span class="line">Intent intentMessenger = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</span><br><span class="line">bindService(intentMessenger, messengerSconn, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC机制</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC机制(三) -- ContentProvider、Socket和Binder池</title>
    <url>/2021/01/29/IPC%E6%9C%BA%E5%88%B6-%E4%B8%89-ContentProvider%E3%80%81Socket%E5%92%8CBinder%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="1-ContentProvider"><a href="#1-ContentProvider" class="headerlink" title="1.ContentProvider"></a>1.ContentProvider</h3><p>ContentProvider的底层实现是基于Binder，系统为我们做了深度的封装，让我们使用起来非常容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line"><span class="comment">// 实现一个内容提供者，每个CURD方法中实现对数据的提供，可以是大多是从数据库加载数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">&quot;com.gacrnd.gcs.ipc.BookProvider&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOK_CONTENT_URI = Uri.parse(<span class="string">&quot;content://&quot;</span> + AUTHORITY + <span class="string">&quot;/book&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_CONTENT_URI = Uri.parse(<span class="string">&quot;content://&quot;</span> + AUTHORITY + <span class="string">&quot;/user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_URI_CODE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_URI_CODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sUriMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sUriMatcher.addURI(AUTHORITY,<span class="string">&quot;book&quot;</span>,BOOK_URI_CODE);</span><br><span class="line">        sUriMatcher.addURI(AUTHORITY,<span class="string">&quot;user&quot;</span>,USER_URI_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过uri获取表名</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.BOOK_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> USER_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">//以下应该在子线程中加载数据库</span></span><br><span class="line">        initDatabase();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDatabase = <span class="keyword">new</span> DbOpenHelper(mContext).getWritableDatabase();</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;DELETE FROM &quot;</span> + DbOpenHelper.BOOK_TABLE_NAME);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;DELETE FROM &quot;</span> + DbOpenHelper.USER_TABLE_NAME);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO book VALUES(1,&#x27;ANDROID 1&#x27;);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO book VALUES(2,&#x27;ANDROID 2&#x27;);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO book VALUES(3,&#x27;ANDROID 3&#x27;);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO user VALUES(1,&#x27;JackOu&#x27;,0);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO user VALUES(2,&#x27;DY&#x27;,1);&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;JackOu&quot;</span>,<span class="string">&quot;query:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        String tableName = getTableName(uri);</span><br><span class="line">        <span class="keyword">if</span> (tableName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;uri illegal！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDatabase.query(tableName,projection,selection,selectionArgs,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//需要基于数据库实现对应的CURD操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二步 在manifest中声明该Provider</span></span><br><span class="line">&lt;provider</span><br><span class="line">    android:authorities=<span class="string">&quot;com.gacrnd.gcs.ipc.BookProvider&quot;</span></span><br><span class="line">    android:name=<span class="string">&quot;.BookProvider&quot;</span></span><br><span class="line">    android:permission=<span class="string">&quot;com.gacrnd.gcs.PROVIDER&quot;</span></span><br><span class="line">    android:process=<span class="string">&quot;:provider&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">&quot;book_provider.db&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">&quot;book&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + BOOK_TABLE_NAME</span><br><span class="line">            + <span class="string">&quot;(_id INTEGER PRIMARY KEY, name TEXT)&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + USER_TABLE_NAME</span><br><span class="line">            + <span class="string">&quot;(_id INTEGER PRIMARY KEY, name TEXT, sex INT)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">        db.execSQL(CREATE_USER_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 忽略数据库版本升级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第四步在需要使用的地方获取数据即可</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.gacrnd.gcs.ipc.BookProvider&quot;</span>);</span><br><span class="line">getContentResolver().query(uri,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>); <span class="comment">// 写两个主要是想打印工作线程信息</span></span><br><span class="line">getContentResolver().query(uri,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>


<h3 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2. Socket"></a>2. Socket</h3><p>Socket称为“套接字”，是网络通信中的概念，分为流式套接字和用户数据报套接字两种，分别对应网络传输控制层的TCP和UDP协议。TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性。而UDP是无连接的，提供不稳定的单向/双向通信功能，在性能上，UDP协议不需要握手和挥手，效率会更高</p>
<h4 id="2-1-Socket服务端"><a href="#2-1-Socket服务端" class="headerlink" title="2.1 Socket服务端"></a>2.1 Socket服务端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDestory = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 正常应该用一个线程池来处理客户端来的请求的，但是作为demo，就暴力的新开一个线程处理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TcpServer()).start();</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 死循环处理客户端的请求</span></span><br><span class="line">            <span class="keyword">while</span> (!mDestory) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 接收客户端</span></span><br><span class="line">                    <span class="keyword">final</span> Socket client = serverSocket.accept();</span><br><span class="line">                    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//处理客户端发来的内容并且回复客户端</span></span><br><span class="line">                                responseClient(client);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseClient</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//接收客户端的消息</span></span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">        <span class="comment">//发送数据到客户端</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream())));</span><br><span class="line">        <span class="keyword">while</span> (!mDestory) &#123;</span><br><span class="line">            String fromClient = in.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;msg from client:&quot;</span> + fromClient);</span><br><span class="line">            <span class="keyword">if</span> (fromClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//客户端断开，直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">&quot;收到你的消息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交流完毕</span></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDestory = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-Socket客户端"><a href="#2-2-Socket客户端" class="headerlink" title="2.2 Socket客户端"></a>2.2 Socket客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//很粗暴的连接服务端，接收并且发送，主要是演示socket通信过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectServerSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrintWriter pw = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader br= <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!mDestory) &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">            pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())),<span class="keyword">true</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;client send msg&quot;</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            System.out.println(<span class="string">&quot;receive from server:&quot;</span> + br.readLine());</span><br><span class="line">         &#125;</span><br><span class="line">        pw.close();</span><br><span class="line">        br.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-Binder池"><a href="#3-Binder池" class="headerlink" title="3. Binder池"></a>3. Binder池</h4><p>由于项目业务逻辑越来越服务，需要和多个AIDL交互，如果一个一个绑定，调用，这样显得比较麻烦，所以就有了Binder池的概念出来。所有要请求服务端都放在Binder池中，客户端通过Binder池拿到自己需要服务的客户端。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a060c429afef494a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder池.png"></p>
<h4 id="3-1-binder池服务端"><a href="#3-1-binder池服务端" class="headerlink" title="3.1 binder池服务端"></a>3.1 binder池服务端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder mBinderPool = <span class="keyword">new</span> BinderPoolImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinderPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolImpl</span> <span class="keyword">extends</span> <span class="title">IBinderPool</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECURITY_SERVICE_PROXY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPUTE_SERVICE_PROXY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderPoolImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (binderCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> SECURITY_SERVICE_PROXY:</span><br><span class="line">                <span class="comment">// 此处用伪代码实现，返回SecurityCenterImpl，他继承ISecurityCenter.Stub()，实现了对应接口</span></span><br><span class="line">                <span class="comment">//binder = new SecurityCenterImpl();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COMPUTE_SERVICE_PROXY:</span><br><span class="line">                <span class="comment">//binder = new ComputerImpl();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-2-Binder池客户端"><a href="#3-2-Binder池客户端" class="headerlink" title="3.2 Binder池客户端"></a>3.2 Binder池客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> BinderPool sInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> IBinderPool mBinderPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 用于等待连接BinderPool，如果没有连接就一直阻塞等待</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch mCountDownLatch;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> BinderPoolServiceConnection();</span><br><span class="line">    <span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> BinderPoolDeathRecipient();</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderPool</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context.getApplicationContext();</span><br><span class="line">        connectBinderPoolService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinderPool <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BinderPool.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> BinderPool(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connectBinderPoolService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCountDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(mContext, BinderPoolService.class);</span><br><span class="line">        mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCountDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询binder接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> </span>&#123;</span><br><span class="line">        IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBinderPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从Binder服务端查询需要的接口</span></span><br><span class="line">                binder = mBinderPool.queryBinder(binderCode);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolServiceConnection</span> <span class="keyword">implements</span> <span class="title">ServiceConnection</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mBinderPool = IBinderPool.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mBinderPool.asBinder().linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//绑定成功，释放线程继续执行</span></span><br><span class="line">            mCountDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mBinderPool.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">            mBinderPool = <span class="keyword">null</span>;</span><br><span class="line">            connectBinderPoolService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC机制</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>回不去的过去，前进吧，战士</title>
    <url>/2021/01/30/%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E8%BF%87%E5%8E%BB%EF%BC%8C%E5%89%8D%E8%BF%9B%E5%90%A7%EF%BC%8C%E6%88%98%E5%A3%AB/</url>
    <content><![CDATA[<h3 id="1-回不去的学生时代"><a href="#1-回不去的学生时代" class="headerlink" title="1.回不去的学生时代"></a>1.回不去的学生时代</h3><p>回忆总想哭，但是有了过去战斗后的伤痕累累，才能给当前的自己更加不畏未来勇气！</p>
<blockquote>
<p>2011年9月 - 2015年7月               重庆邮电大学                          电气工程及其自动化</p>
<p>2015年9月 - 2018年7月               重庆大学(保研)                                 车辆工程</p>
</blockquote>
<h3 id="2-皮实的大学时光"><a href="#2-皮实的大学时光" class="headerlink" title="2.皮实的大学时光"></a>2.皮实的大学时光</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-6a0bed97c6ec2df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崎岖之路.png"></p>
<p>为什么是皮实的大学时光？请看上面这张图片，这是我大学走过的最崎岖的一条路，而我的大学生活也似乎像这条路一样曲折，但当到达山顶的那一刻，没人能体会到其中的兴奋。因为我是一个闲不下来，喜欢到处走走；停不下来，喜欢到处做做，喜欢到处折腾的人。在大学4年，有太多的失败，又有不少的成功。正是这些一件件“瞎折腾”构成了我皮实的大学时光。下面我以相册中的<strong>”照片残骸“</strong>来慢慢回忆吧。</p>
<h4 id="2-1-接管科技创新协会"><a href="#2-1-接管科技创新协会" class="headerlink" title="2.1 接管科技创新协会"></a>2.1 接管科技创新协会</h4><p>时间回到2012年下半年。当时我接管了科技创新协会(学校的一个社团)。<br>在大一上的时候，我和室友在准备一节课的上台表演时，偶然搜到了乔布斯的一些故事，越看越崇拜他，当时还做了一个简陋的面具，如下照片。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-07c9df645b8f965d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jobs.jpg"></p>
<p>在那时之后，对于一些高科技东西特别好奇，由于专业原因，我和室友开始学习<strong>《郭天祥的51单片机》</strong>，边学边动手搭建自己的最小系统板子，最后在2012年，暑假两个月的时间，我和室友一起成功的自己焊接电路板，自己写程序完成了一个<strong>“带有自动感光功能计算器”</strong>，虽然这个特别简单，但是对于自己亲手做成的东西，特别有成就感。在开学之后，以社团的名义，参加了重庆市组织的《高校联盟电子设计大赛》,并且获得了不错成绩。最后在12月份的时候，我们社团因此被评为<strong>”十佳社团“</strong>(全校91个社团)。下图是获奖照片和社团内的比赛分享。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4120b6d219fe8102.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="科技创新协会.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-368fe056cca5260e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单片机比赛分享.jpg"></p>
<h4 id="2-2-创业经历"><a href="#2-2-创业经历" class="headerlink" title="2.2 创业经历"></a>2.2 创业经历</h4><h5 id="2-2-1-被扼杀的外卖"><a href="#2-2-1-被扼杀的外卖" class="headerlink" title="2.2.1 被扼杀的外卖"></a>2.2.1 被扼杀的外卖</h5><p>大二大三，闲不下来的我发现同学们经常上完课就回寝室，可能是因为食堂饭菜吃腻了，中午也不愿意食堂吃饭。于是，我拉了几个朋友，一起创办了<strong>“零点外卖”</strong>，主要负责部分同学们的午餐和晚餐。当时为了宣传，创建了各种共享群（代取包裹群，拼车群，练车群…….）。我们平均一天可以有300单左右的量。但是正当我们想放大规模的时候，美团和饿了么开始“打架”。推出“8元吃饱，10元吃好”的口号，一下子就把我们外卖创业史扼杀在摇篮中。</p>
<h5 id="2-2-2-过于旺盛的驾校"><a href="#2-2-2-过于旺盛的驾校" class="headerlink" title="2.2.2 过于旺盛的驾校"></a>2.2.2 过于旺盛的驾校</h5><p>我们原班人马都还在感叹资本的强大和叹息我们第一份创业经历就这样失败的不舍时，我们发现学校的驾校每天都有好多人在排队学车，一个人只能练习一两趟，而要等待一上午。由于做外卖有了一点点积累，于是我们几个都没什么商量，凑足了十几万块，买了两辆长安逸动，加盟了凤凰驾校，在我们重邮开启了凤凰驾校-重邮分部。当时由于学校十分提倡大学生创业创新，辅导员也帮我们做了很多宣传，我们每天也做到学车接送服务，在开学两三个月的时间，我们就招了180多名学员，严重超了我们两辆车的培训负荷，导致很多同学学了车，不能去考试(交管所限制了一辆车一个月的考试人数)，最后我们不得不把学习结束的同学安排到总校去参加考试。</p>
<p>此时时间也到了大三下，该做人生抉择的时候，由于我当时成绩每年都在年级前10(总共206人)，顺利申请到了保研名额，在经过各种考试，面试之后，我顺利保送到了重庆大学。</p>
<h5 id="2-2-3-总算盛开的洗碗机"><a href="#2-2-3-总算盛开的洗碗机" class="headerlink" title="2.2.3 总算盛开的洗碗机"></a>2.2.3 总算盛开的洗碗机</h5><p>由于保研了，有一段空闲的时间，不甘心前面失败的我们又搞起了事情，由于之前做过外卖，我们也发现学校周边餐馆生意异常火爆，每天中午和晚上饭后都堆了很大一摊子等待清晰的碗筷，如果餐馆自己洗，必定每个餐馆要请一个人专门干这个事情。于是乎团队的一个小伙伴说，一起搞洗碗机，把周边的所有碗筷收集起来，我们洗完了送回去。就出于这个简单的想法，大家都一拍即合的开始干起来，开始很多餐馆不愿意把碗筷交给我们洗，不是因为收费，是因为怕自己的碗筷到了别人家的餐馆，自己亏了，后来我们想到直接我们出统一的碗筷，直接给餐馆使用，用完了，我们收回来直接一起洗了…..<br>很庆幸的是，这个项目最后得到了我们院某位老师的支持，最后在有一定运营规模的时候，我们和老师一起做了一个洗碗流水线，大大加快了洗碗效率。<br>由于后面去重大读研了，我也很不舍的离开了我们的团队。<br>不过很庆幸的是，居然我们的事情，还有一名记者报道出来了。<a href="https://www.163.com/dy/article/DM9H7G7Q0511D84J.html">小辣椒消毒服务公司</a></p>
<h3 id="3-战斗的研究生生活"><a href="#3-战斗的研究生生活" class="headerlink" title="3.战斗的研究生生活"></a>3.战斗的研究生生活</h3><p>刚到了新的学校，我时常反思自己到底想干什么。虽然本科在创业上花了不少时间，但是我对技术的喜爱一点没有降，研究生的生活再次燃起了我对技术的热爱。</p>
<p>研一的时候，在一次听前言讲座的机会中，偶然接触到了讯飞发布语音交互产品，当时觉得特别好玩，特别牛X，一回来我就到处找资料。由于当时讯飞主要是To B的业务，几乎没有预留给个人开发者的接口。但是天无绝人之路，我发现当时百度对个人开发者提供了很多开发接口，于是就开启了我的开发之路。</p>
<h5 id="3-1-用“助理小荣”备战“上汽杯”软件挑战赛"><a href="#3-1-用“助理小荣”备战“上汽杯”软件挑战赛" class="headerlink" title="3.1 用“助理小荣”备战“上汽杯”软件挑战赛"></a>3.1 用“助理小荣”备战“上汽杯”软件挑战赛</h5><p>当真正接入到百度语音交互方式之后，结合我本科自己对单片机的学习经历，我花了研二一年的时间，基于STM32开发板，自己搭模块、调驱动和应用程序；基于百度语音，百度地图等API，开发出自己的V1，V2和V3版“助理小荣”。V1版实现了硬件各模块调通能运行需要的五类功能，V2版实现了基于百度各开放API开发的语音交互系统，V3版是结合软硬件一起合成的“助理小荣”，这个版本的助理小荣已经具备语音交互，语音控制等复杂一些的功能了。我开发板安装在长安逸动上，实现了一整条链路的控制。<strong>最后通过这个项目拿到了广汽研究院、泛亚技术中心和上汽乘用车实习Offer。</strong></p>
<p><a href="https://www.iqiyi.com/w_19rtqsmjl1.html">V3版助理小荣–实现五大类语音交互控制</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-8d893e0ff15484e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上汽实习通知.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7557d298036e93a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广汽实习通知.png"></p>
<h5 id="3-2-DuerOS开发者"><a href="#3-2-DuerOS开发者" class="headerlink" title="3.2 DuerOS开发者"></a>3.2 DuerOS开发者</h5><p>在广汽研究院实习期间，我也没有闲着，我继续基于百度语音和生态API开发应用，最后在百度第一次发布DuerOS之后，经过和其他开发者PK基于百度开发的应用，成功成为了<strong>DuerOS第一批开发者</strong>，最后结合百度的核心板加一个普通音箱，实现了<strong>AI音箱</strong>的功能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-050a0ddc879fc5d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方推广.jpg"></p>
<h5 id="3-3-ACM图灵中国大会"><a href="#3-3-ACM图灵中国大会" class="headerlink" title="3.3 ACM图灵中国大会"></a>3.3 ACM图灵中国大会</h5><p>当实习结束回到重庆之后，我拉着师弟们一起继续战斗，报名参加了<strong>ACM图灵中国联合清华大学举办的“全国高校物联网应用创新大赛”</strong>。我和师弟们通宵达旦破解长安逸动DBC协议，最后使用我之前已经搭建完成的语音交互app和控制板，完成了五大类语音交互功能和在黑盒情况下语音控制整车一部分的作品(实现整车启停，所有灯光，座椅，空调，雨刮，车窗)。最后用此项目，获得了<strong>西南片区第一名，全国第三名</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-0f10262e12ea4857.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西南赛区一等奖领奖.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-84be8d1b7242b628.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ACM领奖.jpg"></p>
<h3 id="4-完美收官毕业"><a href="#4-完美收官毕业" class="headerlink" title="4.完美收官毕业"></a>4.完美收官毕业</h3><p>在研究生期间，我还有一个研究方向是基于DSRC专用短程通信技术的车辆防碰撞系统，主要是基于DSRC通信技术，结合超声波雷达传感器，解析报文协议，做了前向制动提示功能，当前车踩刹车制动的时候，判断两车距离和速度，如果找警戒阈值内就发出警报提示。(演示视频在答辩PPT中)</p>
<p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201901&filename=1018853533.nh&v=%25mmd2BEvx5EgDftSeuKY9NRchOx9%25mmd2FT%25mmd2FYIUMvrnTD3QIVrgcFqltS9pzJzIOQC54h7lnkb">基于DSRC技术的车辆防碰撞语音提示与辅助控制系统的研发</a></p>
<h3 id="5-学生时代所有自己开发的项目视频"><a href="#5-学生时代所有自己开发的项目视频" class="headerlink" title="5.学生时代所有自己开发的项目视频"></a>5.学生时代所有自己开发的项目视频</h3><blockquote>
<p>链接：<a href="https://pan.baidu.com/s/14Zvq1LSM9zYgEhwsgpxEIg">https://pan.baidu.com/s/14Zvq1LSM9zYgEhwsgpxEIg</a><br>提取码：547s<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu安装工具篇</title>
    <url>/2021/02/09/Ubuntu%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E7%AF%87/</url>
    <content><![CDATA[<h3 id="1-安装VMware-Tools"><a href="#1-安装VMware-Tools" class="headerlink" title="1.安装VMware Tools"></a>1.安装VMware Tools</h3><p>1.1 选择安装/重新安装VMware tools</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-aee2d7937bb7cc4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装或者重新安装VMtools.png"></p>
<p><strong>1.2 VMware会自动下载最新的安装包</strong>(默认会在以下目录：/media/&lt;你的用户名&gt;/VMware Tools)</p>
<p><strong>1.3 进入安装包目录</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-97f9b808e074b119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装包目录.png"></p>
<p><strong>1.4 解压安装包</strong>(指令：tar -zxvf VMwareTools-10.2.5-8068393.tar.gz)</p>
<p>如果报以下错误：<strong>chmod: changing permissions of ‘VMwareTools-10.2.5-8068393.tar.gz’: Read-only file system</strong></p>
<p>使用以下指令，将压缩包解压到可写目录即可：tar -zxvf VMwareTools-10.2.5-8068393.tar.gz -C  /home/jackou/Desktop</p>
<p><strong>1.5 进入vmware-tools-distrib然后运行./vmware-install.pl 按默认安装一直回车到底即可。</strong>、</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-9efd8917947dda3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装.png"></p>
<p><strong>1.6 安装成功</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b96be5c744b247a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装成功.png"></p>
<h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git </span><br><span class="line">git config -–global user.email “test<span class="meta">@test</span>.com” </span><br><span class="line">git config -–global user.name “test”</span><br></pre></td></tr></table></figure>


<h3 id="3-安装CURL"><a href="#3-安装CURL" class="headerlink" title="3.安装CURL"></a>3.安装CURL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>


<h3 id="4-安装repo"><a href="#4-安装repo" class="headerlink" title="4.安装repo"></a>4.安装repo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">curl https:<span class="comment">//storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span></span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>


<h3 id="5-安装python3-6"><a href="#5-安装python3-6" class="headerlink" title="5.安装python3.6"></a>5.安装python3.6</h3><p>如果使用下面的被拒绝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:jonathonf/python-<span class="number">3.6</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python3<span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>请使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python3<span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>不关需要安装python3.6，还需要安装pip和python3.6-dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装pip</span><br><span class="line">wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py  --no-check-certificate</span><br><span class="line">python3 get-pip.py</span><br><span class="line">     </span><br><span class="line">#安装python3.6-dev</span><br><span class="line">apt-get install python3.6-dev</span><br></pre></td></tr></table></figure>


<h3 id="6-安装open-jdk"><a href="#6-安装open-jdk" class="headerlink" title="6.安装open-jdk"></a>6.安装open-jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装Unbuntu 16.04</title>
    <url>/2021/02/09/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Unbuntu-16-04/</url>
    <content><![CDATA[<h3 id="1-准备Ubuntu虚拟机"><a href="#1-准备Ubuntu虚拟机" class="headerlink" title="1.准备Ubuntu虚拟机"></a>1.准备Ubuntu虚拟机</h3><p>因为我准备编译Android P的源码，所以至少需要安装16.04版本，如果编译Android M的源码，可以安装14.04的。这个就不多介绍了，直接上Ubuntu链接(墙裂不建议在官网下，没墙出去，贼慢！)，各位看哪个信源快自己选择吧。</p>
<blockquote>
<p>官方下载地址（不推荐）<br><a href="https://www.ubuntu.com/download">https://www.ubuntu.com/download</a><br>中科大源<br><a href="http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/">http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/</a><br>阿里云开源镜像站<br><a href="http://mirrors.aliyun.com/ubuntu-releases/16.04/">http://mirrors.aliyun.com/ubuntu-releases/16.04/</a><br>北京理工大学开源<br><a href="http://mirror.bit.edu.cn/ubuntu-releases/16.04/">http://mirror.bit.edu.cn/ubuntu-releases/16.04/</a><br>浙江大学<br><a href="http://mirrors.zju.edu.cn/ubuntu-releases/16.04/">http://mirrors.zju.edu.cn/ubuntu-releases/16.04/</a></p>
</blockquote>
<h3 id="2-安装Ubuntu虚拟机"><a href="#2-安装Ubuntu虚拟机" class="headerlink" title="2.安装Ubuntu虚拟机"></a>2.安装Ubuntu虚拟机</h3><p><strong>2.1 点击文件 -&gt; 新建虚拟机</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5492dbb603f35746.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建虚拟机.png"></p>
<p><strong>2.2 选择“自定义(高级)”，然后选择虚拟机兼容设置，直接选择“下一步”</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-da112db8fe01e15d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚拟机向导.png"></p>
<p><strong>2.3 选择“安装程序光盘映像文件(iso)”，然后找到第一小节下载的Ubuntu镜像文件</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b7520ad539733544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择镜像安装.png"></p>
<p><strong>2.4 填写ubuntu基本信息</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-88f7d06104bd89d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本信息填写.png"></p>
<p><strong>2.5 给虚拟机取个名字，和选择虚拟机存放的位置</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-12ec53f348ae0b23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命名并选择存放的位置.png"></p>
<p><strong>2.6 给虚拟机分配处理器和内核数</strong></p>
<ul>
<li><p>处理器数量表示有几个处理器；</p>
</li>
<li><p>总处理器核心数 = 处理器数量 * 每个处理器的核心数；</p>
</li>
<li><p>线程数可以右键“电脑”属性查看。</p>
<p>这个看自己需求来定，如果主要在虚拟机办公了，那就多分配几个内核数来处理虚拟机的事务，如果主要在window下办公，就处理器申请1，内核数分配2-3就差不多。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4e69bb67deaddcaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="给虚拟机分配处理器和内核数.png"></p>
<p><strong>2.7 分配虚拟机内存</strong></p>
<p>还是看需求定，分配多了window会卡一点，分配少了虚拟机会卡。不经常不用虚拟机就分配1G就行，我要编系统，分配4G。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-23251e953d397f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配虚拟机内存.png"></p>
<p><strong>2.8 后面的网络类型、I/O控制器、创建磁盘、使用磁盘以及磁盘大小直接选择的默认选项。</strong></p>
<p>关于磁盘分配，因为Android原生代码特别大，我建议分配100G，小了后面要扩展，很麻烦。现在分配100G也不是真实用到的100G，只是最大100G。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a1723ce659171fac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配磁盘.png"></p>
<p><strong>2.9 确认配置，就创建好虚拟机了。</strong></p>
<p>最后就等系统自动安装就行了，等待的时间有点久，至少20多分钟吧，慢慢等就行。最后出现登录界面，登录进图就大功告成了，后面可以安装一些工具。<br><img src="https://upload-images.jianshu.io/upload_images/13838098-cb5a4470319a1da1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认配置.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e9ce4a244c9f942f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录界面.png"></p>
<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><p><img src="/2021/02/09/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Unbuntu-16-04/blog\source_posts\虚拟机安装Unbuntu-16-04\无法打开配置文件.png" alt="无法打开配置文件"></p>
<p>解决办法：直接以管理员身份运行虚拟机即可</p>
<p>![Intel VT-x被禁用](G:\blog\source_posts\虚拟机安装Unbuntu-16-04\Intel VT-x被禁用.png)</p>
<p>解决办法：在bios中使能Intel Virtualization Technology开关即可</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VmWare</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 16.04磁盘扩容</title>
    <url>/2021/02/22/ubuntu-16-04%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>在编译Android O系统源码的时候，看着都快成功了，但是突然VMware虚拟机报磁盘不够了，导致编译失败，删除各种应用也不够，因为要编译Android源码太费磁盘了！！！我之前分配了100G，源码就占了83G左右，所以必须扩容，我先暂时扩展为215G试试吧(要编译aosp_car_x86_64-userdebug至少需要预留300G以上，我这篇文档先暂时演示扩容过程)，下面就开始搞事~~</p>
<h3 id="2-扩展目标"><a href="#2-扩展目标" class="headerlink" title="2.扩展目标"></a>2.扩展目标</h3><p>从目前的208G扩展到218G吧(主要演示过程，其实208G是我自己测试扩展后的容量，我再扩展10G吧)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-350f703829a489b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化内存.png"></p>
<h3 id="3-主要流程"><a href="#3-主要流程" class="headerlink" title="3.主要流程"></a>3.主要流程</h3><ul>
<li>在VMware设置期望扩展后的最大内存大小</li>
<li>将新加的内存分配到主分区</li>
<li>更新UUID</li>
</ul>
<h4 id="4-详细流程"><a href="#4-详细流程" class="headerlink" title="4.详细流程"></a>4.详细流程</h4><h4 id="Step1：关闭虚拟机，点击“编辑虚拟机设置”"><a href="#Step1：关闭虚拟机，点击“编辑虚拟机设置”" class="headerlink" title="Step1：关闭虚拟机，点击“编辑虚拟机设置”"></a>Step1：关闭虚拟机，点击“编辑虚拟机设置”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-30e9f2eb0a4dae1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑VMWARE虚拟机设置.png"></p>
<h4 id="Step2：点击“硬盘-SCSI-”-gt-“扩展”"><a href="#Step2：点击“硬盘-SCSI-”-gt-“扩展”" class="headerlink" title="Step2：点击“硬盘(SCSI)” -&gt; “扩展”"></a>Step2：点击“硬盘(SCSI)” -&gt; “扩展”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-7217457ea0853c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改扩展的最大内存.png"></p>
<h4 id="Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”"><a href="#Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”" class="headerlink" title="Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”"></a>Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-10834daf4db3d7db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置最大可占内存.png"></p>
<h4 id="Step4：开机安装“gparted”工具"><a href="#Step4：开机安装“gparted”工具" class="headerlink" title="Step4：开机安装“gparted”工具"></a>Step4：开机安装“gparted”工具</h4><blockquote>
<p>在终端输入：sudo apt-get install gparted</p>
<p>然后输入Y确定即可</p>
</blockquote>
<h4 id="Step5：启动“gparted”，输入管理员密码进入工具"><a href="#Step5：启动“gparted”，输入管理员密码进入工具" class="headerlink" title="Step5：启动“gparted”，输入管理员密码进入工具"></a>Step5：启动“gparted”，输入管理员密码进入工具</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-1c184f2ecaf8e06f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择Gparted工具启动.png"></p>
<h4 id="Step6：可以看到刚刚分配的10G-从最大215G修改成225G"><a href="#Step6：可以看到刚刚分配的10G-从最大215G修改成225G" class="headerlink" title="Step6：可以看到刚刚分配的10G(从最大215G修改成225G)"></a>Step6：可以看到刚刚分配的10G(从最大215G修改成225G)</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-96f1eb133d2f994f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刚分配的10G.png"></p>
<p>1./dev/sda1是主分区</p>
<p>2./dev/sda2是扩展分区</p>
<p>3./dev/sda5是逻辑分区</p>
<p>由于我们需要将为分配分区添加到主分支中，而未分配分区和主分区中间不能有其他分区，所有我们需要先禁止交换空间，并且删除扩展分区和交换空间。</p>
<h4 id="Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）"><a href="#Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）" class="headerlink" title="Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）"></a>Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-ec1252839e4d6567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关闭交换空间.png"></p>
<h4 id="Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”"><a href="#Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”" class="headerlink" title="Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”"></a>Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-a5b0c1c6c3a658ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除对应分区.png"></p>
<p>删除交换空间和扩展空间后：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-044c15348d87ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除扩展和交换分区后.png"></p>
<h4 id="Step9：扩展主分区，鼠标移入-dev-sda1，右键选择“Resize-move”-更改大小-移动"><a href="#Step9：扩展主分区，鼠标移入-dev-sda1，右键选择“Resize-move”-更改大小-移动" class="headerlink" title="Step9：扩展主分区，鼠标移入/dev/sda1，右键选择“Resize/move”(更改大小/移动)"></a>Step9：扩展主分区，鼠标移入/dev/sda1，右键选择“Resize/move”(更改大小/移动)</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-e2663a0fc8558bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改主分区大小.png"></p>
<h4 id="Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3-4G左右-填了new-size大小，这个会自动减去-，然后点击“resize”"><a href="#Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3-4G左右-填了new-size大小，这个会自动减去-，然后点击“resize”" class="headerlink" title="Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3.4G左右(填了new size大小，这个会自动减去)，然后点击“resize”"></a>Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3.4G左右(填了new size大小，这个会自动减去)，然后点击“resize”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-c16db94d3bd4cdf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配主分区.png"></p>
<p>主分区分配后结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4ce0c57e17ed8b28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主分区分配后结果.png"></p>
<h4 id="Step11：创建扩展分区，鼠标移入“unallocated”-选择“new”"><a href="#Step11：创建扩展分区，鼠标移入“unallocated”-选择“new”" class="headerlink" title="Step11：创建扩展分区，鼠标移入“unallocated”,选择“new”"></a>Step11：创建扩展分区，鼠标移入“unallocated”,选择“new”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-2081d24ff65569d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建扩展分区.png"></p>
<h4 id="Step12：创建为“扩展分区”，选择“Extended-Partition”-并点击“add”"><a href="#Step12：创建为“扩展分区”，选择“Extended-Partition”-并点击“add”" class="headerlink" title="Step12：创建为“扩展分区”，选择“Extended Partition”,并点击“add”"></a>Step12：创建为“扩展分区”，选择“Extended Partition”,并点击“add”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-89853801dc0c26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择扩展分区.png"></p>
<h4 id="Step13：创建交换空间，鼠标移入“unallocated”-选择“new”-进入之后点击“file-system”-选择“linux-swap”-最后点击“add”添加交换分区"><a href="#Step13：创建交换空间，鼠标移入“unallocated”-选择“new”-进入之后点击“file-system”-选择“linux-swap”-最后点击“add”添加交换分区" class="headerlink" title="Step13：创建交换空间，鼠标移入“unallocated”,选择“new”,进入之后点击“file system”,选择“linux-swap”,最后点击“add”添加交换分区"></a>Step13：创建交换空间，鼠标移入“unallocated”,选择“new”,进入之后点击“file system”,选择“linux-swap”,最后点击“add”添加交换分区</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-b41d6635abd7a681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置交换空间.png"></p>
<p>添加完成扩展分区和交换分区的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-680fe218fd31ca9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加扩展分区和交换分区结果.png"></p>
<h4 id="Step14：应用以上的配置，点击“√”，并且点击“apply”"><a href="#Step14：应用以上的配置，点击“√”，并且点击“apply”" class="headerlink" title="Step14：应用以上的配置，点击“√”，并且点击“apply”"></a>Step14：应用以上的配置，点击“√”，并且点击“apply”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-f54e629d635419ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击确认.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2a3e33a5ca6df29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击apply.png"></p>
<h4 id="Step15：分配完成，点击“close”"><a href="#Step15：分配完成，点击“close”" class="headerlink" title="Step15：分配完成，点击“close”"></a>Step15：分配完成，点击“close”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-83b24558095cb0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配成功.png"></p>
<h4 id="Step16：查看并记住交换空间的UUID"><a href="#Step16：查看并记住交换空间的UUID" class="headerlink" title="Step16：查看并记住交换空间的UUID"></a>Step16：查看并记住交换空间的UUID</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-150c15ee7aa94e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="记录UUID.png"></p>
<h4 id="Step17：修改-etc-fstab中的UUID值"><a href="#Step17：修改-etc-fstab中的UUID值" class="headerlink" title="Step17：修改/etc/fstab中的UUID值"></a>Step17：修改/etc/fstab中的UUID值</h4><blockquote>
<p>sudo vim /etc/fstab</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a653f745a19104ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改UUID.png"></p>
<h4 id="Step18：查看是否扩展成功了"><a href="#Step18：查看是否扩展成功了" class="headerlink" title="Step18：查看是否扩展成功了"></a>Step18：查看是否扩展成功了</h4><blockquote>
<p>输入：df -h</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-311dcc324b229072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扩展成功.png"></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>磁盘扩容</tag>
        <tag>源码编译</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>徒手搭建编译环境，编译Android源码(手把手，嘴对嘴版本)</title>
    <url>/2021/02/10/%E5%BE%92%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81-%E6%89%8B%E6%8A%8A%E6%89%8B%EF%BC%8C%E5%98%B4%E5%AF%B9%E5%98%B4%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>作为有点点小追求的Android Developer，应该都需要拥有一套自己的Android源码吧，一方面方便自己对源码的理解，另一方面也方便自己验证自己的很多猜想。本文主要记录一下源码从下载到编译成功的一整套完整过程，以便以后自己在其他地方搭环境或者其他朋友搭建有借鉴的地方。</p>
<p>在Windows上从零开始搭建环境我理解分为以下几个步骤：</p>
<ul>
<li>搭建Linux运行环境，详见第一章</li>
<li>安装下载和编译需要的各种工具，详见第二章</li>
<li>下载源码</li>
<li>构建编译环境</li>
<li>编译源码</li>
<li>运行</li>
</ul>
<p>下面我就一个一个的记录所有的操作，尽量细致哈，哈哈哈哈</p>
<h3 id="1-安装VMWare和Ubuntu"><a href="#1-安装VMWare和Ubuntu" class="headerlink" title="1.安装VMWare和Ubuntu"></a>1.安装VMWare和Ubuntu</h3><p>参见</p>
<h3 id="2-安装下载和编译需要的工具"><a href="#2-安装下载和编译需要的工具" class="headerlink" title="2.安装下载和编译需要的工具"></a>2.安装下载和编译需要的工具</h3><p>参见</p>
<h3 id="3-下载源码"><a href="#3-下载源码" class="headerlink" title="3.下载源码"></a>3.下载源码</h3><p>由于国内种种原因，我们访问qiang外的网站非常慢，甚至无法访问，导致下载源码真是要折磨死人。<br>好在各大高校提供了国内的镜像源，可以供国内的小伙伴们一起学习交流，目前中国科学技术大学和清华大学的比较稳定，其具体使用都差不多，我就以清华源的镜像进行一步一步搭建吧。（<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp/">科大源</a>、<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华源</a>）</p>
<p><strong>3.1 创建源目录</strong></p>
<p>创建源代码目录，主要用于将所有源代码，以后编译出来的中间产物等都放着这里面方便管理。<br>这个源文件目录随便创建，但是方便看，我们就在自己用户目录下创建source目录吧。</p>
<p><strong>3.1.1 创建目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mkdir ~/work_directory</span><br><span class="line">cd ~/work_directory</span><br></pre></td></tr></table></figure>


<p><strong>3.1.2 初始化仓库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repo init -u https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest</span></span><br></pre></td></tr></table></figure>
<p>如果执行该命令的过程中,如果提示无法连接到 gerrit.googlesource.com，那么我们只需要编辑 ~/bin/repo文件，找到REPO_URL这一行,然后将其内容修改为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">REPO_URL = <span class="string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-673bf5c2e80190aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改repo.png"></p>
<p>PS:由于我希望下Android P的代码，使用-b参数来指定哪个分支，所有我的初始化仓库为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repo init -u git:<span class="comment">//mirrors.ustc.edu.cn/aosp/platform/manifest -b android-9.0.0_r33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//坑点：大家不要下清华源的android-9.0.0_r1,访问我同步下来是编不过的。</span></span><br><span class="line"><span class="comment">// 如果下载Android9的话，建议下载：android-9.0.0_r8或者android-9.0.0_r33，亲测可以编过</span></span><br></pre></td></tr></table></figure>
<p>具体 Android 版本(<a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds">列表</a>)</p>
<p><strong>3.1.3 同步代码到本地</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure>
<p>！！！一直！！！使用以上代码即可完成代码同步。</p>
<p>同步代码是一个非常耗费人力的事情，反正我睡前开始第一步同步，半夜起来同步了几次，第二天一直守着电脑，一旦出现：repo sync has finished successfully.我就再用repo sync再次看看同步结果没有，结果还要无休止的同步…….大家耐心等待吧，至少折磨一天，反正目前我到了这一步还在同步，一天了….  </p>
<p>一直等此次同步结束，然后再执行repo sync…..如此往复就行了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1514cee998488f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此次同步结束.png"></p>
<h3 id="3-1-4-自动化脚本"><a href="#3-1-4-自动化脚本" class="headerlink" title="3.1.4 自动化脚本"></a>3.1.4 自动化脚本</h3><p>是不是看了3.1.3然后自己一直repo sync，等，repo sync……如此循环都快绝望了。别绝望，下面介绍一个脚本，自动下载。</p>
<p>首先，在工作目录下创建一个python脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//step1 创建脚本文件</span><br><span class="line">vim ~/download.sh</span><br><span class="line">    </span><br><span class="line">// step2 在脚本中输入</span><br><span class="line">echo &quot;======start repo sync======&quot;</span><br><span class="line">repo sync</span><br><span class="line">while [ $? == 1 ]; do</span><br><span class="line">echo &quot;======sync failed, re-sync again======&quot;</span><br><span class="line">sleep 30</span><br><span class="line">repo sync</span><br><span class="line">done </span><br><span class="line">    </span><br><span class="line">// step3 赋权限</span><br><span class="line">chmod a+x download.sh</span><br><span class="line">    </span><br><span class="line">// step4 执行即可</span><br><span class="line">./download.sh</span><br></pre></td></tr></table></figure>
<p>可以洗洗睡了，第二天看看下完没有吧，准备开始编译吧。</p>
<h3 id="4-构建编译环境"><a href="#4-构建编译环境" class="headerlink" title="4.构建编译环境"></a>4.构建编译环境</h3><p>源码下载完成后,就可以构建编译环境了.在开始之前,我们先来看看一些编译要求:</p>
<p><strong>4.1 硬件要求:</strong><br> 64位的操作系统只能编译2.3.x以上的版本,如果你想要编译2.3.x以下的,那么需要32位的操作系统.<br> 磁盘空间越多越好,至少在100GB以上.意思就是,你可以去买个大点的硬盘了啊<br> 如果你想要在是在虚拟机运行linux,那么至少需要16GB的RAM/swap.<br> (实际上,我非常不推荐在虚拟机中编译2.3.x以上的代码.)</p>
<p><strong>4.2 软件要求:</strong><br> <em>1. 操作系统要求</em><br> 在<a href="https://link.jianshu.com/?t=https://android.googlesource.com/">AOSP开源</a>中,主分支使用Ubuntu长期版本开发和测试的,因此也建议你使用Ubuntu进行编译,下面我们列出不同版本的的Ubuntu能够编译那些android版本:</p>
<table>
<thead>
<tr>
<th>Android版本</th>
<th>编译要求的Ubuntu最低版本</th>
</tr>
</thead>
<tbody><tr>
<td>Android 6.0至AOSP master</td>
<td>Ubuntu 14.04</td>
</tr>
<tr>
<td>Android 2.3.x至Android 5.x</td>
<td>Ubuntu 12.04</td>
</tr>
<tr>
<td>Android 1.5至Android 2.2.x</td>
<td>Ubuntu 10.04</td>
</tr>
</tbody></table>
<p><em>2. JDK版本要求</em><br> 除了操作系统版本这个问题外,我们还需要关注JDK版本问题,为了方便,同样我们也列出的不同Android版本的源码需要用到的JDK版本:</p>
<table>
<thead>
<tr>
<th>Android版本</th>
<th>编译要求的JDK版本</th>
</tr>
</thead>
<tbody><tr>
<td>AOSP的Android主线</td>
<td>OpenJDK 8</td>
</tr>
<tr>
<td>Android 5.x至android 6.0</td>
<td>OpenJDK 7</td>
</tr>
<tr>
<td>Android 2.3.x至Android 4.4.x</td>
<td>Oracle JDK 6</td>
</tr>
<tr>
<td>Android 1.5至Android 2.2.x</td>
<td>Oracle JDK 5</td>
</tr>
</tbody></table>
<p>更具体的可以参看:<a href="https://link.jianshu.com/?t=https://source.android.com/source/requirements.html">Google源码编译要求</a></p>
<p>我现在在Ubuntu 16.04下编译AOSP主线代码,因此需要安装OpenJDK 8,执行命令如下:<br> <code>sudo apt-get install openjdk-8-jdk</code><br> 如果你需要在Ubuntu 14.04下编译AOSP主线代码,同样需要安装OpenJDK 8,此时需要执行如下命令:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install openjdk<span class="number">-8</span>-jdk</span><br></pre></td></tr></table></figure>
<p>如果你要编译的是Android 5.x到android 6.0之间的系统版本,需要采用openjdk7.但是在Ubuntu 15.04及之后的版本的在线安装库中只支持openjdk8和openjdk9的安装.因此,如果你想要安装openjdk 7需要首先设置ppa:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">add</span>-apt-repository ppa:openjdk-r/ppa </span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br></pre></td></tr></table></figure>
<p>然后再执行安装命令:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install openjdk<span class="number">-7</span>-jdk </span><br></pre></td></tr></table></figure>
<p>有时候,我们需要编译不同版本的android系统,就可能使用不同的jdk版本.关于jdk版本切换,可以使用如下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-alternative --config java</span><br><span class="line">sudo update-alternative --config javac</span><br></pre></td></tr></table></figure>
<p><em>3. 其他要求</em></p>
<p><a href="https://link.jianshu.com/?t=https://source.android.com/source/initializing.html">Google官方构建编译环境指南</a>中已经说明了Ubuntu14.04,Ubuntu 12.04,Ubuntu 10.04需要添加的依赖,这里我们就不做介绍了.我原先以为,Ubuntu16.04的设置和Ubuntu14.04的依赖设置应该差不多,但是只能说too young too simple.<br> 下面是Ubuntu16.04中的依赖设置:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install libx11<span class="operator">-</span>dev:i386 libreadline6<span class="operator">-</span>dev:i386 libgl1<span class="operator">-</span>mesa<span class="operator">-</span>dev g<span class="operator">++-</span>multilib </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install <span class="operator">-</span>y git flex bison gperf build<span class="operator">-</span>essential libncurses5<span class="operator">-</span>dev:i386 </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install tofrodos python<span class="operator">-</span>markdown libxml2<span class="operator">-</span>utils xsltproc zlib1g<span class="operator">-</span>dev:i386 </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install dpkg<span class="operator">-</span>dev libsdl1.<span class="number">2</span><span class="operator">-</span>dev libesd0<span class="operator">-</span>dev</span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install git<span class="operator">-</span>core gnupg flex bison gperf build<span class="operator">-</span>essential  </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install zip curl zlib1g<span class="operator">-</span>dev gcc<span class="operator">-</span>multilib g<span class="operator">++-</span>multilib </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install libc6<span class="operator">-</span>dev<span class="operator">-</span>i386 </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install lib32ncurses5<span class="operator">-</span>dev x11proto<span class="operator">-</span>core<span class="operator">-</span>dev libx11<span class="operator">-</span>dev </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install libgl1<span class="operator">-</span>mesa<span class="operator">-</span>dev libxml2<span class="operator">-</span>utils xsltproc unzip m4</span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install lib32z<span class="operator">-</span>dev ccache</span><br></pre></td></tr></table></figure>
<p>(其中几个命令中参数是重复的,但不妨碍我们)</p>
<h3 id="5-编译系统"><a href="#5-编译系统" class="headerlink" title="5.编译系统"></a>5.编译系统</h3><h4 id="5-1-初始化编译环境"><a href="#5-1-初始化编译环境" class="headerlink" title="5.1 初始化编译环境"></a>5.1 初始化编译环境</h4><p>在工作目录使用以下指令初始化编译环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure>
<p>执行命令之后：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-fc6c952a9e6c8711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化编译环境.png"></p>
<p>不难发现该命令只是引入了其他执行脚本,至于这些脚本做什么,目前不在本文中细说.该命令执行成功后,我们会得到了一些有用的命令,比如最下面要用到的lunch命令.</p>
<h4 id="5-2-选择编译目标"><a href="#5-2-选择编译目标" class="headerlink" title="5.2 选择编译目标"></a>5.2 选择编译目标</h4><p>使用lunch指令选择编译目标。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-70a723ef6c2eac71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择编译目标.png"></p>
<p>使用lunch指令之后会出现上图的结果，让我们选择要编译的目标系统。因为我希望编译车机的系统，我选择10，于是输入“10”，然后回车。会出现如下结果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e31f0eac9442899b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译车机系统.png"></p>
<h4 id="5-3-开始编译"><a href="#5-3-开始编译" class="headerlink" title="5.3 开始编译"></a>5.3 开始编译</h4><p>通过make指令进行代码编译,该指令通过<code>-j</code>参数来设置参与编译的线程数量,以提高编译速度.比如这里我们设置8个线程同时编译:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>需要注意的是,参与编译的线程并不是越多越好,通常是根据你机器cup的核心来确定:core*2,即当前cpu的核心的2倍.比如,我现在的笔记本是双核四线程的,因此根据公式,最快速的编译可以make -j8.<br> (通过<code>cat /proc/cpuinfo</code>查看相关cpu信息)</p>
<p><strong>注意：</strong>使用j8参数一定要注意，最好电脑配置要高，反正我笔记本使用j8开始报oom，然后直接卡死…..</p>
<p>建议直接使用make指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>


<p>如果一切顺利，出现：**<em>#### build completed successfully (06:43 (mm:ss)) ####**</em></p>
<p>那就恭喜你，编程完成了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-75ad995e983eac7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功.png"></p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h3><blockquote>
<p>XH分支</p>
<ul>
<li><p>repo环境配置：<br>mkdir /home/xxx/bin &amp;&amp; cp repo /home/xxx/bin<br>export PATH= /home/xxx/bin:$PATH</p>
</li>
<li><p>代码下载：<br>mkdir a55 &amp;&amp; cd a55<br>repo init -u ssh://xxx@10.5.20.68:29418/8155_a55/manifest.git -b master –repo-url=<a href="https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/">https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/</a><br>repo sync</p>
</li>
<li><p>代码编译<br>./build_target.sh msmnile_gvmq -a</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>编译Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide源码分析--生命周期管理</title>
    <url>/2021/02/23/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>声明：</strong>我目前分析的源码是最新的Glide源码：4.12.0版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.github.bumptech.glide:glide:4.12.0&#x27;</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.github.bumptech.glide:compiler:4.12.0&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-Glide简介"><a href="#1-Glide简介" class="headerlink" title="1. Glide简介"></a>1. Glide简介</h3><p>Glide是一个支持拉取，解码和展示视频快照，图片，和GIF动画的框架，正如它的名字翻译一样：滑翔。让用户加载任何形式的图片列表尽可能地变得更快、更平滑。</p>
<p>Glide 使用简明灵活的流式语法API，允许你在大部分情况下一行代码搞定需求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">     .load(url)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>
<p>默认情况下，Glide使用的是一个定制化的基于<code>HttpUrlConnection</code>的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</p>
<h3 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h3><p>Glide 充分考虑了Android图片加载性能的两个关键方面：</p>
<ul>
<li><p>图片解码速度</p>
</li>
<li><p>解码图片带来的资源压力</p>
</li>
</ul>
<p>为了让用户拥有良好的App使用体验，图片不仅要快速加载，而且还不能因为过多的主线程I/O或频繁的垃圾回收导致页面的闪烁和抖动现象。Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p>
<ul>
<li>自动、智能地下采样(<code>downsampling</code>)和缓存(<code>caching</code>)，以最小化存储开销和解码次数；</li>
<li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li>
<li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>
</ul>
<h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h3><p>关于<a href="https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html">Glide的详细使用介绍</a>，参见前面链接即可，但是分析源码也要有个开始吧，那我们就从最基本的用法入手，Glide最基本的用法就是三段论：with、load和into。那我们现在就先从with开始。</p>
<h4 id="3-1-生命周期的作用域（1-Application，-2-Activity，-3-Fragment）"><a href="#3-1-生命周期的作用域（1-Application，-2-Activity，-3-Fragment）" class="headerlink" title="3.1 生命周期的作用域（1.Application， 2.Activity， 3.Fragment）"></a>3.1 生命周期的作用域（1.Application， 2.Activity， 3.Fragment）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.Glide.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getRetriever(context)返回RequestManagerRetriever，下面的生命周期关联会用到</span></span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getContext()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Glide.with()静态方法中，我们可以看到方法可以传入5个参数：Context、Activity、FragmentActivity、Fragment或者View。按照作用域分，我们可以把它分成两类：Application类和非Application类。</p>
<ul>
<li>Application类：它的生命周期是全局的，没有空白Fragment就绑定Activity/Fragment。</li>
<li>非Application类，它的生命周期跟随Activity和Fragment的生命周期，专门有一个空白Fragment绑定Activity/Fragment。</li>
</ul>
<p>从上面with的重载方法看出都会调用到getRetriever()方法，他其实最终就是返回RequestManagerRetriever对象，紧接着，我们看看RequestManagerRetriever的get方法。这里先分两个来看：</p>
<ul>
<li>Activity、FragmentActivity、Fragment和View</li>
<li>Context</li>
</ul>
<h5 id="3-1-1-Activity类的get"><a href="#3-1-1-Activity类的get" class="headerlink" title="3.1.1 Activity类的get()"></a>3.1.1 Activity类的get()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">       <span class="comment">//如果不是UI线程，生命周期划分到Application</span></span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext()); </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">    <span class="keyword">return</span> get((FragmentActivity) activity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertNotDestroyed(activity);</span><br><span class="line">    frameWaiter.registerSelf(activity);</span><br><span class="line">    android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">    <span class="comment">// 不管是Activity、FragmentActivity、Fragment和View的get()，最终都会调用到fragmentGet()</span></span><br><span class="line">    <span class="keyword">return</span> fragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终with返回绑定了代理Fragemnt的RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个没有UI的空Fragment来监控用户自定义的Activity生命周期</span></span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//创建Glide实例</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      <span class="comment">//绑定Glide和空白的Fragemnt</span></span><br><span class="line">      <span class="comment">//注意！！:这里创建RequestManager的时候会传入Lifecycle,后面会根据这个lifecycle来透传fragment的生命周期给Glide</span></span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">        requestManager.onStart();</span><br><span class="line">      &#125;</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-1-2-Context类的get"><a href="#3-1-2-Context类的get" class="headerlink" title="3.1.2 Context类的get()"></a>3.1.2 Context类的get()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="comment">// 如果在UI线程，并且是3.1.1小节的组件，就调用Activity类的get()，返回绑定了空Fragment的requestManager</span></span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper</span><br><span class="line">        &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 作用域是Application返回的返回绑定了空Fragment的requestManager</span></span><br><span class="line">  <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class="line">    <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//生命周期和Application一致</span></span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                  <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-1-3-小结"><a href="#3-1-3-小结" class="headerlink" title="3.1.3 小结"></a>3.1.3 小结</h5><p>Glide的with()生命周期总结如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c39dde94e49da200.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作用域总结.png"></p>
<ul>
<li>子线程中Glide调用get()、传入ApplicationContext和ServiceContext，对应的生命周期属于Application域，生命周期和Application一致</li>
<li>Activity、Fragment和View对应的生命周期是被代理Fragemnt监控的，Glide内部逻辑会根据Activity的生命周期做相应调整</li>
</ul>
<h4 id="3-2-Glide生命周期感知过程"><a href="#3-2-Glide生命周期感知过程" class="headerlink" title="3.2 Glide生命周期感知过程"></a>3.2 Glide生命周期感知过程</h4><p>如3.1.1小节中分析的，不管with传入的是fragment、Activity还是View，RequestManagerRetriever都会创建一个没有UI的Fragment(SupportRequestManagerFragment)来当代理,当用户自定义的Activity或者Fragment生命周期发生变化的时候，Glide内部可以通过代理Fragment知道生命周期发生的变化，因此内部也做相应的处理。例如下载并且加载是一个比较耗时操作，如果下载完成之后，Activity已经被销毁了，那就不用加载了，所有这就是Glide感知组件生命周期的意义，用户不用主动调用clear()方法来释放资源了。关联关系如下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-20b9b7768530ab59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期与组件关联.png"></p>
<h4 id="3-3-Glide与空Fragment绑定过程"><a href="#3-3-Glide与空Fragment绑定过程" class="headerlink" title="3.3 Glide与空Fragment绑定过程"></a>3.3 Glide与空Fragment绑定过程</h4><p>从3.1.3小结中可以知道，只有在<strong>主线程</strong>中调用with()并且传入Activity或者Fragment会绑定空Fragment。当传入的activity，这个activity上覆盖的空Fragment是RequestManagerFragment；当传入的是fragment，覆盖在上面的空fragment是SupportRequestManagerFragment。逻辑都是一样的，下面以传入fragment来分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Pending adds for SupportRequestManagerFragments. </span></span><br><span class="line"><span class="comment">* 空Fragment(SupportRequestManagerFragment)与FragmentManager的映射关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">final</span> Map&lt;FragmentManager, SupportRequestManagerFragment&gt; pendingSupportRequestManagerFragments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从三个地方去拿空Fragment，紧接着会分析</span></span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class="line">    <span class="comment">// 从空Fragment中拿到requestManager</span></span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 实例化glide用于在创建requestManager的时候绑定glide</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      <span class="comment">// 创建requestManager并且绑定glide</span></span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      <span class="comment">//如果父fragment可见，就通知glide的onStart()</span></span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">        requestManager.onStart();</span><br><span class="line">      &#125;</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> <span class="keyword">final</span> FragmentManager fm, <span class="meta">@Nullable</span> Fragment parentHint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个地方:先从FragmentManager中去拿</span></span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 第二个地方:从内存中去拿</span></span><br><span class="line">      current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//以上两个地方都没有,就创建一个空Fragment然后返回</span></span><br><span class="line">        current = <span class="keyword">new</span> SupportRequestManagerFragment();</span><br><span class="line">        current.setParentFragmentHint(parentHint);</span><br><span class="line">        <span class="comment">//记录映射关系在内存中，临时存的</span></span><br><span class="line">        pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">        <span class="comment">//提交Fragment事务</span></span><br><span class="line">        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">        <span class="comment">//如果提交成功之后就删除临时存的映射关系</span></span><br><span class="line">        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从supportFragmentGet()方法中我们看到了Glide内部逻辑和空Fragment的绑定过程。</p>
<p>不知道大家有没有疑惑：<strong>为什么在getSupportRequestManagerFragment()方法中要在pendingSupportRequestManagerFragments中临时保存空Fragment？</strong></p>
<p>其实就是为了<strong>避免 SupportRequestManagerFragment 在一个作用域中重复创建。</strong><br>因为commitAllowingStateLoss() 是将事务 post 到消息队列中的，也就是说，事务是异步处理的，而不是同步处理的。假设没有临时保存记录，一旦在事务异步等待执行时调用了Glide.with(…) ，就会在该作用域中重复创建 Fragment。</p>
<h4 id="3-4-生命周期的详细监听过程"><a href="#3-4-生命周期的详细监听过程" class="headerlink" title="3.4 生命周期的详细监听过程"></a>3.4 生命周期的详细监听过程</h4><p>从上面小节分析可以看出，生命周期的管理，主要对Activity、Fragment和View(实质也是Activity或Fragment)有效，其他的都是Application域，没必须分析。所以后面的分析都是基于Activity或者Fragment的生命周期，而这两个逻辑都是一样的，我们还是以Fragment的分析为例。</p>
<p>从前面看出，每个Activity或者Fragment域都会创建一个空Fragment盖在上面。下来我们就从这个空Fragment开始分析Glide的生命周期是如何受影响的。Fragment盖的空Fragment是SupportRequestManagerFragment.java，那我们就从这里开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportRequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ActivityFragmentLifecycle lifecycle;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> ActivityFragmentLifecycle());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="meta">@SuppressLint(&quot;ValidFragment&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">(<span class="meta">@NonNull</span> ActivityFragmentLifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    lifecycle.onStart();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function">ActivityFragmentLifecycle <span class="title">getGlideLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">  ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从3.1.1小节可以看到，创建RequestManager时是通过工厂创建的，那我们在看看这个工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RequestManagerRetriever.java中</span></span><br><span class="line"><span class="comment">//创建Glide实例</span></span><br><span class="line">Glide glide = Glide.get(context);</span><br><span class="line">requestManager =factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//factory接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestManagerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">RequestManager <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Glide glide,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> RequestManagerTreeNode requestManagerTreeNode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Context context)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的RequestManager工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestManagerFactory DEFAULT_FACTORY =</span><br><span class="line">    <span class="keyword">new</span> RequestManagerFactory() &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Glide glide,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> RequestManagerTreeNode requestManagerTreeNode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestManager(glide, lifecycle, requestManagerTreeNode, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>RequestManager工厂在创建RequestManager的时候，传入了glide和lifecycle，在RequestManager中完成绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span>, <span class="title">LifecycleListener</span>,...</span>&#123;</span><br><span class="line">    </span><br><span class="line">    RequestManager(</span><br><span class="line">        Glide glide,</span><br><span class="line">        Lifecycle lifecycle,</span><br><span class="line">        RequestManagerTreeNode treeNode,</span><br><span class="line">        RequestTracker requestTracker,</span><br><span class="line">        ConnectivityMonitorFactory factory,</span><br><span class="line">        Context context) &#123;</span><br><span class="line">      <span class="keyword">this</span>.glide = glide;</span><br><span class="line">      <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">      <span class="keyword">this</span>.treeNode = treeNode;</span><br><span class="line">      <span class="keyword">this</span>.requestTracker = requestTracker;</span><br><span class="line">      <span class="keyword">this</span>.context = context;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        Util.postOnUiThread(addSelfToLifecycle);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//lifecycle的生命周期回调加入到RequestManager中</span></span><br><span class="line">        lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        resumeRequests();</span><br><span class="line">        <span class="comment">// targetTracker维持着Traker列表,每个Traker属于Glide内部需要监听生命周期的逻辑</span></span><br><span class="line">        targetTracker.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseRequests();</span><br><span class="line">        targetTracker.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，生命周期的详细监听过程就通了。</p>
<p><strong>总结：</strong>调用with()创建RequestManager，创建RequestManager传入Lifecycle对象(这个对象是在无界面 Fragment 中创建的)，RequestManager通过Lifecycle通知Glide内部的各个业务Traker。</p>
<p>当 Fragment 的生命周期变化时，无界面 Fragment会感知到生命周期变化，然后通过Lifecycle 对象将事件分发到 RequestManager，RequestManager的onStart()将事件分发给targetTracker，targetTracker分发给Glide内部逻辑。</p>
<p><strong>参考文档：</strong></p>
<p><a href="https://muyangmin.github.io/glide-docs-cn/">1.Glide简介</a></p>
<p><a href="https://blog.csdn.net/guolin_blog/article/details/53939176">2.郭霖关于Glide的源码分析</a></p>
]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>-Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>基于源码从零开始编译第一个app</title>
    <url>/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="%5Bhttp://jackou.top/2021/02/10/%E5%BE%92%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81-%E6%89%8B%E6%8A%8A%E6%89%8B%EF%BC%8C%E5%98%B4%E5%AF%B9%E5%98%B4%E7%89%88%E6%9C%AC/%5D(http://jackou.top/2021/02/10/%E5%BE%92%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81-%E6%89%8B%E6%8A%8A%E6%89%8B%EF%BC%8C%E5%98%B4%E5%AF%B9%E5%98%B4%E7%89%88%E6%9C%AC/)">《Android源码编译》</a>中我详细叙述了有了源码之后，如何把原生的代码编译成功的过程。现在有了原生的系统镜像之后，我们是不是也应该编一个app在系统中运行呀，好，那就开始吧，一切从HelloWorld开始。</p>
<h3 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1.创建工程"></a>1.创建工程</h3><h4 id="1-1-搭建最小工程模块"><a href="#1-1-搭建最小工程模块" class="headerlink" title="1.1 搭建最小工程模块"></a>1.1 搭建最小工程模块</h4><p>还记得以前学习单片机的时候，都是从最小系统搭起，那么我们创建工程，最小的工程目录会包含哪些东西呢。见下图，至少包含：</p>
<ul>
<li>AndroidManifest.xml配置文件</li>
<li>Android.mk 编译脚本文件</li>
<li>res目录    用于放资源文件</li>
<li>src目录    用于放源码文件</li>
</ul>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\最小代码模块.png" alt="最小代码模块"></p>
<h4 id="1-2-编写代码"><a href="#1-2-编写代码" class="headerlink" title="1.2 编写代码"></a>1.2 编写代码</h4><p>这个是我在AS中自动生成的工程，代码及其简单。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//AndroidManifest.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.android.helloworld&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//activity_main.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Hello World!&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.android.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\工程目录树.png" alt="工程目录树"></p>
<h4 id="1-3-编写mk文件"><a href="#1-3-编写mk文件" class="headerlink" title="1.3 编写mk文件"></a>1.3 编写mk文件</h4><p>下面介绍部分常用的配置用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义模块标签，build系统根据标签决定哪些模块需要安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash">user:  指该模块只在user版本下才编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">eng:  指该模块只在eng版本下才编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tests: 指该模块只在tests版本下才编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">optional:指该模块在所有版本下都编译</span></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> $(call all-java-files-under, &lt;src&gt;)：获取指定目录下的所有java文件。</span></span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用指定目录下的manifest文件（如果不与mk文件在同一目录的话必须定义）</span></span><br><span class="line">LOCAL_MANIFEST_FILE := src/main/AndroidManifest.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">资源文件目录，可选定义，不定义也没问题</span></span><br><span class="line">LOCAL_RESOURCE_DIRS := $(LOCAL_PATH)/src/main/res</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">模块名称，apk一般使用LOCAL_PACKAGE_NAME，其它使用LOCAL_MODULE</span></span><br><span class="line">LOCAL_PACKAGE_NAME := helloworld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果导入第三方jar包才使用这句</span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义引用别名   xxxxx为jar包的别名，可以随便取，只要与下面相对应就行</span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := xxxxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">签署当前应用的证书名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用于指定签名时使用的KEY，如果不指定，默认使用testkey，LOCAL_CERTIFICATE可设置的值如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  LOCAL_CERTIFICATE:= platform</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  LOCAL_CERTIFICATE:= shared</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  LOCAL_CERTIFICATE:= media</span></span><br><span class="line"><span class="meta">#</span><span class="bash">而在Android.mk中的这些配置，需要在APK源码的AndroidManifest.xml文件中的manifest节点添加如下内容：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  android:sharedUserId=<span class="string">&quot;android.uid.system&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  android:sharedUserId=<span class="string">&quot;android.uid.shared&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  android:sharedUserId=<span class="string">&quot;android.media&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">这些刚好与上面的mk文件里的配置对应上。</span></span><br><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以声明app需要放在/system/priv-app下</span></span><br><span class="line">LOCAL_PRIVILEGED_MODULE := true</span><br><span class="line"></span><br><span class="line">LOCAL_SDK_VERSION := current</span><br><span class="line"></span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果jar包放在libs目录下，且libs与Android.mk文件是同级目录，则jar包路径如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##############################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := xxxxx:libs/3part.jar       // 引用名：jar包名路径</span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br></pre></td></tr></table></figure>
<p>我编helloword工程用到的脚本如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"></span><br><span class="line">LOCAL_PACKAGE_NAME := HelloWorld</span><br><span class="line">LOCAL_SDK_VERSION := current</span><br><span class="line"></span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use the following include to make our <span class="built_in">test</span> apk.</span></span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>


<h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h3><p>使用如下指令初始化指令环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure>


<p>然后使用mm或者mmm来编译即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">- croot: Changes directory to the top of the tree.</span><br><span class="line">- m: Makes <span class="keyword">from</span> the top of the tree.</span><br><span class="line">- mm: Builds all of the modules <span class="keyword">in</span> the current directory.</span><br><span class="line">- mmm: Builds all of the modules <span class="keyword">in</span> the supplied directories.</span><br><span class="line">- cgrep: Greps <span class="keyword">on</span> all local C/C++ files.</span><br><span class="line">- jgrep: Greps <span class="keyword">on</span> all local Java files.</span><br><span class="line">- resgrep: Greps <span class="keyword">on</span> all local res<span class="comment">/*.xml files.</span></span><br><span class="line"><span class="comment">- godir: Go to the directory containing a file.</span></span><br></pre></td></tr></table></figure>
<p>mm是编译当前目录下的所有模块<br>mmm是编译指定目录的所有模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//编译Launcher2模块</span><br><span class="line">mmm packages/apps/Launcher2/</span><br><span class="line"></span><br><span class="line">//编译当前目录下的模块</span><br><span class="line">jackou@ubuntu:~/work_directory/pdk/apps/HelloWorld$ mm</span><br></pre></td></tr></table></figure>


<p>因为我就在工程目录，就直接使用mm即可，可以看到提示了很多配置信息，其中最后一个OUT_DIR就是编译完成的app会放在out目录下。</p>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\mm.png" alt="mm"></p>
<h4 id="3-编译成功"><a href="#3-编译成功" class="headerlink" title="3.编译成功"></a>3.编译成功</h4><p>我们可以看到最后一行编程成功，然后apk放在out/target/product…c/system/app/HelloWorld目录下。</p>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\编译完成.png" alt="编译完成"></p>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\apk.png" alt="apk"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>编译Android源码</tag>
        <tag>编译apk</tag>
      </tags>
  </entry>
  <entry>
    <title>源码编译引入第三方库</title>
    <url>/2021/03/05/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<h3 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h3><p>在Android工程开发中难免会有引入第三方库的需求，例如GSON，Okhttp，Glide等等，但是在源码中用makefile编译如何让编译器知道你引入的库呢？下面我举一个例子来说明</p>
<ul>
<li>例如我们工程需要引入GSON库，没引入的时候编译报错如下图。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6290edf6a973d4a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译报错.png"></p>
<ul>
<li>引入库制定编译规则<br><img src="https://upload-images.jianshu.io/upload_images/13838098-49354c71db02cb34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖库问题.png"></li>
</ul>
<h3 id="2-寻找原因"><a href="#2-寻找原因" class="headerlink" title="2. 寻找原因"></a>2. 寻找原因</h3><p>原因的话编译器已经报出来了，就是找不到对应的类，也就是找不到对应的库文件。</p>
<h3 id="3-解决办法-引入第三方库方法"><a href="#3-解决办法-引入第三方库方法" class="headerlink" title="3. 解决办法(引入第三方库方法)"></a>3. 解决办法(引入第三方库方法)</h3><p>在解决问题之前首先介绍一下这两个编译参数：<strong>BUILD_JAVA_LIBRARY 与 BUILD_STATIC_JAVA_LIBRARY</strong></p>
<p>​    在Android.mk中可通过调用include $(BUILD_JAVA_LIBRARY)和include $(BUILD_STATIC_JAVA_LIBRARY)来分别生成目标设备上的共享JAVA库与静态JAVA库。</p>
<p>​    二者的区别在于<strong>静态JAVA库是由.class文件打包而成JAR包，它在任何一个JAVA虚拟机上都可以运行</strong>；而<strong>共享JAVA库则是在静态库的基础上进一步打包成的.dex文件</strong>，众所周知，dex是在android系统上所使用的文件格式。</p>
<p>​    由以上结论可做出进一步的推论：即Android.mk中变量LOCAL_JAVA_LIBRARIES所指定的为android系统使用的dex类库；而LOCAL_STATIC_JAVA_LIBRARIES变量所指定的则是.class文件打包而成的JAR文件：即静态JAVA库。</p>
<p>​    <strong>BUILD_STATIC_JAVA_LIBRARY</strong>会生成out/target/common/obj/JAVA_LIBRARIES/lib名_intermediates目录及其下的JAR文件；而<strong>BUILD_JAVA_LIBRARY</strong>生成此目录的同时会将其中的JAR包复制到out/target/product/<product-name>/system/framework/中；除此之外，还存在<strong>BUILD_HOST_JAVA_LIBRARY</strong>命令则是在out/host/linux-x86/framework目录下生成相应的JAR包。分别使用此三条命令执行的结果如下所示：注意其中带有红色下划线的LOG信息。</product-name></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译第三方库基本用法</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在Android.mk目录下建立libs,然后将jar包放入libs，先预编译到out/target/product/generic/obj/JAVA_LIBRARIES下，然后本项目就会找到依赖的者jar包了</span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := gson:libs/gson-2.8.2.jar</span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################以下是顺带的说明########################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################完整的mk文件###########################</span></span></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_PACKAGE_NAME := Permission</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">LOCAL_SDK_VERSION 和LOCAL_PRIVATE_PLATFORM_APIS在Android.mk中必须用一个</span></span><br><span class="line"><span class="meta">#</span><span class="bash">LOCAL_SDK_VERSION := current  意思是编译时忽略系统隐藏类(@hide)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">LOCAL_PRIVATE_PLATFORM_APIS := <span class="literal">true</span> 表示可以应用系统的API(@hide或者@SystemApi)</span></span><br><span class="line">LOCAL_PRIVATE_PLATFORM_APIS := true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭混淆优化器，没有这个配置，会报:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">there were 194 unresolved references to program class members.Your input classes appear to be inconsistent.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">there were 2494 unresolved references to library class members. You probably need to update the library versions. Alternatively, you may have to specify the option</span> </span><br><span class="line">LOCAL_PROGUARD_ENABLED := disabled</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"><span class="meta">#</span><span class="bash">编译aidl文件</span></span><br><span class="line">LOCAL_SRC_FILES += $(call all-Iaidl-files-under,src/com/xh/permission) \</span><br><span class="line">                    src/com/xh/permission/ICarPermissionManager.aidl</span><br><span class="line"></span><br><span class="line">LOCAL_AIDL_INCLUDES := $(LOCAL_PATH)/src/com/xh/permission</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">应用第三方库</span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := gson \</span><br><span class="line">	android-support-v7-appcompat \</span><br><span class="line">	xhframework</span><br><span class="line"></span><br><span class="line">LOCAL_STATIC_ANDROID_LIBRARIES := android-support-annotations</span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############我是分割线#####################</span></span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := gson</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := gson:libs/gson-2.8.2.jar</span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br></pre></td></tr></table></figure>


<h3 id="4-扩展点"><a href="#4-扩展点" class="headerlink" title="4.扩展点"></a>4.扩展点</h3><p>如果在Android FrameWork集成第三方SDK的jar包和so库，首先在framework/opt/建立XXXSDK的文件夹讲jar包和so库拷贝进去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-685d49a988fde6a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="framework依赖库编译.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################### mk文件如下 ################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copyright (C) 2009 The Android Open Source Project</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you may not use this file except <span class="keyword">in</span> compliance with the License.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You may obtain a copy of the License at</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#      http://www.apache.org/licenses/LICENSE-2.0</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See the License <span class="keyword">for</span> the specific language governing permissions and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> limitations under the License.</span></span><br><span class="line"> </span><br><span class="line">LOCAL_PATH := $(my-dir)</span><br><span class="line"> </span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"> </span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := okhttp-3.12.0.jar \</span><br><span class="line">                                        rxjava-2.1.12.jar \</span><br><span class="line">                                        sqlite.jar</span><br><span class="line"> </span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlife</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlife.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlifeserver</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlifeserver.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlifeservicejni</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlifeservicejni.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlifevehicle</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlifevehicle.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>调用Android原生@SystemApi、@Hide方法和解决混淆问题</title>
    <url>/2021/03/08/%E8%B0%83%E7%94%A8Android%E5%8E%9F%E7%94%9F-SystemApi%E5%92%8C-Hide%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-关于-SystemApi和-Hide方法"><a href="#1-关于-SystemApi和-Hide方法" class="headerlink" title="1.关于@SystemApi和@Hide方法"></a>1.关于@SystemApi和@Hide方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-9e5be0ee94f529c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统api.png"></p>
<p>如上图所示，PackageManager.getPermissionFlags()方法是被@SystemApi注解修饰过的方法，@SystemApi 只允许system app 调用或者用反射方法调用, 反射方法实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.mPackageManager = context.getPackageManager();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = mPackageManager.getClass(). getMethod(<span class="string">&quot;getPermissionFlags&quot;</span>);</span><br><span class="line">    method.invoke(mPackageManager, permName, packageName, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是非 system app 用反射方法调用SystemApi，即使编译通过， 实际运行是还会遇到permission check。例如getPermissionFlags就需要GRANT_RUNTIME_PERMISSIONS，REVOKE_RUNTIME_PERMISSIONS，GET_RUNTIME_PERMISSIONS中的任意一个，如果应用没有申请这其中的任意一个权限，运行是也会报错。申请了以上三个中任意一个权限，就需要有系统签名。归根究底，要调用系统API就必须要系统签名，否则即使编译成功了，运行时也会报错。</p>
<h3 id="2-源码编译模块"><a href="#2-源码编译模块" class="headerlink" title="2.源码编译模块"></a>2.源码编译模块</h3><p>在使用mk文件编译的时候，会有<strong>LOCAL_PRIVATE_PLATFORM_APIS</strong>和<strong>LOCAL_SDK_VERSION</strong>参数选择，在mk文件中声明这两个参数的时候是互斥的，意思是只能<strong>声明其中一个</strong>。</p>
<ul>
<li><strong>LOCAL_PRIVATE_PLATFORM_APIS</strong>设置之后，如果模块中有用到系统api，会使用sdk的hide的api来编译。</li>
<li><strong>LOCAL_SDK_VERSION</strong>设置之后，编译的应用不能访问hide的api，会报找不到该方法错误。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//报错内容</span></span><br><span class="line">pdk/apps/Permission/src/com/xh/permission/server/CarPermissionManagerService.java:<span class="number">269</span>: error: cannot find symbol</span><br><span class="line">     <span class="keyword">int</span> flags = <span class="keyword">this</span>.mPackageManager.getPermissionFlags(permissionInfo.name, packageInfo.packageName, Process.myUserHandle());</span><br><span class="line">                         ^</span><br><span class="line">  	symbol:   <span class="function">method <span class="title">getPermissionFlags</span><span class="params">(String,String,UserHandle)</span></span></span><br><span class="line"><span class="function"> 	location: variable mPackageManager of type PackageManager</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5f51673cf8003d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译找不到方法.png"></p>
<h3 id="3-调用原生api总结"><a href="#3-调用原生api总结" class="headerlink" title="3.调用原生api总结"></a>3.调用原生api总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以调用系统的api，但是需要给apk系统签名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LOCAL_CERTIFICATE := platform</span></span><br><span class="line">LOCAL_PRIVATE_PLATFORM_APIS := true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译时忽略系统隐藏类(@hide)</span></span><br><span class="line">LOCAL_SDK_VERSION := current</span><br></pre></td></tr></table></figure>


<h3 id="4-编译混淆问题"><a href="#4-编译混淆问题" class="headerlink" title="4.编译混淆问题"></a>4.编译混淆问题</h3><p>在编译过程中如果遇到如下图编译报错，或者如下提示：</p>
<blockquote>
<ol>
<li>If there are unresolved references to class members in <em>program classes</em>, your compiled class files are most likely inconsistent. Possibly, some class file didn’t get recompiled properly, or some class file was left behind after its source file was removed. Try removing all compiled class files and rebuilding your project.</li>
<li>If there are unresolved references to class members in <em>library classes</em>, your compiled class files are inconsistent with the libraries. You may need to recompile the class files, or otherwise upgrade the libraries to consistent versions.</li>
</ol>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-16e869614f36b453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未配置混淆文件报错.png"></p>
<p>就可以归纳为<a href="https://www.guardsquare.com/en/products/proguard/manual/troubleshooting#unresolvedprogramclassmember">代码混淆配置问题</a>。</p>
<h3 id="5-解决办法"><a href="#5-解决办法" class="headerlink" title="5.解决办法"></a>5.解决办法</h3><p>源码编译时会用ProGuard混淆器做代码混淆、优化，过程中可能会删除掉个别类里的个别方法。</p>
<p>处理代码混淆问题有两个方法：</p>
<ul>
<li>在mk文件里加上一句：LOCAL_PROGUARD_ENABLED := disabled，禁用混淆器。</li>
<li>在mk文件里加上一句：LOCAL_PROGUARD_FLAG_FILES := proguard.flags，然后创建一个配置文件”proguard.flags”，配置部分类/方法/属性禁止混淆。(可以参照源码环境下的Settings里写法) </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################以下是原生设置的混淆文件#######################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##########还有很多其他规则，这里不详细列举，度娘一下，你就知道##########</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a configuration file <span class="keyword">for</span> ProGuard.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://proguard.sourceforge.net/index.html<span class="comment">#manual/usage.html</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep all Fragments <span class="keyword">in</span> this package, <span class="built_in">which</span> are used by reflection.</span></span><br><span class="line">-keep public class com.android.settings.** extends android.app.Fragment</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep all preference controllers needed by slice and DashboardFragment.</span></span><br><span class="line">-keep class * extends com.android.settings.core.BasePreferenceController &#123;</span><br><span class="line">    *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keep class * extends com.android.settings.core.TogglePreferenceController &#123;</span><br><span class="line">    *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> We want to keep methods <span class="keyword">in</span> Activity that could be used <span class="keyword">in</span> the XML attribute onClick.</span></span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">    public void *(android.view.View);</span><br><span class="line">    public void *(android.view.MenuItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep setters <span class="keyword">in</span> Views so that animations can still work.</span></span><br><span class="line">-keep public class * extends android.view.View &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class="line"></span><br><span class="line">    void set*(***);</span><br><span class="line">    *** get*();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep classes that may be inflated from XML.</span></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">&#125;</span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class="line">&#125;</span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int, int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep annotated classes or class members.</span></span><br><span class="line">-keep @android.support.annotation.Keep class *</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep specific fields used via reflection.</span></span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    public static ** SEARCH_INDEX_DATA_PROVIDER;</span><br><span class="line">    public static ** SUMMARY_PROVIDER_FACTORY;</span><br><span class="line">&#125;</span><br><span class="line">-keep class android.support.v4.app.CoreComponentFactory</span><br></pre></td></tr></table></figure>
<h3 id="6-编译成功"><a href="#6-编译成功" class="headerlink" title="6.编译成功"></a>6.编译成功</h3><p>最后模块编译成功之后会提示如下结果</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-accf096c4234d491.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模块编译成功.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>反编译经验总结</title>
    <url>/2021/03/10/%E5%8F%8D%E7%BC%96%E8%AF%91%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1. 内部类"></a>1. 内部类</h3><p>内部类反编出来会出现如下结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2c24402723b9cf7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内部类反编结果.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点开任意一个可以看出是实现的Runnable方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> -$$<span class="title">Lambda</span>$<span class="title">ExtNetworkTracker</span>$<span class="title">InterfaceObserver</span>$6<span class="title">h5H0nN5nrJkfCZwlwJqwAaVTc0</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用的外部类的方法</span></span><br><span class="line">        InterfaceObserver.lambda$interfaceRemoved$<span class="number">1</span>(<span class="keyword">this</span>.f$<span class="number">0</span>, <span class="keyword">this</span>.f$<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-给外部类参数赋值"><a href="#2-给外部类参数赋值" class="headerlink" title="2. 给外部类参数赋值"></a>2. 给外部类参数赋值</h3><p>如果在反编译文件中出现access$xxx等标识，基本都是对外部类变量赋值，找到外部类对应变量进行复制即可即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-72522781ae636664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="给外部类参数赋值.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上两句话，相当于下面两句话，mLinkStateIfaceName，mNetworkLinkState是外部类的两个变量</span></span><br><span class="line">mLinkStateIfaceName = ifaceName;</span><br><span class="line">mNetworkLinkState = state;</span><br></pre></td></tr></table></figure>


<h3 id="3-Log日志"><a href="#3-Log日志" class="headerlink" title="3. Log日志"></a>3. Log日志</h3><p>日常中打的log，在反编译之后，会使用StringBuilder来包装一句log日志。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-03304d8ed8468733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="log日志.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上语音相当于一下语句</span></span><br><span class="line">Log.d(TAG, <span class="string">&quot;interfaceLinkStateChanged:&quot;</span> + ifaceName + <span class="string">&quot; up: &quot;</span> + state);</span><br></pre></td></tr></table></figure>


<h4 id="4-for循环的解析"><a href="#4-for循环的解析" class="headerlink" title="4.for循环的解析"></a>4.for循环的解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果遇到for (;;)，其实就while循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    bool1 = bool2;</span><br><span class="line">    <span class="comment">//重试三次计数</span></span><br><span class="line">    <span class="keyword">if</span> ((i &gt;= <span class="number">3</span>) || (paramBoolean)) &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//实际逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception localException)&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.printStackTrace();</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析代码</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实际逻辑</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-同步代码块"><a href="#5-同步代码块" class="headerlink" title="5.同步代码块"></a>5.同步代码块</h3><h4 id="5-1-类锁"><a href="#5-1-类锁" class="headerlink" title="5.1 类锁"></a>5.1 类锁</h4><p>如果遇到try-finally组合，且finally是空的，考虑是synchronized代码同步块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInterface</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实际逻辑代码</span></span><br><span class="line">        Object localObject = TAG;</span><br><span class="line">        StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;updateInterface(iface:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramString);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;, status:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramBoolean);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        Log.d((String)localObject, localStringBuilder.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInterface</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//实际逻辑代码</span></span><br><span class="line">        Object localObject = TAG;</span><br><span class="line">        StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;updateInterface(iface:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramString);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;, status:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramBoolean);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        Log.d((String)localObject, localStringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-2-对象锁"><a href="#5-2-对象锁" class="headerlink" title="5.2 对象锁"></a>5.2 对象锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个还是很容易看出是对象锁的，我之前有一处很难发现的代码没找到了，下次找到更新在这里，此处预留</span></span><br><span class="line"><span class="keyword">synchronized</span> (CarlibTimeoutUtil.<span class="keyword">this</span>.mLock)&#123;</span><br><span class="line">	<span class="comment">//真实逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-编译器对象擦除机制"><a href="#6-编译器对象擦除机制" class="headerlink" title="6.编译器对象擦除机制"></a>6.编译器对象擦除机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随意丢一个方法过来，分析java编译中对象擦除机制。为了方便好看，下面实例代码中使用“方法”来代替实际的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInterface</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object localObject = TAG;</span><br><span class="line">        StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;updateInterface(iface:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramString);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;, status:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramBoolean);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        Log.d((String) localObject, localStringBuilder.toString());</span><br><span class="line">        localObject = (ExtNetworkSet) <span class="keyword">this</span>.mExtNetworkSets.方法;</span><br><span class="line">        <span class="keyword">if</span> (localObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            localObject = TAG;</span><br><span class="line">            localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            localStringBuilder.append(<span class="string">&quot;ExtNetworkSet of &quot;</span>);</span><br><span class="line">            localStringBuilder.append(paramString);</span><br><span class="line">            localStringBuilder.append(<span class="string">&quot; not found&quot;</span>);</span><br><span class="line">            Log.e((String) localObject, localStringBuilder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ((ExtNetworkSet) localObject).mNetworkFactory.方法;</span><br><span class="line">        (((ExtNetworkSet) localObject).mIpConfig.方法;</span><br><span class="line">        ((ExtNetworkSet) localObject).mNetworkFactory.方法;</span><br><span class="line">        ((ExtNetworkSet) localObject).mNetworkFactory.方法;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到localObject这个对象从方法进入到方法结束都一直使用的这个变量。这就是java在编译之后进行对象擦拭机制。进入方法之后，<strong>编译器会把所有对象擦拭成Object对象，然后在适合的位置强转成真实的对象。</strong></p>
<p>例如：在方法进入，编译器先创建了一个Object对象，接收TAG参数，在Log.d方法中将它转化成String对象；<br>然后接收从mExtNetworkSets集合中获得的ExtNetworkSet对象，在方法最后强转成ExtNetworkSet对象来使用它。</p>
<h3 id="7-关于资源文件的解析"><a href="#7-关于资源文件的解析" class="headerlink" title="7.关于资源文件的解析"></a>7.关于资源文件的解析</h3><p>在代码中有关于资源文件的应用如下<br><img src="https://upload-images.jianshu.io/upload_images/13838098-b85f9b90af8d7ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源文件解析.png"></p>
<p><strong>解析方法：</strong></p>
<ul>
<li>首先将十进制“2130837504”转化成十六进制为“0x7f020000”</li>
<li>将apk文件直接拖入Android Studio，找到resources.arsc索引文件，然后根据要查看的内容类型找到具体的内容。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f80225779b402afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应资源内容.png"></p>
<h3 id="8-超高难度解析–内部类调用外部类方法"><a href="#8-超高难度解析–内部类调用外部类方法" class="headerlink" title="8.超高难度解析–内部类调用外部类方法"></a>8.超高难度解析–内部类调用外部类方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-39939aedd0fb6c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内部类超高难度理解.png"></p>
<p>该文件是内部类中的一个实现，实现了Runnable接口。</p>
<p>然后看InterfaceObserver.lambda$interfaceRemoved$1(this.f$0, this.f$1);  这个是interfaceRemoved接口方法中会调用$1(this.f$0, this.f$1)方法。</p>
<p>以上方法的破解有两个方案：</p>
<ul>
<li>一般是内部的实现方法，根据接口的名字interfaceRemoved猜测外部类private的哪个方法比较靠近这个实现，然后用这个方法去试逻辑是否吻合</li>
<li>用排除法，先将其他方法都处理完成之后，看那几个方法没有被调用过，然后结合传入参数，实现内容就可以初步断定调用哪个方法。最后在编译出来上机验证是否符合猜测。</li>
</ul>
<h3 id="9-超高难度解析–解析协议"><a href="#9-超高难度解析–解析协议" class="headerlink" title="9.超高难度解析–解析协议"></a>9.超高难度解析–解析协议</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-692eb6a358d72a0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协议解析.png"></p>
<p>如果遇到以上这种情况，反编译代码中会有奇形怪状的数字(hash值)，这个情况一般是编译器为了找到运行时的对象，算了一个hash值，所以我们不必关心这个hash值，我们就看判断的内容即可。</p>
<p>根据截图以上的代码上下文，可以判断localObject2是协议的key值，localObject3是协议的value值，然后判断key值是否与对应的key值相等，然后处理对应的value值。</p>
<p>根据上面分析，解析结果可以判断为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String key = pair[<span class="number">0</span>];</span><br><span class="line">String value = pair[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ip&quot;</span>:</span><br><span class="line">        ipConfig.ipAddress = <span class="keyword">new</span> LinkAddress(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;domains&quot;</span>:</span><br><span class="line">        ipConfig.domains = value;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;gateway&quot;</span>:</span><br><span class="line">        ipConfig.gateway = InetAddress.parseNumericAddress(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;dns&quot;</span>: &#123;</span><br><span class="line">        ArrayList&lt;InetAddress&gt; dnsAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address : value.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            dnsAddresses.add(InetAddress.parseNumericAddress(address));</span><br><span class="line">        &#125;</span><br><span class="line">        ipConfig.dnsServers.addAll(dnsAddresses);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected key: &quot;</span> + key</span><br><span class="line">                + <span class="string">&quot; in &quot;</span> + configs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>生成签名文件和签名应用</title>
    <url>/2021/03/11/%E7%94%9F%E6%88%90%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%E5%92%8C%E7%AD%BE%E5%90%8D%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-签名文件简介"><a href="#1-签名文件简介" class="headerlink" title="1.签名文件简介"></a>1.签名文件简介</h3><p><a href="https://android.googlesource.com/platform/build/+/donut-release/target/product/security">签名文件说明出处</a>，标准的测试秘钥包含四个部分：testkey、platform、shared和media。</p>
<blockquote>
<p>The following standard test keys are currently included:</p>
<p>testkey – a generic key for packages that do not otherwise specify a key.<br>platform – a test key for packages that are part of the core platform.<br>shared – a test key for things that are shared in the home/contacts process.<br>media – a test key for packages that are part of the media/download system.</p>
</blockquote>
<ul>
<li>testkey是没有指定特定秘钥的通用秘钥，可以用于开发阶段的普通apk签名(没有签名系统可能会在安装的时候就报错，不让安装)</li>
<li>platform主要用于平台app做签名，例如某个平台app需要访问到@SystemApi或者@hide注解的方法，就需要使用platform文件来签名应用。</li>
<li>shared 用于一些要共享数据应用数据的应用签名</li>
<li>media 用于媒体和系统下载应用签名</li>
</ul>
<h3 id="2-签名文件的生成"><a href="#2-签名文件的生成" class="headerlink" title="2.签名文件的生成"></a>2.签名文件的生成</h3><h4 id="2-1命令行生成方式"><a href="#2-1命令行生成方式" class="headerlink" title="2.1命令行生成方式"></a>2.1命令行生成方式</h4><ul>
<li><p>生成秘钥对：openssl genrsa -3 -out testkey.pem 2048</p>
</li>
<li><p>生成pem格式的证书：openssl req -new -x509 -key testkey.pem -out testkey.x509.pem -days 10000   -subj ‘/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com’</p>
</li>
<li><p>生成私钥文件：openssl pkcs8 -in testkey.pem -topk8 -outform DER -out testkey.pk8 -nocrypt</p>
</li>
</ul>
<h4 id="2-2脚本生成证书方式"><a href="#2-2脚本生成证书方式" class="headerlink" title="2.2脚本生成证书方式"></a>2.2脚本生成证书方式</h4><p>在源码**development/tools/**目录中，有一个make_key脚本，可以使用这个脚本来生成证书</p>
<p>Step 1：cd到development/tools/目录</p>
<p>Step 2：运行make_key脚本： sudo ./make_key platform ‘/C=CN/ST=YourProvince/L=YourLocation/O=YourOrganization/OU=YourOrganizationalUnit/CN=YourName’</p>
<p>说明：testkey是生成的文件名，后面是证书里面的内容</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/C</td>
<td>国家代号</td>
</tr>
<tr>
<td>/ST</td>
<td>省份代号</td>
</tr>
<tr>
<td>/L</td>
<td>位置代号</td>
</tr>
<tr>
<td>/O</td>
<td>组织代号</td>
</tr>
<tr>
<td>/OU</td>
<td>单位代号</td>
</tr>
<tr>
<td>/CN</td>
<td>名称</td>
</tr>
</tbody></table>
<p>Step 3：输入自定义密码</p>
<p>此时就会生成：platform.x509.pem和platform.pk8</p>
<p>此时就可以使用**out/host/linux-x86/framework/**目录下的signapk.jar包来对apk进行签名了</p>
<h4 id="2-3-生成signapk-jar"><a href="#2-3-生成signapk-jar" class="headerlink" title="2.3 生成signapk.jar"></a>2.3 生成signapk.jar</h4><ul>
<li>在源码根目录使用<strong>source build/envsetup.sh</strong>创建指令环境</li>
<li>进入/build/tools/signapk/目录</li>
<li>执行指令：mm</li>
<li>在out/host/linux-x86/framework/目录找到signapk.jar</li>
</ul>
<h3 id="3-对apk进行签名"><a href="#3-对apk进行签名" class="headerlink" title="3.对apk进行签名"></a>3.对apk进行签名</h3><h4 id="3-1-使用指令签名"><a href="#3-1-使用指令签名" class="headerlink" title="3.1 使用指令签名"></a>3.1 使用指令签名</h4><p>如果使用原生的证书，目录在**/build/target/product/security/**中可以找到platform.pk8 platform.x509.pem文件，如果有我们上面生成的也可以。</p>
<p>将要打包的apk、证书和signapk.jar放到一个目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar signapk.jar  platform.x509.pem platform.pk8　old.apk new.apk</span><br></pre></td></tr></table></figure>


<h4 id="3-2-使用Android-Studio签名"><a href="#3-2-使用Android-Studio签名" class="headerlink" title="3.2 使用Android Studio签名"></a>3.2 使用Android Studio签名</h4><p>要使用Android Studio对应用自动签名，需要生成.jks的证书，该二进制格式的证书，同时包含证书和私钥，一般有密码保护。</p>
<p><strong>如果是没有密码的pem格式的证书生成.jks文件方式如下：</strong></p>
<ul>
<li>生成platform.pem文件<br>openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out platform.pem</li>
<li>生成platform.p12文件，设置别名和密码，即AS打包APK时输入的别名和密码<br>openssl pkcs12 -export -in platform.x509.pem -out platform.p12 -inkey platform.pem -password pass:android -name key</li>
<li>生成platform.jks(钥匙文件) （-srcstorepass android）是.jks文件的密码<br>keytool -importkeystore -deststorepass android -destkeystore ./platform.jks -srckeystore ./platform.p12 -srcstoretype PKCS12 -srcstorepass android</li>
</ul>
<p><strong>有密码的pem格式的证书生成.jks文件的方式：</strong></p>
<p>假如密码是：c6a04bdc7236f5d18c75840f50dee482b36ad4cc</p>
<ul>
<li><p>生成platform.pem文件</p>
<p>openssl pkcs8 -inform DER -passin pass:c6a04bdc7236f5d18c75840f50dee482b36ad4cc -in platform.pk8 -out platform.pem</p>
</li>
<li><p>生成platform.p12文件，设置别名和密码，即AS打包APK时输入的别名和密码</p>
<p>openssl pkcs12 -export -in platform.x509.pem -out platform.p12 -inkey platform.pem -password pass:android -name key</p>
</li>
<li><p>生成platform.jks(钥匙文件) （-srcstorepass android）是.jks文件的密码</p>
<p>keytool -importkeystore -deststorepass android -destkeystore ./platform.jks -srckeystore ./platform.p12 -srcstoretype PKCS12 -srcstorepass android</p>
</li>
</ul>
<p>生成.jks文件之后，导入as中，编译工程的时候，选择<strong>Generate Signed Bundle or APK</strong>按照上面生成输入的昵称和密码一直下一步就可以完成工程签名了。</p>
<h3 id="4-验证是否签名成功"><a href="#4-验证是否签名成功" class="headerlink" title="4.验证是否签名成功"></a>4.验证是否签名成功</h3><ul>
<li>将apk直接用zip等解压工具直接解压到本地目录</li>
<li>进入到<strong>META-INF</strong>目录找到：CERT.RSA文件</li>
<li>在<strong>META-INF</strong>目录打开控制台输入：keytool -printcert -file CERT.RSA    即可看到签名文件的输出</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2479c61c2e762bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="签名文件内容.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>签名文件</tag>
      </tags>
  </entry>
  <entry>
    <title>HIDL demo实现详细步骤</title>
    <url>/2021/03/19/HIDL-demo%E5%AE%9E%E7%8E%B0%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h3><p>首先将AOSP的源码编译一下，<a href="https://www.jianshu.com/p/eff1e738befe">编译步骤详见传送门</a></p>
<p>编译完成之后，查看：源码根目录/out/host/linux-x86/bin中是否有<strong>hidl-gen</strong>工具。</p>
<ul>
<li><p>如果有就可以直接配置环境变量</p>
</li>
<li><p>如果没有使用(在根目录)：make hidl-gen 生成hidl-gen工具</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-05b5ac1e03508121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成hidl-gen工具.png"></p>
<p>配置环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jackou@ubuntu:~$ vim .bashrc </span><br></pre></td></tr></table></figure>
<p>在末尾添加</p>
<blockquote>
<p>export PATH=$PATH:/home/jackou/work_directory/out/host/linux-x86/bin/</p>
</blockquote>
<h3 id="2-新建HIDL模块"><a href="#2-新建HIDL模块" class="headerlink" title="2.新建HIDL模块"></a>2.新建HIDL模块</h3><h4 id="2-1-新建hal接口文件"><a href="#2-1-新建hal接口文件" class="headerlink" title="2.1 新建hal接口文件"></a>2.1 新建hal接口文件</h4><p>在hardware/interfaces目录新建存放接口的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p hidltest/1.0</span><br></pre></td></tr></table></figure>
<p>创建hal文件，名为IHidlTest.hal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.hardware.hidltest@<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IHidlTest</span> </span>&#123;</span><br><span class="line">    helloWorld(string name) generates (string result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-生成-h和-cpp文件"><a href="#2-2-生成-h和-cpp文件" class="headerlink" title="2.2 生成.h和.cpp文件"></a>2.2 生成.h和.cpp文件</h4><p>在根目录下利用hidl-gen生成对应的服务端代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PACKAGE=android.hardware.hidltest@1.0</span><br><span class="line">LOC=hardware/interfaces/hidltest/1.0/default/</span><br><span class="line">hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE</span><br><span class="line">hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE</span><br></pre></td></tr></table></figure>
<img src="/2021/03/19/HIDL-demo%E5%AE%9E%E7%8E%B0%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/blog\source\_posts\HIDL-demo实现详细步骤\生成bp文件.png" alt="生成bp文件" style="zoom:75%;">



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动生成的HidlTest.h头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_HARDWARE_HIDLTEST_V1_0_HIDLTEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_HARDWARE_HIDLTEST_V1_0_HIDLTEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/hidltest/1.0/IHidlTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/MQDescriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/Status.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> hardware &#123;</span><br><span class="line"><span class="keyword">namespace</span> hidltest &#123;</span><br><span class="line"><span class="keyword">namespace</span> V1_0 &#123;</span><br><span class="line"><span class="keyword">namespace</span> implementation &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_array;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_memory;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_string;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_vec;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Return;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Void;</span><br><span class="line"><span class="keyword">using</span> ::android::sp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HidlTest</span> :</span> <span class="keyword">public</span> IHidlTest &#123;</span><br><span class="line">    <span class="comment">// Methods from ::android::hardware::hidltest::V1_0::IHidlTest follow.</span></span><br><span class="line">    <span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> most likely delete, this is only for passthrough implementations</span></span><br><span class="line"><span class="comment">// 如果使用直通模式，一定把下面语句注释删掉</span></span><br><span class="line"><span class="comment">// 此软件包经过 dlopen 处理，且实现使用 HIDL_FETCH_IHidlTest 进行了实例化。</span></span><br><span class="line"><span class="comment">// 参考说明：https://source.android.com/devices/architecture/hidl</span></span><br><span class="line"> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">IHidlTest* <span class="title">HIDL_FETCH_IHidlTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace implementation</span></span><br><span class="line">&#125;  <span class="comment">// namespace V1_0</span></span><br><span class="line">&#125;  <span class="comment">// namespace hidltest</span></span><br><span class="line">&#125;  <span class="comment">// namespace hardware</span></span><br><span class="line">&#125;  <span class="comment">// namespace android</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ANDROID_HARDWARE_HIDLTEST_V1_0_HIDLTEST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动生成的c++实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HidlTest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> hardware &#123;</span><br><span class="line"><span class="keyword">namespace</span> hidltest &#123;</span><br><span class="line"><span class="keyword">namespace</span> V1_0 &#123;</span><br><span class="line"><span class="keyword">namespace</span> implementation &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::android::hardware::hidltest::V1_0::IHidlTest follow.</span></span><br><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">HidlTest::helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO implement</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ::<span class="built_in">snprintf</span>(buf,<span class="number">100</span>,<span class="string">&quot;hello world, %s&quot;</span>,name.c_str());</span><br><span class="line">    <span class="function">hidl_string <span class="title">result</span><span class="params">(buf)</span></span>;</span><br><span class="line">    _hidl_cb(result);</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span></span><br><span class="line"><span class="function">IHidlTest* <span class="title">HIDL_FETCH_IHidlTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HidlTest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;  <span class="comment">// namespace implementation</span></span><br><span class="line">&#125;  <span class="comment">// namespace V1_0</span></span><br><span class="line">&#125;  <span class="comment">// namespace hidltest</span></span><br><span class="line">&#125;  <span class="comment">// namespace hardware</span></span><br><span class="line">&#125;  <span class="comment">// namespace android</span></span><br></pre></td></tr></table></figure>


<h4 id="2-3-更新bp文件"><a href="#2-3-更新bp文件" class="headerlink" title="2.3 更新bp文件"></a>2.3 更新bp文件</h4><p>使用一下脚本更新bp文件，不知道为什么，我使用的Android P代码，lunch 10产品，使用一下脚本始终不能像博友生成Android.mk文件，只生成了Andorid.bp文件。不过没关系，不影响编译，bp文件也是可以编译的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;hardware&#x2F;interfaces&#x2F;update-makefiles.sh</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6f2f45a84eb8d14f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更新makefile文件.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d4f20b0291860191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用脚本更新bp文件.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// Android.bp文件</span><br><span class="line">// This file is autogenerated by hidl-gen -Landroidbp.</span><br><span class="line"></span><br><span class="line">hidl_interface &#123;</span><br><span class="line">    name: &quot;android.hardware.hidltest@1.0&quot;,</span><br><span class="line">    root: &quot;android.hardware&quot;,</span><br><span class="line">    vndk: &#123;</span><br><span class="line">        enabled: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;IHidlTest.hal&quot;,</span><br><span class="line">    ],</span><br><span class="line">    interfaces: [</span><br><span class="line">        &quot;android.hidl.base@1.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">    gen_java: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标签说明：</strong></p>
<ul>
<li>name 需要与package name 相同，编译的时候会根据需要生成对应的so 或jar</li>
<li>root 即为与hidl 对应的root name</li>
<li>interfaces 为编译过程中依赖的接口名称，如c 中的shared library</li>
<li>types 为模块中所需要的自定义类型</li>
<li>如果有需要的java 代码可以将 gen_java  设为 true，如果没有（例如passthrough 模式）需要将这里设为false。不过一般通过update_makefiles.sh 就可以自动生成。详细看<a href="https://blog.csdn.net/shift_wwx/article/details/86525079">Android HIDL 中 hidl-gen使用</a></li>
</ul>
<p>配置完成之后，编译会在**~/work_directory/out/soong/.intermediates/hardware/interfaces/hidltest/1.0**生成如下文件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f71fb8d6f8e195fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根目录Android.bp生成文件说明.png"></p>
<ul>
<li><p><a href="mailto:&#97;&#x6e;&#x64;&#x72;&#111;&#105;&#100;&#x2e;&#104;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#104;&#105;&#100;&#x6c;&#116;&#101;&#x73;&#x74;&#x40;&#49;&#x2e;&#x30;">&#97;&#x6e;&#x64;&#x72;&#111;&#105;&#100;&#x2e;&#104;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#104;&#105;&#100;&#x6c;&#116;&#101;&#x73;&#x74;&#x40;&#49;&#x2e;&#x30;</a> 就是模块对应的库文件；</p>
</li>
<li><p><a href="mailto:&#x61;&#x6e;&#100;&#x72;&#111;&#105;&#x64;&#46;&#x68;&#97;&#114;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#104;&#105;&#x64;&#108;&#116;&#x65;&#x73;&#x74;&#64;&#49;&#46;&#48;&#x5f;&#103;&#101;&#110;&#99;">&#x61;&#x6e;&#100;&#x72;&#111;&#105;&#x64;&#46;&#x68;&#97;&#114;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#104;&#105;&#x64;&#108;&#116;&#x65;&#x73;&#x74;&#64;&#49;&#46;&#48;&#x5f;&#103;&#101;&#110;&#99;</a>++ 为生成对应的C++临时文件，在使用的时候都是链接到这里；</p>
</li>
<li><p><a href="mailto:&#x61;&#x6e;&#100;&#114;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#x72;&#101;&#46;&#x68;&#x69;&#x64;&#x6c;&#x74;&#101;&#x73;&#116;&#64;&#49;&#x2e;&#48;&#95;&#103;&#101;&#x6e;&#x63;">&#x61;&#x6e;&#100;&#114;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#x72;&#101;&#46;&#x68;&#x69;&#x64;&#x6c;&#x74;&#101;&#x73;&#116;&#64;&#49;&#x2e;&#48;&#95;&#103;&#101;&#x6e;&#x63;</a>++_headers 为生成的C++ 所需的头文件；</p>
</li>
<li><p>android.hardware.hidltest-V1.0-java 为java 代码所使用的java 库文件；</p>
</li>
<li><p>android.hardware.hidltest-V1.0-java_gen_java 为java 代码所使用的java 文件</p>
</li>
</ul>
<h4 id="2-4-采取直通模式"><a href="#2-4-采取直通模式" class="headerlink" title="2.4 采取直通模式"></a>2.4 采取直通模式</h4><p>将HidlTest.h中的以下注释解开，代码如2.2小节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extern &quot;C&quot; IHidlTest* HIDL_FETCH_IHidlTest(const char* name);</span></span><br></pre></td></tr></table></figure>
<p>将HidlTest.cpp中的以下代码注解解开，代码如2.2小节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">IHidlTest* <span class="title">HIDL_FETCH_IHidlTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HidlTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-5-实现功能"><a href="#2-5-实现功能" class="headerlink" title="2.5 实现功能"></a>2.5 实现功能</h4><p>在HidlTest.cpp中实现接口的功能，代码见代码如2.2小节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">HidlTest::helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO implement</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ::<span class="built_in">snprintf</span>(buf,<span class="number">100</span>,<span class="string">&quot;hello world, %s&quot;</span>,name.c_str());</span><br><span class="line">    <span class="function">hidl_string <span class="title">result</span><span class="params">(buf)</span></span>;</span><br><span class="line">    _hidl_cb(result);</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，现在大功告成； 准备开始编译。</p>
<h4 id="2-6-编译模块"><a href="#2-6-编译模块" class="headerlink" title="2.6 编译模块"></a>2.6 编译模块</h4><p>在根目录使用以下命令编译模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmm hardware/interfaces/hidltest/1.0/default/</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f1551c396f339e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功.png"></p>
<p>具有实现的so库有了，我们开始构建binder通信服务。</p>
<h4 id="2-7-编写-x61-110-x64-114-111-x69-x64-x2e-x68-97-x72-100-x77-97-114-x65-46-104-105-x64-108-116-101-x73-116-64-x31-x2e-x30-x2d-x73-x65-114-x76-105-x63-x65-46-x72-99-文件"><a href="#2-7-编写-x61-110-x64-114-111-x69-x64-x2e-x68-97-x72-100-x77-97-114-x65-46-104-105-x64-108-116-101-x73-116-64-x31-x2e-x30-x2d-x73-x65-114-x76-105-x63-x65-46-x72-99-文件" class="headerlink" title="2.7  编写&#x61;&#110;&#x64;&#114;&#111;&#x69;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#x77;&#97;&#114;&#x65;&#46;&#104;&#105;&#x64;&#108;&#116;&#101;&#x73;&#116;&#64;&#x31;&#x2e;&#x30;&#x2d;&#x73;&#x65;&#114;&#x76;&#105;&#x63;&#x65;&#46;&#x72;&#99;文件"></a>2.7  编写<a href="mailto:&#x61;&#110;&#x64;&#114;&#111;&#x69;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#x77;&#97;&#114;&#x65;&#46;&#104;&#105;&#x64;&#108;&#116;&#101;&#x73;&#116;&#64;&#x31;&#x2e;&#x30;&#x2d;&#x73;&#x65;&#114;&#x76;&#105;&#x63;&#x65;&#46;&#x72;&#99;">&#x61;&#110;&#x64;&#114;&#111;&#x69;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#x77;&#97;&#114;&#x65;&#46;&#104;&#105;&#x64;&#108;&#116;&#101;&#x73;&#116;&#64;&#x31;&#x2e;&#x30;&#x2d;&#x73;&#x65;&#114;&#x76;&#105;&#x63;&#x65;&#46;&#x72;&#99;</a>文件</h4><p>在default目录创建<a href="mailto:&#x61;&#110;&#100;&#x72;&#x6f;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#x64;&#x77;&#x61;&#114;&#101;&#x2e;&#104;&#105;&#100;&#x6c;&#x74;&#101;&#115;&#116;&#64;&#x31;&#x2e;&#x30;&#45;&#x73;&#x65;&#x72;&#x76;&#x69;&#x63;&#x65;&#46;&#114;&#x63;">&#x61;&#110;&#100;&#x72;&#x6f;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#x64;&#x77;&#x61;&#114;&#101;&#x2e;&#104;&#105;&#100;&#x6c;&#x74;&#101;&#115;&#116;&#64;&#x31;&#x2e;&#x30;&#45;&#x73;&#x65;&#x72;&#x76;&#x69;&#x63;&#x65;&#46;&#114;&#x63;</a>文件，作为启动文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service hidltest_hal_service /vendor/bin/hw/android.hardware.hidltest@1.0-service</span><br><span class="line">	class hal</span><br><span class="line">	user system</span><br><span class="line">	group system</span><br></pre></td></tr></table></figure>
<p>配置服务的名字为hidltest_hal_service。</p>
<h4 id="2-8-编写service文件"><a href="#2-8-编写service文件" class="headerlink" title="2.8 编写service文件"></a>2.8 编写service文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default目录下建立service.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">&quot;android.hardware.hidltest@1.0-service&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/hidltest/1.0/IHidlTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/LegacySupport.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> android::hardware::hidltest::V1_0::IHidlTest;</span><br><span class="line"><span class="keyword">using</span> android::hardware::defaultPassthroughServiceImplementation;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start hidltest service&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;IHidlTest&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="2-9-在Android-bp中添加对服务器的编译："><a href="#2-9-在Android-bp中添加对服务器的编译：" class="headerlink" title="2.9 在Android.bp中添加对服务器的编译："></a>2.9 在Android.bp中添加对服务器的编译：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim hardware/interfaces/hidltest/1.0/default/Android.bp</span><br></pre></td></tr></table></figure>
<p>在Android.bp中添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;android.hardware.hidltest@1.0-service&quot;,</span><br><span class="line">    relative_install_path: &quot;hw&quot;,</span><br><span class="line">    proprietary: true,</span><br><span class="line">    init_rc: [&quot;android.hardware.hidltest@1.0-service.rc&quot;],</span><br><span class="line">    srcs: [&quot;service.cpp&quot;],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libcutils&quot;,</span><br><span class="line">        &quot;libdl&quot;,</span><br><span class="line">        &quot;libbase&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">        &quot;libhardware&quot;,</span><br><span class="line">        &quot;libhidlbase&quot;,</span><br><span class="line">        &quot;libhidltransport&quot;,</span><br><span class="line">        &quot;android.hardware.hidltest@1.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-10-编写manifest-xml文件"><a href="#2-10-编写manifest-xml文件" class="headerlink" title="2.10 编写manifest.xml文件"></a>2.10 编写manifest.xml文件</h4><p>为了使客户端能够调用服务端的代码需要在manifest.xml中添加服务：在device/qcom/msm8996/manifest.xml文件最后添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hal</span> <span class="attr">format</span>=<span class="string">&quot;hidl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hardware.hidltest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--由于之前采用的是直通式，所以这里也要用直通式，否则会找不到服务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transport</span>&gt;</span>passthrough<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>IHidlTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者在车机 /vendor/etc/vintf/manifest.xml中</p>
<h4 id="2-11-再次编译模块"><a href="#2-11-再次编译模块" class="headerlink" title="2.11 再次编译模块"></a>2.11 再次编译模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmm hardware/interfaces/hidltest/1.0/default/</span><br></pre></td></tr></table></figure>
<p>最后生成的文件</p>
<blockquote>
<p>out/target/product/generic_x86_64/vendor/lib64/hw/android.hardware.hidltest@1.0-impl.so</p>
<p>out/target/product/generic_x86_64/vendor/bin/hw/android.hardware.hidltest@1.0-service</p>
<p>out/target/product/generic_x86_64/system/lib64/vndk-28/android.hardware.hidltest@1.0.so</p>
</blockquote>
<h4 id="2-12-编写C-客户端"><a href="#2-12-编写C-客户端" class="headerlink" title="2.12 编写C++客户端"></a>2.12 编写C++客户端</h4><p>在hardware/interfaces/hidltest/1.0/建立test目录，用于存储c++客户端代码。</p>
<p>创建HidlTestClient.cpp文件，并且编写客户端代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/hidltest/1.0/IHidlTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/Status.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/LegacySupport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/misc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/HidlSupport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_string;</span><br><span class="line"><span class="keyword">using</span> ::android::sp;</span><br><span class="line"><span class="keyword">using</span> android::hardware::hidltest::V1_0::IHidlTest;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    android::sp&lt;IHidlTest&gt; service = IHIdlTest::getService();</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to get service\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    service-&gt;helloWorld(<span class="string">&quot;HidlTest&quot;</span>, [&amp;](hidl_string result)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, result.c_str());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2-13-编写客户端编译脚本"><a href="#2-13-编写客户端编译脚本" class="headerlink" title="2.13 编写客户端编译脚本"></a>2.13 编写客户端编译脚本</h4><p>在hardware/interfaces/hidltest/1.0/test目录下，创建Android.bp</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    relative_install_path: &quot;hw&quot;,</span><br><span class="line">    defaults: [&quot;hidl_defaults&quot;],</span><br><span class="line">    name: &quot;hidltest_client&quot;,</span><br><span class="line">    proprietary: true,</span><br><span class="line">    srcs: [&quot;HidlTestClient.cpp&quot;],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libhardware&quot;,</span><br><span class="line">        &quot;libhidlbase&quot;,</span><br><span class="line">        &quot;libhidltransport&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">        &quot;android.hardware.hidltest@1.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1ade4363c462ffc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端代码.png"></p>
<h4 id="2-14-编译模块"><a href="#2-14-编译模块" class="headerlink" title="2.14 编译模块"></a>2.14 编译模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmm hardware/interfaces/hidltest/1.0/</span><br></pre></td></tr></table></figure>
<ul>
<li>out/target/product/generic_x86_64/system/framework/oat/x86_64/目录下生成android.hardware.hidltest-V1.0-java.odex可执行文件</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5d7770432e7d3810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hidl客户端编译成功.png"></p>
<h4 id="2-15-编写Android-app端代码"><a href="#2-15-编写Android-app端代码" class="headerlink" title="2.15 编写Android app端代码"></a>2.15 编写Android app端代码</h4><h5 id="2-15-1-取的jar包"><a href="#2-15-1-取的jar包" class="headerlink" title="2.15.1 取的jar包"></a>2.15.1 取的jar包</h5><p>从2.3中~/work_directory/out/soong/.intermediates/hardware/interfaces/hidltest/1.0/android.hardware.hidltest-V1.0-java/android_common/combined目录拿到Android端使用的jar包。</p>
<h5 id="2-15-2-建立AS工程"><a href="#2-15-2-建立AS工程" class="headerlink" title="2.15.2 建立AS工程"></a>2.15.2 建立AS工程</h5><p>由于HIDL调用需要java 8，所以在build.gradle中加入以下配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ......</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-15-3-编写代码"><a href="#2-15-3-编写代码" class="headerlink" title="2.15.3 编写代码"></a>2.15.3 编写代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MainActivity.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> Button mShow;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextShow;</span><br><span class="line">    IHidlTest mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextShow = findViewById(R.id.textView);</span><br><span class="line">        mShow = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        String content;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得服务</span></span><br><span class="line">            mService = IHidlTest.getService();</span><br><span class="line">            <span class="keyword">if</span> (mService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;service is null&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            content = mService.helloWorld(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">            mTextShow.setText(content);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mShow.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String content = mService.helloWorld(<span class="string">&quot;hello world!&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                    mTextShow.setText(content);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上面demo工程，生成apk文件，准备在目标板子上运行。</p>
<p><strong>至此，所有准备工作已经做完了。</strong></p>
<h4 id="2-16-将目标文件烧写到车机"><a href="#2-16-将目标文件烧写到车机" class="headerlink" title="2.16 将目标文件烧写到车机"></a>2.16 将目标文件烧写到车机</h4><p>需要准备的文件</p>
<blockquote>
<p>base path: ~/work_directory/out/target/product/generic_x86_64</p>
<p>abstract path:</p>
<ul>
<li>/vendor/lib64/hw/android.hardware.hidltest@1.0-impl.so</li>
<li>/system/lib64/android.hardware.hidltest@1.0.so</li>
<li>/vendor/bin/hw/hidltest_client</li>
<li>/vendor/bin/hw/android.hardware.hidltest@1.0-service</li>
</ul>
</blockquote>
<blockquote>
<p>车机中的manifest.xml修改之后push到原来的目录</p>
</blockquote>
<h5 id="2-16-1-push路径说明"><a href="#2-16-1-push路径说明" class="headerlink" title="2.16.1 push路径说明"></a>2.16.1 push路径说明</h5><blockquote>
<p><a href="mailto:&#97;&#110;&#100;&#x72;&#111;&#x69;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#119;&#x61;&#x72;&#x65;&#46;&#x68;&#x69;&#100;&#x6c;&#x74;&#101;&#115;&#x74;&#64;&#49;&#x2e;&#48;&#x2d;&#x69;&#109;&#x70;&#108;&#46;&#115;&#x6f;">&#97;&#110;&#100;&#x72;&#111;&#x69;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#119;&#x61;&#x72;&#x65;&#46;&#x68;&#x69;&#100;&#x6c;&#x74;&#101;&#115;&#x74;&#64;&#49;&#x2e;&#48;&#x2d;&#x69;&#109;&#x70;&#108;&#46;&#115;&#x6f;</a>  –&gt;      /vendor/lib64/hw</p>
<p><a href="mailto:&#x61;&#110;&#x64;&#114;&#111;&#105;&#x64;&#46;&#104;&#97;&#114;&#100;&#119;&#97;&#114;&#x65;&#x2e;&#x68;&#105;&#x64;&#108;&#x74;&#x65;&#115;&#x74;&#64;&#49;&#x2e;&#x30;&#x2e;&#x73;&#x6f;">&#x61;&#110;&#x64;&#114;&#111;&#105;&#x64;&#46;&#104;&#97;&#114;&#100;&#119;&#97;&#114;&#x65;&#x2e;&#x68;&#105;&#x64;&#108;&#x74;&#x65;&#115;&#x74;&#64;&#49;&#x2e;&#x30;&#x2e;&#x73;&#x6f;</a>           –&gt;     /system/lib64</p>
<p>hidltest_client                                               –&gt;    /vendor/bin/hw</p>
<p><a href="mailto:&#97;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#x68;&#97;&#114;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#x68;&#x69;&#x64;&#x6c;&#116;&#x65;&#x73;&#x74;&#x40;&#x31;&#46;&#48;&#x2d;&#x73;&#101;&#x72;&#x76;&#x69;&#x63;&#x65;">&#97;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#x68;&#97;&#114;&#100;&#x77;&#x61;&#x72;&#101;&#x2e;&#x68;&#x69;&#x64;&#x6c;&#116;&#x65;&#x73;&#x74;&#x40;&#x31;&#46;&#48;&#x2d;&#x73;&#101;&#x72;&#x76;&#x69;&#x63;&#x65;</a>  –&gt;    /vendor/bin/hw</p>
<p>manifest.xml                                               –&gt;    /vendor/etc/vintf</p>
</blockquote>
<p>2.16.2 安装apk</p>
<blockquote>
<p>adb install -r  /本地路径/app-debug.apk</p>
</blockquote>
<h4 id="2-17-启动服务，测试功能"><a href="#2-17-启动服务，测试功能" class="headerlink" title="2.17 启动服务，测试功能"></a>2.17 启动服务，测试功能</h4><blockquote>
<p>1.启动Hidl模块服务<br>./vendor/bin/hw/android.hardware.hidltest@1.0-service</p>
<p>2.启动客户端<br>./vendor/bin/hw/hidltest_client  </p>
<p>3.运行apk看界面现象</p>
</blockquote>
<p><strong>Notice</strong>：HAL回调实现下一小节叙述，或者见参考文献3</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.csdn.net/shift_wwx/article/details/86530600">1. Android HIDL 实例</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1619361">2. HIDL实战笔记</a></p>
<p><a href="https://www.jianshu.com/p/b80865c61d8e">3. Android HIDL学习（3） —- 注册回调</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>HIDL</tag>
      </tags>
  </entry>
  <entry>
    <title>(1)Iptables教程</title>
    <url>/2021/03/23/Iptables%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="0-Iptables介绍"><a href="#0-Iptables介绍" class="headerlink" title="0. Iptables介绍"></a>0. Iptables介绍</h3><p>iptables防火墙可以用于创建过滤(filter)与NAT规则。所有Linux发行版都能使用iptables，因此理解如何配置iptables将会帮助你更有效地管理Linux防火墙。如果你是第一次接触iptables，你会觉得它很复杂，但是一旦你理解iptables的工作原理，你会发现其实它很简单。</p>
<p>首先介绍iptables的结构：iptables -&gt; Tables -&gt; Chains -&gt; Rules. 简单地讲，tables由chains组成，而chains又由rules组成。如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a1a23a58ea0dbfeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-table-chain-rule-structure.png"></p>
<h3 id="1-iptables的表与链"><a href="#1-iptables的表与链" class="headerlink" title="1.  iptables的表与链"></a>1.  iptables的表与链</h3><p>iptables具有Filter, NAT, Mangle, Raw四种内建表：Filter表、NAT表、Mangle表和Raw表</p>
<h4 id="1-1-Filter表"><a href="#1-1-Filter表" class="headerlink" title="1.1 Filter表"></a>1.1 Filter表</h4><p>Filter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：</p>
<ul>
<li>INPUT链 – 处理来自外部的数据。</li>
<li>OUTPUT链 – 处理向外发送的数据。</li>
<li>FORWARD链 – 将数据转发到本机的其他网卡设备上。</li>
</ul>
<h4 id="1-2-NAT表"><a href="#1-2-NAT表" class="headerlink" title="1.2 NAT表"></a>1.2 NAT表</h4><p>NAT表有三种内建链：</p>
<ul>
<li>PREROUTING链 – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。</li>
<li>POSTROUTING链 – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。</li>
<li>OUTPUT链 – 处理本机产生的数据包。</li>
</ul>
<h4 id="3-Mangle表"><a href="#3-Mangle表" class="headerlink" title="3. Mangle表"></a>3. Mangle表</h4><p>Mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链(解释见上)：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
<li>FORWARD</li>
<li>INPUT</li>
<li>POSTROUTING</li>
</ul>
<h3 id="4-Raw表"><a href="#4-Raw表" class="headerlink" title="4. Raw表"></a>4. Raw表</h3><p>Raw表用于处理异常，它具有2个内建链：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
</ul>
<p>以下是Iptables中的三个重要表格</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b9b4675931350c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-filter-nat-mangle-tables.png"></p>
<h3 id="2-IPTABLES-规则-Rules"><a href="#2-IPTABLES-规则-Rules" class="headerlink" title="2.IPTABLES 规则(Rules)"></a>2.IPTABLES 规则(Rules)</h3><p>牢记以下三点式理解iptables规则的关键：</p>
<ul>
<li>Rules包括一个条件和一个<strong>目标值</strong>(target)</li>
<li>如果满足条件，就执行目标(target)中的规则或者特定值。</li>
<li>如果不满足条件，就判断下一条Rules。</li>
</ul>
<p><strong>目标值（Target Values）</strong></p>
<p>下面是你可以在target里指定的特殊值：</p>
<ul>
<li>ACCEPT – 允许防火墙接收数据包</li>
<li>DROP – 防火墙丢弃包</li>
<li>QUEUE – 防火墙将数据包移交到用户空间</li>
<li>RETURN – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。</li>
</ul>
<p>如果你执行<code>iptables --list</code>你将看到防火墙上的可用规则。下例说明当前系统没有定义防火墙，你可以看到，它显示了默认的filter表，以及表内默认的input链, forward链, output链。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -t filter --list</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li>target：目标值     </li>
<li>prot： 协议</li>
<li>opt：选项</li>
<li>source：数据包源地址</li>
<li>destination：数据包目标地址</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-97d2c29e31e90ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter表内容.png"></p>
<p>bw_INPUT、bw_OUTPUT和bw_FORWARD chain用于带宽(Bandwidth)控制；</p>
<p>fw_INPUT、fw_OUTPUT和fw_FORWARD chain用于防火墙(Firewall)控制；</p>
<p>natctrl_FORWARD用于网络地址转换(NAT)控制；</p>
<p>oem_fwd、oem_out用于OEM厂商自定义的控制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看mangle表</span></span><br><span class="line">iptables -t mangle --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看nat表</span></span><br><span class="line">iptables -t nat --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看raw表</span></span><br><span class="line">iptables -t raw --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于默认表是filter表，不加-t选项默认输出filter表</span></span><br><span class="line">iptables -t filter --list</span><br><span class="line">(or)</span><br><span class="line">iptables --list</span><br></pre></td></tr></table></figure>


<h3 id="3-清空所有iptables规则"><a href="#3-清空所有iptables规则" class="headerlink" title="3.清空所有iptables规则"></a>3.清空所有iptables规则</h3><p>在配置iptables之前，你通常需要用<code>iptables --list</code>命令或者<code>iptables-save</code>命令查看有无现存规则，因为有时需要删除现有的iptables规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables --flush</span><br><span class="line">或者</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>
<p>这两条命令是等效的。但是并非执行后就万事大吉了。你仍然需要检查规则是不是真的清空了，因为有的linux发行版上这个命令不会清除NAT表中的规则，此时只能手动清除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t NAT -F</span><br></pre></td></tr></table></figure>


<h3 id="4-永久生效"><a href="#4-永久生效" class="headerlink" title="4.永久生效"></a>4.永久生效</h3><p>当你删除、添加规则后，这些更改并不能永久生效，这些规则很有可能在系统重启后恢复原样。为了让配置永久生效，根据平台的不同，具体操作也不同。下面进行简单介绍：</p>
<h4 id="4-1-Ubuntu"><a href="#4-1-Ubuntu" class="headerlink" title="4.1 Ubuntu"></a>4.1 Ubuntu</h4><p>首先，保存现有的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>然后新建一个bash脚本，并保存到/etc/network/if-pre-up.d/目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">iptables-restore &lt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>这样，每次系统重启后iptables规则都会被自动加载。<br>/!\注意：不要尝试在.bashrc或者.profile中执行以上命令，因为用户通常不是root，而且这只能在登录时加载iptables规则。</p>
<h4 id="4-2-CentOS-RedHat"><a href="#4-2-CentOS-RedHat" class="headerlink" title="4.2 CentOS, RedHat"></a>4.2 CentOS, RedHat</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 保存iptables规则</span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line"># 重启iptables服务</span><br><span class="line">service iptables stop</span><br><span class="line">service iptables start</span><br></pre></td></tr></table></figure>
<p>查看当前规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat  &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure>


<h3 id="5-追加iptables规则"><a href="#5-追加iptables规则" class="headerlink" title="5. 追加iptables规则"></a>5. 追加iptables规则</h3><p>可以使用<code>iptables -A</code>命令追加新规则，其中-A表示Append。因此，新的规则将追加到链尾。<br>一般而言，最后一条规则用于丢弃(DROP)所有数据包。如果你已经有这样的规则了，并且使用-A参数添加新规则，那么就是无用功。</p>
<h4 id="5-1语法"><a href="#5-1语法" class="headerlink" title="5.1语法"></a>5.1语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A chain firewall-rule</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">-A chain – 指定要追加规则的链</span></span><br><span class="line"><span class="meta">#</span><span class="bash">firewall-rule – 具体的规则参数</span></span><br></pre></td></tr></table></figure>


<h4 id="5-2-描述规则的基本参数"><a href="#5-2-描述规则的基本参数" class="headerlink" title="5.2 描述规则的基本参数"></a>5.2 描述规则的基本参数</h4><p>以下这些规则参数用于描述数据包的协议、源地址、目的地址、允许经过的网络接口，以及如何处理这些数据包。这些描述是对规则的基本描述。</p>
<h5 id="p-协议（protocol）"><a href="#p-协议（protocol）" class="headerlink" title="-p 协议（protocol）"></a>-p 协议（protocol）</h5><ul>
<li><p>指定规则的协议，如tcp, udp, icmp等，可以使用all来指定所有协议。</p>
</li>
<li><p>如果不指定-p参数，则默认是all值。这并不明智，请总是明确指定协议名称。</p>
</li>
<li><p>可以使用协议名(如tcp)，或者是协议值（比如6代表tcp）来指定协议。映射关系请查看/etc/protocols</p>
</li>
<li><p>还可以使用–protocol参数代替-p参数</p>
</li>
</ul>
<h5 id="s-源地址（source）"><a href="#s-源地址（source）" class="headerlink" title="-s 源地址（source）"></a>-s 源地址（source）</h5><ul>
<li>指定数据包的源地址</li>
<li>参数可以使IP地址、网络地址、主机名</li>
<li>例如：-s 192.168.1.101指定IP地址</li>
<li>例如：-s 192.168.1.10/24指定网络地址</li>
<li>如果不指定-s参数，就代表所有地址</li>
<li>还可以使用–src或者–source</li>
</ul>
<h5 id="d-目的地址（destination）"><a href="#d-目的地址（destination）" class="headerlink" title="-d 目的地址（destination）"></a>-d 目的地址（destination）</h5><ul>
<li>指定目的地址</li>
<li>参数和-s相同</li>
<li>还可以使用–dst或者–destination</li>
</ul>
<h5 id="j-执行目标（jump-to-target）"><a href="#j-执行目标（jump-to-target）" class="headerlink" title="-j 执行目标（jump to target）"></a>-j 执行目标（jump to target）</h5><ul>
<li>-j代表”jump to target”</li>
<li>-j指定了当与规则(Rule)匹配时如何处理数据包</li>
<li>可能的值是ACCEPT, DROP, QUEUE, RETURN</li>
<li>还可以指定其他链（Chain）作为目标</li>
</ul>
<h5 id="i-输入接口（input-interface）"><a href="#i-输入接口（input-interface）" class="headerlink" title="-i 输入接口（input interface）"></a>-i 输入接口（input interface）</h5><ul>
<li>-i代表输入接口(input interface)</li>
<li>-i指定了要处理来自哪个接口的数据包</li>
<li>这些数据包即将进入INPUT, FORWARD, PREROUTE链</li>
<li>例如：-i eth0指定了要处理经由eth0进入的数据包</li>
<li>如果不指定-i参数，那么将处理进入所有接口的数据包</li>
<li>如果出现! -i eth0，那么将处理所有经由eth0以外的接口进入的数据包</li>
<li>如果出现-i eth+，那么将处理所有经由eth开头的接口进入的数据包</li>
<li>还可以使用–in-interface参数</li>
</ul>
<h5 id="o-输出（out-interface）"><a href="#o-输出（out-interface）" class="headerlink" title="-o 输出（out interface）"></a>-o 输出（out interface）</h5><ul>
<li>-o代表”output interface”</li>
<li>-o指定了数据包由哪个接口输出</li>
<li>这些数据包即将进入FORWARD, OUTPUT, POSTROUTING链</li>
<li>如果不指定-o选项，那么系统上的所有接口都可以作为输出接口</li>
<li>如果出现! -o eth0，那么将从eth0以外的接口输出</li>
<li>如果出现-i eth+，那么将仅从eth开头的接口输出</li>
<li>还可以使用–out-interface参数</li>
</ul>
<h4 id="5-3-描述规则的扩展参数"><a href="#5-3-描述规则的扩展参数" class="headerlink" title="5.3 描述规则的扩展参数"></a>5.3 描述规则的扩展参数</h4><p>对规则有了一个基本描述之后，有时候我们还希望指定端口、TCP标志、ICMP类型等内容。</p>
<h5 id="–sport-源端口（source-port）针对-p-tcp-或者-p-udp"><a href="#–sport-源端口（source-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–sport 源端口（source port）针对 -p tcp 或者 -p udp"></a>–sport 源端口（source port）针对 -p tcp 或者 -p udp</h5><ul>
<li>缺省情况下，将匹配所有端口</li>
<li>可以指定端口号或者端口名称，例如”–sport 22″与”–sport ssh”。</li>
<li>/etc/services文件描述了上述映射关系。</li>
<li>从性能上讲，使用端口号更好</li>
<li>使用冒号可以匹配端口范围，如”–sport 22:100″</li>
<li>还可以使用”–source-port”</li>
</ul>
<h5 id="–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp"><a href="#–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–-dport 目的端口（destination port）针对-p tcp 或者 -p udp"></a>–-dport 目的端口（destination port）针对-p tcp 或者 -p udp</h5><ul>
<li>参数和–sport类似</li>
<li>还可以使用”–destination-port”</li>
</ul>
<h5 id="–tcp-flags-TCP标志-针对-p-tcp"><a href="#–tcp-flags-TCP标志-针对-p-tcp" class="headerlink" title="-–tcp-flags TCP标志 针对-p tcp"></a>-–tcp-flags TCP标志 针对-p tcp</h5><ul>
<li>可以指定由逗号分隔的多个参数</li>
<li>有效值可以是：SYN, ACK, FIN, RST, URG, PSH</li>
<li>可以使用ALL或者NONE</li>
</ul>
<h5 id="–icmp-type-ICMP类型-针对-p-icmp"><a href="#–icmp-type-ICMP类型-针对-p-icmp" class="headerlink" title="-–icmp-type ICMP类型 针对-p icmp"></a>-–icmp-type ICMP类型 针对-p icmp</h5><ul>
<li>–icmp-type 0 表示Echo Reply</li>
<li>–icmp-type 8 表示Echo</li>
</ul>
<h4 id="5-4-追加规则的完整实例：仅允许SSH服务"><a href="#5-4-追加规则的完整实例：仅允许SSH服务" class="headerlink" title="5.4 追加规则的完整实例：仅允许SSH服务"></a>5.4 追加规则的完整实例：仅允许SSH服务</h4><p>本例实现的规则将仅允许SSH数据包通过本地计算机，其他一切连接（包括ping）都将被拒绝。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.清空所有iptables规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.接收目标端口为22的数据包</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.拒绝所有其他数据包</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure>


<h3 id="6-更改默认策略"><a href="#6-更改默认策略" class="headerlink" title="6. 更改默认策略"></a>6. 更改默认策略</h3><p>上例的例子仅对接收的数据包过滤，而对于要发送出去的数据包却没有任何限制。本节主要介绍如何更改链策略，以改变链的行为。</p>
<h4 id="6-1-默认链策略"><a href="#6-1-默认链策略" class="headerlink" title="6.1 默认链策略"></a>6.1 默认链策略</h4><p>/!\警告：请勿在远程连接的服务器、虚拟机上测试！<br>当我们使用-L选项验证当前规则是发现，所有的链旁边都有policy ACCEPT标注，这表明当前链的默认策略为ACCEPT：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh</span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p>这种情况下，如果没有明确添加DROP规则，那么默认情况下将采用ACCEPT策略进行过滤。除非：<br>a)为以上三个链单独添加DROP规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -j DROP</span><br><span class="line">iptables -A OUTPUT -j DROP</span><br><span class="line">iptables -A FORWARD -j DROP</span><br></pre></td></tr></table></figure>
<p>b)更改默认策略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>


<h3 id="7-配置应用程序规则"><a href="#7-配置应用程序规则" class="headerlink" title="7.配置应用程序规则"></a>7.配置应用程序规则</h3><p>尽管5.4节已经介绍了如何初步限制除SSH以外的其他连接，但是那是在链默认策略为ACCEPT的情况下实现的，并且没有对输出数据包进行限制。本节在上一节基础上，以SSH和HTTP所使用的端口为例，教大家如何在默认链策略为DROP的情况下，进行防火墙设置。在这里，我们将引进一种新的参数-m state，并检查数据包的状态字段。</p>
<h4 id="7-1-SSH"><a href="#7-1-SSH" class="headerlink" title="7.1 SSH"></a>7.1 SSH</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的SSH请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.允许发送本地主机的SSH响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">-m state: 启用状态匹配模块（state matching module）</span><br><span class="line">–-state: 状态匹配模块的参数。当SSH客户端第一个数据包到达服务器时，状态字段为NEW；建立连接后数据包的状态字段都是ESTABLISHED</span><br><span class="line">–sport 22: sshd监听22端口，同时也通过该端口和客户端建立连接、传送数据。因此对于SSH服务器而言，源端口就是22</span><br><span class="line">–dport 22: ssh客户端程序可以从本机的随机端口与SSH服务器的22端口建立连接。因此对于SSH客户端而言，目的端口就是22</span><br></pre></td></tr></table></figure>


<h4 id="7-2-HTTP"><a href="#7-2-HTTP" class="headerlink" title="7.2 HTTP"></a>7.2 HTTP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.允许发送本地主机的HTTP响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="7-3-完整的配置"><a href="#7-3-完整的配置" class="headerlink" title="7.3 完整的配置"></a>7.3 完整的配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.删除现有规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.配置默认链策略</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.允许远程主机进行SSH连接</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.允许本地主机进行SSH连接</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.允许HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>



<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.thegeekstuff.com/2011/01/iptables-fundamentals/">1.  Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals</a></p>
<p><a href="https://www.thegeekstuff.com/2011/02/iptables-add-rule/">2. Linux IPTables: How to Add Firewall Rules (With Allow SSH Example)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/03/iptables-inbound-and-outbound-rules/">3. Linux IPTables: Incoming and Outgoing Rule Examples (SSH and HTTP)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/06/iptables-rules-examples/">4. 25 Most Frequently Used Linux IPTables Rules Examples</a></p>
<p><a href="https://www.thegeekstuff.com/category/iptables/">5. iptables相关所有教程</a></p>
<p><a href="https://www.zsythink.net/archives/1199">6.朱双印的一系列Iptables原理讲解教程</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>应用沙盒</title>
    <url>/2021/03/15/%E5%BA%94%E7%94%A8%E6%B2%99%E7%9B%92/</url>
    <content><![CDATA[<h3 id="1-应用沙盒"><a href="#1-应用沙盒" class="headerlink" title="1.应用沙盒"></a>1.应用沙盒</h3><p>Android 平台利用基于用户的 Linux 保护机制识别和隔离应用资源，可将不同的应用分隔开来，并保护应用和系统免受恶意应用的攻击。为此，Android 会为每个 Android 应用分配一个独一无二的用户 ID (UID)，并让应用在自己的进程中运行。</p>
<p>Android 会使用该 UID 设置一个内核级应用沙盒。内核会在进程级别利用标准的 Linux 机制（例如，分配给应用的用户 ID 和组 ID）实现应用和系统之间的安全防护。默认情况下，应用不能彼此交互，而且对操作系统的访问权限会受到限制。如果应用 A 尝试执行恶意操作（例如在没有权限的情况下读取应用 B 的数据或拨打电话），系统会阻止此类行为，因为应用 A 没有相应的默认用户权限。这一沙盒机制非常简单，可审核，并且基于已有数十年历史的 UNIX 风格的进程用户隔离和文件权限机制。</p>
<p>由于应用沙盒位于内核层面，因此该安全模型的保护范围扩展到了原生代码和操作系统应用。位于更高层面的所有软件（例如，操作系统库、应用框架、应用运行时环境和所有应用）都会在应用沙盒中运行。某些平台会限制开发者只能使用特定的开发框架、API 或语言。在 Android 上，并没有为此而限制开发者必须如何编写应用；在这方面，原生代码与解释型代码一样进行沙盒化。</p>
<h3 id="2-保护机制"><a href="#2-保护机制" class="headerlink" title="2.保护机制"></a>2.保护机制</h3><p>通常，为了在经过适当配置的设备上攻破应用沙盒这道防线，必须先攻破 Linux 内核的安全功能。但是，与其他安全功能类似，强制执行应用沙盒的各种保护机制并非无懈可击，因此深度防御对于防止通过单个漏洞入侵操作系统或其他应用非常重要。</p>
<p>Android 依靠许多保护机制来强制执行应用沙盒。这些强制措施是随着时间的推移不断引入的，并且显著增强了基于 UID 的原始自主访问控制 (DAC) 沙盒的安全性。以前的 Android 版本包括以下保护机制：</p>
<ul>
<li>在 Android 5.0 中，SELinux 提供了强制访问控制 (MAC) 来将系统和应用分离开。但是，所有第三方应用都在相同的 SELinux 环境中运行，因此应用间的隔离主要由 UID DAC 强制执行。</li>
<li>在 Android 6.0 中，SELinux 沙盒经过扩展，可以跨各个物理用户边界隔离应用。此外，Android 还为应用数据设置了更安全的默认设置：对于 <code>targetSdkVersion &gt;= 24</code> 的应用，应用主目录上的默认 DAC 权限从 751 更改为 700。这为私有应用数据提供了更安全的默认设置（但应用可能会替换这些默认设置）。</li>
<li>在 Android 8.0 中，所有应用都设为使用 <code>seccomp-bpf</code> 过滤器运行，该过滤器可限制允许应用使用的系统调用，从而增强应用/内核边界的安全性。</li>
<li>在 Android 9 中，<code>targetSdkVersion &gt;= 28</code> 的所有非特权应用都必须在不同的 SELinux 沙盒中运行，并针对各个应用提供 MAC。这种保护机制可以提升应用隔离效果，防止替换安全默认设置，并且（最重要的是）防止应用的数据可让所有人访问。</li>
<li>在 Android 10 中，应用的文件系统的原始视图有限，且无法直接访问 /sdcard/DCIM 之类的路径。不过，应用保留对任何适用方法（例如 [Context.getExternalFilesDir()](<a href="https://developer.android.com/reference/android/content/Context.html#getExternalFilesDir">https://developer.android.com/reference/android/content/Context.html#getExternalFilesDir</a>(jav a.lang.String))）返回的软件包专用路径的完整原始访问权限。</li>
</ul>
<h3 id="3-共享文件指南"><a href="#3-共享文件指南" class="headerlink" title="3.共享文件指南"></a>3.共享文件指南</h3><p>将应用数据设为可供所有人访问从安全方面来讲是一种不好的做法，这会为所有人授予访问权限，并且无法限定只让目标受众访问这些数据。这种做法会导致信息披露泄露，让代理漏洞变得混乱，并会成为针对包含敏感数据的应用（例如电子邮件客户端）的恶意软件的首选目标。在 Android 9 及更高版本中，明确禁止 <code>targetSdkVersion&gt;=28</code> 的应用以这种方式共享文件。</p>
<p>在共享文件时，请遵循以下指南，而不是让应用数据可供所有人访问：</p>
<ul>
<li>如果您的应用需要与其他应用共享文件，请使用<a href="https://developer.android.com/guide/topics/providers/content-provider-basics.html">内容提供程序</a>。内容提供程序会以适当的粒度共享数据，并且不会出现使用所有人都可访问的 UNIX 权限会带来的诸多问题（如需了解详情，请参阅<a href="https://developer.android.com/guide/topics/providers/content-provider-basics.html">内容提供程序基础知识</a>）。</li>
<li>如果您的应用包含确实应让所有人访问的文件（例如照片），相应文件必须是媒体文件（仅限照片、视频和音频文件）且使用 <a href="https://developer.android.com/reference/android/provider/MediaStore">MediaStore</a> 类存储。（如需详细了解如何添加媒体内容，请参阅<a href="https://developer.android.com/training/data-storage/shared/media#add-item">访问共享存储空间中的媒体文件</a>）。</li>
</ul>
<p><strong>存储</strong>运行时权限控制着通过 <strong>MediaStore</strong> 对强类型媒体集合的访问权限。如需访问弱类型文件（例如 PDF）和 <a href="https://developer.android.com/reference/android/provider/MediaStore.Downloads">MediaStore.Downloads</a> 类，应用必须使用 <a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_OPEN_DOCUMENT">ACTION_OPEN_DOCUMENT</a> 等 intent。</p>
<p>如需实现 Android 10 行为，请使用 <code>requestLegacyExternalStorage</code> 清单属性，并遵循<a href="https://developer.android.com/training/permissions/usage-notes">应用权限最佳做法</a>。</p>
<ul>
<li>对于以 Android 9（及更低版本）为目标平台的应用，清单标记的默认值为 <code>true</code>。</li>
<li>对于以 Android 10 为目标平台的应用，默认值为 false。如需在以 Android 10 为目标平台的应用中暂时退出已过滤的存储空间视图，请将清单标记的值设置为 <code>true</code>。</li>
<li>使用受限权限，安装程序会将允许使用未进行沙盒化的存储的应用加入白名单。未加入白名单的应用会被沙盒化。</li>
</ul>
]]></content>
      <categories>
        <category>Android Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>应用沙盒</tag>
      </tags>
  </entry>
  <entry>
    <title>Android启动时验证</title>
    <url>/2021/03/15/Android%E5%90%AF%E5%8A%A8%E6%97%B6%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h3 id="1-设备状态"><a href="#1-设备状态" class="headerlink" title="1.设备状态"></a>1.设备状态</h3><p>设备状态用于指明能够以多大的自由度将软件刷写到设备上，以及是否强制执行验证。设备状态为 <code>LOCKED</code> 和 <code>UNLOCKED</code>。状态为 <code>LOCKED</code> 的设备禁止您将新软件刷写到设备上，而状态为 <code>UNLOCKED</code> 的设备允许您进行修改。</p>
<p>当设备开机后，引导加载程序会先检查设备状态是 <code>LOCKED</code> 还是 <code>UNLOCKED</code>。如果设备状态为 <code>UNLOCKED</code>，引导加载程序会向用户显示警告，然后继续启动，即使加载的操作系统不是由信任根签名也是如此。</p>
<p>如果设备状态为 <code>LOCKED</code>，引导加载程序会完成<a href="https://source.android.com/security/verifiedboot/verified-boot">验证启动</a>中的步骤，验证该设备的软件。只有在加载的操作系统是由信任根正确签名时，状态为 <code>LOCKED</code> 的设备才会启动。如需了解详情，请参阅<a href="https://source.android.com/security/verifiedboot/boot-flow">启动流程</a>。</p>
<h4 id="1-1-更改设备状态"><a href="#1-1-更改设备状态" class="headerlink" title="1.1 更改设备状态"></a>1.1 更改设备状态</h4><p>如需<a href="https://source.android.com/devices/bootloader/unlock-trusty">更改设备状态</a>，请使用 <code>fastboot flashing [unlock | lock]</code> 命令。为了保护用户数据，只要设备状态发生变化，都会先清除 data 分区中的数据，并会在删除数据之前要求用户确认。<br>当用户购买二手开发设备后，应该将设备状态从 <code>UNLOCKED</code> 改为 <code>LOCKED</code>。锁定设备后，只要没有警告，用户应该就能确信设备处于设备制造商开发的状态。如果开发者出于开发目的希望停用设备上的验证功能，应该将设备状态从 <code>LOCKED</code> 改为 <code>UNLOCKED</code>。</p>
<h4 id="1-2-信任根"><a href="#1-2-信任根" class="headerlink" title="1.2 信任根"></a>1.2 信任根</h4><p>信任根是用于为设备上存储的 Android 副本签名的加密密钥。信任根的不公开部分只有设备制造商才知道，用于为旨在分发的每个 Android 版本签名。信任根的公开部分嵌入在设备中并存储在一个不会被篡改的位置（通常是只读存储区）。<br>加载 Android 时，引导加载程序会使用信任根来验证真实性。如需详细了解此流程，请参阅<a href="https://source.android.com/security/verifiedboot/verified-boot">验证启动</a>。设备可能具有多个引导加载程序，因此可能有多个加密密钥。</p>
<h4 id="1-3-可由用户设置的信任根"><a href="#1-3-可由用户设置的信任根" class="headerlink" title="1.3 可由用户设置的信任根"></a>1.3 可由用户设置的信任根</h4><p>设备可以根据需要选择允许用户配置信任根（例如，公钥）。设备可以使用此可由用户设置的信任根（而非内置的信任根）进行启动时验证。这样，用户既可以安装并使用自定义的 Android 版本，又不会牺牲启动时验证这项安全改进功能。</p>
<p>如果实现了可由用户设置的信任根，则应满足以下要求：</p>
<ul>
<li>需要进行物理确认才能设置/清除可由用户设置的信任根。</li>
<li>可由用户设置的信任根只能由最终用户设置，而不能在出厂时或在最终用户获得设备之前的任意中间点设置。</li>
<li>可由用户设置的信任根存储在防篡改的存储空间中。“防篡改”是指可以检测到 Android 数据是否遭到篡改（例如，数据是否被覆盖或更改）。</li>
<li>如果设置了可由用户设置的信任根，则设备应该允许启动使用内置信任根或可由用户设置的信任根签名的 Android 版本。</li>
<li>设备每次使用可由用户设置的信任根启动时，系统都应通知用户设备正在加载自定义的 Android 版本。例如，警告屏幕，请参阅<a href="https://source.android.com/security/verifiedboot/boot-flow#locked-devices-with-custom-key-set">状态为 <code>LOCKED</code> 并已设置自定义密钥的设备</a>。</li>
</ul>
<p>实现可由用户设置的信任根的一种方法是，将虚拟分区设置为仅当设备处于 <code>UNLOCKED</code> 状态时才能刷写或清除。Google Pixel 2 设备使用此方法以及名为 <code>avb_custom_key</code> 的虚拟分区。<code>avbtool extract_public_key</code> 命令会输出此分区中数据的格式。以下示例展示了如何设置可由用户设置的信任根：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avbtool extract_public_key --key key.pem --output pkmd.bin</span><br><span class="line">fastboot flash avb_custom_key pkmd.bin</span><br></pre></td></tr></table></figure>
<p>可由用户设置的信任根可通过发出以下命令来清除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastboot erase avb_custom_key</span><br></pre></td></tr></table></figure>


<h3 id="2-验证启动"><a href="#2-验证启动" class="headerlink" title="2.验证启动"></a>2.验证启动</h3><p>对于要启动的 Android 版本中包含的所有可执行代码和数据，启动时验证均要求在使用前以加密形式对其进行验证，其中包括内核（从 <code>boot</code> 分区加载）、设备树（从 <code>dtbo</code> 分区加载）、<code>system</code> 分区和 <code>vendor</code> 分区等。</p>
<p>对于 <code>boot</code> 和 <code>dtbo</code> 这类仅读取一次的小分区，通常是通过将整个内容加载到内存中，然后计算其哈希值来进行验证。接下来，系统会将计算出的哈希值与预期哈希值进行比较。如果值不一致，则 Android 将无法加载。如需了解详情，请参阅<a href="https://source.android.com/security/verifiedboot/boot-flow">启动流程</a>。</p>
<p>内存装不下的较大分区（如文件系统）可能会使用哈希树；在这种情况下，验证流程会在将数据加载到内存的过程中持续进行。对于这种情况，系统会在运行时计算哈希树的根哈希值，并将其与预期根哈希值进行比较。Android 包含用于验证较大分区的 <a href="https://source.android.com/security/verifiedboot/dm-verity">dm-verity 驱动程序</a>。如果在某个时刻计算出的根哈希值与预期根哈希值不一致，系统便不会使用相应数据，而且 Android 会出现错误。如需了解详情，请参阅 <a href="https://source.android.com/security/verifiedboot/boot-flow#dm-verity-corruption">dm-verity 损坏</a>。</p>
<p>预期哈希值通常存储在每个经过验证的分区的末尾或开头、专用分区中，或同时存储在以上两个位置。最重要的是，这些哈希值已由信任根以直接或间接的方式签名。举个例子，AVB 实现就支持这两种方式；如需了解详情，请参阅 <a href="https://source.android.com/security/verifiedboot/avb">Android 启动时验证</a>。</p>
<h4 id="2-1回滚保护"><a href="#2-1回滚保护" class="headerlink" title="2.1回滚保护"></a>2.1回滚保护</h4><p>即使更新流程完全安全，攻击者仍可能会利用非永久性 Android 内核漏洞来手动安装更易受攻击的旧版 Android 系统，重新启动进入易受攻击的版本，然后通过该 Android 版本来安装永久性漏洞。在这种情况下，攻击者可通过这种漏洞永久拥有相应设备，并可以执行任何操作（包括停用更新）。</p>
<p>防范这类攻击的保护措施称为“回滚保护”。“回滚保护”通常通过以下方式实现：使用防篡改的存储空间来记录最新的 Android 版本，并在 Android 版本低于记录的版本时拒绝启动 Android。系统通常会针对每个分区来跟踪版本。</p>
<p>如需详细了解 AVB 处理回滚保护的方式，请参阅 AVB <a href="https://android.googlesource.com/platform/external/avb/+/master/README.md#Rollback-Protection">README</a>。</p>
<h4 id="2-2-处理验证错误"><a href="#2-2-处理验证错误" class="headerlink" title="2.2 处理验证错误"></a>2.2 处理验证错误</h4><p>如果验证在运行时失败，恢复流程就会更复杂一些。如果设备使用的是 dm-verity，则应在 <code>restart</code> 模式下进行配置。在 <code>restart</code> 模式下，如果遇到验证错误，设备会立即重启，并设置特定标记以表明错误原因。引导加载程序应该会注意到该标记，并将 dm-verity 切换为使用 I/O 错误 (<code>eio</code>) 模式并保持该模式，直到安装新的更新为止。</p>
<h3 id="3-启动流程"><a href="#3-启动流程" class="headerlink" title="3.启动流程"></a>3.启动流程</h3><p><img src="/2021/03/15/Android%E5%90%AF%E5%8A%A8%E6%97%B6%E9%AA%8C%E8%AF%81/blog\source_posts\Android启动时验证\verified-boot-flow.png" alt="verified-boot-flow"></p>
<h4 id="3-1-适用于-A-B-设备的流程"><a href="#3-1-适用于-A-B-设备的流程" class="headerlink" title="3.1 适用于 A/B 设备的流程"></a>3.1 适用于 A/B 设备的流程</h4><p>如果设备使用的是 A/B 系统，则启动流程略有不同。必须先使用<a href="https://android.googlesource.com/platform/hardware/interfaces/+/master/boot/1.0/IBootControl.hal">启动控件 HAL</a> 将要启动的槽位标记为 <code>SUCCESSFUL</code>，然后再更新回滚保护 (Rollback Protection) 元数据。</p>
<p>如果平台更新失败（未标记 <code>SUCCESSFUL</code>），A/B 堆栈便会回退至仍具有先前 Android 版本的其他槽位。不过，如果已设置回滚保护元数据，之前的版本会因回滚保护而无法启动。</p>
<h4 id="3-2-将启动时验证状态传达给-Android"><a href="#3-2-将启动时验证状态传达给-Android" class="headerlink" title="3.2 将启动时验证状态传达给 Android"></a>3.2 将启动时验证状态传达给 Android</h4><p>引导加载程序通过内核命令选项将启动时验证状态传达给 Android。它会将 <code>androidboot.verifiedstate</code> 选项设置为以下其中一个值：</p>
<ul>
<li><code>green</code>：如果设备处于<code>LOCKED</code>状态且未使用可由用户设置的信任根</li>
<li><code>yellow</code>：如果设备处于<code>LOCKED</code>状态且使用了可由用户设置的信任根</li>
<li><code>orange</code>：如果设备处于<code>UNLOCKED</code>状态</li>
</ul>
<p><code>androidboot.veritymode</code> 选项设置为 <code>eio</code> 或 <code>restart</code>，具体取决于启动加载程序在处理 dm-verity 错误时所处的状态。如需了解详情，请参阅<a href="https://source.android.com/security/verifiedboot/verified-boot#handling-verification-errors">处理验证错误</a>。</p>
<h3 id="4-实现-dm-verity"><a href="#4-实现-dm-verity" class="headerlink" title="4.实现 dm-verity"></a>4.实现 dm-verity</h3><p>Android 4.4 及更高版本支持通过可选的 device-mapper-verity (dm-verity) 内核功能进行启动时验证，以便对块存储设备进行透明的完整性检查。dm-verity 有助于阻止可以持续保有 Root 权限并入侵设备的持续性 Rootkit。验证启动功能有助于 Android 用户在启动设备时确定设备状态与上次使用时是否相同。</p>
<p>具有 Root 权限的可能有害的应用 (PHA) 可以躲开检测程序的检测，并以其他方式掩蔽自己。可以获取 Root 权限的软件就能够做到这一点，因为它通常比检测程序的权限更高，从而能够“欺骗”检测程序。</p>
<p>通过 dm-verity 功能，您可以查看块设备（文件系统的底部存储层），并确定它是否与预期配置一致。该功能是利用加密哈希树做到这一点的。对于每个块（通常为 4k），都有一个 SHA256 哈希。</p>
<p>由于哈希值存储在页面树中，因此顶级“根”哈希必须可信，才能验证树的其余部分。能够修改任何块相当于能够破坏加密哈希。下图描绘了此结构。</p>
<p><img src="/2021/03/15/Android%E5%90%AF%E5%8A%A8%E6%97%B6%E9%AA%8C%E8%AF%81/blog\source_posts\Android启动时验证\dm-verity-hash-table.png" alt="dm-verity-hash-table"></p>
<p>启动分区中包含一个公钥，该公钥必须已由设备制造商在外部进行验证。该密钥用于验证相应哈希的签名，并用于确认设备的系统分区是否受到保护且未被更改。</p>
<h4 id="4-1-具体实施措施"><a href="#4-1-具体实施措施" class="headerlink" title="4.1 具体实施措施"></a>4.1 具体实施措施</h4><p>dm-verity 保护机制位于内核中。因此，如果获取 Root 权限的软件在内核启动之前入侵系统，它将会一直拥有该权限。为了降低这种风险，大多数制造商都会使用烧录到设备的密钥来验证内核。该密钥在设备出厂后即无法更改(OTP寄存器保证？)。</p>
<p> dm-verity 只有在各个块被访问时才会对其进行单独验证。将块读入内存时，会以并行方式对其进行哈希处理。然后，会从第一级开始逐级验证整个哈希树的哈希。</p>
<p>如果验证失败，设备会生成 I/O 错误，指明无法读取相应块。设备看起来与文件系统损坏时一样，也与预期相同。</p>
<p>应用可以选择在没有结果数据的情况下继续运行，例如，当这些结果并不是应用执行主要功能所必需的数据时。不过，如果应用在没有这些数据的情况下无法继续运行，则会失败。</p>
<h4 id="4-2前向纠错"><a href="#4-2前向纠错" class="headerlink" title="4.2前向纠错"></a>4.2前向纠错</h4><p>Android 7.0 及更高版本通过前向纠错 (FEC) 功能提高了 dm-verity 的稳健性。AOSP 实现首先使用常用的 <a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction">Reed-Solomon</a> 纠错码，并应用一种称为交错的技术来减少空间开销并增加可以恢复的损坏块的数量。有关 FEC 的更多详情，请参阅<a href="https://android-developers.googleblog.com/2016/07/strictly-enforced-verified-boot-with.html">严格强制执行的启动时验证与纠错</a>。</p>
<h4 id="4-3实现dm-verity步骤"><a href="#4-3实现dm-verity步骤" class="headerlink" title="4.3实现dm-verity步骤"></a>4.3实现dm-verity步骤</h4><ul>
<li>生成 EXT4 系统映像。</li>
<li>为该映像<a href="https://source.android.com/security/verifiedboot/dm-verity#hash-tree">生成哈希树</a>。</li>
<li>为该哈希树<a href="https://source.android.com/security/verifiedboot/dm-verity#mapping-table">构建 dm-verity 表</a>。</li>
<li><a href="https://source.android.com/security/verifiedboot/dm-verity#signing">为该 dm-verity 表签名</a>以生成表签名。</li>
<li>将表签名和 dm-verity 表<a href="https://source.android.com/security/verifiedboot/dm-verity#metadata">绑定</a>到 Verity 元数据。</li>
<li>将系统映像、Verity 元数据和哈希树连接起来。</li>
</ul>
<p>如需关于哈希树和 dm-verity 表的详细说明，请参阅 <a href="http://www.chromium.org/chromium-os/chromiumos-design-docs/verified-boot">Chromium 项目 - 启动时验证</a>。</p>
<h5 id="4-3-1-生成哈希树"><a href="#4-3-1-生成哈希树" class="headerlink" title="4.3.1  生成哈希树"></a>4.3.1  生成哈希树</h5><p>如简介中所述，哈希树是 dm-verity 不可或缺的一部分。<a href="https://gitlab.com/cryptsetup/cryptsetup/wikis/DMVerity">cryptsetup</a> 工具将为您生成哈希树。</p>
<p>为了形成哈希，该工具会将系统映像在第 0 层拆分成 4k 大小的块，并为每个块分配一个 SHA256 哈希。然后，通过仅将这些 SHA256 哈希组合成 4k 大小的块来形成第 1 层，从而产生一个小得多的映像。接下来再使用第 1 层的 SHA256 哈希以相同的方式形成第 2 层。</p>
<p>直到前一层的 SHA256 哈希可以放到一个块中，该过程就完成了。获得该块的 SHA256 哈希后，就相当于获得了树的根哈希。</p>
<p>哈希树的大小（以及相应的磁盘空间使用量）会因已验证分区的大小而异。在实际中，哈希树一般都比较小，通常不到 30 MB。</p>
<p>如果某个层中的某个块无法由前一层的哈希正好填满，您应在其中填充 0 来获得所需的 4k 大小。这样一来，您就知道哈希树没有被移除，而是填入了空白数据。</p>
<p>为了生成哈希树，需要将第 2 层哈希组合到第 1 层哈希的上方，将第 3 层哈希组合到第 2 层哈希的上方，依次类推。然后将所有这些数据写入到磁盘中。请注意，这种方式不会引用根哈希的第 0 层。</p>
<p>总而言之，构建哈希树的一般算法如下：</p>
<ol>
<li><p>选择一个随机盐（十六进制编码）。</p>
</li>
<li><p>将系统映像拆分成 4k 大小的块。</p>
</li>
<li><p>获取每个块的加盐 SHA256 哈希。</p>
</li>
<li><p>组合这些哈希以形成层。</p>
</li>
<li><p>在层中填充 0，直至达到 4k 块的边界。</p>
</li>
<li><p>将层组合到哈希树中。</p>
</li>
<li><p>重复第 2-6 步（使用前一层作为下一层的来源），直到最后只有一个哈希。</p>
</li>
</ol>
<h5 id="4-3-2-构建-dm-verity-映射表"><a href="#4-3-2-构建-dm-verity-映射表" class="headerlink" title="4.3.2 构建 dm-verity 映射表"></a>4.3.2 构建 dm-verity 映射表</h5><p>构建 dm-verity 映射表，该映射表会标明内核的块存储设备（或目标）以及哈希树的位置（是同一个值）。在生成 <code>fstab</code>和设备启动时会用到此映射。该映射表还会标明块的大小和 hash_start，即哈希树的起始位置（具体来说，就是哈希树在映像开头处的块编号）。</p>
<p>如需关于 Verity 目标映射表字段的详细说明，请参阅 <a href="https://code.google.com/p/cryptsetup/wiki/DMVerity">cryptsetup</a>。</p>
<h5 id="4-3-3为-dm-verity-表签名"><a href="#4-3-3为-dm-verity-表签名" class="headerlink" title="4.3.3为 dm-verity 表签名"></a>4.3.3为 dm-verity 表签名</h5><p>为 dm-verity 表签名以生成表签名。在验证分区时，会首先验证表签名。该验证是对照位于启动映像上某个固定位置的密钥来完成的。密钥通常包含在制造商的编译系统中，以便自动添加到设备上的固定位置。</p>
<p>如需使用这种签名和密钥的组合来验证分区，请执行以下操作：</p>
<ol>
<li>将一个格式与 libmincrypt 兼容的 RSA-2048 密钥添加到 <code>/verity_key</code> 分区的 <code>/boot</code> 中。确定用于验证哈希树的密钥所在的位置。</li>
<li>在相关条目的 fstab 中，将 <code>verify</code> 添加到 <code>fs_mgr</code> 标记。</li>
</ol>
<h5 id="4-3-4将表签名绑定到元数据"><a href="#4-3-4将表签名绑定到元数据" class="headerlink" title="4.3.4将表签名绑定到元数据"></a>4.3.4将表签名绑定到元数据</h5><p>将表签名和 dm-verity 表绑定到 Verity 元数据。为整个元数据块添加版本号，以便它可以进行扩展，例如添加第二种签名或更改某些顺序。</p>
<p>一个魔数（作为一个健全性检查项目）会与每组表元数据相关联，以协助标识表。由于长度包含在 EXT4 系统映像标头中，因此这为您提供了一种在不知道数据本身内容的情况下搜索元数据的方式。</p>
<p>这可确保您未选择验证未验证的分区。如果是这样，缺少此魔数将会导致验证流程中断。该数字类似于：<br>0xb001b001</p>
<p>十六进制的字节值为：</p>
<ul>
<li>第一字节 = b0</li>
<li>第二字节 = 01</li>
<li>第三字节 = b0</li>
<li>第四字节 = 01</li>
</ul>
<p>下图展示了 Verity 元数据的细分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;magic number&gt;|&lt;version&gt;|&lt;signature&gt;|&lt;table length&gt;|&lt;table&gt;|&lt;padding&gt;</span><br><span class="line">\-------------------------------------------------------------------&#x2F;</span><br><span class="line">\----------------------------------------------------------&#x2F;   |</span><br><span class="line">                            |                                  |</span><br><span class="line">                            |                                 32K</span><br><span class="line">                       block content</span><br></pre></td></tr></table></figure>
<p>下表介绍了这些元数据字段。</p>
<p>**表 1.**Verity 元数据字段</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">用途</th>
<th align="left">大小</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">魔数</td>
<td align="left">供 fs_mgr 用作一个健全性检查项目</td>
<td align="left">4 个字节</td>
<td align="left">0xb001b001</td>
</tr>
<tr>
<td align="left">版本</td>
<td align="left">用于为元数据块添加版本号</td>
<td align="left">4 个字节</td>
<td align="left">目前为 0</td>
</tr>
<tr>
<td align="left">签名</td>
<td align="left">PKCS1.5 填充形式的表签名</td>
<td align="left">256 个字节</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">表长度</td>
<td align="left">dm-verity 表的长度（以字节数计）</td>
<td align="left">4 个字节</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">表</td>
<td align="left">上文介绍的 dm-verity 表</td>
<td align="left">字节数与表长度相同</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">填充</td>
<td align="left">此结构会通过填充 0 达到 32k 长度</td>
<td align="left"></td>
<td align="left">0</td>
</tr>
</tbody></table>
<h5 id="4-3-5优化-dm-verity"><a href="#4-3-5优化-dm-verity" class="headerlink" title="4.3.5优化 dm-verity"></a>4.3.5优化 dm-verity</h5><p>为了充分发挥 dm-verity 的最佳性能，您应该：</p>
<ul>
<li>在内核中开启 NEON SHA-2（如果是 ARMv7）或 SHA-2 扩展程序（如果是 ARMv8）。</li>
<li>使用不同的预读设置和 prefetch_cluster 设置进行实验，找出适合您设备的最佳配置。</li>
</ul>
<h3 id="5-验证-system-other-分区实现"><a href="#5-验证-system-other-分区实现" class="headerlink" title="5.验证 system_other 分区实现"></a>5.验证 system_other 分区实现</h3><p>搭载 Android 9 及更低版本且具有 A/B 分区的 Android 设备可以使用闲置的 <code>system_other</code> 分区（例如，当 <code>slot_a</code> 处于活动状态时，<code>system_b</code> 闲置）存储预优化的 VDEX/ODEX 文件。使用 <code>system_other</code> 时，<code>ro.cp_system_other_odex</code> 被设置为 1，以便软件包管理器服务设置 <code>sys.cppreopt=requested</code>，使 <code>cppreopts.rc</code>能对其执行操作。</p>
<p>Android 10 中引入了 <a href="https://android.googlesource.com/platform/system/core/+/refs/heads/master/fs_mgr/libfs_avb/"><code>libfs_avb</code></a>，以便支持对 <code>system_other</code> 分区进行独立的 AVB 验证。此类分区的 VBMeta 结构附加在分区末尾，将由文件系统中的预期公钥验证。Android 构建系统支持对 <code>system_other.img</code> 签名，并将相应的签名密钥包含在 <code>/product/etc/security/avb/system_other.avbpubkey</code> 下。发布工具 <code>sign_target_files_apks.py</code> 还支持将签名密钥替换为发布版本。</p>
<p>如果 A/B 设备搭载的 Android 版本低于 Android 10，即便升级到 Android 10 并将 <code>PRODUCT_RETROFIT_DYNAMIC_PARTITIONS</code> 设置为 <code>true</code>，也具有一个 <code>system_other</code> 物理分区。</p>
<p><strong>注意</strong>：建议不要在这些设备上启用 AVB。无线下载软件包中不包含 <code>system_other.img</code>，这可能会在一些 A/B 更新后导致验证错误。</p>
<p>搭载 Android 10 的 A/B 设备必须具有一个 <code>system_other</code> 逻辑分区。以下示例显示了对 <code>system_other</code> 启用 AVB 的典型 <code>fstab.postinstall</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&lt;dev&gt; &lt;mnt_point&gt; &lt;<span class="built_in">type</span>&gt;  &lt;mnt_flags options&gt;  &lt;fs_mgr_flags&gt;</span></span><br><span class="line">system /postinstall ext4 ro,nosuid,nodev,noexec</span><br><span class="line">slotselect_other,logical,avb_keys=/product/etc/security/avb/system_other.avbpubkey</span><br></pre></td></tr></table></figure>
<p>需要对 <code>system_other</code> 分区启用 AVB 的设备应将 <code>fstab</code> 文件放到产品分区中，并将属性 <code>ro.postinstall.fstab.prefix</code> 设置为 <code>/product</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Use /product/etc/fstab.postinstall to mount system_other. PRODUCT_PRODUCT_PROPERTIES += \</span></span><br><span class="line"><span class="bash">ro.postinstall.fstab.prefix=/product</span></span><br><span class="line"></span><br><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line"><span class="meta">$</span><span class="bash">(LOCAL_PATH)/fstab.postinstall:$(TARGET_COPY_OUT_PRODUCT)/etc/fstab.postinstall</span></span><br></pre></td></tr></table></figure>


<h3 id="6-Android-启动时验证"><a href="#6-Android-启动时验证" class="headerlink" title="6.Android 启动时验证"></a>6.Android 启动时验证</h3><p>Android 8.0 及更高版本包含启动时验证的一个供参考的实现，名为 Android 启动时验证 (Android Verified Boot , AVB) 或启动时验证 2.0。AVB 是支持 <a href="https://source.android.com/devices/architecture#hidl">Project Treble</a> 架构的一个启动时验证版本，可以将 Android 框架与底层供应商实现分离开来。</p>
<p>AVB 与 Android 构建系统相集成，并通过一行代码（负责生成所有必要的 dm-verity 元数据并为其签名）进行启用。如需了解详情，请参阅<a href="https://android.googlesource.com/platform/external/avb/+/master/README.md#Build-System-Integration">构建系统集成</a>。</p>
<p>AVB 提供 libavb，后者是一个在启动时用于验证 Android 的 C 库。您可以通过以下方式将 libavb 与引导加载程序集成在一起：针对 I/O 实现<a href="https://android.googlesource.com/platform/external/avb/+/master/libavb/avb_ops.h">特定于平台的功能</a>，提供信任根，并获取/设置回滚保护元数据。</p>
<p>AVB 的主要功能包括：针对不同分区委托更新、提供用于对分区进行签名的通用页脚格式，以及防止攻击者回滚到存在漏洞的 Android 版本。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://source.android.com/security/verifiedboot/device-state">Android关于启动时安全的验证</a></li>
<li><a href="https://blog.csdn.net/shangyexin/article/details/86649504">Android Verified Boot 2.0 最新安卓P AVB详解</a></li>
<li><a href="https://source.android.com/security">Android安全概述全集</a></li>
</ul>
]]></content>
      <categories>
        <category>Android Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AVB</tag>
      </tags>
  </entry>
  <entry>
    <title>SELinux介绍(一)</title>
    <url>/2021/03/15/SELinux%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-Android-中的安全增强型-Linux"><a href="#1-Android-中的安全增强型-Linux" class="headerlink" title="1.Android 中的安全增强型 Linux"></a>1.Android 中的安全增强型 Linux</h3><p>作为 Android <a href="https://source.android.com/security">安全模型</a>的一部分，Android 使用安全增强型 Linux (SELinux) 对所有进程强制执行强制访问控制 (MAC)，甚至包括以 Root/超级用户权限运行的进程（Linux 功能）。很多公司和组织都为 Android 的 <a href="https://android.googlesource.com/platform/external/selinux/">SELinux 实现</a>做出了贡献。借助 SELinux，Android 可以更好地保护和限制系统服务、控制对应用数据和系统日志的访问、降低恶意软件的影响，并保护用户免遭移动设备上的代码可能存在的缺陷的影响。</p>
<p>SELinux 按照默认拒绝的原则运行：任何未经明确允许的行为都会被拒绝。SELinux 可按两种全局模式运行：</p>
<ul>
<li>宽容模式：权限拒绝事件会被记录下来，但不会被强制执行。</li>
<li>强制模式：权限拒绝事件会被记录下来<strong>并</strong>强制执行。</li>
</ul>
<p>Android 中包含 SELinux（处于强制模式）和默认适用于整个 AOSP 的相应安全政策。在强制模式下，非法操作会被阻止，并且尝试进行的所有违规行为都会被内核记录到 <code>dmesg</code> 和 <code>logcat</code>。开发时，您应该先利用这些错误信息对软件和 SELinux 政策进行优化，再对它们进行强制执行。如需了解详情，请参阅<a href="https://source.android.com/security/selinux/implement">实现 SELinux</a>。</p>
<p>此外，SELinux 还支持基于域的宽容模式。在这种模式下，可将特定域（进程）设为宽容模式，同时使系统的其余部分处于全局强制模式。简单来说，域是安全政策中用于标识一个进程或一组进程的标签，安全政策会以相同的方式处理所有具有相同域标签的进程。借助基于域的宽容模式，可逐步将 SELinux 应用于系统中越来越多的部分，还可以为新服务制定政策（同时确保系统的其余部分处于强制模式）。</p>
<h4 id="1-1背景"><a href="#1-1背景" class="headerlink" title="1.1背景"></a>1.1背景</h4><p>Android 安全模型部分基于<a href="https://source.android.com/security/app-sandbox">应用沙盒</a>的概念。每个应用都在自己的沙盒内运行。在 Android 4.3 之前的版本中，这些沙盒是通过为每个应用创建独一无二的 Linux UID（在应用安装时创建）来定义的。Android 4.3 及更高版本使用 SELinux 进一步定义 Android 应用沙盒的边界。</p>
<p>基于 Android 4.3（宽容模式）和 Android 4.4（部分强制模式），在 Android 5.0 及更高版本中，已全面强制执行 SELinux。通过此项变更，Android 已从对有限的一组关键域（<code>installd</code>、<code>netd</code>、<code>vold</code> 和 <code>zygote</code>）强制执行 SELinux 转为对所有域（超过 60 个）强制执行 SELinux。具体而言：</p>
<ul>
<li>在 Android 5.x 及更高版本中，所有域均处于强制模式。</li>
<li><code>init</code> 以外的任何进程都不应在 <code>init</code> 域中运行。</li>
<li>出现任何常规拒绝事件（对于 <code>block_device</code>、<code>socket_device</code>、<code>default_service</code>），都表示设备需要一个特殊域。</li>
</ul>
<p>Android 6.0 通过降低我们政策的宽容度强化了系统安全，从而实现更好的用户隔离和 IOCTL 过滤、降低可从设备/系统之外访问的服务面临的威胁、进一步强化 SELinux 域，以及高度限制对 <code>/proc</code> 的访问。</p>
<p>Android 7.0 更新了 SELinux 配置，以进一步锁定应用沙盒并缩小受攻击面。此版本还将单片式 mediaserver 堆栈拆分为较小的进程，以缩小其权限范围。如需了解详情，请参阅<a href="https://android-developers.googleblog.com/2016/07/protecting-android-with-more-linux.html">利用更多的 Linux 内核防护功能保护 Android 系统</a>和<a href="https://android-developers.googleblog.com/2016/05/hardening-media-stack.html">媒体堆栈安全强化</a>。</p>
<p>Android 8.0 更新了 SELinux 以便与 <a href="https://source.android.com/devices/architecture#hidl">Treble</a> 配合使用，后者可将较低级别的供应商代码与 Android 系统框架分离开来。此版本更新了 SELinux 政策以允许设备制造商和 SOC 供应商更新自己的政策部分、构建自己的映像（<code>vendor.img</code>、<code>boot.img</code> 等），然后更新这些映像而不受平台影响，反之亦然。</p>
<p>虽然可以在设备上运行更高/更新版本的平台（框架），但反之并不成立；供应商映像 (<code>vendor.img/odm.img</code>) 的版本不能高于平台 (<code>system.img</code>) 的版本。因此，较新版平台可能会带来 SELinux 兼容性问题，因为平台 SELinux 政策的版本要比该政策的供应商 SELinux 部分更新。Android 8.0 模型提供了一种<a href="https://source.android.com/security/selinux/compatibility">保持兼容性</a>的方法，以免进行不必要的同时 OTA。</p>
<h4 id="1-2其他资源"><a href="#1-2其他资源" class="headerlink" title="1.2其他资源"></a>1.2其他资源</h4><p>如需关于构建实用 SELinux 政策的帮助，请参阅以下资源：</p>
<ul>
<li><a href="https://events.static.linuxfound.org/sites/events/files/slides/abs2014_seforandroid_smalley.pdf">Security Enhancements for Linux（针对 Linux 的安全增强功能）</a></li>
<li><a href="http://www.cs.columbia.edu/~lierranli/coms6998-7Spring2014/papers/SEAndroid-NDSS2013.pdf">Security Enhanced (SE) Android: Bringing Flexible MAC to Android（安全增强 (SE) Android：在 Android 中引入灵活 MAC）</a></li>
<li><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf">The SELinux Notebook, 4th Edition（SELinux 手册第 4 版）</a></li>
<li><a href="http://selinuxproject.org/page/ObjectClassesPerms">SELinux Object Classes and Permissions Reference（SELinux 对象类和权限参考文档）</a></li>
<li><a href="https://www.nsa.gov/resources/everyone/digital-media-center/publications/research-papers/assets/files/implementing-selinux-as-linux-security-module-report.pdf">Implementing SELinux as a Linux Security Module（将 SELinux 作为 Linux 安全模块实现）</a></li>
<li><a href="https://www.nsa.gov/resources/everyone/digital-media-center/publications/research-papers/assets/files/configuring-selinux-policy-report.pdf">Configuring the SELinux Policy（配置 SELinux 政策）</a></li>
<li><a href="https://www.gnu.org/software/m4/manual/index.html">GNU M4 - GNU Macro Processor Manual（GNU M4 - GNU 宏处理器手册）</a></li>
<li><a href="https://opensource.com/business/13/11/selinux-policy-guide">Your visual how-to guide for SELinux policy enforcement（有关强制执行 SELinux 政策的直观操作指南）</a></li>
</ul>
<h3 id="2-SELinux-概念"><a href="#2-SELinux-概念" class="headerlink" title="2.SELinux 概念"></a>2.SELinux 概念</h3><p>请查看此页中的内容，熟悉 SELinux 概念。</p>
<h4 id="2-1强制访问控制"><a href="#2-1强制访问控制" class="headerlink" title="2.1强制访问控制"></a>2.1强制访问控制</h4><p>安全增强型 Linux (SELinux) 是适用于 Linux 操作系统的强制访问控制 (MAC) 系统。作为 MAC 系统，它与 Linux 中用户非常熟悉的自主访问控制 (DAC) 系统不同。在 DAC 系统中，存在所有权的概念，即特定资源的所有者可以控制与该资源关联的访问权限。这种系统通常比较粗放，并且容易出现无意中提权的问题。MAC 系统则会在每次收到访问请求时都先咨询核心机构，再做出决定。</p>
<p>SELinux 已作为 Linux 安全模块 (LSM) 框架的一部分实现，该框架可识别各种内核对象以及对这些对象执行的敏感操作。其中每项操作要执行时，系统都会调用 LSM 钩子函数，以便根据不透明安全对象中存储的关于相应操作的信息来确定是否应允许执行相应操作。SELinux 针对这些钩子以及这些安全对象的管理提供了相应的实现，该实现可结合自己的政策来决定是否允许相应访问。</p>
<p>通过结合使用其他 Android 安全措施，Android 的访问控制政策能够大大降低遭到入侵的计算机和帐号可能蒙受的损失。Android 的自主访问控制和强制访问控制等工具可为您提供一种结构，确保您的软件仅以最低权限级别运行。这样可降低攻击造成的影响，并降低错误进程重写数据甚至是传输数据的可能性。</p>
<p>在 Android 4.3 及更高版本中，SELinux 开始为传统的自主访问控制 (DAC) 环境提供强制访问控制 (MAC) 保护功能。例如，软件通常情况下必须以 Root 用户帐号的身份运行，才能向原始块设备写入数据。在基于 DAC 的传统 Linux 环境中，如果 Root 用户遭到入侵，攻击者便可以利用该用户身份向每个原始块设备写入数据。不过，可以使用 SELinux 为这些设备添加标签，以便被分配了 Root 权限的进程可以只向相关政策中指定的设备写入数据。这样一来，该进程便无法重写特定原始块设备之外的数据和系统设置。</p>
<p>如需更多安全威胁示例以及使用 SELinux 解决安全威胁的方法，请参阅<a href="https://source.android.com/security/selinux/implement#use_cases">用例</a>。</p>
<h4 id="2-2强制执行级别"><a href="#2-2强制执行级别" class="headerlink" title="2.2强制执行级别"></a>2.2强制执行级别</h4><p>SELinux 可以在各种模式下实现：</p>
<ul>
<li>宽容模式 - 仅记录但不强制执行 SELinux 安全政策。</li>
<li>强制模式 - 强制执行并记录安全政策。如果失败，则显示为 EPERM 错误。</li>
</ul>
<p>在选择强制执行级别时只能二择其一，您的选择将决定您的政策是采取操作，还是仅允许您收集潜在的失败事件。宽容模式在实现过程中尤其有用。</p>
<h4 id="2-3标签、规则和域"><a href="#2-3标签、规则和域" class="headerlink" title="2.3标签、规则和域"></a>2.3标签、规则和域</h4><p>SELinux 依靠标签来匹配操作和政策。标签用于决定允许的事项。套接字、文件和进程在 SELinux 中都有标签。SELinux 在做决定时需参照两点：一是为这些对象分配的标签，二是定义这些对象如何交互的政策。</p>
<p>在 SELinux 中，标签采用以下形式：<code>user:role:type:mls_level</code>，其中 type 是访问决定的主要组成部分，可通过构成标签的其他组成部分进行修改。对象会映射到类，对每个类的不同访问类型由权限表示。</p>
<p>政策规则采用以下形式：<code>allow *domains* *types*:*classes* *permissions*;</code>，其中：</p>
<ul>
<li>Domain - 一个进程或一组进程的标签。也称为域类型，因为它只是指进程的类型。</li>
<li>Type - 一个对象（例如，文件、套接字）或一组对象的标签。</li>
<li>Class - 要访问的对象（例如，文件、套接字）的类型。</li>
<li>Permission - 要执行的操作（例如，读取、写入）。</li>
</ul>
<p>使用政策规则时将遵循的结构示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow appdomain app_data_file:file rw_file_perms;</span><br></pre></td></tr></table></figure>
<p>这表示所有应用域都可以读取和写入带有 <code>app_data_file</code> 标签的文件。请注意，该规则依赖于在 <code>global_macros</code> 文件中定义的宏，您还可以在 <code>te_macros</code> 文件中找到一些其他非常实用的宏。其中提供了一些适用于常见的类、权限和规则分组的宏。应尽可能使用这些宏，以便降低因相关权限被拒而导致失败的可能性。这些宏文件位于 <a href="https://android.googlesource.com/platform/system/sepolicy/">system/sepolicy</a> 目录中。在 Android 8.0 及更高版本中，它们与其他受支持的公共 sepolicy 一起位于 <code>public</code> 子目录中。</p>
<p>除了在规则中逐个列出域或类型之外，还可以通过属性引用一组域或类型。简单来说，属性是一组域或类型的名称。每个域或类型都可以与任意数量的属性相关联。当编写的规则指定了某个属性名称时，该名称会自动扩展为列出与该属性关联的所有域或类型。例如，domain 属性与所有进程域相关联，file_type 属性与所有文件类型相关联。</p>
<p>使用上述语法可以创建构成 SELinux 政策基本内容的 avc 规则。规则采用以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RULE_VARIANT SOURCE_TYPES TARGET_TYPES : CLASSES PERMISSIONS</span><br></pre></td></tr></table></figure>
<p>该规则指明了，当带有任何 source_types 标签的主体尝试对包含任何 classes 类且带有 target_types 标签的对象执行与任何 permissions 对应的操作时，应该发生什么情况。这些规则的一个最常见示例是 allow 规则，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow domain null_device:chr_file &#123; open &#125;;</span><br></pre></td></tr></table></figure>
<p>该规则允许具有与 <code>domain</code> 属性关联的任何 domain 的进程对 target_type 标签为 <code>null_device</code> 的 class <code>chr_file</code>（字符设备文件）的对象执行 permission <code>open</code> 所描述的操作。在实践中，该规则可能会扩展，包含其他权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow domain null_device:chr_file &#123; getattr open read ioctl lock append write&#125;;</span><br></pre></td></tr></table></figure>
<p>当了解到 <code>domain</code> 是分配给所有进程域的属性，并且 <code>null_device</code> 是字符设备 <code>/dev/null</code> 的标签时，该规则基本上会允许对 <code>/dev/null</code> 进行读写操作。</p>
<p>一个 domain 通常对应一个进程，而且具有与其关联的标签。</p>
<p>例如，典型的 Android 应用会在自己的进程中运行，并且具有 <code>untrusted_app</code> 标签（用于向其授予特定受限权限）。</p>
<p>系统中内置的平台应用会以单独的标签运行，并会被授予一组不同的权限。作为核心 Android 系统的一部分，系统 UID 应用以表示另一组权限的 <code>system_app</code> 标签运行。</p>
<p>在任何情况下，都不应直接允许域访问以下通用标签；而应为一个或多个对象创建一个更具体的类型：</p>
<ul>
<li><code>socket_device</code></li>
<li><code>device</code></li>
<li><code>block_device</code></li>
<li><code>default_service</code></li>
<li><code>system_data_file</code></li>
<li><code>tmpfs</code></li>
</ul>
<h3 id="3-实现-SELinux"><a href="#3-实现-SELinux" class="headerlink" title="3.实现 SELinux"></a>3.实现 SELinux</h3><p>SELinux 被设置为“默认拒绝”模式，这表示，对于在内核中存在钩子的每一次访问，都必须获得政策的明确许可。这意味着政策文件中包含规则、类型、类、权限等方面的大量信息。关于 SELinux 的完整注意事项不在本文档的讨论范围之内，现在您必须要了解的是在启动新的 Android 设备时如何编写政策规则。目前有大量关于 SELinux 的信息可供您参考。关于建议的资源，请参阅<a href="https://source.android.com/security/selinux#supporting_documentation">支持文档</a>。</p>
<h4 id="3-1关键文件"><a href="#3-1关键文件" class="headerlink" title="3.1关键文件"></a>3.1关键文件</h4><p>如需启用 SELinux，请集成<a href="https://android.googlesource.com/kernel/common/">最新的 Android 内核</a>，然后整合 <a href="https://android.googlesource.com/platform/system/sepolicy/">system/sepolicy</a> 目录中的文件。这些文件在编译后会包含 SELinux 内核安全政策，并涵盖上游 Android 操作系统。</p>
<p>通常情况下，您不能直接修改 <code>system/sepolicy</code> 文件，但您可以添加或修改自己的设备专用政策文件（位于 <code>/device/manufacturer/device-name/sepolicy</code> 目录中）。在 Android 8.0 及更高版本中，您对这些文件所做的更改只会影响供应商目录中的政策。如需详细了解 Android 8.0 及更高版本中的公共 sepolicy 分离，请参阅<a href="https://source.android.com/security/selinux/customize#android-o">在 Android 8.0 及更高版本中自定义 SEPolicy</a>。无论是哪个 Android 版本，您都仍需要修改以下文件：</p>
<h4 id="3-2政策文件"><a href="#3-2政策文件" class="headerlink" title="3.2政策文件"></a>3.2政策文件</h4><p>以 <code>*.te</code> 结尾的文件是 SELinux 政策源代码文件，用于定义域及其标签。您可能需要在 <code>/device/manufacturer/device-name/sepolicy</code> 中创建新的政策文件，但您应尽可能尝试更新现有文件。</p>
<h4 id="3-3上下文的描述文件"><a href="#3-3上下文的描述文件" class="headerlink" title="3.3上下文的描述文件"></a>3.3上下文的描述文件</h4><p>您可以在上下文的描述文件中为您的对象指定标签。</p>
<ul>
<li><code>file_contexts</code> 用于为文件分配标签，并且可供多种用户空间组件使用。在创建新政策时，请创建或更新该文件，以便为文件分配新标签。如需应用新的 <code>file_contexts</code>，请重新构建文件系统映像，或对要重新添加标签的文件运行 <code>restorecon</code>。在升级时，对 <code>file_contexts</code> 所做的更改会在升级过程中自动应用于系统和用户数据分区。此外，您还可以通过以下方式使这些更改在升级过程中自动应用于其他分区：在以允许读写的方式装载相应分区后，将 <code>restorecon_recursive</code> 调用添加到 init.board.rc 文件中。</li>
<li><code>genfs_contexts</code> 用于为不支持扩展属性的文件系统（例如，<code>proc</code> 或 <code>vfat</code>）分配标签。此配置会作为内核政策的一部分进行加载，但更改可能对内核 inode 无效。要全面应用更改，您需要重新启动设备，或卸载并重新装载文件系统。此外，通过使用 <code>context=mount</code> 选项，您还可以为装载的特定系统文件（例如 <code>vfat</code>）分配特定标签。</li>
<li><code>property_contexts</code> 用于为 Android 系统属性分配标签，以便控制哪些进程可以设置这些属性。在启动期间，<code>init</code> 进程会读取此配置。</li>
<li><code>service_contexts</code> 用于为 Android Binder 服务分配标签，以便控制哪些进程可以为相应服务添加（注册）和查找（查询）Binder 引用。在启动期间，<code>servicemanager</code> 进程会读取此配置。</li>
<li><code>seapp_contexts</code> 用于为应用进程和 <code>/data/data</code> 目录分配标签。在每次应用启动时，<code>zygote</code> 进程都会读取此配置；在启动期间，<code>installd</code> 会读取此配置。</li>
<li><code>mac_permissions.xml</code> 用于根据应用签名和应用软件包名称（后者可选）为应用分配 <code>seinfo</code> 标记。随后，分配的 <code>seinfo</code> 标记可在 <code>seapp_contexts</code> 文件中用作密钥，以便为带有该 <code>seinfo</code> 标记的所有应用分配特定标签。在启动期间，<code>system_server</code> 会读取此配置。</li>
</ul>
<h4 id="3-4-BoardConfig-mk-makefile"><a href="#3-4-BoardConfig-mk-makefile" class="headerlink" title="3.4 BoardConfig.mk makefile"></a>3.4 BoardConfig.mk makefile</h4><p>修改或添加政策文件和上下文的描述文件后，请更新您的 <code>/device/manufacturer/device-name/BoardConfig.mk</code>makefile 以引用 <code>sepolicy</code> 子目录和每个新的政策文件。如需详细了解 <code>BOARD_SEPOLICY</code> 变量，请参阅 <a href="https://android.googlesource.com/platform/system/sepolicy/+/master/README"><code>system/sepolicy/README</code> 文件</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOARD_SEPOLICY_DIRS +&#x3D; \</span><br><span class="line">        &lt;root&gt;&#x2F;device&#x2F;manufacturer&#x2F;device-name&#x2F;sepolicy</span><br><span class="line"></span><br><span class="line">BOARD_SEPOLICY_UNION +&#x3D; \</span><br><span class="line">        genfs_contexts \</span><br><span class="line">        file_contexts \</span><br><span class="line">        sepolicy.te</span><br></pre></td></tr></table></figure>
<p>重新进行构建后，您的设备会启用 SELinux。现在，您可以根据您向 Android 操作系统添加的内容自定义 SELinux 政策（如<a href="https://source.android.com/security/selinux/customize">自定义</a>中所述），也可以验证现有设置（如<a href="https://source.android.com/security/selinux/validate">验证</a>中所述）。</p>
<p>在新政策文件和 BoardConfig.mk 更新部署到位后，新政策设置会自动内置到最终的内核政策文件中。如需详细了解如何在设备上构建 sepolicy，请参阅<a href="https://source.android.com/security/selinux/build">构建 sepolicy</a>。</p>
<h4 id="3-5-实现"><a href="#3-5-实现" class="headerlink" title="3.5 实现"></a>3.5 实现</h4><p>如需开始使用 SELinux，请执行以下操作：</p>
<ol>
<li><p>在内核中启用 SELinux：<code>CONFIG_SECURITY_SELINUX=y</code></p>
</li>
<li><p>更改 kernel_cmdline 参数，以便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOARD_KERNEL_CMDLINE :&#x3D; androidboot.selinux&#x3D;permissive</span><br></pre></td></tr></table></figure>
<p>这仅适用于初始制定设备政策的情况。在拥有初始引导程序政策后，请移除此参数，以便将设备恢复强制模式，否则设备将无法通过 CTS 验证。</p>
</li>
<li><p>以宽容模式启动系统，看看在启动时会遇到哪些拒绝事件：</p>
<p>在 Ubuntu 14.04 或更高版本中，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell su -c dmesg | grep denied | audit2allow -p out&#x2F;target&#x2F;product&#x2F;BOARD&#x2F;root&#x2F;sepolicy</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu 12.04 中，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull &#x2F;sys&#x2F;fs&#x2F;selinux&#x2F;policy</span><br><span class="line">adb logcat -b all | audit2allow -p policy</span><br></pre></td></tr></table></figure></li>
<li><p>评估与以下内容类似的警告的输出：<code>init: Warning! Service name needs a SELinux domain defined; please fix!</code>。如需查看相关说明和工具，请参阅<a href="https://source.android.com/security/selinux/validate">验证</a>。</p>
</li>
<li><p>标识设备以及需要添加标签的其他新文件。</p>
</li>
<li><p>为您的对象使用现有标签或新标签。查看 <code>*_contexts</code> 文件，了解之前是如何为内容添加标签的，然后根据对标签含义的了解分配一个新标签。这个标签最好是能够融入到政策中的现有标签，但有时也需要使用新标签，而且还需要提供关于访问该标签的规则。将您的标签添加到相应的上下文的描述文件中。</p>
</li>
<li><p>标识应该拥有自己的安全域的域/进程。您可能需要为每一项分别编写一个全新的政策。例如，从</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init</span><br></pre></td></tr></table></figure>


<p>   衍生的所有服务都应该有自己的安全域。以下命令有助于查看保持运行的服务（不过所有服务都需要如此处理）：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell su -c ps -Z | grep init</span><br></pre></td></tr></table></figure>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell su -c dmesg | grep &#39;avc: &#39;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li><p>查看 <code>init.device.rc</code> 以发现没有域类型的域。请在开发过程早期为其提供相应的域，以避免向 <code>init</code> 添加规则或将 <code>init</code> 访问权限与其自身政策中的访问权限混淆。</p>
</li>
<li><p>设置 <code>BOARD_CONFIG.mk</code> 以使用 <code>BOARD_SEPOLICY_*</code> 变量。如需详细了解如何进行此项设置，请参阅 <code>system/sepolicy</code> 中的 <a href="https://android.googlesource.com/platform/system/sepolicy/+/master/README">README</a>。</p>
</li>
<li><p>检查 init.device.rc 和 fstab.device 文件，确保每一次使用 <code>mount</code> 都对应一个添加了适当标签的文件系统，或者指定了 <code>context= mount</code> 选项。</p>
</li>
<li><p>查看每个拒绝事件，并创建 SELinux 政策来妥善处理每个拒绝事件。请参阅<a href="https://source.android.com/security/selinux/customize">自定义</a>中的示例。</p>
</li>
</ol>
<p>建议从 AOSP 中的政策入手，然后在这些政策的基础上创建自己的自定义政策。要详细了解政策策略以及其中一些步骤，请参阅<a href="https://source.android.com/security/selinux/device-policy">编写 SELinux 政策</a>。</p>
<h4 id="3-6-用例"><a href="#3-6-用例" class="headerlink" title="3.6 用例"></a>3.6 用例</h4><p>下面列举了一些在开发软件以及制定关联的 SELinux 政策时需要注意的具体漏洞：</p>
<p><strong>符号链接</strong> - 由于符号链接以文件形式显示，因此系统通常将其作为文件进行读取，而这可能会导致漏洞。例如，某些特权组件（例如 <code>init</code>）会更改某些文件的权限，有时会使之极度开放。</p>
<p>这样一来，攻击者便可以将这些文件替换成指向其控制的代码的符号链接，从而重写任意文件。但如果您知道自己的应用绝不会遍历符号链接，则可以通过 SELinux 来禁止您的应用遍历符号链接。</p>
<p><strong>系统文件</strong> - 以应该只有系统服务器可以修改的一系列系统文件为例。由于 <code>netd</code>、<code>init</code> 和 <code>vold</code> 是以 Root 身份运行的，因此它们也可以访问这些系统文件。这样一来，如果 <code>netd</code> 遭到入侵，这些文件乃至系统服务器本身都可能遭到入侵。</p>
<p>借助 SELinux，您可以将这些文件标识为系统服务器数据文件。这样一来，系统服务器就是唯一对这些文件具有读写权限的域。即使 <code>netd</code> 遭到入侵，它也无法将域切换到系统服务器域并访问这些系统文件，就算它是以 Root 身份运行的也是如此。</p>
<p><strong>应用数据</strong> - 另一个示例是必须以 Root 身份运行但不应获得应用数据访问权限的一系列函数。这一项非常有用，因为它可以做出广泛的声明，例如禁止与应用数据无关的特定域访问互联网。</p>
<p><strong>setattr</strong> - 对于 <code>chmod</code> 和 <code>chown</code> 等命令，您可以标识关联域可以在哪些文件中进行 <code>setattr</code> 操作。这样一来，便可以禁止对这些文件之外的任何文件进行这类更改，即使以 Root 身份进行也不例外。因此，应用可以对带 <code>app_data_files</code> 标签的文件运行 <code>chmod</code> 和 <code>chown</code>，但不能对带 <code>shell_data_files</code> 或 <code>system_data_files</code> 标签的文件运行这些命令。</p>
]]></content>
      <categories>
        <category>Android Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SeLinux</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo引入图床，手机和web不显示图片的问题</title>
    <url>/2021/03/23/%E8%A7%A3%E5%86%B3hexo%E5%BC%95%E5%85%A5%E5%9B%BE%E5%BA%8A%EF%BC%8C%E6%89%8B%E6%9C%BA%E5%92%8Cweb%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>hexo引入图片的方式有很多种：</p>
<ul>
<li>从本地文件加载，方法参见参考文献一。</li>
<li>使用图床，markdown中直接引用图床的链接。</li>
</ul>
<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>Hexo使用图床的方式加载在blog中加载图片，会在非本人的电脑或者手机端报“html访问图片资源403问题(http referrer)”，导致采用图床方式加载的图片全部无法加载。</p>
<h3 id="2-问题原因"><a href="#2-问题原因" class="headerlink" title="2.问题原因"></a>2.问题原因</h3><p>http请求体的header中有一个referrer字段，用来表示发起http请求的源地址信息，这个referrer信息是可以省略但是不可修改的，就是说你只能设置是否带上这个referrer信息，不能定制referrer里面的值。</p>
<p>服务器端在拿到这个referrer值后就可以进行相关的处理，比如图片资源，可以通过referrer值判断请求是否来自本站，若不是则返回403或者重定向返回其他信息，从而实现图片的防盗链。上面出现403就是因为，请求的是别人服务器上的资源，但把自己的referrer信息带过去了，被对方服务器拦截返回了403。</p>
<p>在前端可以通过meta来设置referrer policy(来源策略)，具体可以设置哪些值以及对应的结果参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy">这里</a>。所以针对上面的403情况的解决方法，就是把referrer设置成<code>no-referrer</code>，这样发送请求不会带上referrer信息，对方服务器也就无法拦截了。</p>
<p>浏览器中referrer默认的值是<code>no-referrer-when-downgrade</code>，就是除了降级请求的情况以外都会带上referrer信息。降级请求是指https协议的地址去请求http协议，所以上面403的情况还有另一种解决方法就是，请求的图片地址换成http协议，自己的地址使用http协议，这样降级请求也不会带上referrer。</p>
<h3 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h3><h4 id="3-1-butterfly主题"><a href="#3-1-butterfly主题" class="headerlink" title="3.1 butterfly主题"></a>3.1 butterfly主题</h4><p>在G:\blog\themes\butterfly\layout\includes目录下有一个head.pug文件，修改该文件的meta信息，会使生成的所有页面都带有该head。在head.pug文件中添加如下内容，结果参见图片。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">meta(name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1b07689b2e132b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="butterfly添加头.png"></p>
<h4 id="3-2-yilia主题"><a href="#3-2-yilia主题" class="headerlink" title="3.2 yilia主题"></a>3.2 yilia主题</h4><p>在G:\blog\themes\yilia\layout_partial目录下有一个head.ejs，同样在head.ejs文件中添加如下meta信息即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>


<h3 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用hexo g 重新生成一下工程</span><br></pre></td></tr></table></figure>
<p>在G:\blog\public\2021目录下就是所有21年生成的blog，找到该目录下的任意一个index.html，用文本编辑器打开就可以看到已经自动生成了referrer标签了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-56e5002b6d7d74d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成的html中包含有referrer头.png"></p>
<p>然后使用hexo d指令将工程同步到github即可</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://blog.csdn.net/qq_38148394/article/details/79997971">1. 加载本地图片的方法</a></p>
<p><a href="https://www.jianshu.com/p/56df73d0d128">2. html访问图片资源403问题(http referrer)</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ndk工具编译so库问题</title>
    <url>/2021/04/02/%E8%A7%A3%E5%86%B3ndk%E5%B7%A5%E5%85%B7%E7%BC%96%E8%AF%91so%E5%BA%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>使用ndk-build编译so库的时候，控制台会报</p>
<blockquote>
<p>Android NDK: Could not find application project directory !<br>Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.<br>F:\Sdk\ndk-bundle\build\..\build\core\build-local.mk:151: *** Android NDK: Aborting    .  Stop.</p>
</blockquote>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>见文献1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//在&lt;工程path&gt;/app目录</span><br><span class="line">// your_project_path是jni的目录，注意，目录一定要是jni,在AS中自动存放cpp文件的是cpp目录，需要改成jni才可以编译。</span><br><span class="line">ndk-build -C your_project_path</span><br></pre></td></tr></table></figure>


<h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote>
<p>Android NDK: WARNING: APP_PLATFORM android-16 is higher than android:minSdkVersion 1 in G:/android_project/PlatformService_X5R/app/src/main/AndroidManifest.xml. NDK binaries will <em>not</em> be compatible with devices older than android-1.6<br>See <a href="https://android.googlesource.com/platform/ndk/+/master/docs/user/common_problems.md">https://android.googlesource.com/platform/ndk/+/master/docs/user/common_problems.md</a> for more information.</p>
</blockquote>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>在Application.mk文件中加</p>
<blockquote>
<p>APP_PLATFORM := android-16</p>
</blockquote>
<p><strong>参考文献</strong></p>
<p><a href="https://stackoverflow.com/questions/14156596/ndk-cant-find-the-application-directory">解决：Could not find application project directory</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>调查车机无法上网</title>
    <url>/2021/04/01/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<p><a href="https://gw.tai.qq.com/">https://gw.tai.qq.com/</a></p>
<p>112.53.1.114</p>
<p><strong>1. 修改系统时间</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 默认格式MMDDhhmm[[CC]YY][.ss]</span><br><span class="line">date 040912542021.30 </span><br></pre></td></tr></table></figure>


<p><strong>2. ifconfig</strong></p>
<p>查看网卡是否已经起来了。</p>
<p>A55 Tbox网卡是usb0</p>
<p>与QNX交互的网卡是eth0</p>
<p>//启动网卡</p>
<p># ifconfig eth0 up</p>
<p>//设置IP</p>
<p># ifconfig eth0 192.168.1.2</p>
<p>//开启混杂模式的命令是：</p>
<p># ifconfig usb0 promisc</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/AB78C433C65E457EA6A8BD09446FB633/1017" alt="0"></p>
<p>开启混杂模式的命令是：ifconfig usb0 promisc</p>
<p><strong>3.ping 百度</strong></p>
<p>如果ping不通，如下图，可能是DNS问题</p>
<p><img src="/2021/04/01/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/blog\source_posts\调查车机无法上网\ping百度排查dns问题.png" alt="ping百度排查dns问题"></p>
<p><strong>4.ping 百度的ip</strong></p>
<p>//指定使用wlan0 ping百度</p>
<p># ping -I wlan0 183.232.231.172 </p>
<p>如果能ping通，说明就是DNS问题</p>
<p><strong>5.netstat</strong></p>
<p>//查看所有对应进程的网络连接情况</p>
<p># netstat -ap </p>
<p>//监听该设备的网络访问情况</p>
<p># ip monitor dev eth0</p>
<p><strong>6.路由表</strong></p>
<p># netstat -r</p>
<p># cat /proc/net/route</p>
<p>//查看路由表</p>
<p>msmnile_gvmq:/ # ip route</p>
<p>172.20.10.0/28 dev wlan0 proto kernel scope link src 172.20.10.7</p>
<p>192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</p>
<p>224.224.224.245 dev eth0 scope link</p>
<p>//查看具体的路由表</p>
<p>msmnile_gvmq:/ # ip route list table wlan0</p>
<p>default via 172.20.10.1 dev wlan0 proto static</p>
<p>172.20.10.0/28 dev wlan0 proto static scope link</p>
<p>// 添加路由表</p>
<p># ip route add default dev wlan0</p>
<p>//删除该路由表</p>
<p># ip route del default dev wlan0</p>
<p>如下表示172.20.10.0网段的ip都走wlan0网卡</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/9335E7756ECF45909C5F1624D51FBA1D/1016" alt="0"></p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/5AD0A765F78244AE8BAB901FEC33DFBE/1021" alt="0"></p>
<p><strong>路由规则</strong></p>
<p># ip rule</p>
<p># ip rule add from all fwmark 0x0/0xffff iif lo lookup wlan0 prio 22000</p>
<p># ip rule del</p>
<p><strong>DNS</strong></p>
<p>查看对应网络设备的DNS，每个设备一个DNS</p>
<p>msmnile_gvmq:/ # getprop|grep wlan0</p>
<p><strong>连上wifi后正常配置示例</strong></p>
<p>msmnile_gvmq:/ # getprop|grep wlan0</p>
<p>msmnile_gvmq:/ # ip route</p>
<p>172.20.10.0/28 dev wlan0 proto kernel scope link src 172.20.10.7</p>
<p>192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</p>
<p>224.224.224.245 dev eth0 scope link</p>
<p>msmnile_gvmq:/ # ip route list table wlan0</p>
<p>default via 172.20.10.1 dev wlan0 proto static</p>
<p>172.20.10.0/28 dev wlan0 proto static scope link</p>
<p>msmnile_gvmq:/ # ip rule</p>
<p>0:   from all lookup local</p>
<p>9998:  from all lookup main</p>
<p>9999:  from all lookup main</p>
<p>10000: from all fwmark 0xc0000/0xd0000 lookup legacy_system</p>
<p>10500: from all iif lo oif dummy0 uidrange 0-0 lookup dummy0</p>
<p>10500: from all iif lo oif wlan0 uidrange 0-0 lookup wlan0</p>
<p>13000: from all fwmark 0x10063/0x1ffff iif lo lookup local_network</p>
<p>13000: from all fwmark 0x10066/0x1ffff iif lo lookup wlan0</p>
<p>14000: from all iif lo oif dummy0 lookup dummy0</p>
<p>14000: from all iif lo oif wlan0 lookup wlan0</p>
<p>15000: from all fwmark 0x0/0x10000 lookup legacy_system</p>
<p>16000: from all fwmark 0x0/0x10000 lookup legacy_network</p>
<p>17000: from all fwmark 0x0/0x10000 lookup local_network</p>
<p>19000: from all fwmark 0x66/0x1ffff iif lo lookup wlan0</p>
<p>22000: from all fwmark 0x0/0xffff iif lo lookup wlan0</p>
<p>32000: from all unreachable</p>
<p>logcat -G 200M</p>
<p>logcat -v time | grep -iE -v ‘CAR|tsrsdk|Hidl|VHAL|hvsm|vehicle’</p>
<p>logcat -v time | grep -iE -v ‘CAR|tsrsdk|Hidl|VHAL|hvsm|vehicle’ &gt; /data/net2021.log</p>
<p><strong>A55 CS版本wifi不能上网问题排查</strong></p>
<p><strong>问题描述：</strong>CS版本连接wifi后，无法使用wifi上网，同步时间后可以使用。</p>
<p><strong>问题原因：</strong>eth0在A55被作为与QNX交互的虚拟网卡，在原生Android是以太网网卡，评分高于没有验证通过的WLAN，所以被当做默认上网网卡。</p>
<p>两个版本对eth0的配置有差异。</p>
<p>ES版本配置</p>
<p>​    eth1;;ip=2.2.2.2/24</p>
<p>​    eth0;;ip=192.168.1.2/24 gateway=192.168.1.1 dns=4.4.4.4,8.8.8.8</p>
<p>CS版本配置</p>
<p>​    eth0;12,13,14,15;ip=192.168.1.2/24 gateway=192.168.1.1 dns=4.4.4.4,8.8.8.8</p>
<p>CS版本采用ES版本的config仍会导致eth0的ip被清除，目前从netd及上层逻辑看无论是CS还是ES版本如果eth0没被配为INTERNET确实会被清除IP。</p>
<p>需确认ES版本vsomeipd是否有配置eth0的ip地方，而在CS版本上没有合入导致？</p>
<p><strong>临时解决：</strong>wifi验证的网址改为国内网址，使可以验证通过。</p>
<p>排查相关命令</p>
<p>logcat -v time | grep -iE “Connectivity”</p>
<p>logcat -v time | grep -iE “NetworkMonitor|ConnectivityService|NetworkFactory|yangx|CommandListener”</p>
<p>mount -o rw,remount /</p>
<p>网络配置文件</p>
<p>vi device/qcom/msmnile_gvmq/overlay/frameworks/base/core/res/res/values/config.xml</p>
<p>cd frameworks/base/services/core/java/com/android/server</p>
<p><strong>git指令</strong></p>
<p>查看ES与CS分支差异</p>
<p>git diff origin/cauchy-falcon-wukong origin/cauchy_p-falcon-wukong-LA.AU.0.0.1_rb2.16 IpClient.java</p>
<p>git log -p 指定文件</p>
<p>设置IP log</p>
<p>D/CommandListener( 377): Setting iface cfg</p>
<p>清除IP log</p>
<p>D/CommandListener( 315): Clearing all IP addresses on eth0</p>
<p>切换默认网络 log</p>
<p>D/ConnectivityService( 808): Switching to new default network:</p>
<p>修改获取settings值</p>
<p>settings put global disable_static_ip_assignment 1</p>
<p>settings list global | grep disable_static_ip_assignment</p>
<p><strong>网络评分机制：</strong></p>
<p>Wifi初始分值为60（WifiStateMachine.java）； </p>
<p>Ethernet初始分值为70（EthernetNetworkFactory.java）； </p>
<p>Mobile network初始分值为50（DataConnection.java）； </p>
<p>bt-pan初始分值为69（BluetoothTetheringNetworkFactory.java）： </p>
<p>当网络与internet不通时，分值减去40</p>
<p>如果用户指定，直接返回100</p>
<p><strong>网络优先级设置</strong></p>
<p>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/">frameworks</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/">base</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/">core</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/">res</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/">res</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/values/">values</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/values/config.xml">config.xml</a></p>
<p>会被device/qcom/msmnile_gvmq/overlay/frameworks/base/core/res/res/values/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/values/config.xml">config.xml</a>覆盖</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/5BC4AEC6991443E983498E6AA22F9F99/1020" alt="0"></p>
<p>网卡配置</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/9B8F39D556FA4051925AF1B7FC00E447/1018" alt="0"></p>
<p><strong>X5R项目：</strong></p>
<p>eth0网卡配置取消网络能力12 13 14 15</p>
<p>配置规则：</p>
<p>ip rule add from 192.168.1.3 table 100<br>ip rule add to 192.168.1.1 table 100<br>ip route add 192.168.1.0/24 dev eth0 src 192.168.1.3 table 100</p>
<p>拉起浏览器界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">am start -a android.intent.action.VIEW -d http://www.baidu.com</span><br></pre></td></tr></table></figure>


<h4 id="双APN配置："><a href="#双APN配置：" class="headerlink" title="双APN配置："></a>双APN配置：</h4><p><img src="/2021/04/01/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/blog\source_posts\调查车机无法上网\双APN配置.png" alt="双APN配置"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>车机无法上网</tag>
      </tags>
  </entry>
  <entry>
    <title>网络能力理解(NetworkCapabilities)</title>
    <url>/2021/04/06/%E7%BD%91%E7%BB%9C%E8%83%BD%E5%8A%9B%E7%90%86%E8%A7%A3-NetworkCapabilities/</url>
    <content><![CDATA[<p>声明: 以下枚举值基于Android Api 30</p>
<p>NetworkCapabilities这个类取代了旧版的TYPE_MOBILE网络选择，当一个更快没有风险的网络出现，且一个应用需要这个网络时，就切换到该网络，而不是继续连接WIFI；类似的，当一个应用需要批量上传文件，需要不计量网络的时候，应该切换到wifi传输。</p>
<h3 id="1-网络能力枚举"><a href="#1-网络能力枚举" class="headerlink" title="1.网络能力枚举"></a>1.网络能力枚举</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该网络能连接到运营商MMSC服务器，可以用来接收和发送彩信</span></span><br><span class="line">NET_CAPABILITY_MMS = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商SUPL服务器，用户可以接收到GPS信息</span></span><br><span class="line">NET_CAPABILITY_SUPL = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的DUN服务器或者以太网网关</span></span><br><span class="line">NET_CAPABILITY_DUN = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的FOTA服务器，专门用于OTA升级</span></span><br><span class="line">NET_CAPABILITY_FOTA = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的IMS服务器，用于网络注册和信令</span></span><br><span class="line">NET_CAPABILITY_IMS = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的CBS服务器，用于运营商特定的服务</span></span><br><span class="line">NET_CAPABILITY_CBS = <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能到达WIFI直连</span></span><br><span class="line">NET_CAPABILITY_WIFI_P2P = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的初始连接服务器</span></span><br><span class="line">NET_CAPABILITY_IA = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够连接运营商的RCS服务器的网络，用于富通信服务。</span></span><br><span class="line">NET_CAPABILITY_RCS = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够连接到运营商的XCAP服务器的网络，用于配置和控制。</span></span><br><span class="line">NET_CAPABILITY_XCAP = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够到达运营商的紧急IMS服务器或其他服务的网络，用于紧急呼叫期间的网络信令。</span></span><br><span class="line">NET_CAPABILITY_EIMS = <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络未定义</span></span><br><span class="line">NET_CAPABILITY_NOT_METERED = <span class="number">11</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络应能够访问互联网。</span></span><br><span class="line">NET_CAPABILITY_INTERNET = <span class="number">12</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络可用于一般用途</span></span><br><span class="line">NET_CAPABILITY_NOT_RESTRICTED = <span class="number">13</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示用户已指示此网络的隐式信任</span></span><br><span class="line">NET_CAPABILITY_TRUSTED = <span class="number">14</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络不是VPN</span></span><br><span class="line">NET_CAPABILITY_NOT_VPN = <span class="number">15</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络上的连接已成功验证</span></span><br><span class="line">NET_CAPABILITY_VALIDATED = <span class="number">16</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络在上次探测时被发现有一个强制门户</span></span><br><span class="line">NET_CAPABILITY_CAPTIVE_PORTAL = <span class="number">17</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络不是漫游，Android 10新加</span></span><br><span class="line">NET_CAPABILITY_NOT_ROAMING = <span class="number">18</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此网络可供应用程序使用，而不是后台网络，以便于快速网络切换的网络</span></span><br><span class="line">NET_CAPABILITY_FOREGROUND = <span class="number">19</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络不是拥堵的。如果网络处于拥堵状态，应用应该将请求网络的行为延后一段时间，例如上报采集信息。</span></span><br><span class="line">NET_CAPABILITY_NOT_CONGESTED = <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络当前没有挂起。</span></span><br><span class="line"><span class="comment">// 网络被挂起:IP地址和链接都是有效的，但是暂时不能传数据，例如进入隧道，蜂窝网络暂时进入暂时丢失状态。这种网络不会被挂起，仍然可以传输数据。</span></span><br><span class="line">NET_CAPABILITY_NOT_SUSPENDED = <span class="number">21</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示通过此网络的流量由oem支付。例如，这个网络可以被系统应用程序用来上传遥测数据。</span></span><br><span class="line">NET_CAPABILITY_OEM_PAID = <span class="number">22</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够访问运营商的关键任务服务器的网络。</span></span><br><span class="line">NET_CAPABILITY_MCX = <span class="number">23</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络用于测试，仅仅提供部分连接功能</span></span><br><span class="line">NET_CAPABILITY_PARTIAL_CONNECTIVITY = <span class="number">24</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此功能将为通常已计量但当前未计量的网络设置，例如，因为用户位于特定区域。此功能可以随时更改。当它被删除时，应用程序负责停止任何不应该在按流量计费的网络上发生的数据传输。</span></span><br><span class="line">NET_CAPABILITY_TEMPORARILY_NOT_METERED = <span class="number">25</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-网络传输类型"><a href="#2-网络传输类型" class="headerlink" title="2.网络传输类型"></a>2.网络传输类型</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 表示该网络使用蜂窝流量传输</span><br><span class="line">TRANSPORT_CELLULAR &#x3D; 0,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用wifi传输</span><br><span class="line">TRANSPORT_WIFI &#x3D; 1,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用蓝牙传输</span><br><span class="line">TRANSPORT_BLUETOOTH &#x3D; 2,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用以太网传输</span><br><span class="line">TRANSPORT_ETHERNET &#x3D; 3,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用VPN传输</span><br><span class="line">TRANSPORT_VPN &#x3D; 4,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用WIFI-AWARE传输</span><br><span class="line">TRANSPORT_WIFI_AWARE &#x3D; 5,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用LoWPAN传输</span><br><span class="line">TRANSPORT_LOWPAN &#x3D; 6,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试虚拟网络接口</span><br><span class="line">TRANSPORT_TEST &#x3D; 7,</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-Apn参数组成"><a href="#3-Apn参数组成" class="headerlink" title="3.Apn参数组成"></a>3.Apn参数组成</h3><p>例：移动apn，把所有的属性都放在一起如下</p>
<p>apn carrier=”中国移动彩信 (China Mobile)”<br>mcc=”460”<br>mnc=”00”<br>apn=”cmwap”<br>proxy=”10.0.0.172”<br>port=”80”<br>mmsc=”<a href="http://mmsc.monternet.com”/">http://mmsc.monternet.com”</a><br>mmsproxy=”10.0.0.172”<br>mmsport=”80”<br>user=”mms”<br>password=”mms”<br>type=”mms”<br>authtype=”1”<br>protocol=”IPV4V6” </p>
<p><strong>其对应的属性定义如下：</strong></p>
<p>Carrier：apn的名字，可为空，只用来显示apn列表中此apn的显示名字。<br>Mcc：由三位数组成。 用于识别移动用户的所在国家;<br>Mnc：由两位或三位组成。 用于识别移动用户的归属PLMN。 MNC的长度（两位或三位数）取决于MCC的值。<br>Apn：APN网络标识（接入点名称），是APN参数中的必选组成部分。此标识由运营商分配。<br>Proxy：代理服务器的地址<br>Port：代理服务器的端口号<br>Mmsc：MMS中继服务器/多媒体消息业务中心，是彩信的交换服务器。<br>Mmsproxy：彩信代理服务器的地址<br>Mmsport：彩信代理服务器的端口号<br>Protocol：支持的协议，不配置默认为IPV4。<br>User：用户<br>Password：密码<br>Authtype：apn的认证协议，PAP为口令认证协议，是二次握手机制。CHAP是质询握手认证协议，是三次握手机制。</p>
<table>
<thead>
<tr>
<th>None</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>PAP</td>
<td>1</td>
</tr>
<tr>
<td>CHAP</td>
<td>2</td>
</tr>
<tr>
<td>PAP or CHAP</td>
<td>3</td>
</tr>
</tbody></table>
<p>Type: apn的接入点类型</p>
<table>
<thead>
<tr>
<th>Default</th>
<th>默认网络连接</th>
</tr>
</thead>
<tbody><tr>
<td>Mms</td>
<td>彩信专用连接，此连接与default类似，用于与载体的多媒体信息服务器对话的应用程序</td>
</tr>
<tr>
<td>Supl</td>
<td>是Secure User Plane Location“安全用户面定位”的简写，此连接与default类似，用于帮助定位设备与载体的安全用户面定位服务器对话的应用程序</td>
</tr>
<tr>
<td>Dun</td>
<td>Dial Up Networking拨号网络的简称，此连接与default连接类似，用于执行一个拨号网络网桥，使载体能知道拨号网络流量的应用程序</td>
</tr>
<tr>
<td>Hipri</td>
<td>高优先级网络，与default类似，但路由设置不同。只有当进程访问移动DNS服务器，并明确要求使用requestRouteToHost(int, int)才会使用此连接</td>
</tr>
</tbody></table>
<p>注意：此表中的数据连接优先级是由低到高，即default数据连接的优先级最低，而hipri数据连接的优先级最高。比如：手机上网聊天，建立的是default数据连接。如果此时接到一条彩信，由于彩信的数据连接是mms，优先级比default高，所以会先断开default数据连接，建立mms数据连接，让手机先收到彩信。所以收发彩信的同时不能上网。（单条pdp连接的情况）</p>
<p>注：mnc的位数由mcc决定。比如，墨西哥334020，此国家的mnc为020，mccmnc的值都固定在了SIM卡保存的IMSI中，配置apn参数时mnc不可简洁为20，否则apn列表中将读取不到此国家的334020运营商的参数。</p>
<h3 id="4-原生网络方案"><a href="#4-原生网络方案" class="headerlink" title="4.原生网络方案"></a>4.原生网络方案</h3><p><a href="https://blog.csdn.net/sjz4860402/article/details/78522001">UICC框架初识</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78524091">AsyncChannel的工作机制</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78531626">StateMachine状态机初识</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78532856">ConnectivityService框架初识</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78613015">路由配置信息的获取</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/79836065">ServiceStateTracker网络状态的处理</a></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>网络能力</tag>
      </tags>
  </entry>
  <entry>
    <title>网络管理(ConnectivityService)</title>
    <url>/2021/04/08/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-ConnectivityService/</url>
    <content><![CDATA[<h3 id="1-网络管理概览"><a href="#1-网络管理概览" class="headerlink" title="1.网络管理概览"></a>1.网络管理概览</h3><p>​    Android中提供的数据业务方式有几种：移动数据网络，WIFI，热点，网线等。这些数据业务本身可以独立使用，但是同一时刻，只能使用其中的一种数据业务方式。管理这些数据业务方式的使用由ConnectivityService，NetworkFactory，NetworkAgent，NetworkMonitor等来完成，ConnectivityService处于核心调度位置。</p>
<p>​    在公司项目中,引入了Tbox和车内以太网。这两类网络上网的方式主要替代原生的移动数据网络和以太网。</p>
<p>​    ConnectivityService主要和以下四个模块交互来完成网络管理：</p>
<ul>
<li>网络有效性检测（NetworkMonitor） </li>
<li>网络评分机制（NetworkFactory） </li>
<li>路由配置信息的获取（NetworkAgent） </li>
<li>网络物理端口的设置（Netd）</li>
</ul>
<p><strong>Android网络管理架构如下图所示</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f4b58a927db33e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android网络管理.png"></p>
<p>当Android数据业务服务可用时，会将自己(NetworkFactory和NetworkAgent)注册到ConnectivityService中统一管理，ConnectivityService通过ping网络来检查网络的有效性(AOSP中的网址是墙外的网址，极有可能ping不通，因此项目中应该修改此网址，否则可能会导致期望的网络得不到上网权限)，进而影响到各个数据业务方式的评分值，ConnectivityService通过这些评分值来决定以哪个数据业务方式连接网络。决定好数据业务方式后，把这些路由配置信息设置到网络物理设备中。这样我们的手机就可以正常上网了。</p>
<h3 id="2-各个服务的初始化"><a href="#2-各个服务的初始化" class="headerlink" title="2.各个服务的初始化"></a>2.各个服务的初始化</h3><h4 id="2-1-1-ConnectivityService的初始化"><a href="#2-1-1-ConnectivityService的初始化" class="headerlink" title="2.1.1 ConnectivityService的初始化"></a>2.1.1 ConnectivityService的初始化</h4><p>ConnectivityService属于系统服务，在SystemServer中被启动。</p>
<p>SystemServer启动系统核心服务分为三个阶段:</p>
<ul>
<li>启动引导服务，包含AMS PMS DMS PKMS等</li>
<li>启动核心服务：DropBox，Battery,UsageStats,WebViewUpdate等</li>
<li>启动其他服务：InputManagerService，WindowManagerService，ConnectivityService等</li>
</ul>
<p>咱们的主角ConnectivityService就是在其他服务中被启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 设置时区</span></span><br><span class="line">        String timezoneProperty =  SystemProperties.get(<span class="string">&quot;persist.sys.timezone&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Timezone not set; setting to GMT.&quot;</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.timezone&quot;</span>, <span class="string">&quot;GMT&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 设置语言，国家等等</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.get(<span class="string">&quot;persist.sys.language&quot;</span>).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.locale&quot;</span>, languageTag);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.language&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.country&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.localevar&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Here we go!</span></span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Entered the Android system server!&quot;</span>);</span><br><span class="line">        ......</span><br><span class="line">		<span class="comment">//此处省略部分主要干了清理更多内存出来为初始化服务做准备，设置后台任务，增加binder最大线程等</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">        android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize native services.</span></span><br><span class="line">        System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the system context.</span></span><br><span class="line">        <span class="comment">//创建android上下文</span></span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the system service manager.</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">        <span class="comment">//开始启动服务了   ,这个方法是启动引导服务 例如AMS PMS DMS PKMS</span></span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        <span class="comment">//启动核心服务：DropBox，Battery,UsageStats,WebViewUpdate</span></span><br><span class="line">        startCoreServices();</span><br><span class="line">        <span class="comment">//启动其他服务</span></span><br><span class="line">        startOtherServices();</span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    <span class="comment">//systemServer一直循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Context context = mSystemContext;</span><br><span class="line">        VibratorService vibrator = <span class="keyword">null</span>;</span><br><span class="line">        IStorageManager storageManager = <span class="keyword">null</span>;</span><br><span class="line">        NetworkManagementService networkManagement = <span class="keyword">null</span>;</span><br><span class="line">        NetworkStatsService networkStats = <span class="keyword">null</span>;</span><br><span class="line">        NetworkPolicyManagerService networkPolicy = <span class="keyword">null</span>;</span><br><span class="line">        ConnectivityService connectivity = <span class="keyword">null</span>;</span><br><span class="line">        NetworkScoreService networkScore = <span class="keyword">null</span>;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化NetworkManagementService</span></span><br><span class="line">        <span class="keyword">if</span> (!disableNetwork) &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartNetworkManagementService&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                networkManagement = NetworkManagementService.create(context);</span><br><span class="line">                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">&quot;starting NetworkManagement Service&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            traceEnd();</span><br><span class="line">        &#125;</span><br><span class="line">   		 ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化NetworkStatsService</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartNetworkStatsService&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            networkStats = NetworkStatsService.create(context, networkManagement);</span><br><span class="line">            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;starting NetworkStats Service&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 初始化NetworkPolicyManagerService</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartNetworkPolicyManagerService&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            networkPolicy = <span class="keyword">new</span> NetworkPolicyManagerService(context,</span><br><span class="line">                              mActivityManagerService, networkStats, networkManagement);</span><br><span class="line">            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;starting NetworkPolicy Service&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">            </span><br><span class="line">    	<span class="comment">// 初始化ConnectivityService</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartConnectivityService&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectivity = <span class="keyword">new</span> ConnectivityService(</span><br><span class="line">                context, networkManagement, networkStats, networkPolicy);</span><br><span class="line">            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);</span><br><span class="line">            networkStats.bindConnectivityManager(connectivity);</span><br><span class="line">            networkPolicy.bindConnectivityManager(connectivity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;starting Connectivity Service&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化ConnectivityService的时候传入networkManagement，networkStats，networkPolicy。</p>
<h4 id="2-1-2-获取其他服务的接口"><a href="#2-1-2-获取其他服务的接口" class="headerlink" title="2.1.2 获取其他服务的接口"></a>2.1.2 获取其他服务的接口</h4><p>ConnectivityService构造方法中接收交互服务的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mNetd = checkNotNull(netManager, <span class="string">&quot;missing INetworkManagementService&quot;</span>);</span><br><span class="line">mStatsService = checkNotNull(statsService, <span class="string">&quot;missing INetworkStatsService&quot;</span>);</span><br><span class="line">mPolicyManager = checkNotNull(policyManager, <span class="string">&quot;missing INetworkPolicyManager&quot;</span>);</span><br><span class="line">mPolicyManagerInternal = checkNotNull(</span><br><span class="line">LocalServices.getService(NetworkPolicyManagerInternal.class),</span><br><span class="line"><span class="string">&quot;missing NetworkPolicyManagerInternal&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建mTethering</span></span><br><span class="line">mTethering = <span class="keyword">new</span> Tethering(mContext, mNetd, statsService, mPolicyManager,</span><br><span class="line">IoThread.get().getLooper(), <span class="keyword">new</span> MockableSystemProperties());</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册其他必要的监听和广播，以便接收变化信息和通知变化信息。</span></span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_STARTED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_STOPPED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_ADDED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_REMOVED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_UNLOCKED);</span><br><span class="line">mContext.registerReceiverAsUser(</span><br><span class="line">    mUserIntentReceiver, UserHandle.ALL, intentFilter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">mContext.registerReceiverAsUser(mUserPresentReceiver, UserHandle.SYSTEM,</span><br><span class="line">    <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_PRESENT), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向netd注册mTethering</span></span><br><span class="line">mNetd.registerObserver(mTethering);</span><br><span class="line">mNetd.registerObserver(mDataActivityObserver);</span><br></pre></td></tr></table></figure>


<h4 id="2-2-NetworkFactory的初始化"><a href="#2-2-NetworkFactory的初始化" class="headerlink" title="2.2  NetworkFactory的初始化"></a>2.2  NetworkFactory的初始化</h4><p>NetworkFactory负责构建新增网络默认评分，网络类型，网络能力。为了车机启动起来就能按照网络评分机制来选择网络，ConnectivityService服务起来之后，就不断收集外部注册进来的网络(本文用Tbox注册网络和wifi注册网络来叙述)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-44f70a21b2d72c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NetworkFactory初始化.png"></p>
<p>当管理Tbox的service起来之后，通过获取usb0(tbox通过usb0与车机通信)配置信息(usb0;12,13,14,15;ip=2.2.2.1/24 gateway=2.2.2.2 dns=116.116.116.116,8.8.8.8;0;70)。然后解析配置信息，解析获取网卡信息之后，创建一个NetworkFactory最后调用register()方法，将该网卡注册到ConnectivityService中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NetworkFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.log(<span class="string">&quot;Registering NetworkFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mMessenger == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">this</span>);</span><br><span class="line">        ConnectivityManager.from(<span class="keyword">this</span>.mContext).registerNetworkFactory(<span class="keyword">this</span>.mMessenger, </span><br><span class="line">                                                                       <span class="keyword">this</span>.LOG_TAG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConnectivityService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerNetworkFactory</span><span class="params">(Messenger messenger, String name)</span> </span>&#123;</span><br><span class="line">    enforceConnectivityInternalPermission();</span><br><span class="line">    NetworkFactoryInfo nfi = <span class="keyword">new</span> NetworkFactoryInfo(name, messenger, <span class="keyword">new</span> AsyncChannel());</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_FACTORY, nfi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理EVENT_REGISTER_NETWORK_FACTORY</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRegisterNetworkFactory</span><span class="params">(NetworkFactoryInfo nfi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) log(<span class="string">&quot;Got NetworkFactory Messenger for &quot;</span> + nfi.name);</span><br><span class="line">    mNetworkFactoryInfos.put(nfi.messenger, nfi);</span><br><span class="line">    <span class="comment">//通过asyncChannel通知Networkfactory操作成功</span></span><br><span class="line">    <span class="comment">//注意，在异步回复Networkfactory的时候，asyncChannel会处理CMD_CHANNEL_HALF_CONNECTED来通知创建NetworkAgent</span></span><br><span class="line">    nfi.asyncChannel.connect(mContext, mTrackerHandler, nfi.messenger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-NetworkAgent的初始化"><a href="#2-3-NetworkAgent的初始化" class="headerlink" title="2.3 NetworkAgent的初始化"></a>2.3 NetworkAgent的初始化</h4><p>NetworkAgent是一个网络代理，它里面保存了一些路由的配置信息，比如NetworkInfo，LinkProperties，NetworkCapabilities等。NetworkAgent的初始化都是在路由配置信息获取成功之后。比如打开数据开关，打开wifi开关等操作之后。</p>
<p>注：<br>NetworkInfo 描述一个给定类型的网络接口的状态方面的信息，包括网络连接状态、网络类型、网络可连接性、是否漫游等信息<br>LinkProperties 描述一个网络连接属性信息（包含网络地址、网关、DNS、HTTP代理等属性信息<br>NetworkCapabilities 描述一个网络连接能力方面的信息，包括带宽、延迟等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理CMD_CHANNEL_HALF_CONNECTED </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">maybeHandleAsyncChannelMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">         <span class="keyword">case</span> AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: &#123;</span><br><span class="line">             <span class="comment">// 向NetworkFactory发送路由配置成功了，可以创建NetworkAgent代理了。</span></span><br><span class="line">             handleAsyncChannelHalfConnect(msg);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        ......</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleAsyncChannelHalfConnect</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    AsyncChannel ac = (AsyncChannel) msg.obj;</span><br><span class="line">    <span class="keyword">if</span> (mNetworkFactoryInfos.containsKey(msg.replyTo)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;NetworkFactory connected&quot;</span>);</span><br><span class="line">            <span class="comment">// A network factory has connected.  Send it all current NetworkRequests.</span></span><br><span class="line">            <span class="keyword">for</span> (NetworkRequestInfo nri : mNetworkRequests.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nri.request.isListen()) <span class="keyword">continue</span>;</span><br><span class="line">                NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);</span><br><span class="line">                <span class="comment">// 向NetworkFactory发送CMD_REQUEST_NETWORK请求处理</span></span><br><span class="line">                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK,</span><br><span class="line">                               (nai != <span class="keyword">null</span> ? nai.getCurrentScore() : <span class="number">0</span>), <span class="number">0</span>, nri.request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loge(<span class="string">&quot;Error connecting NetworkFactory&quot;</span>);</span><br><span class="line">            mNetworkFactoryInfos.remove(msg.obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NetworkFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_REQUEST_NETWORK: &#123;</span><br><span class="line">            handleAddRequest((NetworkRequest) msg.obj, msg.arg1, msg.arg2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当路由信息配置成功之后，ConnectivityService会通知NetworkFactory创建NetworkAgent。在handleAddRequest方法中会调用evalRequest根据评分，网络能力等来判断是否需要创建代理。</p>
<p><strong>调用链路：</strong>handleAddRequest() –&gt; evalRequest() –&gt;  needNetworkFor() –&gt;  NetworkFactory.startNetwork()–&gt; ExtNetworkFactory.startNetwork() –&gt; mayStartIpManager() –&gt; startIpManager() –&gt;  new NetworkAgent()</p>
<h4 id="2-4-NetworkMonitor的初始化"><a href="#2-4-NetworkMonitor的初始化" class="headerlink" title="2.4 NetworkMonitor的初始化"></a>2.4 NetworkMonitor的初始化</h4><p>NetworkMonitor主要是检测网络有效性的，通过Http封装类去ping一个网站，根据ping网站的结果来影响评分值。因此，它的初始化是在NetworkAgent初始化之后，必须要获取到路由配置信息NetworkAgent后才会去初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建NetworkAgent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkAgent</span><span class="params">(Looper looper, Context context, String logTag, NetworkInfo ni, NetworkCapabilities nc, LinkProperties lp, <span class="keyword">int</span> score, NetworkMisc misc)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 向ConnectivityService中注册NetworkAgent</span></span><br><span class="line">    <span class="keyword">this</span>.netId = cm.registerNetworkAgent(<span class="keyword">new</span> Messenger(<span class="keyword">this</span>), <span class="keyword">new</span> NetworkInfo(ni), <span class="keyword">new</span> LinkProperties(lp), <span class="keyword">new</span> NetworkCapabilities(nc), score, misc);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerNetworkAgent</span><span class="params">(Messenger messenger, NetworkInfo networkInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            LinkProperties linkProperties, NetworkCapabilities networkCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> currentScore, NetworkMisc networkMisc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  构建NetworkAgentInfo，在NetworkAgentInfo中构建NetworkMonitor</span></span><br><span class="line">    <span class="keyword">final</span> NetworkAgentInfo nai = <span class="keyword">new</span> NetworkAgentInfo(messenger, <span class="keyword">new</span> AsyncChannel(),</span><br><span class="line">          <span class="keyword">new</span> Network(reserveNetId()), <span class="keyword">new</span> NetworkInfo(networkInfo), <span class="keyword">new</span> LinkProperties(</span><br><span class="line">linkProperties), <span class="keyword">new</span> NetworkCapabilities(networkCapabilities), currentScore,mContext, mTrackerHandler, <span class="keyword">new</span> NetworkMisc(networkMisc), mDefaultRequest, <span class="keyword">this</span>);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-网络有效性检测（NetworkMonitor）"><a href="#3-网络有效性检测（NetworkMonitor）" class="headerlink" title="3. 网络有效性检测（NetworkMonitor）"></a>3. 网络有效性检测（NetworkMonitor）</h3><p>NetworkMonitor是一个状态机。负责检测网络有效性，也就是ping网络的过程。ping网络过程中产生的几种状态如下：</p>
<ul>
<li>DefaultState 默认状态 </li>
<li>EvaluatingState 验证状态 </li>
<li>ValidatedState 验证通过状态 </li>
<li>LingeringState 休闲状态，表示网络的验证位是真实的，并且曾经是满足特定NetworkRequest的最高得分网络，但是此时另一个网络满足了NetworkRequest的更高分数，在断开连接前的一段时间前，该网络被“固定”为休闲状态。 </li>
<li>CaptivePortalState 强制门户状态 </li>
<li>MaybeNotifyState 可能通知状态，表示用户可能已被通知需要登录。 在退出该状态时，应该小心清除通知。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-54dfaf5e8c873a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NetworkMonitor状态机.png"></p>
<p>以正常的ping网站过程为例，DefaultState为默认状态，NetworkMonitor接收到CMD_NETWORK_CONNECTED事件消息后，先由DefaultState状态处理，然后由EvaluatingState处理，最后交给ValidatedState处理。</p>
<p>从NetworkMonitor的初始化，到ping网站的过程，到ping网站的结果影响评分值。这个过程的时序图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-07f4f715a1ef8978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NetworkMonitor初始化流程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handles a network appearing or improving its score.</span></span><br><span class="line"><span class="comment">// - Evaluates all current NetworkRequests that can be</span></span><br><span class="line"><span class="comment">//   satisfied by newNetwork, and reassigns to newNetwork</span></span><br><span class="line"><span class="comment">//   any such requests for which newNetwork is the best.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - Lingers any validated Networks that as a result are no longer</span></span><br><span class="line"><span class="comment">//   needed. A network is needed if it is the best network for</span></span><br><span class="line"><span class="comment">//   one or more NetworkRequests, or if it is a VPN.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - Tears down newNetwork if it just became validated</span></span><br><span class="line"><span class="comment">//   but turns out to be unneeded.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - If reapUnvalidatedNetworks==REAP, tears down unvalidated</span></span><br><span class="line"><span class="comment">//   networks that have no chance (i.e. even if validated)</span></span><br><span class="line"><span class="comment">//   of becoming the highest scoring network.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.新的NetworkAgentInfo出来，要重新评估所有的NetworkRequests，如果这个网络是最好的网络，会将这些NetworkRequests reassigns到这个新网络， 比如数据网络连接的情况下，wifi连接成功且网络判通成功，这时候一些网络请求的NetworkRequests 要reassigns 到wifi的NetworkAgentInfo</span></span><br><span class="line"><span class="comment">//  2.Lingers任何一个不再需要的validated Networks，理解 “不再需要”，wifi连接的情况下，data网络正常是会linger的，但是如果此时有一个或多个NetworkRequest的指定的transportType为NetworkCapabilities.TRANSPORT_CELLULAR 此时不会linger这个数据网络，另外这个网络是VPN.也不会被linger</span></span><br><span class="line"><span class="comment">//  3.如果一个不需要的网络，就是被linger的网络，会执行Tears down newNetwork ，导致networkagent调用unwanted()方法 网络interface 都会被关闭（可以通过ifconfig 中消失掉来验证）</span></span><br><span class="line"><span class="comment">//  4.reapUnvalidatedNetworks 最后一个网络会传REAP，导致网络被tear down</span></span><br><span class="line">rematchNetworkAndRequests(NetworkAgentInfo newNetwork,</span><br><span class="line">        ReapUnvalidatedNetworks reapUnvalidatedNetworks, <span class="keyword">long</span> now)</span><br></pre></td></tr></table></figure>
<p>当网络状态变化，网络信息变化都会调用到rematchNetworkAndRequests方法中，最后会根据状态机状态，send不同类型的message，NetworkMonitor收到message之后进行相应的处理。</p>
<p>以收到CMD_NETWORK_CONNECTED为例，当monitor收到CMD_NETWORK_CONNECTED消息的时候，会将状态机切换到EvaluatingState状态，在EvaluatingState的enter()方法中发送CMD_REEVALUATE消息。在processMessage()中处理该消息。最后会调用到isCaptivePortal();中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isCaptivePortal会根据http或者https请求发起HttpURLConnection()</span></span><br><span class="line">CaptivePortalProbeResult probeResult = isCaptivePortal();</span><br><span class="line"><span class="comment">//根据不同的ping结果，做相应处理</span></span><br><span class="line"><span class="keyword">if</span> (probeResult.isSuccessful()) &#123;</span><br><span class="line">    transitionTo(mValidatedState);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (probeResult.isPortal()) &#123;</span><br><span class="line">    mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED,</span><br><span class="line">               NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));</span><br><span class="line">    mLastPortalProbeResult = probeResult;</span><br><span class="line">    transitionTo(mCaptivePortalState);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Message msg = obtainMessage(CMD_REEVALUATE, ++mReevaluateToken, <span class="number">0</span>);</span><br><span class="line">    sendMessageDelayed(msg, mReevaluateDelayMs);</span><br><span class="line">    logNetworkEvent(NetworkEvent.NETWORK_VALIDATION_FAILED);</span><br><span class="line">    mConnectivityServiceHandler.sendMessage(obtainMessage(</span><br><span class="line">        EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId,</span><br><span class="line">        probeResult.redirectUrl));</span><br><span class="line">    <span class="keyword">if</span> (mAttempts &gt;= BLAME_FOR_EVALUATION_ATTEMPTS) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t continue to blame UID forever.</span></span><br><span class="line">        TrafficStats.clearThreadStatsUid();</span><br><span class="line">    &#125;</span><br><span class="line">    mReevaluateDelayMs *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mReevaluateDelayMs &gt; MAX_REEVALUATE_DELAY_MS) &#123;</span><br><span class="line">        mReevaluateDelayMs = MAX_REEVALUATE_DELAY_MS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据ping网络的结果来执行不同的操作： </p>
<ul>
<li><strong>ping网络成功</strong>，如果收到的响应码是204，将状态机切换到ValidatedState。当状态机切换到ValidatedState之后，在enter()方法中会发送消息EVENT_NETWORK_TESTED。当ConnectivityService收到EVENT_NETWORK_TESTED之后，调用updateCapabilities()更新网卡能力和重新评估这个网络是否对于所有请求是最优的；如果当前能ping通的网络评分和以前的评分不一致，调用sendUpdatedScoreToFactories()更新评分。</li>
<li><strong>ping网络失败</strong>，网络返回200~399，转到CaptivePortalState状态处理。 </li>
<li><strong>ping网络失败</strong>，不是204，也不是200~399，则发送CMD_REEVALUATE消息，重新触发ping网络的动作。第一次失败，8s后重新ping网络，第二次失败，16s后重新ping网络，时间依次倍增，最长的时间间隔为10分钟。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">maybeHandleNetworkMonitorMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">case</span> NetworkMonitor.EVENT_NETWORK_TESTED: &#123;</span><br><span class="line">        <span class="keyword">final</span> NetworkAgentInfo nai;</span><br><span class="line">        <span class="keyword">synchronized</span> (mNetworkForNetId) &#123;</span><br><span class="line">            nai = mNetworkForNetId.get(msg.arg2);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">            <span class="keyword">if</span> (valid != nai.lastValidated) &#123;</span><br><span class="line">                <span class="comment">// 更新评分</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> oldScore = nai.getCurrentScore();</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 更新网络接口能力</span></span><br><span class="line">                updateCapabilities(oldScore, nai, nai.networkCapabilities);</span><br><span class="line">                <span class="comment">// 更新评分到网络工厂</span></span><br><span class="line">                <span class="keyword">if</span> (oldScore != nai.getCurrentScore()) sendUpdatedScoreToFactories(nai);</span><br><span class="line">            &#125;</span><br><span class="line">           .....</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ping网络的状态会保存到NetworkAgentInfo中，而后续所有的评分值都会调用NetworkAgentInfo的getCurrentScore()方法来获取，getCurrentScore()方法会根据当前ping网络的状态重新计算评分值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCurrentScore</span><span class="params">(<span class="keyword">boolean</span> pretendValidated)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是用户指定的网络，直接给100分</span></span><br><span class="line">	<span class="keyword">if</span> (networkMisc.explicitlySelected &amp;&amp; (networkMisc.acceptUnvalidated || 						pretendValidated)) &#123;</span><br><span class="line">		<span class="keyword">return</span> MAXIMUM_NETWORK_SCORE; <span class="comment">//100</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> score = currentScore;</span><br><span class="line">    <span class="comment">// 如果ping失败了就扣40分，如果ping网络成功，则评分值不变。</span></span><br><span class="line">    <span class="keyword">if</span> (!lastValidated &amp;&amp; !pretendValidated &amp;&amp; !ignoreWifiUnvalidationPenalty()) &#123;</span><br><span class="line">   		score -= UNVALIDATED_SCORE_PENALTY; <span class="comment">// -40</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (score &lt; <span class="number">0</span>) score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-网络评分机制"><a href="#3-网络评分机制" class="headerlink" title="3.网络评分机制"></a>3.网络评分机制</h3><p>NetworkFactory的存在意义就是为了帮助ConnectivityService进行评分的管理。一般在NetworkFactory在初始化时，设置固定的评分值，作为评判的标准。<br>NetworkAgent作为一个代理信息的抽象，在其初始化时，也设置了固定的评分值，不过，这个评分值会根据当前的网络情况的不同而变化，其最后的评分值会和NetworkFactory中的固定评分值进行比较，从而筛选出最优网络。</p>
<p>项目中可能涉及的网络源如下：WifiNetworkFactory，TelephonyNetwork，EthernetNetwork，PhoneSwitcher，Tbox。</p>
<p>这些工厂在初始化的时候，会将默认评分注册到ConnectivityService中</p>
<table>
<thead>
<tr>
<th></th>
<th>NetworkFactory初始化</th>
<th>NetworkAgent初始化</th>
<th>NetworkMonitor中ping网络</th>
<th>disconnect</th>
</tr>
</thead>
<tbody><tr>
<td>TelephonyNetwork</td>
<td>50</td>
<td>50</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>Tbox</td>
<td>50</td>
<td>50</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>Wifi</td>
<td>60</td>
<td>60</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>EthernetNetwork</td>
<td>69</td>
<td>69</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>PhoneSwitcher</td>
<td>101</td>
<td>101</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
</tbody></table>
<p>各种数据业务类型的评分标准，除了其基础评分值不同之外，其他的评判标准都一样。其评分值的变化，主要有以下几种情况：<br>一．代理信息获取结束后，会参与ping网络的过程，如果ping网络成功，那么NetworkAgent中的评分值不变。如果ping网络失败，那么NetworkAgent中的评分值-40。如果用户指定了某种网络类型作为连接方式，那么NetworkAgent重的评分值+100。<br>二．如果NetworkAgent和ConnectivityService的AsyncChannel通道断开，需要设置其评分值为0，好让其他的评分高的网络类型连接。</p>
<p><strong>NetworkFactory中的评分标准：</strong></p>
<p>NetworkFactory中维持了基础的评分分值mScore，mScore只有在 NetworkFactory对象创建的时候才会赋值。因网络环境的变化导致需要重新进行网络评估时，使用基础评分分值与传进来的NetworkRequestInfo中的分值进行比较。</p>
<ul>
<li>如果当前的NetworkRequestInfo没有requested过，且当前的分值score比基础分值mScore小，说明当前的NetworkRequestInfo为最优网络，调用needNetworkFor()连接网络。</li>
<li>如果当前的NetworkRequestInfo已经requested过，且当前的分值score比基础分值mScore大，说明当前的NetworkRequestInfo已经不是最优网络了，有个更优的网络可用连接，此时应该调用releaseNetworkFor()释放掉此类网络连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evalRequest</span><span class="params">(NetworkRequestInfo n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;evalRequest request = &quot;</span> + n.request + <span class="string">&quot; with requested = &quot;</span> + n.requested);</span><br><span class="line">    <span class="keyword">if</span> (n.requested == <span class="keyword">false</span> &amp;&amp; n.score &lt; mScore &amp;&amp;</span><br><span class="line">            n.request.networkCapabilities.satisfiedByNetworkCapabilities(</span><br><span class="line">            mCapabilityFilter) &amp;&amp; acceptRequest(n.request, n.score)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;  needNetworkFor&quot;</span>);</span><br><span class="line">        needNetworkFor(n.request, n.score);</span><br><span class="line">        n.requested = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.requested == <span class="keyword">true</span> &amp;&amp;</span><br><span class="line">            (n.score &gt; mScore || n.request.networkCapabilities.satisfiedByNetworkCapabilities(</span><br><span class="line">            mCapabilityFilter) == <span class="keyword">false</span> || acceptRequest(n.request, n.score) == <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;  releaseNetworkFor&quot;</span>);</span><br><span class="line">        releaseNetworkFor(n.request);</span><br><span class="line">        n.requested = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;  done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>触发评分的过程：</strong></p>
<p>1.NetworkFactory与ConnectivityService通过AsyncChannel建立连接的时候，初始化评分，并参与了第一次的评分过程。如果此时还没有ping网络的话，其传进来的评分值为基础评分值，以上代码会执行else逻辑。 </p>
<p>2.调用sendUpdatedScoreToFactories()方法触发了评分过程<br>在ping网络过程中，会触发多次评分过程。在NetworkMonitor的多个状态中，都有向ConnectivityService发起EVENT_NETWORK_TESTED事件消息更新评分</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>网络管理</tag>
        <tag>ConnectivityService</tag>
      </tags>
  </entry>
  <entry>
    <title>解决编译系统时报:ckati failed with: signal: killed</title>
    <url>/2021/04/28/%E8%A7%A3%E5%86%B3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E6%97%B6%E6%8A%A5-ckati-failed-with-signal-killed/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>刚把1804虚拟机搭建起来，然后迫不及待的把Android Q代码编译起来，结果每次在编译一两分钟之后就把如下错误，也不报具体源码哪里有问题，搞的脑子着实大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vendor/qcom/build/tasks/generate_extra_images.mk:<span class="number">558</span>: warning: overriding commands <span class="keyword">for</span> target `kernelclean<span class="string">&#x27;</span></span><br><span class="line"><span class="string">device/qcom/common/generate_extra_images.mk:558: warning: ignoring old commands for target `kernelclean&#x27;</span></span><br><span class="line">vendor/ts/build/tasks/gen_vehiclecfg_img.mk:<span class="number">87</span>: warning: overriding commands <span class="keyword">for</span> target `out/target/product/msmnile_gvmq/vehicledefcfg.img<span class="string">&#x27;</span></span><br><span class="line"><span class="string">build/make/core/Makefile:1869: warning: ignoring old commands for target `out/target/product/msmnile_gvmq/vehicledefcfg.img&#x27;</span></span><br><span class="line">vendor/ts/build/tasks/gen_vehiclecfg_img.mk:<span class="number">123</span>: warning: overriding commands <span class="keyword">for</span> target `out/target/product/msmnile_gvmq/vehicleconfig.img<span class="string">&#x27;</span></span><br><span class="line"><span class="string">build/make/core/Makefile:1916: warning: ignoring old commands for target `out/target/product/msmnile_gvmq/vehicleconfig.img&#x27;</span></span><br><span class="line"><span class="comment">// 留意一下这个错误</span></span><br><span class="line"><span class="number">18</span>:<span class="number">30</span>:<span class="number">48</span> ckati failed with: signal: killed</span><br></pre></td></tr></table></figure>
<p>以上错误ckati构建系统强行把编译行为中止了。</p>
<p>找了好多资料都没有找到原因是啥，平白无故的将我的编译行为杀掉了，我就猜测是不是什么系统资源不够了？因为之前把内存调到4G的时候，系统经常不报代码原因，直接被干掉了。</p>
<p>于是基于这一点，查到<strong>默认安装的Ubuntu18</strong>，分区是自动分的， <strong>swap 分区只给了2G</strong>。但是电脑内存16G，一般swap分区要大于或等于物理内存(1-1.5倍)，而且刚跑程序电脑卡死无奈重启，top命令最后引起我注意的是进场command：kswapd0， 所以摁下重启键回来增大swap分区试试。</p>
<h4 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h4><p>增加交换分区步骤如下：</p>
<ul>
<li>1.查看内存情况：<code>free -m</code></li>
<li>2.创建一个新的swap文件<br><code>sudo dd if=/dev/zero of=swap bs=1G count=24</code><br>count的值是24G， 创建文件名为swap。（<strong>这步应该在/路径下执行了</strong>）</li>
<li>3.创建swap文件系统<br><code>sudo mkswap -f swap</code></li>
<li>4.开启新的swap<br><code>sudo swapon swap</code></li>
<li>5.关闭并删除原有的swap文件<br><code>sudo swapoff swapfile</code><br><code>sudo rm /swapfile</code></li>
<li>6.设置开机启动<br><code>sudo subl /etc/fstab</code><br>将原有的swapfile改为swap</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>安装如上配置之后，就可以开开心心编译系统了。经过半天的编译，正常情况下就会编译成功了</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bb4a986a91b95b92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译Android成功.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-37a1d23cd71dbf3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译系统整包成功.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>交换空间不足</tag>
      </tags>
  </entry>
  <entry>
    <title>Android P源码编译, 第三方jar包报DateTimeException</title>
    <url>/2021/04/27/Android-P%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91-%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%E6%8A%A5DateTimeException/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>Android P源码环境下AOSP源码以及编译完成，但是引入第三方jar包之后，编译报“ Invalid value for MonthOfYear (valid values 1 - 12): 0 ” 错误。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-77ce144031aab4bb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常信息.jpg"></p>
<h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>第三方提供的jar包编译环境与系统不一致。详见<a href="https://stackoverflow.com/questions/46508081/jarsigner-error-java-time-datetimeexception-invalid-value-for-monthofyear-val">1.统一编译环境</a></p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>确认如下环境是否一致：</p>
<ul>
<li>java环境：java -version</li>
<li>javac环境：javac -version</li>
</ul>
<p>环境配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载对应版本</span></span><br><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line">	</span><br><span class="line"><span class="meta">#</span><span class="bash"> 版本之间切换</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line">sudo update-alternatives --config javac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确定ubuntu版本信息</span></span><br><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>


<p>如果环境一致了还是不好使，那么<strong>必须将模块代码放入源码编译!!!!</strong></p>
<p>开始项目代码是用Android Studio开发的，打jar包也是用AS来构建的，随便怎么配置，随便怎么对环境，打出来的jar包在Android Q源码里都会报”DateTimeException”。其他版本的源码不报这个异常。</p>
<p>所以真正解决这个问题的办法只有将代码移入到Android Q源码中，写一个Android.mk脚本来编译就可以了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d7652f367013e859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功.png"></p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://stackoverflow.com/questions/46508081/jarsigner-error-java-time-datetimeexception-invalid-value-for-monthofyear-val">1.统一编译环境</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>编译第三方jar包</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide源码分析</title>
    <url>/2021/04/29/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="1-Glide总览"><a href="#1-Glide总览" class="headerlink" title="1. Glide总览"></a>1. Glide总览</h3><p>Glide图片加载框架从总体来看采用三段论来让用户轻松加载图片。</p>
<ul>
<li>with()方法主要通过创建一个空白的Fragment盖在展示的页面上，感知展示页面的生命周期，来动态调整Glide内部请求等业务。详细参见<a href="https://www.jianshu.com/p/f42a2c00c9d1">Glide源码分析-生命周期管理</a></li>
<li>load()方法完成通用请求的构建</li>
<li>into()方法主要维护这运行队列和等待队列，当生命周期改变的时候，动态清除一些不必要加载的请求。同时还维护着活动缓存和内存缓存，多级缓存有利于节约资源和加载效率，最后如果没有缓存就采用网络请求的方式加载请求的内容。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b1a128a4e99cfd2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide总览.png"></p>
<h3 id="2-with"><a href="#2-with" class="headerlink" title="2. with()"></a>2. with()</h3><p>with()方法的详细分析可以参见上一篇Glide的叙述：<a href="https://www.jianshu.com/p/f42a2c00c9d1">Glide源码分析-生命周期管理</a>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7f361758e40a09a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide_with.png"></p>
<p>总体来讲，with()方法中发生了如下事情：</p>
<ul>
<li>Glide类:主要做一些 init 工作，比如缓存，线程池，复用池的构建等等。</li>
<li>RequestManagerRetriever类：主要是获得一个 <code>RequestManager</code> 请求管理类，然后绑定一个 Fragment</li>
<li>SupportRequestManagerFragment 类:用于管理请求的生命周期。</li>
<li>RequestManager:主要用于对请求的管理封装。</li>
</ul>
<h3 id="3-load"><a href="#3-load" class="headerlink" title="3. load()"></a>3. load()</h3><p>load()流程其实不是很复杂，主要做了通用资源类型的设置选项和启动负载，在RequestBuilder 中完成。流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f3aa2776268cc9e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide_with_load.png"></p>
<p>RequestBuilder : 这是一个通用请求构建类，可以处理通用资源类型的设置选项和启动负载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ModelTypes</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">Drawable</span>&gt;&gt; </span>&#123;</span><br><span class="line">      </span><br><span class="line">  .....</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里调用 Drawable 图片加载请求器为其加载</span></span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@CheckResult</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(uri);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@CheckResult</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(file);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">  &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilder</span>&lt;<span class="title">TranscodeType</span>&gt; <span class="keyword">extends</span> <span class="title">BaseRequestOptions</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">TranscodeType</span>&gt;&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">ModelTypes</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">TranscodeType</span>&gt;&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 描述加载的数据源-这里可以看做是我们传递进来的 http://xxxx.png</span></span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> Object model;</span><br><span class="line">  <span class="comment">// 描述这个请求是否已经添加了加载的数据源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isModelSet;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// model是我们需要加载的数据源，可能为null，为了保证model一定被赋值，此处引进isModelSet来保证。</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.model = model;</span><br><span class="line">      isModelSet = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里 RequestBuilder 就构建好了， RequestBuilder构建出来，接下来就是重头戏into()。</p>
<h3 id="4-into"><a href="#4-into" class="headerlink" title="4.into()"></a>4.into()</h3><p>into()是所有流程中最最复杂的方法，有60多个步骤，此处我们分成几个环节来一一分析流程。</p>
<p>分析之前，我们脑子中一定记住从最初是状态开始翻代码，最初始状态就是：<strong>拿到了url，各级缓存都没有资源，需要从网上下载资源，然后加载到控件中。</strong></p>
<p><strong>into()整体流程图</strong><a href="https://github.com/oujie123/Glide">在Glide工程中src目录中</a>。</p>
<h4 id="4-1-确定控件大小"><a href="#4-1-确定控件大小" class="headerlink" title="4.1 确定控件大小"></a>4.1 确定控件大小</h4><p>我们从网上加载的inputstram不可能是下载多少就加载多少，这样内存可能爆掉，或者效率很低，我们应该按需加载，控件多大，我们就将图片压缩到多大加载。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e2e80706f9f2534b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确定控件大小.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(view);</span><br><span class="line">  <span class="comment">// 根据 ImageView 布局中的 scaleType 来重构 requestOptions</span></span><br><span class="line">  BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果在 xml ImageView 节点中 没有设置 scaleType 那么默认在构造函数中进行了初始化为   mScaleType = ScaleType.FIT_CENTER;  </span></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">     .....</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        <span class="comment">//这里用到了克隆（原型设计模式），选择一个&quot;居中合适&quot;显示的方案</span></span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用 into 重载函数，创建一个 ViewTarget</span></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">    	<span class="comment">//调用 buildImageViewTarget 构建一个 ImageView 类型的 Target(Bitmap/Drawable)</span></span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      requestOptions,</span><br><span class="line">      Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就两大步：</p>
<p>   第一步：先拿到当前 ImageView getScaleType 类型的属性，然后重新 clone 一个进行配置；</p>
<p>   第二步：调用 into 重载继续构建；</p>
<p>先来看下 glideContext.buildImageViewTarget 是怎么构建出来 ImageViewTarget 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> &lt;X&gt; <span class="function">ViewTarget&lt;ImageView, X&gt; <span class="title">buildImageViewTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> ImageView imageView, <span class="meta">@NonNull</span> Class&lt;X&gt; transcodeClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用 工厂模式 根据 transcodeClass 生成出一个对应的 ImageViewTarget</span></span><br><span class="line">  <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTargetFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> &lt;Z&gt; <span class="function">ViewTarget&lt;ImageView, Z&gt; <span class="title">buildTarget</span><span class="params">(<span class="meta">@NonNull</span> ImageView view,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果目标的编码类型属于 Bitmap 那么就创建一个 Bitmap 类型的 ImageViewTarget</span></span><br><span class="line">    <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">    <span class="comment">////如果目标的编码类型属于 Drawable 那么就创建一个 Drawable 类型的 ImageViewTarget</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">&quot;Unhandled class: &quot;</span> + clazz + <span class="string">&quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 生产 Target 的时候注意一下，只要调用了  <code>asBitmap</code> 才会执行生产 BitmapImageViewTarget ,所以这里我们关注 Drawable 类型就行了，我们就先简单看看这个 target 内部怎么实现的，因为最后当拿到请求资源之后，会在target中设置资源到view中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableImageViewTarget</span> <span class="keyword">extends</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Drawable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view, <span class="keyword">boolean</span> waitForLayout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view, waitForLayout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Drawable resource)</span> </span>&#123;</span><br><span class="line">    view.setImageDrawable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以知道 DrawableImageViewTarget 继承的是 ImageViewTarget 重写的 setResource 函数，实现了显示 Drawable 图片的逻辑。</p>
<p>回到主流程，into()重载方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">      BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="comment">//这里的 isModelSet 是在 load 的时候赋值为 true 的，所以不会抛异常，确保了信息源一定被设置。</span></span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//为这个 http://xxx.png 生成一个 Glide request 请求</span></span><br><span class="line">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line">		<span class="comment">//相当于拿到上一个请求</span></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    <span class="comment">//下面的几行说明是否与上一个请求冲突，一般不用管 直接看下面 else 判断</span></span><br><span class="line">    <span class="comment">// 如果两个请求参数和大小相同，就不用再请求了，直接返回。此if中也会判断前一个请求是否在请求中等状态，此处我们不用关心，第一次加载图片不会进入此if语句。</span></span><br><span class="line">    <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      request.recycle();</span><br><span class="line">      <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果是一个新请求，先清理掉目标请求管理</span></span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    <span class="comment">//重新为目标设置一个 Glide request 请求</span></span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    <span class="comment">//最后是调用 RequestManager 的 track 来执行目标的 Glide request 请求</span></span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上核心就两个点：</p>
<p>​    第一点：为 target buildRequest 构建一个 Glide request 请求； </p>
<p>​    第二点：将构建出来的 Request 交于 RequestManager 来执行；</p>
<p>我们先简单的来看下怎么构建的 Request：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildRequestRecursive(</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      <span class="comment">/*parentCoordinator=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      transitionOptions,</span><br><span class="line">      requestOptions.getPriority(),</span><br><span class="line">      requestOptions.getOverrideWidth(),</span><br><span class="line">      requestOptions.getOverrideHeight(),</span><br><span class="line">      requestOptions,</span><br><span class="line">      callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">obtainRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestCoordinator requestCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SingleRequest.obtain(</span><br><span class="line">      context,</span><br><span class="line">      glideContext,</span><br><span class="line">      model,</span><br><span class="line">      transcodeClass,</span><br><span class="line">      requestOptions,</span><br><span class="line">      overrideWidth,</span><br><span class="line">      overrideHeight,</span><br><span class="line">      priority,</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      requestListeners,</span><br><span class="line">      requestCoordinator,</span><br><span class="line">      glideContext.getEngine(),</span><br><span class="line">      transitionOptions.getTransitionFactory(),</span><br><span class="line">      callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们发现是 <code>SingleRequest.obtain</code> 来为我们构建的 Request 请求对象，开始只是初始化一些配置属性。</p>
<p>继续回到上面看request的track()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里对当前 class 加了一个同步锁避免线程引起的安全性  </span></span><br><span class="line"> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//添加一个目标任务  </span></span><br><span class="line">  	targetTracker.track(target);</span><br><span class="line">  	<span class="comment">//执行 Glide request</span></span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(<span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加一个请求</span></span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="comment">//是否暂停</span></span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">      <span class="comment">//没有暂停，开始调用 Request begin 执行</span></span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果调用了 暂停，清理请求</span></span><br><span class="line">      request.clear();</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑是先为 <code>requests</code> 添加一个请求，看看是否是停止状态，如果不是就调用 <code>request.begin();</code>执行。</p>
<p>这里的 <code>Request</code> 是一个接口，通过之前我们讲到 <code>buildRequest</code> 函数可知  <code>Request</code>  的实现类是  <code>SingleRequest</code> 我们就直接看它的 <code>begin</code> 函数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   assertNotCallingCallbacks();</span><br><span class="line">   stateVerifier.throwIfRecycled();</span><br><span class="line">   startTime = LogTime.getLogTime();</span><br><span class="line">   <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//检查外部调用的尺寸是否有效</span></span><br><span class="line">     <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">       width = overrideWidth;</span><br><span class="line">       height = overrideHeight;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//失败的回调</span></span><br><span class="line">     <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">     onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">&quot;Received null model&quot;</span>), logLevel);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot restart a running request&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">     <span class="comment">//表示资源准备好了</span></span><br><span class="line">     onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   status = Status.WAITING_FOR_SIZE;</span><br><span class="line">   <span class="comment">//这里表示大小已经准备好了</span></span><br><span class="line">   <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">     <span class="comment">// 需要加载的尺寸已经测量好了，接下里就开始加载引擎。</span></span><br><span class="line">     onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     target.getSize(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">//这里是刚刚开始执行的回调，相当于显示开始的进度</span></span><br><span class="line">   <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">       &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">     target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">     logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">      loadStatus =</span><br><span class="line">          engine.load(</span><br><span class="line">              glideContext,</span><br><span class="line">              model,</span><br><span class="line">              requestOptions.getSignature(),</span><br><span class="line">              <span class="keyword">this</span>.width,</span><br><span class="line">              <span class="keyword">this</span>.height,</span><br><span class="line">              requestOptions.getResourceClass(),</span><br><span class="line">              transcodeClass,</span><br><span class="line">              priority,</span><br><span class="line">              requestOptions.getDiskCacheStrategy(),</span><br><span class="line">              requestOptions.getTransformations(),</span><br><span class="line">              requestOptions.isTransformationRequired(),</span><br><span class="line">              requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">              requestOptions.getOptions(),</span><br><span class="line">              requestOptions.isMemoryCacheable(),</span><br><span class="line">              requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">              requestOptions.getUseAnimationPool(),</span><br><span class="line">              requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">              <span class="keyword">this</span>,</span><br><span class="line">              callbackExecutor);</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-2-从不同缓存中搜寻资源"><a href="#4-2-从不同缓存中搜寻资源" class="headerlink" title="4.2 从不同缓存中搜寻资源"></a>4.2 从不同缓存中搜寻资源</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-0644fe6707e53fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从不同缓存中获取资源过程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到缓存或者请求的 key</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">		<span class="comment">//根据 key 拿到活动缓存中的资源</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="comment">//如果 ActiveResources 活动缓存中有就回调出去</span></span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从 LruResourceCache 中找寻这个资源 </span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果内存缓存 Lru 中资源存在回调出去</span></span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------- 走到这里说明活动缓存 跟内存 缓存都没有找到 -----------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据 Key 看看缓存中是否正在执行</span></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果正在执行，把数据回调出去</span></span><br><span class="line">      current.addCallback(cb, callbackExecutor);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">&quot;Added to existing load&quot;</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------   走到这里说明是一个新的任务  ---------------</span></span><br><span class="line">    <span class="comment">// --------------   构建新的请求任务  ---------------</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line">		<span class="comment">//把当前需要执行的 key 添加进缓存</span></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">		<span class="comment">//执行任务的回调</span></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="comment">//开始执行。</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>engine.load</code> 这个函数里面的逻辑，我们可以总结3点：</p>
<ol>
<li><p>先构建请求或者缓存 KEY ;</p>
</li>
<li><p>根据 KEY 从内存缓存中查找对应的资源数据(ActiveResources（活动缓存，内部是一个 Map 用弱引用持有）,LruResourceCache)，如果有就回调 对应监听的 onResourceReady 表示数据准备好了。</p>
</li>
<li><p>从执行缓存中查找对应 key 的任务</p>
<ol>
<li><p>如果找到了，就说明已经正在执行了，不用重复执行。</p>
</li>
<li><p>没有找到，通过 EngineJob.start 开启一个新的请求任务执行。</p>
</li>
</ol>
</li>
</ol>
<p>为了看主线，时刻记住开始强调的，<strong>所有缓存中都没有数据！</strong>直接看 EngineJob.start </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    <span class="comment">//拿到 Glide 执行的线程池</span></span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">        ? diskCacheExecutor</span><br><span class="line">        : getActiveSourceExecutor();</span><br><span class="line">    <span class="comment">//开始执行</span></span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>DecodeJob</code> 源码得知，它是实现的 <code>Runnable</code> 接口，这里 GlideExecutor 线程池开始执行，就会启动 DecodeJob 的 run 函数。</p>
<p>细心的小伙伴可以看出engineJob之后就decodeJob，不难想出，这两个任务之间一定有获取到资源的过程。而decodeJob包裹了engineJob，decodeJob是一个runnable，所以不难猜出会在线程池中网络请求资源，并且解码资源。下面我们就来看看是如何加载资源和解码的。</p>
<h4 id="4-3-寻找资源加载器"><a href="#4-3-寻找资源加载器" class="headerlink" title="4.3 寻找资源加载器"></a>4.3 寻找资源加载器</h4><p>此处不得不佩服框架考虑得的确很周全，我们需要加载资源，肯定就需要资源加载器，那么是不是只有一个加载器呢，当然不是，只有一个加载器的代码可能是我写的，哈哈哈。<strong>透露小秘密：框架会根据我们load传入的不同信息源，获取不同的资源加载器。</strong>下面我们来看一下流程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-44d8321db10c4208.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取url加载器.png"></p>
<p>上一小节结束我们可以看到包裹了engineJob的decodeJob任务会在线程池中执行，那么不难想出decodeJob的run()肯定会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 线程执行调用 run</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        GlideTrace.beginSectionFormat(<span class="string">&quot;DecodeJob#run(model=%s)&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">        DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//是否取消了当前请求</span></span><br><span class="line">          <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">            notifyFailed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//执行</span></span><br><span class="line">          runWrapped();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CallbackException e) &#123;</span><br><span class="line"></span><br><span class="line">         .....<span class="comment">//一些错误回调</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分析runWrapped:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="comment">//获取资源状态</span></span><br><span class="line">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">        <span class="comment">//根据当前资源状态，获取资源执行器</span></span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="comment">//如果外部调用配置了资源缓存策略，那么返回 Stage.RESOURCE_CACHE</span></span><br><span class="line">       	<span class="comment">//否则继续调用 Stage.RESOURCE_CACHE 执行。</span></span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="comment">//如果外部配置了源数据缓存，那么返回 Stage.DATA_CACHE</span></span><br><span class="line">        <span class="comment">//否则继续调用 getNextStage(Stage.DATA_CACHE)</span></span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="comment">//如果只能从缓存中获取数据，则直接返回 FINISHED，否则，返回SOURCE。</span></span><br><span class="line">        <span class="comment">//意思就是一个新的资源</span></span><br><span class="line">        <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码可以知道，我们在找资源的执行器，这里由于我们没有在外部配置缓存策略所以，直接从源数据加载，看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">      <span class="comment">//从资源缓存执行器</span></span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//源数据磁盘缓存执行器</span></span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//什么都没有配置，源数据的执行器</span></span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由于我们什么都没有配置，返回的是 <code>SourceGenerator</code> 源数据执行器。继续下面代码执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentThread = Thread.currentThread();</span><br><span class="line">    startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//判断是否取消，是否开始</span></span><br><span class="line">    <span class="comment">//调用 DataFetcherGenerator.startNext() 判断是否是属于开始执行的任务</span></span><br><span class="line">    <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">   </span><br><span class="line">      ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先看 <code>currentGenerator.startNext()</code> 这句代码，<code>DataFetcherGenerator</code> 是一个抽象类，那么这里执行的实现类是哪一个，可以参考下面说明：</p>
<table>
<thead>
<tr>
<th>状态标记</th>
<th>作用</th>
<th>执行器</th>
</tr>
</thead>
<tbody><tr>
<td>Stage.RESOURCE_CACHE</td>
<td>从磁盘中获取缓存的资源数据</td>
<td>ResourceCacheGenerator</td>
</tr>
<tr>
<td>Stage.DATA_CACHE</td>
<td>从磁盘中获取缓存的源数据</td>
<td>DataCacheGenerator</td>
</tr>
<tr>
<td>Stage.SOURCE</td>
<td>一次新的请求任务</td>
<td>SourceGenerator</td>
</tr>
</tbody></table>
<p>因为这里我们没有配置缓存，那么直接看 <code>SourceGenerator</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">    loadData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">      <span class="comment">//获取一个 ModelLoad 加载器</span></span><br><span class="line">      loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">          &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//使用加载器中的 fetcher 根据优先级加载数据</span></span><br><span class="line">        loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> started;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑很简单，首先获取加载器，然后从加载器中使用fetcher来加载数据就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isLoadDataSet) &#123;</span><br><span class="line">     isLoadDataSet = <span class="keyword">true</span>;</span><br><span class="line">     loadData.clear(); </span><br><span class="line">     <span class="comment">//从 Glide 注册的 Model 来获取加载器（注册是在 Glide 初始化的时候通过 registry</span></span><br><span class="line">      <span class="comment">// .append()添加的）</span></span><br><span class="line">     List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = modelLoaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">       ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">       LoadData&lt;?&gt; current =</span><br><span class="line">         <span class="comment">// 构建加载器。modelLoader是一个接口，需要知道是那个类的buildLoadData()来构建加载器。看看下面的分析。</span></span><br><span class="line">           modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">       <span class="comment">//如果加载器器不为空，那么添加进临时缓存</span></span><br><span class="line">       <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">         loadData.add(current);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> loadData;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>获取到加载器之后，会通过加载器中的fetcher加载数据，然后我们进入loadData()一看，fetcher是一个接口(DataFetcher<Data>)，实现类有一大堆(如下图)，我们根本没法知道到底是哪个来加载数据。</Data></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-01822f1043c41de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fetcher实现类.png"></p>
<p>此处就是框架设计巧妙的一点了，到底是怎么知道哪个fetcher呢？</p>
<p>此时我们要回到 <strong>Glide 初始的时候 通过 <code>Registry.append()</code> 添加的！！！！！！</strong> 下面我们来看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide(</span><br><span class="line">      <span class="meta">@NonNull</span> Context context,</span><br><span class="line">      <span class="meta">@NonNull</span> Engine engine,</span><br><span class="line">      <span class="meta">@NonNull</span> MemoryCache memoryCache,</span><br><span class="line">      <span class="meta">@NonNull</span> BitmapPool bitmapPool,</span><br><span class="line">      <span class="meta">@NonNull</span> ArrayPool arrayPool,</span><br><span class="line">      <span class="meta">@NonNull</span> RequestManagerRetriever requestManagerRetriever,</span><br><span class="line">      <span class="meta">@NonNull</span> ConnectivityMonitorFactory connectivityMonitorFactory,</span><br><span class="line">      <span class="keyword">int</span> logLevel,</span><br><span class="line">      <span class="meta">@NonNull</span> RequestOptionsFactory defaultRequestOptionsFactory,</span><br><span class="line">      <span class="meta">@NonNull</span> Map&lt;Class&lt;?&gt;, TransitionOptions&lt;?, ?&gt;&gt; defaultTransitionOptions,</span><br><span class="line">      <span class="meta">@NonNull</span> List&lt;RequestListener&lt;Object&gt;&gt; defaultRequestListeners,</span><br><span class="line">      <span class="keyword">boolean</span> isLoggingRequestOriginsEnabled,</span><br><span class="line">      <span class="keyword">boolean</span> isImageDecoderEnabledForBitmaps) &#123;</span><br><span class="line">	......</span><br><span class="line">    registry</span><br><span class="line">        .append(Uri.class, InputStream.class, <span class="keyword">new</span> UrlUriLoader.StreamFactory())</span><br><span class="line">        .append(URL.class, InputStream.class, <span class="keyword">new</span> UrlLoader.StreamFactory())</span><br><span class="line">        .append(Uri.class, File.class, <span class="keyword">new</span> MediaStoreFileLoader.Factory(context))</span><br><span class="line">        <span class="comment">// 我们load传入的是一个url，所以我们的fetcher就是HttpGlideUrlLoader。</span></span><br><span class="line">        .append(GlideUrl.class, InputStream.class, <span class="keyword">new</span> HttpGlideUrlLoader.Factory())</span><br><span class="line">        .append(<span class="keyword">byte</span>[].class, ByteBuffer.class, <span class="keyword">new</span> ByteArrayLoader.ByteBufferFactory())</span><br><span class="line">        .append(<span class="keyword">byte</span>[].class, InputStream.class, <span class="keyword">new</span> ByteArrayLoader.StreamFactory())</span><br><span class="line">        .append(Uri.class, Uri.class, UnitModelLoader.Factory.&lt;Uri&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.&lt;Drawable&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, <span class="keyword">new</span> UnitDrawableDecoder())</span><br><span class="line">        <span class="comment">/* Transcoders */</span></span><br><span class="line">        .register(Bitmap.class, BitmapDrawable.class, <span class="keyword">new</span> BitmapDrawableTranscoder(resources))</span><br><span class="line">        .register(Bitmap.class, <span class="keyword">byte</span>[].class, bitmapBytesTranscoder)</span><br><span class="line">        .register(</span><br><span class="line">            Drawable.class,</span><br><span class="line">            <span class="keyword">byte</span>[].class,</span><br><span class="line">            <span class="keyword">new</span> DrawableBytesTranscoder(</span><br><span class="line">                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))</span><br><span class="line">        .register(GifDrawable.class, <span class="keyword">byte</span>[].class, gifDrawableBytesTranscoder);</span><br><span class="line">    </span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Glide的构造方法中，我们找到了线索，registry.append()会根据我们load()传入不同类型的参数，为我们注册不同的fetcher。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说明：load传入参数类型----加载后的资源形式--------加载器----</span></span><br><span class="line">append(GlideUrl.class, InputStream.class, <span class="keyword">new</span> HttpGlideUrlLoader.Factory())</span><br></pre></td></tr></table></figure>
<p>我们可以这么理解，我们传入的参数是URL，使用HttpGlideUrlLoader来加载，最终返回一个InputStream流。看了注册加载器之后，<strong>我们继续回到如何构建加载器的主路线上：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadData&lt;InputStream&gt;就是加载器包裹，HttpUrlFetcher就是我们要找到真正的网络资源加载器！！！！</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> GlideUrl model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span></span><br><span class="line">    <span class="comment">// spent parsing urls.</span></span><br><span class="line">    GlideUrl url = model;</span><br><span class="line">    <span class="keyword">if</span> (modelCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">        url = model;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> timeout = options.get(TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(url, <span class="keyword">new</span> HttpUrlFetcher(url, timeout));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此时就很清晰了，我们是通过<code>HttpUrlFetcher</code>来加载资源的，然后我们进入资源加载环节。</p>
<h4 id="4-4-加载资源"><a href="#4-4-加载资源" class="headerlink" title="4.4 加载资源"></a>4.4 加载资源</h4><p>从上一小节中，我们知道了我们传入的url是通过<code>HttpUrlFetcher</code>来加载资源。那么我们就进入<code>HttpUrlFetcher</code>的loadData()。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ecf374cbf67ca2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载资源.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//http 请求，返回一个 InputStream 输入流</span></span><br><span class="line">      InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">      <span class="comment">//将 InputStream 以回调形式回调出去</span></span><br><span class="line">      callback.onDataReady(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      callback.onLoadFailed(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(URL url, <span class="keyword">int</span> redirects, URL lastUrl,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&quot;Too many (&gt; &quot;</span> + MAXIMUM_REDIRECTS + <span class="string">&quot;) redirects!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastUrl != <span class="keyword">null</span> &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&quot;In re-direct loop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        <span class="comment">// Do nothing, this is best effort.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    urlConnection = connectionFactory.build(url);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    urlConnection.setConnectTimeout(timeout);</span><br><span class="line">    urlConnection.setReadTimeout(timeout);</span><br><span class="line">    urlConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">    urlConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    urlConnection.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">    urlConnection.connect();</span><br><span class="line"></span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> statusCode = urlConnection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (isHttpOk(statusCode)) &#123;</span><br><span class="line">      <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">    &#125; </span><br><span class="line">    ...<span class="comment">//抛的异常我们暂时先不管</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码我们可以看出 HttpURLConnection 作为 Glide 底层成网络请求的。请求成功之后直接返回的是一个输入流，最后会通过 <code>onDataReady</code> 回调到 DecodeJob的onDataFetcherReady 函数中。</p>
<p>此时我们已经从网络上获取到资源了，现在来看是如何回调的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">      dataToCache = data;</span><br><span class="line">      cb.reschedule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">          loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会有 else 因为我们没有配置缓存,继续回调:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,</span></span></span><br><span class="line"><span class="function"><span class="params">          DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentSourceKey = sourceKey; <span class="comment">//当前返回数据的 key</span></span><br><span class="line">        <span class="keyword">this</span>.currentData = data; <span class="comment">//返回的数据</span></span><br><span class="line">        <span class="keyword">this</span>.currentFetcher = fetcher; <span class="comment">//返回的数据执行器，这里可以理解为 HttpUrlFetcher</span></span><br><span class="line">        <span class="keyword">this</span>.currentDataSource = dataSource; <span class="comment">//数据来源 url</span></span><br><span class="line">        <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">          runReason = RunReason.DECODE_DATA;</span><br><span class="line">          callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          GlideTrace.beginSection(<span class="string">&quot;DecodeJob.decodeFromRetrievedData&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//解析返回回来的数据</span></span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            GlideTrace.endSection();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;   </span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们的数据已经从网络上加载完成。最后通过<code>decodeFromRetrievedData()</code>方法来解析inputstream流。</p>
<h4 id="4-5-解析资源"><a href="#4-5-解析资源" class="headerlink" title="4.5 解析资源"></a>4.5 解析资源</h4><p>从上一小节，我们拿到了资源流，下面我们来看看是如何解析资源的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c3c98a0b247497c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析资源.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析返回的数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 decodeFrom 解析 数据；HttpUrlFetcher , InputStream ,  currentDataSource</span></span><br><span class="line">    resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">    e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">    throwables.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析完成后，通知下去</span></span><br><span class="line">  <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runGenerators();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromData</span><span class="params">(DataFetcher&lt;?&gt; fetcher, Data data,</span></span></span><br><span class="line"><span class="function"><span class="params">      DataSource dataSource)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">   	  ...  </span><br><span class="line">      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class="line">      ....</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromFetcher</span><span class="params">(Data data, DataSource dataSource)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前数据类的解析器 LoadPath </span></span><br><span class="line">    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">    <span class="comment">//通过 LoadPath 解析器来解析数据</span></span><br><span class="line">    <span class="keyword">return</span> runLoadPath(data, dataSource, path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> &lt;Data, ResourceType&gt; <span class="function">Resource&lt;R&gt; <span class="title">runLoadPath</span><span class="params">(Data data, DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">      LoadPath&lt;Data, ResourceType, R&gt; path)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Options options = getOptionsWithHardwareConfig(dataSource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为这里返回的是一个 InputStream 所以 这里拿到的是 InputStreamRewinder</span></span><br><span class="line">    DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将解析资源的任务转移到 Load.path 方法中</span></span><br><span class="line">      <span class="keyword">return</span> path.load(</span><br><span class="line">          rewinder, options, width, height, <span class="keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rewinder.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意上面代码，为了解析数据首先构建一个 LoadPath, 然后创建一个 InputStreamRewinder 类型的 DataRewinder, 最终将数据解析的操作放到了 LoadPath.load 方法中 ，接下来看下 LoadPath.load 方法的具体逻辑操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">load</span><span class="params">(DataRewinder&lt;Data&gt; rewinder, <span class="meta">@NonNull</span> Options options, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      listPool.release(throwables);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;Transcode&gt; <span class="title">loadWithExceptionList</span><span class="params">(DataRewinder&lt;Data&gt; rewinder,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width, <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;Transcode&gt; result = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//遍历内部存储的 DecodePath 集合，通过他们来解析数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;</span><br><span class="line">      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里才是真正解析数据的地方</span></span><br><span class="line">        result = path.decode(rewinder, width, height, options, decodeCallback);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最终通过path.decode()根据尺寸来解析inputstream流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//调用 decodeResourec 将数据解析成中间资源</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">//解析完数据回调出去</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//转换资源为目标资源</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看看 decodeResource 怎么解析成中间资源的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResource</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> decodeResourceWithList(rewinder, width, height, options, exceptions);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResourceWithList</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options, List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;ResourceType&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;</span><br><span class="line">      ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        DataType data = rewinder.rewindAndGet();</span><br><span class="line">        <span class="keyword">if</span> (decoder.handles(data, options)) &#123;</span><br><span class="line">          data = rewinder.rewindAndGet();</span><br><span class="line">          <span class="comment">// 调用 ResourceDecoder.decode 解析数据</span></span><br><span class="line">          result = decoder.decode(data, width, height, options);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;</span><br><span class="line">				...</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到数据解析的任务最终是通过 DecodePath 来执行的, 它内部有三大步操作</p>
<ul>
<li>第一大步：deResource 将源数据解析成资源（源数据: InputStream，  中间产物: Bitmap）</li>
<li>第二大步：调用 DecodeCallback.onResourceDecoded 处理资源</li>
<li>第三大步：调用 ResourceTranscoder.transcode 将资源转为目标资源（目标资源类型: Drawable）</li>
</ul>
<p>可以发现，通过上面的 decoder.decode 源码可知，它是一个接口，由于我们这里的源数据是 InputStream,所以，它的实现类是 <strong>StreamBitmapDecoder类</strong> ,我们就来看下 它内部的解码过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(<span class="meta">@NonNull</span> InputStream source, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use to fix the mark limit to avoid allocating buffers that fit entire images.</span></span><br><span class="line">    <span class="keyword">final</span> RecyclableBufferedInputStream bufferedStream;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ownsBufferedStream;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据请求配置来对数据进行采样压缩，获取一个 Resource&lt;Bitmap&gt; </span></span><br><span class="line">      <span class="keyword">return</span> downsampler.decode(invalidatingStream, width, height, options, callbacks);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最终是通过downsampler去根据目标的宽高，来对输入数据流进行压缩。</p>
<p>回到主线中的三大步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//第一步： 调用 decodeResourec 将数据解析成中间资源 Bitmap</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">//第二步： 解析完数据回调出去</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//第三步： 转换资源为目标资源 Bitmap to Drawable</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>解析完数据，看第二注释里面回调，最后会回调到 DecodeJob：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line">      ...  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">onResourceDecoded</span><span class="params">(<span class="meta">@NonNull</span> Resource&lt;Z&gt; decoded)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DecodeJob.<span class="keyword">this</span>.onResourceDecoded(dataSource, decoded);</span><br><span class="line">    &#125; </span><br><span class="line">      ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synthetic</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  &lt;Z&gt; <span class="function">Resource&lt;Z&gt; <span class="title">onResourceDecoded</span><span class="params">(DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Resource&lt;Z&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取资源类型</span></span><br><span class="line">    Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();</span><br><span class="line">    Transformation&lt;Z&gt; appliedTransformation = <span class="keyword">null</span>;</span><br><span class="line">    Resource&lt;Z&gt; transformed = decoded;</span><br><span class="line">    <span class="comment">//如果不是从磁盘资源中获取需要进行 transform 操作</span></span><br><span class="line">    <span class="keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;</span><br><span class="line">      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);</span><br><span class="line">      transformed = appliedTransformation.transform(glideContext, decoded, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//构建数据编码的策略</span></span><br><span class="line">    <span class="keyword">final</span> EncodeStrategy encodeStrategy;</span><br><span class="line">    <span class="keyword">final</span> ResourceEncoder&lt;Z&gt; encoder;</span><br><span class="line">    <span class="keyword">if</span> (decodeHelper.isResourceEncoderAvailable(transformed)) &#123;</span><br><span class="line">      encoder = decodeHelper.getResultEncoder(transformed);</span><br><span class="line">      encodeStrategy = encoder.getEncodeStrategy(options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      encoder = <span class="keyword">null</span>;</span><br><span class="line">      encodeStrategy = EncodeStrategy.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//根据编码策略，构建缓存 Key</span></span><br><span class="line">    Resource&lt;Z&gt; result = transformed;</span><br><span class="line">    <span class="keyword">boolean</span> isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);</span><br><span class="line">    <span class="keyword">if</span> (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,</span><br><span class="line">        encodeStrategy)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (encoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Registry.NoResultEncoderAvailableException(transformed.get().getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> Key key;</span><br><span class="line">      <span class="keyword">switch</span> (encodeStrategy) &#123;</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">          <span class="comment">//源数据 key</span></span><br><span class="line">          key = <span class="keyword">new</span> DataCacheKey(currentSourceKey, signature);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//... 省略 成吨的代码</span></span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">//初始化编码管理者，用于提交内存缓存</span></span><br><span class="line">      LockedResource&lt;Z&gt; lockedResult = LockedResource.obtain(transformed);</span><br><span class="line">      deferredEncodeManager.init(key, encoder, lockedResult);</span><br><span class="line">      result = lockedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回转换后的 Bitmap</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此处说白了， onResourceDecoded 中, 主要是对中间资源做了如下的操作：</p>
<p>   第一步：对资源进行了转换操作。比如 Fit_Center,CenterCrop, 这些都是在请求的时候配置的；</p>
<p>   第二步：构建磁盘缓存的 key。</p>
<p>资源解析完成，已经存入磁盘，此处开始对资源继续转换。</p>
<h4 id="4-6-资源转换"><a href="#4-6-资源转换" class="headerlink" title="4.6 资源转换"></a>4.6 资源转换</h4><p>从上一节我们通过解码inputstream流得到Bitmap，然而我们显示需要将Bitmap转化成Drawable。下面我们继续接着上一小节看看资源是如何转换的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-0d88a0936eb2e188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源转换.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodePath</span>&lt;<span class="title">DataType</span>, <span class="title">ResourceType</span>, <span class="title">Transcode</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">//省略成吨的代码 ...  </span></span><br><span class="line">  <span class="function">Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//第一步： 调用 decodeResourec 将数据解析成中间资源 Bitmap</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">//第二步： 解析完数据回调出去</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//第三步： 转换资源为目标资源 Bitmap to Drawable</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略成吨的代码 ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续看第三步。通过源码可知，ResourceTranscoder 是一个接口，又因为解析完的数据是 Bitmap 所以它的实现类是 BitmapDrawableTranscoder ，最后看下它的 transcode 具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapDrawableTranscoder</span> <span class="keyword">implements</span> <span class="title">ResourceTranscoder</span>&lt;<span class="title">Bitmap</span>, <span class="title">BitmapDrawable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;BitmapDrawable&gt; <span class="title">transcode</span><span class="params">(<span class="meta">@NonNull</span> Resource&lt;Bitmap&gt; toTranscode,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LazyBitmapDrawableResource.obtain(resources, toTranscode);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBitmapDrawableResource</span> <span class="keyword">implements</span> <span class="title">Resource</span>&lt;<span class="title">BitmapDrawable</span>&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Initializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Resources resources;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Resource&lt;Bitmap&gt; bitmapResource;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyBitmapDrawableResource <span class="title">obtain</span><span class="params">(Context context, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (LazyBitmapDrawableResource)</span><br><span class="line">            obtain(</span><br><span class="line">                context.getResources(),</span><br><span class="line">                BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyBitmapDrawableResource <span class="title">obtain</span><span class="params">(Resources resources, BitmapPool bitmapPool,Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LazyBitmapDrawableResource) obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource&lt;BitmapDrawable&gt; <span class="title">obtain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Resources resources, <span class="meta">@Nullable</span> Resource&lt;Bitmap&gt; bitmapResource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitmapResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyBitmapDrawableResource(resources, bitmapResource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazyBitmapDrawableResource</span><span class="params">(<span class="meta">@NonNull</span> Resources resources,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Resource&lt;Bitmap&gt; bitmapResource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resources = Preconditions.checkNotNull(resources);</span><br><span class="line">    <span class="keyword">this</span>.bitmapResource = Preconditions.checkNotNull(bitmapResource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;BitmapDrawable&gt; <span class="title">getResourceClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BitmapDrawable.class;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get 方法返回了一个 BitmapDrawable 对象</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BitmapDrawable <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapDrawable(resources, bitmapResource.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitmapResource.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bitmapResource.recycle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitmapResource <span class="keyword">instanceof</span> Initializable) &#123;</span><br><span class="line">      ((Initializable) bitmapResource).initialize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化终于完成了 ，将我们解析到的 bitmap 存放到 LazyBitmapDrawableResource 内部, 然后外界通过 get 方法就可以获取到一个 BitmapDrawable 的对象了，解析完就到了展示数据了，请看下面代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解析返回的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//第一步： 调用 decodeFrom 解析 数据；HttpUrlFetcher , InputStream ,  currentDataSource</span></span><br><span class="line">      resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">      e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">      throwables.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步： 解析完成后，通知下去</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runGenerators();</span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>第一步就解析完了数据， 现在第二步执行 <strong>notifyEncodeAndRelease</strong>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//通知调用层数据已经装备好了</span></span><br><span class="line">    notifyComplete(result, dataSource);</span><br><span class="line"></span><br><span class="line">    stage = Stage.ENCODE;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里就是将资源磁盘缓存</span></span><br><span class="line">      <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">        deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//完成</span></span><br><span class="line">    onEncodeComplete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyComplete</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    setNotifiedOrThrow();</span><br><span class="line">    <span class="comment">// 在 DecodeJob 的构建中, 我们知道这个 Callback 是 EngineJob</span></span><br><span class="line">    callback.onResourceReady(resource, dataSource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的 DecodeJob.<strong>decodeFromRetrievedData</strong> 中主要做了三个处理：</p>
<p>  第一个处理：解析返回回来的资源。</p>
<p>  第二个处理：拿到解析的资源，如果配置了本地缓存，就缓存到磁盘。</p>
<p>  第三个处理：通知上层资源准备就绪，可以使用了。</p>
<p>我们直接看 EngineJob 的 onResourceReady 回调函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.resource = resource;</span><br><span class="line">     <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">   &#125;</span><br><span class="line">   notifyCallbacksOfResult();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Synthetic</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">notifyCallbacksOfResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ResourceCallbacksAndExecutors copy;</span><br><span class="line">   Key localKey;</span><br><span class="line">   EngineResource&lt;?&gt; localResource;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     stateVerifier.throwIfRecycled();</span><br><span class="line">     <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">       resource.recycle();</span><br><span class="line">       release();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cbs.isEmpty()) &#123;</span><br><span class="line">     ... </span><br><span class="line">     &#125;</span><br><span class="line">     engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class="line">     hasResource = <span class="keyword">true</span>;</span><br><span class="line">     copy = cbs.copy();</span><br><span class="line">     incrementPendingCallbacks(copy.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     localKey = key;</span><br><span class="line">     localResource = engineResource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//回调上层 Engine 任务完成了</span></span><br><span class="line">   listener.onEngineJobComplete(<span class="keyword">this</span>, localKey, localResource);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历资源回调给 ImageViewTarget </span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">     entry.executor.execute(<span class="keyword">new</span> CallResourceReady(entry.cb));</span><br><span class="line">   &#125;</span><br><span class="line">   decrementPendingCallbacks();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面 EngineJob 的 onResourceReady 回调函数 主要做了 两个处理：</p>
<p>​    第一个处理：通知上层任务完成。 </p>
<p>​    第二个处理：回调 ImageViewTarget 用于展示数据。</p>
<p>看下 listener.onEngineJobComplete 具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onEngineJobComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      resource.setResourceListener(key, <span class="keyword">this</span>);</span><br><span class="line">			<span class="comment">//收到下游返回回来的资源，添加到活动缓存中</span></span><br><span class="line">      <span class="keyword">if</span> (resource.isCacheable()) &#123;</span><br><span class="line">        activeResources.activate(key, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jobs.removeIfCurrent(key, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最终通知 ImageViewTarget, 看下具体操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历资源回调给 ImageViewTarget </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">      entry.executor.execute(<span class="keyword">new</span> CallResourceReady(entry.cb));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CallResourceReady</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ResourceCallback cb;</span><br><span class="line"></span><br><span class="line">   CallResourceReady(ResourceCallback cb) &#123;</span><br><span class="line">     <span class="keyword">this</span>.cb = cb;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (EngineJob.<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (cbs.contains(cb)) &#123;</span><br><span class="line">        ...</span><br><span class="line">         <span class="comment">//返回准备好的资源</span></span><br><span class="line">         callCallbackOnResourceReady(cb);</span><br><span class="line">         removeCallback(cb);</span><br><span class="line">       &#125;</span><br><span class="line">       decrementPendingCallbacks();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 CallResourceReady 实现 Runnable ，当 entry.executor.execute 线程池执行的时候就会调用 run ，最后我们继续跟 callCallbackOnResourceReady函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synthetic</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callCallbackOnResourceReady</span><span class="params">(ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//回调给 SingleRequest</span></span><br><span class="line">    cb.onResourceReady(engineResource, dataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CallbackException(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleRequest onResourceReady 回调实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    loadStatus = <span class="keyword">null</span>;</span><br><span class="line">    ... 省略成吨的代码</span><br><span class="line">    Object received = resource.get();</span><br><span class="line">    <span class="keyword">if</span> (received == <span class="keyword">null</span> || !transcodeClass.isAssignableFrom(received.getClass())) &#123;</span><br><span class="line">      releaseResource(resource);</span><br><span class="line">      ... 省略成吨的代码</span><br><span class="line">      onLoadFailed(exception);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canSetResource()) &#123;</span><br><span class="line">      releaseResource(resource);</span><br><span class="line">      status = Status.COMPLETE;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当资源准备好的时候</span></span><br><span class="line">    onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">      ... 省略成吨的代码</span><br><span class="line">      anyListenerHandledUpdatingTarget |=</span><br><span class="line">          targetListener != <span class="keyword">null</span></span><br><span class="line">              &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">        Transition&lt;? <span class="keyword">super</span> R&gt; animation =</span><br><span class="line">            animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">        <span class="comment">//回调给目标 ImageViewTarget 资源准备好了</span></span><br><span class="line">        target.onResourceReady(result, animation);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//加载成功</span></span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这一步主要把准备好的资源回调给显示层!!!!!!!   终于快看到胜利的曙光了。</p>
<h4 id="4-7-显示资源"><a href="#4-7-显示资源" class="headerlink" title="4.7 显示资源"></a>4.7 显示资源</h4><p>资源终于完全准备好了，下面就是加载资源到控件上。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e81033e60884ea86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载资源到控件上.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Z</span>&gt; <span class="keyword">extends</span> <span class="title">ViewTarget</span>&lt;<span class="title">ImageView</span>, <span class="title">Z</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Transition</span>.<span class="title">ViewAdapter</span> </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> Z resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">      setResourceInternal(resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maybeUpdateAnimatable(resource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用 setResource 函数，将资源显示出来</span></span><br><span class="line">    setResource(resource);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>大家还记得么？在最开始构建的时候，我们知道只有调用 asBitmap 的时候实现类是 <code>BitmapImageViewTarget</code>,在这里的测试，并没有调用这个函数，所以它的实现类是 <code>DrawableImageViewTarget</code>,具体看下它内部实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableImageViewTarget</span> <span class="keyword">extends</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Drawable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view, <span class="keyword">boolean</span> waitForLayout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view, waitForLayout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Drawable resource)</span> </span>&#123;</span><br><span class="line">    view.setImageDrawable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看到抽象类中调用了 setResource ,子类实现并调用了 <strong>view.setImageDrawable(resource);</strong> 图片现在算是真正的显示出来了。</p>
]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>-Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础回顾--字符串操作</title>
    <url>/2021/05/09/C%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="1-字符串定义"><a href="#1-字符串定义" class="headerlink" title="1.字符串定义"></a>1.字符串定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义字符串</span></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;JACKOU&quot;</span>;</span><br><span class="line"><span class="comment">// 注意这样定义字符串最后一定需要加&#x27;\0&#x27;，否者系统会默认加入系统字符。</span></span><br><span class="line"><span class="comment">// 不加&#x27;\0&#x27;如下字符串长度为9，加了为6</span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = &#123;<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-计算字符串长度"><a href="#2-计算字符串长度" class="headerlink" title="2.计算字符串长度"></a>2.计算字符串长度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这种写法相当于: *string != &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (*<span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="built_in">string</span>++;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二不能用作参数传递</span></span><br><span class="line"><span class="keyword">int</span> intArr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(intArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，第二种方式不是完美的，有毛病，C/C++编译器，数组作为参数传递的时候，会把数组优化成指针</span></span><br><span class="line"><span class="comment">// 此时的len结果为：1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLen</span><span class="params">(<span class="keyword">int</span> intArr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(intArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三 #include&lt;string.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>


<h4 id="3-字符串转换"><a href="#3-字符串转换" class="headerlink" title="3.字符串转换"></a>3.字符串转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转int</span></span><br><span class="line">atoi(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转double</span></span><br><span class="line">atof();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转long</span></span><br><span class="line">atol();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转long long</span></span><br><span class="line">atoll();</span><br></pre></td></tr></table></figure>


<h4 id="4-字符串比较"><a href="#4-字符串比较" class="headerlink" title="4.字符串比较"></a>4.字符串比较</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;jackou1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="string">&quot;jackou&quot;</span>;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">strcmp</span>(str1, str2);</span><br><span class="line"><span class="comment">// strcmp相等返回0   strcmp区分大小写</span></span><br><span class="line"><span class="comment">// strcmpi 不区分大小写</span></span><br></pre></td></tr></table></figure>


<h4 id="5-字符串查找"><a href="#5-字符串查找" class="headerlink" title="5. 字符串查找"></a>5. 字符串查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;jackou1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="string">&quot;k&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">strstr</span>(str1,str2);</span><br><span class="line"><span class="comment">// 返回结果:kou1</span></span><br><span class="line"><span class="comment">// str是源字符串，str2是目标字符串，返回从目标字符串开支的以后字符串</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subString</span><span class="params">(<span class="keyword">char</span> *result, <span class="keyword">char</span> *str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        *(result++) = *(str + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6.结构体"></a>6.结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Study</span> <span class="title">study</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Wan</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *content;</span><br><span class="line">    &#125; wan;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">dog</span>;</span></span><br><span class="line">    <span class="comment">// 不赋值为系统值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dog: name=%s, age=%d, sex=%d \n&quot;</span>, dog.name, dog.age, dog.sex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-结构体指针"><a href="#7-结构体指针" class="headerlink" title="7.结构体指针"></a>7.结构体指针</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Cat &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct Cat cat &#x3D; &#123;&quot;cat&quot;, 5&#125;;</span><br><span class="line">    struct Cat *catP &#x3D; &amp;cat;</span><br><span class="line">    printf(&quot;name&#x3D;%s,age&#x3D;%d \n&quot;, catP-&gt;name, catP-&gt;age);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-正确的方法结果接收写法"><a href="#8-正确的方法结果接收写法" class="headerlink" title="8.正确的方法结果接收写法"></a>8.正确的方法结果接收写法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *result = <span class="string">&quot;abc&quot;</span>; <span class="comment">//赋过值的指针不能用于接收结果，因为result已经指向静态常量区的“abc”了</span></span><br><span class="line">    <span class="keyword">char</span> *result1 = <span class="literal">NULL</span>; <span class="comment">//原因同上，已经指向NULL了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *result2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    action(result2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> result3[<span class="number">100</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 不会报错因为数组元素是在栈区分配空间</span></span><br><span class="line">    action(result3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="9-typedef"><a href="#9-typedef" class="headerlink" title="9. typedef"></a>9. typedef</h4><p>为了兼容方法内部的内容不做改变，使用typedef来定义结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Person;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C基础</tag>
        <tag>字符串操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础回顾--指针相关知识点</title>
    <url>/2021/05/09/C%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="1-lt-gt-和“”引用区别"><a href="#1-lt-gt-和“”引用区别" class="headerlink" title="1. &lt;&gt;和“”引用区别"></a>1. &lt;&gt;和“”引用区别</h4><ul>
<li>#include &lt;&gt; 主要用于对标准库的引用</li>
<li>#include “”  主要用于对自定义本地库的引用</li>
</ul>
<h4 id="2-指针函数"><a href="#2-指针函数" class="headerlink" title="2. 指针函数"></a>2. 指针函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result : %d \n&quot;</span>, i + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>(*p)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    p(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// p被明确声明为函数指针，可以省略*</span></span><br><span class="line">    (p)(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// p被明确声明为函数指针，可以省略*</span></span><br><span class="line">    (*p)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(add);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-文档查看"><a href="#3-文档查看" class="headerlink" title="3.文档查看"></a>3.文档查看</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看文档方法中有 &amp;xxxx 可以尝试传NULL试试</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span>) time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rand num: %d \n&quot;</span>, + rand() / <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-静态内存和动态内存"><a href="#4-静态内存和动态内存" class="headerlink" title="4. 静态内存和动态内存"></a>4. 静态内存和动态内存</h4><blockquote>
<p>静态内存(栈内开辟内存)和动态内存开僻(使用malloc开辟内存)。</p>
</blockquote>
<h5 id="4-1-栈上分配内存"><a href="#4-1-栈上分配内存" class="headerlink" title="4.1 栈上分配内存"></a>4.1 栈上分配内存</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用执行会入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">staticMem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>]; <span class="comment">//在栈空间分配20字节内存</span></span><br><span class="line">&#125; <span class="comment">// 执行完毕会出栈</span></span><br><span class="line"><span class="comment">// 每次开辟/释放20字节</span></span><br></pre></td></tr></table></figure>


<h5 id="4-2-堆上分配内存"><a href="#4-2-堆上分配内存" class="headerlink" title="4.2 堆上分配内存"></a>4.2 堆上分配内存</h5><ul>
<li>野指针：没有指向的指针。指针不使用了需要指向NULL。</li>
<li>悬空指针：当堆内存释放之后，指针指向的地址还在，这就形成了悬空指针。当堆内存空间被释放之后，需要将指针指向NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicMem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int *p; // 野指针</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// 规范写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>);   <span class="comment">// 1M</span></span><br><span class="line">    <span class="comment">// &amp;arr取栈上地址, arr堆上的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack addr: %p , deap addr: %p \n&quot;</span>, &amp;arr, arr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr); <span class="comment">//如果不释放，内存地址会一直添加</span></span><br><span class="line">    arr = <span class="literal">NULL</span>;  <span class="comment">// 如果不指向NULL，会出现 “悬空指针”</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack addr: %p , deap addr: %p \n&quot;</span>, &amp;arr, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        dynamicMem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-堆上空间分配使用场景"><a href="#5-堆上空间分配使用场景" class="headerlink" title="5.堆上空间分配使用场景"></a>5.堆上空间分配使用场景</h4><h5 id="5-1-开辟可变空间-malloc"><a href="#5-1-开辟可变空间-malloc" class="headerlink" title="5.1 开辟可变空间(malloc)"></a>5.1 开辟可变空间(malloc)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please insert the count of the number: \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> insert_num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please insert No.%d :&quot;</span>, (i + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;insert_num);</span><br><span class="line">        arr[i] = insert_num;</span><br><span class="line">        <span class="comment">// *(arr + i) == arr[i]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;your number is: %d , the addr: %p\n&quot;</span>, *(arr + i), arr + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr) &#123;</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-2-在原来分配的基础上继续再分配"><a href="#5-2-在原来分配的基础上继续再分配" class="headerlink" title="5.2 在原来分配的基础上继续再分配"></a>5.2 在原来分配的基础上继续再分配</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please insert the count of the number: \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> insert_num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please insert No.%d :&quot;</span>, (i + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;insert_num);</span><br><span class="line">        arr[i] = insert_num;</span><br><span class="line">        <span class="comment">// *(arr + i) == arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;your number is: %d , the addr: %p\n&quot;</span>, *(arr + i), arr + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在原基础上新增加空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please insert the count of the new memory: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> newMem;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;newMem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// realloc第一个参数传入指针是为了防止分配内存不够时，系统会重新开辟一个连续的空间，然后把以前地址(arr)的数据拷贝过来。</span></span><br><span class="line">    <span class="keyword">int</span> *newArr = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (num + newMem));</span><br><span class="line">    <span class="keyword">if</span> (newArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &lt; num + newMem; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> insert_num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;please insert No.%d :&quot;</span>, (i + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;insert_num);</span><br><span class="line">            newArr[i] = insert_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num + newMem; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;your number is: %d , the addr: %p\n&quot;</span>, *(newArr + i), newArr + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newArr) &#123;</span><br><span class="line">        <span class="comment">// 开辟成功了释放新内存空间，包含了旧地址空间</span></span><br><span class="line">        <span class="built_in">free</span>(newArr);</span><br><span class="line">        newArr = <span class="literal">NULL</span>;</span><br><span class="line">        arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没成功释放旧内存即可</span></span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C基础</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide内存管理</title>
    <url>/2021/05/14/Glide%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>Glide框架的核心内容主要包含生命周期自动管理和内存管理，生命周期管理在《<a href="https://www.jianshu.com/p/f42a2c00c9d1">Glide源码分析-生命周期管理</a>》有详细叙述到，本篇主要叙述Glide框架的内存管理。</p>
<h3 id="2-内存管理总体框架"><a href="#2-内存管理总体框架" class="headerlink" title="2.内存管理总体框架"></a>2.内存管理总体框架</h3><p>Glide内存管理分为如下图中五种情况，下面我们一一来分析这五种情况资源是如何在内存中移动的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4b8adbac673e1e55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide内存管理.png"></p>
<h4 id="2-1-资源在活动内存中"><a href="#2-1-资源在活动内存中" class="headerlink" title="2.1 资源在活动内存中"></a>2.1 资源在活动内存中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveResources</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isActiveResourceRetentionAllowed;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor monitorClearedResourcesExecutor;</span><br><span class="line">  <span class="comment">// 保存正在显示资源的弱已用</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span> <span class="keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一种情况是资源仅在活动内存中。</strong>Map&lt;Key, ResourceWeakReference&gt;就是我们所讲的活动内存，此内存保存界面正在加载的资源，当资源仅存在活动内存的时候，Glide会直接加载资源到控件中。</p>
<h4 id="2-2-资源在内存缓存中"><a href="#2-2-资源在内存缓存中" class="headerlink" title="2.2 资源在内存缓存中"></a>2.2 资源在内存缓存中</h4><p><strong>第二种情况是资源不在活动内存中，在内存缓存中。</strong>从图中可以看出，这种情况资源会从内存缓存中删除(<strong>删除后如虚线圈所示</strong>)，然后被挪到活动缓存中，Glide从活动缓存中加载资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">// 从内存缓存中获取资源</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cached.acquire();</span><br><span class="line">      <span class="comment">// 保存到活动缓存中</span></span><br><span class="line">      activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//取资源</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">// cache是内存缓存，首先从内存缓存中取出元素，并且删除内存缓存中元素</span></span><br><span class="line">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">      <span class="comment">// Save an object allocation if we&#x27;ve cached an EngineResource (the typical case).</span></span><br><span class="line">      result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result =</span><br><span class="line">          <span class="keyword">new</span> EngineResource&lt;&gt;(</span><br><span class="line">              cached, <span class="comment">/*isMemoryCacheable=*/</span> <span class="keyword">true</span>, <span class="comment">/*isRecyclable=*/</span> <span class="keyword">true</span>, key, <span class="comment">/*listener=*/</span> <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存资源</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    ResourceWeakReference toPut =</span><br><span class="line">        <span class="keyword">new</span> ResourceWeakReference(</span><br><span class="line">            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存资源到活动缓存中</span></span><br><span class="line">    ResourceWeakReference removed = activeEngineResources.put(key, toPut);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-资源在用户申明的Glide磁盘中"><a href="#2-3-资源在用户申明的Glide磁盘中" class="headerlink" title="2.3 资源在用户申明的Glide磁盘中"></a>2.3 资源在用户申明的Glide磁盘中</h4><p><strong>第三种情况是活动缓存和内存缓存都没有资源，资源保存在用户申明的磁盘缓存中。</strong>这种情况Glide会尝试从本地磁盘缓存中获取，如果获取到了<strong>复制</strong>资源(**实线圈)**到活动缓存中显示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 获取key</span></span><br><span class="line">    EngineKey key =</span><br><span class="line">        keyFactory.buildKey(</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            transformations,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            options);</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line">	  </span><br><span class="line">      <span class="comment">// 内存缓存中没有资源</span></span><br><span class="line">      <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            options,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            cb,</span><br><span class="line">            callbackExecutor,</span><br><span class="line">            key,</span><br><span class="line">            startTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Avoid calling back while holding the engine lock, doing so makes it easier for callers to</span></span><br><span class="line">    <span class="comment">// deadlock.</span></span><br><span class="line">    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>具体如何从磁盘缓存中获取资源流程可以参考《<a href="https://www.jianshu.com/p/cfcca86587e4">Glide源码分析</a>—4.2 从不同缓存中搜寻资源》 </p>
<h4 id="2-4-资源在云端"><a href="#2-4-资源在云端" class="headerlink" title="2.4 资源在云端"></a>2.4 资源在云端</h4><p><strong>第四种情况本地没有资源，资源在云端。</strong>这种情况Glide会首先搜寻活动缓存，然后搜寻内存缓存，再搜寻本地磁盘缓存。如果以上三者都搜不到，那就启动httpurlconnection从网络上加载资源。当资源下载好之后将资源保存在磁盘缓存中，并且将资源复制到活动缓存中，供界面显示。</p>
<h4 id="2-5-资源回收"><a href="#2-5-资源回收" class="headerlink" title="2.5 资源回收"></a>2.5 资源回收</h4><p>当空白Fragment感知到界面被销毁，onDestory()方法被调用之后，Glide最终会调用活动缓存中的onResourceReleased方法，此方法中资源会从活动缓存中回收，然后被保存到内存缓存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从活动缓存中删除</span></span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      <span class="comment">// 保存到内存缓存中</span></span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deactivate</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    ResourceWeakReference removed = activeEngineResources.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-在运行时缓存中为什么会做成两级缓存，意义何在"><a href="#3-在运行时缓存中为什么会做成两级缓存，意义何在" class="headerlink" title="3.在运行时缓存中为什么会做成两级缓存，意义何在"></a>3.在运行时缓存中为什么会做成两级缓存，意义何在</h3><h4 id="3-1-只有LRU内存缓存，没有活动缓存"><a href="#3-1-只有LRU内存缓存，没有活动缓存" class="headerlink" title="3.1 只有LRU内存缓存，没有活动缓存"></a>3.1 只有LRU内存缓存，没有活动缓存</h4><p>LRU内存缓存有个特性，就是当LRU缓存装满的时候，如果还有资源需要存储，缓存会将最近最少使用的资源删除，然后保存新添加的资源。</p>
<p>如果只有LRU内存缓存的话，会出现一个BUG，接入我设置LRU内存缓存大小为5，如果RecycleView需要加载的资源为5张图片了，缓慢滚动屏幕，有一张图片出现，需要新加入到LRU中，那最先放入LRU中的那种图片就会被销毁，然而那种图片还有一部分正在显示。这样就会引起崩溃。</p>
<p>所以鉴于此BUG，活动内存就应运而生，活动内存是一个map集合，随便存多少，因此为了清晰管理内存。活动内存专门存放当前界面显示的资源，LRU缓存负责缓存暂时不在显示的资源。</p>
<h4 id="3-2-只有活动缓存，没有LRU内存缓存"><a href="#3-2-只有活动缓存，没有LRU内存缓存" class="headerlink" title="3.2 只有活动缓存，没有LRU内存缓存"></a>3.2 只有活动缓存，没有LRU内存缓存</h4><p>只有活动缓存(Map)不是不行，只是如果存储和删除都在一个map集合中，管理起来比较混乱，而且在操作map的时候一定要采用同步，扩大了同步操作范围，降低效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步释放资源</span></span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      <span class="comment">// 此处没有同步了，如果用一个集合的话，需要将此map也放在同步块中操作。</span></span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>-Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>(1)C++面向对象</title>
    <url>/2021/05/19/1-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="1-amp-引用"><a href="#1-amp-引用" class="headerlink" title="1. &amp;引用"></a>1. &amp;引用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递，内存地址不一样</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = n1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;n1 &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; &amp;n2 &lt;&lt; <span class="built_in">endl</span>;*/ <span class="comment">// 0xffffcbb4---0xffffcbb0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &amp;引用，对被引用地址操作</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; n2 = n1;</span><br><span class="line"><span class="keyword">int</span> &amp; n9 = n1;</span><br><span class="line">n2 = <span class="number">777</span>;</span><br><span class="line">n9 = <span class="number">9527</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;n1 &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; &amp;n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;值：&quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//结果: 0x28ff0c---0x28ff0c</span></span><br><span class="line"><span class="comment">// 9527---9527</span></span><br></pre></td></tr></table></figure>


<h4 id="2-常量引用"><a href="#2-常量引用" class="headerlink" title="2.常量引用"></a>2.常量引用</h4><p>C++的常量是真的常量，C是伪常量，C的常量可以通过指针修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法内部可以修改student,因此会报问题，需要使用到常量引用，在方法体内部不能修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法。</span></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(<span class="keyword">const</span> Student &amp;student)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//方法内对student为只读，不可修改</span></span><br><span class="line">    <span class="comment">// student是旧地址</span></span><br><span class="line">    <span class="comment">// this是新地址</span></span><br><span class="line">    <span class="comment">// student2就是新地址了</span></span><br><span class="line">    student2 = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-深浅拷贝"><a href="#3-深浅拷贝" class="headerlink" title="3.深浅拷贝"></a>3.深浅拷贝</h4><p>浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">// strcpy运行会报错，支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line">	Student2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;空参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">	Student2(<span class="keyword">char</span> * name) :Student2(name, <span class="number">99</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一个参数构造函数 this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Student2(<span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二个参数构造函数 this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)* <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Student2() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数执行 &amp;this-&gt;name:&quot;</span> &lt;&lt; &amp;<span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认有一个拷贝构造函数 隐士的 我们看不见</span></span><br><span class="line">	<span class="comment">// 一旦复写了拷贝构造函数，默认的还在吗？ Java的构造函数一个思路</span></span><br><span class="line">	Student2(<span class="keyword">const</span> Student2 &amp; stu) &#123;</span><br><span class="line">		<span class="comment">// stu 旧地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// this 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// s2 = 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数 &amp;stu:&quot;</span> &lt;&lt; &amp;stu &lt;&lt; <span class="string">&quot; this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 新地址name = 旧地址 （浅拷贝）</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = stu.name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 深拷贝 后面见  原理全部打通的时候讲</span></span><br><span class="line">	&#125; <span class="comment">// 此拷贝构造函数执行完 旧会出现一个 this==新地址  给 main函数的 stu</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Student2 <span class="title">getStudent</span><span class="params">(<span class="keyword">char</span> * name)</span> </span>&#123;</span><br><span class="line">	<span class="function">Student2 <span class="title">stu</span><span class="params">(name)</span></span>; <span class="comment">// 旧地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;getStudent函数:&quot;</span> &lt;&lt; &amp;stu &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 旧地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stu; <span class="comment">// stu 旧地址</span></span><br><span class="line">&#125; <span class="comment">// 弹栈 释放 栈成员 stu</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainT3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// = 会执行拷贝构造函数</span></span><br><span class="line">	<span class="comment">// stu 新地址</span></span><br><span class="line">	Student2 stu = getStudent(<span class="string">&quot;截拳道&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数:&quot;</span> &lt;&lt; &amp;stu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印：</span></span><br><span class="line">	<span class="comment">// 两个参数构造函数</span></span><br><span class="line">	<span class="comment">// 一个参数构造函数</span></span><br><span class="line">	<span class="comment">// getStudent函数: 1000H地址</span></span><br><span class="line">	<span class="comment">// 拷贝构造函数 构建新地址 把新地址 给 main函数的 stu == 新地址</span></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	<span class="comment">// main函数: </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// getchar(); // 不要一闪而过，让程序停留   需要在拷贝构造函数中使用深拷贝，然后在析构函数中释放this的内存</span></span><br><span class="line">&#125; <span class="comment">// main函数弹栈 stu 新地址 析构函数执行</span></span><br></pre></td></tr></table></figure>


<p>深拷贝：</p>
<p>如果类成员变量中有堆成员，就需要重写拷贝构造函数，实现深拷贝。默认的拷贝构造函数是<strong>浅拷贝</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">// strcpy运行会报错，支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line">	Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;空参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">	Student(<span class="keyword">char</span> * name) :Student(name, <span class="number">99</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一个参数构造函数 this:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Student(<span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二个参数构造函数 this:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)* <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Student() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数执行 &amp;this-&gt;name:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认有一个拷贝构造函数 隐士的 我们看不见</span></span><br><span class="line">	<span class="comment">// 一旦复写了拷贝构造函数，默认的还在吗？ Java的构造函数一个思路</span></span><br><span class="line">	<span class="comment">// 自定义拷贝构造函数 如果有堆成员，必须采用深拷贝</span></span><br><span class="line">	Student(<span class="keyword">const</span> Student &amp; stu) &#123;</span><br><span class="line">		<span class="comment">// stu 旧地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// this 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// s2 = 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数 &amp;stu:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;stu &lt;&lt; <span class="string">&quot; this:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 【浅拷贝】：新地址name  旧地址name 指向同一个空间，会造成，重复free的问题，引发奔溃</span></span><br><span class="line">		<span class="comment">// 新地址name = 旧地址 （浅拷贝）</span></span><br><span class="line">		<span class="comment">// this-&gt;name = stu.name;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 【深拷贝】</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)* <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = stu.age;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数2 this-&gt;name:&quot;</span> &lt;&lt; ((<span class="keyword">int</span>) <span class="keyword">this</span>-&gt;name) &lt;&lt; <span class="string">&quot;  stu.name:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)stu.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 深拷贝 后面见  原理全部打通的时候讲</span></span><br><span class="line">	&#125; <span class="comment">// 此拷贝构造函数执行完 旧会出现一个 this==新地址  给 main函数的 stu</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认的拷贝构造函数 是浅拷贝</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//stu是新地址，拷贝构造函数构建新地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStudent</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;showStudent函数：&quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;stu &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; stu.age&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;刘奋&quot;</span>, <span class="number">31</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	showStudent(stu); <span class="comment">// 弹栈后 新地址name释放一遍</span></span><br><span class="line">	<span class="comment">// showStudent(stu); // 弹栈后 新地址name释放一遍</span></span><br><span class="line">	<span class="comment">// 两次释放新地址name 会奔溃</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放一次新地址name  再释放一次旧name也报错</span></span><br><span class="line"></span><br><span class="line">	showStudent(stu);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">&#125; <span class="comment">// main函数弹栈 stu 旧地址</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>(2)iptables规则管理</title>
    <url>/2021/05/20/2-iptables%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-查看表中规则"><a href="#1-查看表中规则" class="headerlink" title="1.查看表中规则"></a>1.查看表中规则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看filter表中所有规则</span></span><br><span class="line">iptables -t filter -L</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询filter表中INPUT链规则</span></span><br><span class="line">iptables -t filter -L INPUT</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6a5054ba3a6a8777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询表.png"></p>
<h4 id="2-查看规则详情"><a href="#2-查看规则详情" class="headerlink" title="2.查看规则详情"></a>2.查看规则详情</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加入-v参数，查看详情</span></span><br><span class="line">iptables -t filter -L -v</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-fddf11792689aa45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看规则详情.png"></p>
<p>规则字段含义：</p>
<ul>
<li><strong>pkts</strong>:对应规则匹配到的报文的个数。</li>
<li><strong>bytes</strong>:对应匹配到的报文包的大小总和。</li>
<li><strong>target</strong>:规则对应的target，往往表示规则对应的”动作”，即规则匹配成功后需要采取的措施。</li>
<li><strong>prot</strong>:表示规则对应的协议，是否只针对某些协议应用此规则。</li>
<li><strong>opt</strong>:表示规则对应的选项。</li>
<li><strong>in</strong>:表示数据包由哪个接口(网卡)流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li><strong>out</strong>:表示数据包由哪个接口(网卡)流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li><strong>source</strong>:表示规则对应的源头地址，可以是一个IP，也可以是一个网段。</li>
<li><strong>destination</strong>:表示规则对应的目标地址。可以是一个IP，也可以是一个网段。</li>
</ul>
<p>上图中的源地址与目标地址都为anywhere，iptables默认为我们进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低，我们可以使用 <code>-n</code> 选项，表示不对IP地址进行名称反解，直接显示IP地址</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-52e385dc6a00782e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看某链上细化规则.PNG"></p>
<p>链括号中的参数含义：</p>
<p>Chain INPUT (policy ACCEPT 4883 packets, 342K bytes)</p>
<ul>
<li><strong>policy</strong>表示当前链的默认策略，policy ACCEPT表示上图中INPUT的链的默认动作为ACCEPT，换句话说就是，默认接受通过INPUT关卡的所有请求，所以我们在配置INPUT链的具体规则时，应该将需要拒绝的请求配置到规则中，说白了就是”黑名单”机制，默认所有人都能通过，只有指定的人不能通过。</li>
<li><strong>packets</strong>表示当前链（上例为INPUT链）默认策略匹配到的包的数量，0 packets表示默认策略匹配到0。</li>
<li><strong>bytes</strong>表示当前链默认策略匹配到的所有包的大小总和。</li>
</ul>
<h4 id="3-显示规则行号"><a href="#3-显示规则行号" class="headerlink" title="3.显示规则行号"></a>3.显示规则行号</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables --line-number -nvL INPUT</span><br><span class="line"></span><br><span class="line">// 查看精细的字节数可以加-x参数</span><br><span class="line">iptables -nvxL INPUT</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-984020d39d5d27fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看精确字节数.png"></p>
<h4 id="4-添加规则"><a href="#4-添加规则" class="headerlink" title="4.添加规则"></a>4.添加规则</h4><p>使用  <code>-I</code> 或者 <code>-A</code> 来添加规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 14.215.177.39 为百度的一个ip</span></span><br><span class="line">iptables -t filter -I INPUT -s 14.215.177.39 -j DROP</span><br><span class="line">iptables -t filter -A INPUT -s 14.215.177.39 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在INPUT链的第一行添加规则</span></span><br><span class="line">iptables -t filter -A INPUT 1 -s 14.215.177.39 -j ACCEPT</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用-I选项，指明将”规则”插入至哪个链中，-I表示insert，即插入的意思，所以-I INPUT表示将规则插入于INPUT链中，即添加规则之意。</p>
</li>
<li><p>使用-s选项，指明”匹配条件”中的”源地址”，即如果报文的源地址属于-s对应的地址，那么报文则满足匹配条件，-s为source之意，表示源地址。</p>
</li>
<li><p>使用-j选项，指明当”匹配条件”被满足时，所对应的动作，上例中指定的动作为DROP，在上例中，当报文的源地址为14.215.177.39时，报文则被DROP（丢弃）。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bd5416095ad6a169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加规则.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d6fc8d76fc3a0ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证新加规则.png"></p>
<h4 id="5-删除规则"><a href="#5-删除规则" class="headerlink" title="5.删除规则"></a>5.删除规则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除多少行,删除第一行规则</span><br><span class="line">iptables -t filter -D INPUT 1</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cc35faed601dc5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除规则.png"></p>
<h4 id="6-修改规则"><a href="#6-修改规则" class="headerlink" title="6.修改规则"></a>6.修改规则</h4><p>使用 <code>-R</code> 来更改指定行数规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将INPUT链第一行规则改为接受14.215.177.39的报文,此处一定要加上-s，否者将默认0.0.0.0/0，接受全部。</span></span><br><span class="line">iptables -t filter -R INPUT 1 -s 14.215.177.39 -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="7-设置链默认规则"><a href="#7-设置链默认规则" class="headerlink" title="7.设置链默认规则"></a>7.设置链默认规则</h4><p>使用 <code>-P</code>参数设置链默认规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置filter表FORWARD链默认规则为DROP</span></span><br><span class="line">iptables -t filter -P FORWARD DROP</span><br></pre></td></tr></table></figure>


<h4 id="8-保存-恢复配置信息"><a href="#8-保存-恢复配置信息" class="headerlink" title="8.保存/恢复配置信息"></a>8.保存/恢复配置信息</h4><p>使用<code>iptables-save</code> 指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /data/iptables-rules</span><br><span class="line">iptables-restore &lt; /data/iptables-rules</span><br></pre></td></tr></table></figure>


<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.zsythink.net/archives/1517">iptables规则管理</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>解决自定义rc文件启动不生效问题</title>
    <url>/2021/05/14/%E8%A7%A3%E5%86%B3%E8%87%AA%E5%AE%9A%E4%B9%89rc%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-自定义rc文件"><a href="#1-自定义rc文件" class="headerlink" title="1.自定义rc文件"></a>1.自定义rc文件</h3><p>自定义一个标签，找一个可以执行的rc文件赋值进去。我是保存在/device/<vendor>/<product>/init.target.rc中。</product></vendor></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service firewalldaemon /vendor/bin/firewalldaemon</span><br><span class="line">    class main</span><br><span class="line">    user system</span><br><span class="line">    group system inet net_admin</span><br><span class="line">    disabled</span><br><span class="line">    capabilities NET_ADMIN NET_RAW</span><br><span class="line">    socket firewall stream 0660 root system</span><br><span class="line"></span><br><span class="line">on zygote-start</span><br><span class="line">    start firewalldaemon</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android.mk文件</span></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">#LOCAL_PROPRIETARY_MODULE := true</span><br><span class="line">LOCAL_VENDOR_MODULE := <span class="keyword">true</span></span><br><span class="line">LOCAL_MODULE := firewalldaemon</span><br><span class="line">LOCAL_INIT_RC := firewalldaemon.rc</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line">LOCAL_CPPFLAGS := -Wall \</span><br><span class="line">                  -Werror \</span><br><span class="line">                  -Wno-unused-parameter \</span><br><span class="line">                  -DLOG_TAG=\<span class="string">&quot;FirewallDaemon\&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LOCAL_SRC_FILES := src/ServerSocket.cpp \</span></span><br><span class="line"><span class="string">                   src/Socket.cpp \</span></span><br><span class="line"><span class="string">                   src/main.cpp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LOCAL_C_INCLUDES := src/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LOCAL_SHARED_LIBRARIES := \</span></span><br><span class="line"><span class="string">    liblogwrap \</span></span><br><span class="line"><span class="string">    libcutils \</span></span><br><span class="line"><span class="string">    libutils \</span></span><br><span class="line"><span class="string">    liblog</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">include $(GEN_PREBUILT_PACKAGE)</span></span><br><span class="line"><span class="string">include $(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure>


<p>编译出来一个firewalldaemon可执行文件。</p>
<p>将firewalldaemon PUSH到/vendor/bin目录下。</p>
<p>然后修改/vendor/etc/init/hw/init.qcom.rc，将上面rc标签复制到这个文件末尾，重启车机会发现我们标签声明的文件根本没有执行。</p>
<h4 id="2-调查问题"><a href="#2-调查问题" class="headerlink" title="2.调查问题"></a>2.调查问题</h4><h4 id="2-1-Selinux权限问题"><a href="#2-1-Selinux权限问题" class="headerlink" title="2.1 Selinux权限问题"></a>2.1 Selinux权限问题</h4><p>猜测是不是selinux没有给权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:/ # getenforce</span><br><span class="line">Permissive</span><br></pre></td></tr></table></figure>
<p>发现是在兼容模式，讲道理应该只是有日志输出来，不会拦截呀。排除这个可能。</p>
<h4 id="2-2-ramdisk介绍与定制"><a href="#2-2-ramdisk介绍与定制" class="headerlink" title="2.2 ramdisk介绍与定制"></a>2.2 ramdisk介绍与定制</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-4718e1679166d3f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="randisk介绍.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-61adaba8d46c0cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存磁盘镜像.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ad6b9bb1e9b405e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="烧写镜像.png"></p>
<p>最后发现车机高通的系统修改了RC文件，重启之后RC文件并没有被替换成boot.img中的文件。说明修改是生效了的。但是服务还是无法启动。</p>
<h4 id="2-3启动指令启动服务"><a href="#2-3启动指令启动服务" class="headerlink" title="2.3启动指令启动服务"></a>2.3启动指令启动服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:/ # setprop ctl.start firewalldaemon</span><br><span class="line">setprop ctl.start firewalldaemon</span><br></pre></td></tr></table></figure>
<p>我写的firewalldaemon是一个while(1)不会退出程序，结果通过指令也无法启动，查看dmesg信息，报如下问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:/ # dmesg|grep -ie firewall</span><br><span class="line">dmesg|grep -ie firewall</span><br><span class="line">[ 6592.467286] init: Received control message &#x27;start&#x27; for &#x27;firewalldaemon&#x27; from pid: 29798 (setprop ctl.start firewalldaemon)</span><br><span class="line">[ 6592.467412] init: Could not ctl.start for service firewalldaemon: File /vendor/bin/firewalldaemon(labeled &quot;u:object_r:vendor_file:s0&quot;) has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials</span><br></pre></td></tr></table></figure>
<p>此消息说明即使Selinux是Permissive模式也不行，因为进程还没有起来，进程起来之后才可以通过Permissive模式配置规则。</p>
<p>于是开始配置规则。 </p>
<ul>
<li>step 1:  为<code>/vendor/bin/firewalldaemon</code> 添加标签</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//在device/qcom/sepolicy/vendor/common/file_contexts 添加</span><br><span class="line"></span><br><span class="line">/vendor/bin/firewalldaemon                      u:object_r:firewalldaemon_exec:s0</span><br></pre></td></tr></table></figure>
<ul>
<li>step 2: 创建一个新网域“firewalldaemon”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 创建device/qcom/sepolicy/vendor/common/firewalldaemon.te</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewalldaemon service</span></span><br><span class="line">type firewalldaemon, domain;</span><br><span class="line">type firewalldaemon_exec, vendor_file_type, exec_type, file_type;</span><br><span class="line"></span><br><span class="line">init_daemon_domain(firewalldaemon)</span><br></pre></td></tr></table></figure>
<ul>
<li>step 3: 在init.target.rc中添加需要启动的服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;device&#x2F;qcom&#x2F;msmnile_gvmq&#x2F;init.target.rc</span><br><span class="line"></span><br><span class="line">service firewalldaemon &#x2F;vendor&#x2F;bin&#x2F;firewalldaemon</span><br><span class="line">    class main</span><br><span class="line">    user system</span><br><span class="line">    group system inet net_admin</span><br><span class="line">    disabled</span><br><span class="line">    capabilities NET_ADMIN NET_RAW</span><br><span class="line">    socket tsfirewall stream 0660 root system</span><br></pre></td></tr></table></figure>
<ul>
<li>重新编译系统并且烧写img</li>
</ul>
<h4 id="2-4-编译问题"><a href="#2-4-编译问题" class="headerlink" title="2.4 编译问题"></a>2.4 编译问题</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 编译日志输出：</span><br><span class="line">make -j4 2&gt;&amp;1 | tee android_build_log.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4db44212aa601751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译报错.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4cb7fd1c1b88af12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错原因.png"></p>
<p>报错信息：执行文件需要vendor file域，需要在firewalldaemon.te中添加vendor_file_type</p>
<h4 id="2-5-生成vendor-img"><a href="#2-5-生成vendor-img" class="headerlink" title="2.5 生成vendor.img"></a>2.5 生成vendor.img</h4><p>使用fastboot烧写img</p>
<p>进入fastboot模式按住“Q”开机启动，但是串口无法输入。查看USB驱动是否有，查看串口工具配置，记得关闭“流控”。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4355be37af916991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="串口配置.png"></p>
<p>连接成功，进入到fastboot模式</p>
<p>使用电脑CMD查看连接设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 查看设备</span><br><span class="line">fastboot devices -l</span><br><span class="line"></span><br><span class="line">// 烧写img</span><br><span class="line">fastboot flash la_vendor_a C:\Users\81566\Desktop\vendor.img</span><br><span class="line"></span><br><span class="line">// 可刷写的img</span><br><span class="line">fastboot flash la_system_a system.img</span><br><span class="line">fastboot flash la_vendor_a vendor.img</span><br><span class="line">fastboot flash la_userdata userdata.img</span><br><span class="line">fastboot flash la_persist persist.img</span><br><span class="line">fastboot flash vbmeta_a vbmeta.img</span><br><span class="line">fastboot flash dtbo_a dtbo.img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 重启车机</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5458deb41b1a40c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="烧写成功.png"></p>
<h4 id="2-6-重启车机见证奇迹的时刻"><a href="#2-6-重启车机见证奇迹的时刻" class="headerlink" title="2.6 重启车机见证奇迹的时刻"></a>2.6 重启车机见证奇迹的时刻</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-403ac01278d9064a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="firewall服务自启动.png"></p>
<h4 id="3-编译报缺少classes-head-jar"><a href="#3-编译报缺少classes-head-jar" class="headerlink" title="3.编译报缺少classes-head.jar"></a>3.编译报缺少classes-head.jar</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-0fe54998d6f715c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译缺少classes-header.png"></p>
<p>解决办法：将工程移入到/vendor/ts/proprietary</p>
<p>然后正常编译即可</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>(4)Firewall实战</title>
    <url>/2021/05/24/4-Firewall%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h4 id="1-防火墙黑白名单定义"><a href="#1-防火墙黑白名单定义" class="headerlink" title="1. 防火墙黑白名单定义"></a>1. 防火墙黑白名单定义</h4><p>当链的默认策略为ACCEPT时，链中的规则对应的动作应该为DROP或者REJECT，表示只有匹配到规则的报文才会被拒绝，没有被规则匹配到的报文都会被默认接受，这就是”黑名单”机制。</p>
<p>同理，当链的默认策略为DROP时，链中的规则对应的动作应该为ACCEPT，表示只有匹配到规则的报文才会被放行，没有被规则匹配到的报文都会被默认拒绝，这就是”白名单”机制。</p>
<h4 id="2-有问题的白名单机制"><a href="#2-有问题的白名单机制" class="headerlink" title="2.有问题的白名单机制"></a>2.有问题的白名单机制</h4><p>运行ssh远程连接和web服务连接，其他全部拒绝</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -P INPUT DROP</span><br></pre></td></tr></table></figure>
<p>但是这样配置会有问题，如果使用<code>iptables -F</code>清空了所有规则，这样就会导致所有请求都会被DROP，只能通过刷机才能连上车机了。</p>
<h4 id="3-正确的白名单机制"><a href="#3-正确的白名单机制" class="headerlink" title="3.正确的白名单机制"></a>3.正确的白名单机制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -j REJECT</span><br></pre></td></tr></table></figure>
<p>既将INPUT链的默认策略设置为了ACCEPT，同时又使用了白名单机制，因为如果报文符合放行条件，则会被前面的放行规则匹配到，如果报文不符合放行条件，则会被最后一条拒绝规则匹配到，此刻，即使我们误操作，执行了”iptables -F”操作，也能保证管理员能够远程到主机上进行维护，因为默认策略仍然是ACCEPT。</p>
<h4 id="4-自定义链"><a href="#4-自定义链" class="headerlink" title="4.自定义链"></a>4.自定义链</h4><p><code>-N vendor_fw_INPUT</code>表示创建一个自定义链，自定义链的名称为”vendor_fw_INPUT”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建链</span></span><br><span class="line">iptables -t filter -N vendor_fw_INPUT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建规则：http请求走自定义链</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -j vendor_fw_INPUT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下具体配置vendor_fw_INPUT上的规则即可。</span></span><br></pre></td></tr></table></figure>
<p>此时 <code>vendor_fw_INPUT</code> 就会在INPUT链上有一次引用。</p>
<p>如果我们不喜欢vendor_fw_INPUT这个链的名字，需要改成gxatek_fw_INPUT。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -E vendor_fw_INPUT gxatek_fw_INPUT</span><br></pre></td></tr></table></figure>


<h4 id="5-删除自定义链"><a href="#5-删除自定义链" class="headerlink" title="5.删除自定义链"></a>5.删除自定义链</h4><p>使用”-X”选项可以删除自定义链，但是删除自定义链时，需要满足两个条件：</p>
<ul>
<li><p>1、自定义链没有被任何默认链引用，即自定义链的引用计数为0。</p>
</li>
<li><p>2、自定义链中没有任何规则，即自定义链为空。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除gxatek_fw_INPUT链</span></span><br><span class="line">iptables -X gxatek_fw_INPUT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果链上有引用，先删除链上的引用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除input链上第一条，引用gxatek_fw_INPUT的那行</span></span><br><span class="line">iptables -D INPUT 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空链上规则</span></span><br><span class="line">iptables -t filter -F gxatek_fw_INPUT</span><br></pre></td></tr></table></figure>


<h4 id="6-防火墙架构"><a href="#6-防火墙架构" class="headerlink" title="6.防火墙架构"></a>6.防火墙架构</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-765096dbea7f51e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="防火墙架构.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>(3)iptables匹配条件总结</title>
    <url>/2021/05/21/3-iptables%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1-配置多源ip或者网段限制"><a href="#1-配置多源ip或者网段限制" class="headerlink" title="1.配置多源ip或者网段限制"></a>1.配置多源ip或者网段限制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 丢弃掉来自192.168.1.111,192.168.1.112的所有报文</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.111,192.168.1.112 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> DROP掉某个网段的报文</span></span><br><span class="line">iptables -t filter -I INPUT -s 10.6.0.0/16 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对来源地址取反，只要发往本机的报文的源地址不是192.168.1.146，就接受报文</span></span><br><span class="line">iptables -t filter -I INPUT ! -s 192.168.1.146 -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="2-配置对目标ip的限制"><a href="#2-配置对目标ip的限制" class="headerlink" title="2.配置对目标ip的限制"></a>2.配置对目标ip的限制</h4><p>是用<code>-d</code> 参数对目的地址进行限制。注意，如果是对源和目标地址都有限制，<strong>需要同时满足</strong>才会执行对应规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止报文从192.168.1.146发到192.168.1.156</span></span><br><span class="line">iptables -t filter INPUT -s 192.168.1.146 -d 192.168.1.156 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止报文发到192.168.1.156的所有报文</span></span><br><span class="line">iptables -t filter INPUT -d 192.168.1.156 -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="3-协议类型匹配"><a href="#3-协议类型匹配" class="headerlink" title="3.协议类型匹配"></a>3.协议类型匹配</h4><p>使用 <code>-p</code> 参数对报文协议进行匹配，协议内容包含: tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> REJECT掉发往192.168.1.156的tcp协议报文</span></span><br><span class="line">iptables -t filter -I INPUT -d 192.168.1.156 -p tcp -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="4-匹配网卡"><a href="#4-匹配网卡" class="headerlink" title="4.匹配网卡"></a>4.匹配网卡</h4><p>使用<code>-i</code>对车机报文通过某一网卡<strong>流入</strong>进行限制，使用<code>-o</code> 对车机报文通过某一网卡流出进行限制。</p>
<p><code>-i</code>选项只能用于PREROUTING链、INPUT链、FORWARD链，那么<code>-o</code>选项只能用于FORWARD链、OUTPUT链、POSTROUTING链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> DROP掉经过wlan0口的ping报文</span></span><br><span class="line">iptables -t filter -I INPUT -i wlan0 -p icmp -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="5-限制端口"><a href="#5-限制端口" class="headerlink" title="5.限制端口"></a>5.限制端口</h4><h5 id="5-1-限制目标端口"><a href="#5-1-限制目标端口" class="headerlink" title="5.1 限制目标端口"></a>5.1 限制目标端口</h5><p>使用 <code>--dport</code>限制目标端口。在使用<code>--dport</code>选项时，必须事先指定了使用哪种协议，即必须先使用<code>-p</code>选项。</p>
<p>使用<code>-–dport</code>之前，我们使用<code>-m</code>选项，指定了对应的扩展模块为tcp，也就是说，如果想要使用<code>-–dport</code>这个扩展匹配条件，则必须依靠某个扩展模块完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> REJECT 外来报文的目标端口为本机的22号端口（ssh默认端口）</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 22 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  -m tcp表示使用tcp扩展模块，–dport表示tcp扩展模块中的一个扩展匹配条件，可用于匹配报文的目标端口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  注意，-p tcp与 -m tcp并不冲突，-p用于匹配报文的协议，-m 用于指定扩展模块的名称，正好，这个扩展模块也叫tcp。</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport 22 -j REJECT</span><br></pre></td></tr></table></figure>


<h5 id="5-2-限制源端口"><a href="#5-2-限制源端口" class="headerlink" title="5.2 限制源端口"></a>5.2 限制源端口</h5><p>使用<code>--sport</code>可以判断报文是否从指定的端口发出，即匹配报文的源端口是否与指定的端口一致</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --sport 22 -j REJECT</span><br></pre></td></tr></table></figure>


<h5 id="5-3-限制端口范围"><a href="#5-3-限制端口范围" class="headerlink" title="5.3 限制端口范围"></a>5.3 限制端口范围</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> REJECT目标端口为22到25之间的所有端口</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport 22:25 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示匹配0号到22号之间的所有端口</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport :22 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示匹配80号端口以及其以后的所有端口（直到65535）</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport :22 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 管理多个离散的源端口</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dport 22,36,88 -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="6-iprange扩展模块"><a href="#6-iprange扩展模块" class="headerlink" title="6. iprange扩展模块"></a>6. iprange扩展模块</h4><p><code>-s</code>选项与<code>-d</code>选项并不能一次性的指定一段连续的IP地址范围，如果我们需要指定一段连续的IP地址范围，可以使用iprange扩展模块。</p>
<p>iprange扩展模块中有两个扩展匹配条件可以使用: –src-range 和 –dst-range</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果报文的源IP地址如果在192.168.1.127到192.168.1.146之间，则丢弃报文</span></span><br><span class="line">iptables -t filter -I INPUT -m iprange --src-rang 192.168.1.127-192.168.1.146 -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="7-String扩展模块"><a href="#7-String扩展模块" class="headerlink" title="7.String扩展模块"></a>7.String扩展模块</h4><p>使用string扩展模块，可以指定要匹配的字符串，如果报文中包含对应的字符串，则符合匹配条件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -m string --algo bm --string &quot;xxxx&quot; -j REJECT</span><br></pre></td></tr></table></figure>
<p><code>-m string</code>表示使用string模块，<code>--algo bm</code>表示使用bm算法去匹配指定的字符串，<code>--string &quot;xxxx&quot;</code>则表示我们想要匹配的字符串为”xxxx”.</p>
<ul>
<li>–algo：用于指定匹配算法，可选的算法有bm与kmp，此选项为必须选项，我们不用纠结于选择哪个算法，但是我们必须指定一个。</li>
<li>–string：用于指定需要匹配的字符串。</li>
</ul>
<h4 id="8-time扩展模块"><a href="#8-time扩展模块" class="headerlink" title="8.time扩展模块"></a>8.time扩展模块</h4><p>可以通过time扩展模块，根据时间段区匹配报文，如果报文到达的时间在指定的时间范围以内，则符合匹配条件。</p>
<p>8.1 约束在晚上12点-早上7点不能上网，保证充足睡眠。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 限制http端口</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --timestart 00:00:00 --timestop 07:00:00 -j REJECT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 限制https端口</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --timestart 00:00:00 --timestop 07:00:00 -j REJECT</span><br></pre></td></tr></table></figure>


<p>8.2 约束周末不能上网</p>
<p><code>--weekdays</code>可以取反</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --weekdays 6,7 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --weekdays 6,7 -j REJECT</span><br></pre></td></tr></table></figure>


<p>8.3 约束每月某些天不能上网</p>
<p><code>--monthdays</code> 可以取反</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --monthdays 10,11 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --monthdays 10,11 -j REJECT</span><br></pre></td></tr></table></figure>


<p>8.4 限制时间段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --datestart 2021-05-24 --datestop 2021-05-30 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --datestart 2021-05-24 --datestop 2021-05-30 -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="9-connlimit扩展模块"><a href="#9-connlimit扩展模块" class="headerlink" title="9.connlimit扩展模块"></a>9.connlimit扩展模块</h4><p>使用connlimit扩展模块，可以限制每个IP地址同时链接到server端的链接数量，注意：我们不用指定IP，其默认就是针对”每个客户端IP”，即对单IP的并发连接数限制。</p>
<p>9.1 限制每个IP地址最多只能占用两个ssh链接远程到server端</p>
<p>使用<code>–connlimit-above 2</code>表示限制每个IP的链接数量上限为2，再配合<code>-p tcp</code>, <code>–dport 22</code>，即表示限制每个客户端IP的ssh并发链接数量不能高于2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 22 -m connlimt --connlimit-above 2 -j ACCEPT</span><br></pre></td></tr></table></figure>


<p>9.2 限制某个网段，最多多少个链接</p>
<p>使用<code>--connlimit-mask</code>限制某个网段，<code>–connlimit-mask 27</code>表示某个C类网段，这个网段中最多只能有30台机器（30个IP），这30个IP地址最多只能有10个ssh连接同时连接到服务器端。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 22 -m connlimt --connlimit-above 10 --connlimit-mask 27 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>mask是子网掩码的意思，通过子网掩码来限制ip段。</p>
<h4 id="10-limit扩展模块"><a href="#10-limit扩展模块" class="headerlink" title="10.limit扩展模块"></a>10.limit扩展模块</h4><p>使用limit模块是对”报文到达速率”进行限制，可以以秒为单位进行限制，也可以以分钟、小时、天作为单位进行限制。</p>
<p>10.1 限制，外部主机对本机进行ping操作时，本机最多每6秒中放行一个ping。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m limit --limit 10/minute -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>如果单是以上规则，是无法限制每6秒到来的报文的。因为当1-5秒到来的报文，会走默认规则，默认是ACCEPT。</p>
<p>因此，还需要添加默认的匹配规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -j REJECT</span><br></pre></td></tr></table></figure>
<p>需要注意的是，需要先配置接受规则，再配置拒绝规则。</p>
<p>如上配置之后，我们看看现象如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-720e7548317b545d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="令牌桶算法.PNG"></p>
<p>可以看到1-5的报文没有被过滤到，后面的报文每6秒接受到一次，以满足拦截需求的。</p>
<p>出现这个现象的原因是：limit模块使用了<strong>令牌桶算法</strong>。</p>
<p><strong>令牌桶算法</strong>：我们可以这样想象，有一个木桶，木桶里面放了5块令牌，而且这个木桶最多也只能放下5块令牌，所有报文如果想要出关入关，都必须要持有木桶中的令牌才行，这个木桶有一个神奇的功能，就是每隔6秒钟会生成一块新的令牌，如果此时，木桶中的令牌不足5块，那么新生成的令牌就存放在木桶中，如果木桶中已经存在5块令牌，新生成的令牌就无处安放了，只能溢出木桶（令牌被丢弃），如果此时有5个报文想要入关，那么这5个报文就去木桶里找令牌，正好一人一个，于是他们5个手持令牌，快乐的入关了，此时木桶空了，再有报文想要入关，已经没有对应的令牌可以使用了，但是，过了6秒钟，新的令牌生成了，此刻，正好来了一个报文想要入关，于是，这个报文拿起这个令牌，就入关了，在这个报文之后，如果很长一段时间内没有新的报文想要入关，木桶中的令牌又会慢慢的积攒了起来，直到达到5个令牌，并且一直保持着5个令牌，直到有人需要使用这些令牌，这就是令牌桶算法的大致逻辑。</p>
<p>因此，我们可以<code>–limit-burst</code>来限制桶的令牌数目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="11-匹配TCP报文头标志位"><a href="#11-匹配TCP报文头标志位" class="headerlink" title="11.匹配TCP报文头标志位"></a>11.匹配TCP报文头标志位</h4><p>可以使用<code>--tcp-flags</code> 匹配报文tcp头部的标志位。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匹配第一次握手</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</span><br></pre></td></tr></table></figure>
<p>”SYN,ACK,FIN,RST,URG,PSH SYN”, 这串字符就是用于配置我们要匹配的标志位的，我们可以把这串字符拆成两部分去理解，第一部分为”SYN,ACK,FIN,RST,URG,PSH”，第二部分为”SYN”。</p>
<p>第一部分表示：我们需要匹配报文tcp头中的哪些标志位，那么上例的配置表示，我们需要匹配报文tcp头中的6个标志位，这6个标志位分别为为”SYN、ACK、FIN、RST、URG、PSH”，我们可以把这一部分理解成需要匹配的标志位列表。</p>
<p>第二部分表示：第一部分的标志位列表中，哪些标志位必须为1，上例中，第二部分为SYN，则表示，第一部分需要匹配的标志位列表中，SYN标志位的值必须为1，其他标志位必须为0。</p>
<p>所以，上例中的”SYN,ACK,FIN,RST,URG,PSH SYN”表示，需要匹配报文tcp头中的”SYN、ACK、FIN、RST、URG、PSH”这些标志位，其中SYN标志位必须为1，其他的5个标志位必须为0 .</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匹配第二次握手</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --sport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN,ACK -j REJECT</span><br></pre></td></tr></table></figure>


<p>以上两条可以简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags ALL SYN -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --sport 22 --tcp-flags ALL SYN,ACK -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="12-icmp扩展"><a href="#12-icmp扩展" class="headerlink" title="12.icmp扩展"></a>12.icmp扩展</h4><p>我们平常使用ping命令ping某主机时，如果主机可达，对应主机会对我们的ping请求做出回应（此处不考虑禁ping等情况），也就是说，我们发出ping请求，对方回应ping请求，虽然ping请求报文与ping回应报文都属于ICMP类型的报文，但是如果在概念上细分的话，它们所属的类型还是不同的，我们发出的ping请求属于类型8的icmp报文，而对方主机的ping回应报文则属于类型0的icmp报文，根据应用场景的不同，icmp报文被细分为如下各种类型。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-696ef0c3d77e584e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="icmp协议.png"></p>
<p>从上图可以看出，所有表示”目标不可达”的icmp报文的type码为3，而”目标不可达”又可以细分为多种情况，是网络不可达呢？还是主机不可达呢？再或者是端口不可达呢？所以，为了更加细化的区分它们，icmp对每种type又细分了对应的code，用不同的code对应具体的场景，  所以，我们可以使用type/code去匹配具体类型的ICMP报文，比如可以使用”3/1″表示主机不可达的icmp报文。</p>
<p>上图中的第一行就表示ping回应报文，它的type为0，code也为0，从上图可以看出，ping回应报文属于查询类（query）的ICMP报文，从大类上分，ICMP报文还能分为查询类与错误类两大类，目标不可达类的icmp报文则属于错误类报文。</p>
<p>而我们发出的ping请求报文对应的type为8，code为0。</p>
<p>12.1 此时我们只想要ping通别人，但是不想让别人ping通我们</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8 -j REJECT</span><br><span class="line">// echo-request是协议名，中间空格用‘-’代替</span><br><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type &quot;echo-request&quot; -j REJECT</span><br></pre></td></tr></table></figure>
<p>使用”-m icmp”表示使用icmp扩展，因为上例中使用了”-p icmp”，所以”-m icmp”可以省略，使用”–icmp-type”选项表示根据具体的type与code去匹配对应的icmp报文，而上图中的”–icmp-type 8/0″表示icmp报文的type为8，code为0才会被匹配到，也就是只有ping请求类型的报文才能被匹配到，所以，别人对我们发起的ping请求将会被拒绝通过防火墙，而我们之所以能够ping通别人，是因为别人回应我们的报文的icmp type为0，code也为0，所以无法被上述规则匹配到，所以我们可以看到别人回应我们的信息。</p>
<h4 id="13-判断报文是来自回应还是请求"><a href="#13-判断报文是来自回应还是请求" class="headerlink" title="13.判断报文是来自回应还是请求"></a>13.判断报文是来自回应还是请求</h4><p>我们可以使用state模块的<code>--state</code>来追踪链接的状态。</p>
<p>对于state模块的连接而言，”连接”其中的报文可以分为5种状态，报文状态可以为NEW、ESTABLISHED、RELATED、INVALID、UNTRACKED。(详细定义参考文档)</p>
<ul>
<li><p><strong>NEW</strong>：连接中的第一个包，状态就是NEW，我们可以理解为新连接的第一个包的状态为NEW。</p>
</li>
<li><p><strong>ESTABLISHED</strong>：我们可以把NEW状态包后面的包的状态理解为ESTABLISHED，表示连接已建立。</p>
</li>
<li><p><strong>RELATED</strong>：从字面上理解RELATED译为关系，但是这样仍然不容易理解，我们举个例子。</p>
</li>
</ul>
<p>比如FTP服务，FTP服务端会建立两个进程，一个命令进程，一个数据进程。</p>
<p>命令进程负责服务端与客户端之间的命令传输（我们可以把这个传输过程理解成state中所谓的一个”连接”，暂称为”命令连接”）。</p>
<p>数据进程负责服务端与客户端之间的数据传输 ( 我们把这个过程暂称为”数据连接” )。</p>
<p>但是具体传输哪些数据，是由命令去控制的，所以，”数据连接”中的报文与”命令连接”是有”关系”的。</p>
<p>那么，”数据连接”中的报文可能就是RELATED状态，因为这些报文与”命令连接”中的报文有关系。</p>
<p>(注：如果想要对ftp进行连接追踪，需要单独加载对应的内核模块nf_conntrack_ftp，如果想要自动加载，可以配置/etc/sysconfig/iptables-config文件)</p>
<ul>
<li><p><strong>INVALID</strong>：如果一个包没有办法被识别，或者这个包没有任何状态，那么这个包的状态就是INVALID，我们可以主动屏蔽状态为INVALID的报文。</p>
</li>
<li><p><strong>UNTRACKED</strong>：报文的状态为untracked时，表示报文未被追踪，当报文的状态为Untracked时通常表示无法找到相关的连接。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="14-禁止某个域名访问"><a href="#14-禁止某个域名访问" class="headerlink" title="14.禁止某个域名访问"></a>14.禁止某个域名访问</h4><p>禁止 包含qq.com的域名访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I OUTPUT -p tcp -m string --string &quot;qq.com&quot; --algo bm -j DROP</span><br><span class="line">iptables -I OUTPUT -p udp -m string --string &quot;qq.com&quot; --algo kmp -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.linuxtopia.org/Linux_Firewall_iptables/x1347.html">User-land states定义</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio编译引用系统@hide api</title>
    <url>/2021/06/01/Android-Studio%E7%BC%96%E8%AF%91%E5%BC%95%E7%94%A8%E7%B3%BB%E7%BB%9F-hide-api/</url>
    <content><![CDATA[<h4 id="1-问题叙述"><a href="#1-问题叙述" class="headerlink" title="1.问题叙述"></a>1.问题叙述</h4><p>在APP开发中，Android Studio工程无法引用framework.jar带有@hide的api，但是在framework开发中需要引用到系统的@hide接口，为了在AS中开发，需要做如下配置。</p>
<h4 id="2-配置步骤"><a href="#2-配置步骤" class="headerlink" title="2.配置步骤"></a>2.配置步骤</h4><ul>
<li>从android源码的如下目录中获取class.jar （这里的class.jar包含了系统中被标注了@hide的api）</li>
</ul>
<p>out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar</p>
<ul>
<li><p>将framework.jar拷贝到APP的工程目录的libs目录下.</p>
</li>
<li><p>配置build.gradle</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 一定要注释掉，否者会报3小节中的错误</span></span><br><span class="line">    <span class="comment">//implementation fileTree(include: [&#x27;*.jar&#x27;], dir: &#x27;libs&#x27;)</span></span><br><span class="line">    ......</span><br><span class="line">    compileOnly files(<span class="string">&#x27;libs/framework.jar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在根目录build.gradle中加入,<code>-Xbootclasspath/p:</code>后面加入framework.jar的路径</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line"></span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">        tasks.withType(JavaCompile) &#123;</span><br><span class="line">            options.compilerArgs &lt;&lt; <span class="string">&#x27;-Xbootclasspath/p:app/libs/framework.jar&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后编译工程。系统hide API在AS中一样是红色的，但是可以正常编译通过运行。</li>
</ul>
<h4 id="3-编译报错"><a href="#3-编译报错" class="headerlink" title="3.编译报错"></a>3.编译报错</h4><p>引入的framework.jar只能用compileOnly，不能用implement，否则会报如下错误，注释掉implementation也是这个原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.ArrayIndexOutOfBoundsException: 65535</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>Android权限管理</title>
    <url>/2021/05/31/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-定义配置文件字段意义"><a href="#1-定义配置文件字段意义" class="headerlink" title="1.定义配置文件字段意义"></a>1.定义配置文件字段意义</h4><ul>
<li><code>presetPaths</code>：预置应用路径</li>
<li><code>presetShops</code>：预置应用商城包名，可以配置能够安装应用的应用，例如应用商城或者浏览器等。</li>
<li><code>rules</code>：规则集合</li>
<li><code>majorType</code>： 应用主规则名单<ul>
<li>1：白名单应用</li>
<li>2：签名应用</li>
<li>3：预置应用</li>
<li>4：应用商城应用</li>
<li>5：其他应用</li>
</ul>
</li>
<li><code>priority</code> ：优先级</li>
<li><code>enable</code> ：规则生效使能键</li>
<li><code>apps</code>：主规则名单中应用的授权类型</li>
<li><code>packageNames</code>：主规则名单中应用包名</li>
<li><code>authorizationType</code>: 授权类型<ul>
<li>1：全部权限授权</li>
<li>2：部分权限授权</li>
<li>3：全部权限拒绝</li>
<li>4：错误值</li>
</ul>
</li>
<li><code>name</code> ：权限名</li>
<li><code>status</code>：权限状态<ul>
<li>1：默认授权</li>
<li>2：默认拒绝</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;presetPaths&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;/vendor/app/&quot;</span>,</span><br><span class="line">      <span class="string">&quot;/system/app/&quot;</span>,</span><br><span class="line">      <span class="string">&quot;/system/priv-app/&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;presetShops&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;cn.gaei.appstore&quot;</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">&quot;rules&quot;</span>: [&#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">1</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;apps&quot;</span>: [&#123;</span><br><span class="line">               <span class="string">&quot;packageNames&quot;</span>: [</span><br><span class="line">                   <span class="string">&quot;cn.gaei.appstore&quot;</span></span><br><span class="line">               ],</span><br><span class="line">               <span class="string">&quot;authorizationType&quot;</span>: <span class="number">1</span></span><br><span class="line">           &#125;]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">3</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">900</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;authorizationType&quot;</span>: <span class="number">1</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">4</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">800</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;authorizationType&quot;</span>: <span class="number">1</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">5</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">600</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;authorizationType&quot;</span>: <span class="number">2</span>,</span><br><span class="line">           <span class="string">&quot;permissions&quot;</span>: [&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>: <span class="string">&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;</span>,</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="number">2</span></span><br><span class="line">           &#125;]</span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>权限管理分析--Android Runtime Permission</title>
    <url>/2021/06/02/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-Android-Runtime-Permission/</url>
    <content><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><h5 id="1-1-Android6-0以前系统"><a href="#1-1-Android6-0以前系统" class="headerlink" title="1.1 Android6.0以前系统"></a>1.1 Android6.0以前系统</h5><p>结合以前G2项目Android系统版本是4.4(Android 6.0以前)，权限系统只会在安装的时候询问一次(安装时权限)，用户可以选择性的授予应用相关权限。一旦授权，除非卸载应用重新安装，被授权的权限不能撤销。</p>
<h5 id="1-2-Android6-0及以后系统"><a href="#1-2-Android6-0及以后系统" class="headerlink" title="1.2 Android6.0及以后系统"></a>1.2 Android6.0及以后系统</h5><p>Android 6.0 及更高版本中的 Android 应用权限模式需要危险权限的 Android 应用从安装时权限模式转移至运行时权限模式，用户可以在程序运行时授予/撤销危险权限。</p>
<p><strong>因此，关于应用权限管理，针对4.4以前的系统，我们可以在PackageInstaller安装应用的时候，针对项目的权限管理策略，对被安装应用进行授权或撤销；针对Android6.0及以后的系统版本，可以启动一个系统服务，动态的修改应用权限</strong></p>
<h4 id="2-运行时权限"><a href="#2-运行时权限" class="headerlink" title="2.运行时权限"></a>2.运行时权限</h4><h5 id="2-1-权限分类"><a href="#2-1-权限分类" class="headerlink" title="2.1 权限分类"></a>2.1 权限分类</h5><p>Android权限分级具体体现是在PermissionInfo类中<code>protectionLevel</code>成员变量来定义权限的级别。</p>
<p>Android把应用权限分为四类：Normal, Dangerous, Signature, SigatureOrSystem。</p>
<ul>
<li>Normal Permission指的是那些 app获取它所在的sandbox(每个进程都有独立的一个沙箱)以外的数据和资源所对应的权限，这些权限一般不会对用户的隐私信息造成风险. 比如，设置时区的权限（SET_TIME_ZONE）。对于此类权限，app申请后系统会自动赋予。</li>
<li>Dangerous Permission指的是那些可能对用户的隐私信息造成风险，或者可能影响用户数据的行为权限。比如读取用户的联系人。对于Dangerous Permission，app必须显示的获取用户的允许才可以正常使用。Runtime Permission机制针对的即是此类 dangerous permission。</li>
<li>Signature permission：权限请求者只有使用和[权限声明者]相同的证书来签名的情况下，才可以使用的权限。如果证书匹配，系统会自动赋予这些权限，不需要通知或请求用户。</li>
<li>SignatureOrSystem: SDK版本23之前叫“signature|privileged”，该类权限除了上述的 Signature Permission以外，还包括那些只赋予Android System Image内的应用的权限。Android并不建议app使用这类，因为Signature Permission已经能满足大部分的需求，不管这些app是否是build在System Image里。</li>
</ul>
<h5 id="2-2-特殊权限"><a href="#2-2-特殊权限" class="headerlink" title="2.2 特殊权限"></a>2.2 特殊权限</h5><p>上面说明了permission 中属性android:protectionLevel 使用意义，其中存在一些特殊的权限，这些权限比较敏感，在使用的时候必须特殊处理。SYSTEM_ALERT_WINDOW和WRITE_SETTINGS就是此类比较敏感的权限。</p>
<p>例如 WRITE_SETTINGS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;permission android:name=<span class="string">&quot;android.permission.WRITE_SETTINGS&quot;</span></span><br><span class="line">    android:label=<span class="string">&quot;@string/permlab_writeSettings&quot;</span></span><br><span class="line">    android:description=<span class="string">&quot;@string/permdesc_writeSettings&quot;</span></span><br><span class="line">    android:protectionLevel=<span class="string">&quot;signature|preinstalled|appop|pre23&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>官方解释如下：</p>
<blockquote>
<p>​    Note: If the app targets API level 23 or higher, the app user must explicitly grant this<br>permission to the app through a permission management screen.<br>​    The app requests the user’s approval by sending an intent with action ACTION_MANAGE_WRITE_ SETTINGS.<br>​    The app can check whether it has this authorization by calling Settings.System.canWrite().</p>
</blockquote>
<h5 id="2-3-危险权限"><a href="#2-3-危险权限" class="headerlink" title="2.3 危险权限"></a>2.3 危险权限</h5><p>Android 6.0 及更高版本要求危险权限必须使用运行时权限模式。危险权限是具有更高风险的权限（例如READ_CALENDAR），此类权限允许寻求授权的应用访问用户私人数据或获取可对用户造成不利影响的设备控制权。要查看危险权限列表，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list permissions -g -d</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:&#x2F; $ pm list permissions -g -d</span><br><span class="line">pm list permissions -g -d</span><br><span class="line">Dangerous Permissions:</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CONTACTS</span><br><span class="line">  permission:android.permission.WRITE_CONTACTS</span><br><span class="line">  permission:android.permission.GET_ACCOUNTS</span><br><span class="line">  permission:android.permission.READ_CONTACTS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.PHONE</span><br><span class="line">  permission:android.permission.ANSWER_PHONE_CALLS</span><br><span class="line">  permission:android.permission.READ_PHONE_NUMBERS</span><br><span class="line">  permission:android.permission.READ_PHONE_STATE</span><br><span class="line">  permission:android.permission.CALL_PHONE</span><br><span class="line">  permission:android.permission.ACCEPT_HANDOVER</span><br><span class="line">  permission:android.permission.USE_SIP</span><br><span class="line">  permission:com.android.voicemail.permission.ADD_VOICEMAIL</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CALENDAR</span><br><span class="line">  permission:android.permission.READ_CALENDAR</span><br><span class="line">  permission:android.permission.WRITE_CALENDAR</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CALL_LOG</span><br><span class="line">  permission:android.permission.READ_CALL_LOG</span><br><span class="line">  permission:android.permission.WRITE_CALL_LOG</span><br><span class="line">  permission:android.permission.PROCESS_OUTGOING_CALLS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CAMERA</span><br><span class="line">  permission:android.permission.CAMERA</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SENSORS</span><br><span class="line">  permission:android.permission.BODY_SENSORS</span><br><span class="line"></span><br><span class="line">group:android.car.permission-group.CAR_MONITORING</span><br><span class="line">  permission:android.car.permission.CAR_ENERGY</span><br><span class="line"></span><br><span class="line">group:android.permission-group.LOCATION</span><br><span class="line">  permission:android.permission.ACCESS_FINE_LOCATION</span><br><span class="line">  permission:android.car.permission.CAR_SPEED</span><br><span class="line">  permission:android.permission.ACCESS_COARSE_LOCATION</span><br><span class="line"></span><br><span class="line">group:android.permission-group.STORAGE</span><br><span class="line">  permission:android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">  permission:android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line"></span><br><span class="line">group:android.permission-group.MICROPHONE</span><br><span class="line">  permission:android.permission.RECORD_AUDIO</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SMS</span><br><span class="line">  permission:android.permission.READ_SMS</span><br><span class="line">  permission:android.permission.RECEIVE_WAP_PUSH</span><br><span class="line">  permission:android.permission.RECEIVE_MMS</span><br><span class="line">  permission:android.permission.RECEIVE_SMS</span><br><span class="line">  permission:android.permission.SEND_SMS</span><br><span class="line">  permission:android.permission.READ_CELL_BROADCASTS</span><br><span class="line"></span><br><span class="line">ungrouped:</span><br><span class="line">  permission:org.codeaurora.permission.POWER_OFF_ALARM</span><br></pre></td></tr></table></figure>


<h5 id="2-4-权限组"><a href="#2-4-权限组" class="headerlink" title="2.4 权限组"></a>2.4 权限组</h5><p>所有危险的 Android 系统权限都属于权限组。如果设备运行的是 Android 6.0（API 级别 23），并且应用的 targetSdkVersion 是 23 或更高版本，则当用户请求危险权限时系统会发生以下行为：</p>
<ul>
<li><p>如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。</p>
</li>
<li><p>如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请WRITE_CONTACTS，系统将立即授予该权限。</p>
</li>
</ul>
<p>任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。</p>
<h5 id="2-5-权限校验方法"><a href="#2-5-权限校验方法" class="headerlink" title="2.5 权限校验方法"></a>2.5 权限校验方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查某个 uid 和 pid是否有permission</span></span><br><span class="line"><span class="comment">//如果返回PackageManager#PERMISSION_GRANTED，说明该权限已经被allowed</span></span><br><span class="line"><span class="comment">//如果返回PackageManager#PERMISSION_DENIED，说明该权限不被allowed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同checkPermission，这里提供给当前进程调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkCallingPermission</span><span class="params">(String permission)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同checkPermission，这里跟checkCallingPermission区别是，不需要判断调用者是否是当前进程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkCallingOrSelfPermission</span><span class="params">(String permission)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同checkPermission，主要是当返回不是PackageManager.PERMISSION_GRANTED会抛出SecurityException</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforcePermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同enforcePermission</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforceCallingPermission</span><span class="params">(String permission, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同enforcePermission</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforceCallingOrSelfPermission</span><span class="params">(String permission, String message)</span></span></span><br></pre></td></tr></table></figure>


<h5 id="2-6-permission-flags"><a href="#2-6-permission-flags" class="headerlink" title="2.6 permission flags"></a>2.6 permission flags</h5><ul>
<li>PackageManager.FLAG_PERMISSION_USER_SET: 权限被用户设置，应用还可以在runtime 的时候request</li>
<li>PackageManager.FLAG_PERMISSION_USER_FIXED：权限被用户设置，但是应用不能再request此权限（用户勾选了“never ask again”）。</li>
<li>PackageManager.FLAG_PERMISSION_POLICY_FIXED：device policy设定的权限，用户和app都不能修改。</li>
<li>PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE：如果permission被标记了这个flag，那么表示，app升级后被deny的permission，会依然是deny的状态。这个flag会在下面的情况中用到。适用于L以前版本的app,安装得到M的device上，如果它的dangerous permission被撤销了，比如通过settings里面的permission管理撤销或者device policy中设定，那么该APP升级到适用于M新的permission模式后，那么升级后这个permission依然是撤销的状态。也就是dangerous permission如果在升级之前被撤销过，升级后依然是撤销的状态。</li>
<li>PackageManager.FLAG_PERMISSION_SYSTEM_FIXED： 系统app获得的自动授权的permission。</li>
<li>PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT：  默认的系统基本功能app获得的自动授权的permission.</li>
<li>PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED：在app 运行之前必须要进行permission review</li>
</ul>
<h5 id="2-7-授权-撤销权限"><a href="#2-7-授权-撤销权限" class="headerlink" title="2.7 授权/撤销权限"></a>2.7 授权/撤销权限</h5><p>在PackageManager中提供了两个方法来给某个应用赋予/撤销某些权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许权限</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	grantRuntimePermission(packageName, name, userId, <span class="keyword">false</span> <span class="comment">/* Only if not fixed by policy */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销权限</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revokeRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	revokeRuntimePermission(packageName, name, userId, <span class="keyword">false</span> <span class="comment">/* Only if not fixed by policy */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-GrantPermissionsActivity授权界面"><a href="#3-GrantPermissionsActivity授权界面" class="headerlink" title="3. GrantPermissionsActivity授权界面"></a>3. GrantPermissionsActivity授权界面</h4><p>该界面是Android 6.0之后对Runtime Permission控制，与用户的交互界面。</p>
<p>GrantPermissionsActivity的注册信息如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在包安装管理器 packages/apps/PackageInstaller/AndroidManifest.xml</span></span><br><span class="line">&lt;activity android:name=<span class="string">&quot;.permission.ui.GrantPermissionsActivity&quot;</span></span><br><span class="line">	android:configChanges=<span class="string">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br><span class="line">    android:excludeFromRecents=<span class="string">&quot;true&quot;</span></span><br><span class="line">    android:theme=<span class="string">&quot;@style/GrantPermissions&quot;</span></span><br><span class="line">    android:visibleToInstantApps=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        &lt;intent-filter android:priority=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot;</span> /&gt;</span><br><span class="line">            &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>


<p>在Activity.java基类中请求权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(<span class="meta">@NonNull</span> String[] permissions, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;requestCode should be &gt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Can request only one set of permissions at a time&quot;</span>);</span><br><span class="line">        <span class="comment">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class="line">        onRequestPermissionsResult(requestCode, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在PackageManager中去构建intent，主要是pm能够拿到action和intent的包名</span></span><br><span class="line">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class="line">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line">    mHasCurrentPermissionsRequest = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">buildRequestPermissionsIntent</span><span class="params">(<span class="meta">@NonNull</span> String[] permissions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(permissions)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;permission cannot be null or empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// GrantPermissionsActivity的action</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(ACTION_REQUEST_PERMISSIONS);</span><br><span class="line">    <span class="comment">// 声请的权限</span></span><br><span class="line">    intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);</span><br><span class="line">    <span class="comment">// GrantPermissionsActivity所在的包，即PackageInstaller</span></span><br><span class="line">    intent.setPackage(getPermissionControllerPackageName());</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，当某个应用的Activity需要申请权限，都会走到PackageInstaller的GrantPermissionsActivity 里来和用户交互申请权限。</p>
<h5 id="3-1-GrantPermissionsActivity-交互过程"><a href="#3-1-GrantPermissionsActivity-交互过程" class="headerlink" title="3.1 GrantPermissionsActivity 交互过程"></a>3.1 GrantPermissionsActivity 交互过程</h5><p>该Activity主要偏向UI逻辑控制，有以下几个部分：</p>
<p>1.mRequestedPermissions</p>
<p>这个是通过intent 的extra 传过来的，extra 的name 是PackageManager.EXTRA_REQUEST_PERMISSIONS_ NAMES</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRequestedPermissions = getIntent().getStringArrayExtra(PackageManager. EXTRA_REQUEST_PERMISSIONS_NAMES);</span><br></pre></td></tr></table></figure>


<p>2、GrantPermissionsViewHandlerImpl<br>这个是用来更新activity UI的重要类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mViewHandler = <span class="keyword">new</span> com.android.packageinstaller.permission.ui.handheld</span><br><span class="line">            .GrantPermissionsViewHandlerImpl(<span class="keyword">this</span>, getCallingPackage())</span><br><span class="line">            .setResultListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>


<p>3、setContentView(mViewHandler.createView());</p>
<p>acitivity 将GrantPermissionsViewHandlerImpl 中的createView 出来的View 显示出来。</p>
<p>4、mAppPermissions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mAppPermissions = <span class="keyword">new</span> AppPermissions(<span class="keyword">this</span>, callingPackageInfo, <span class="keyword">null</span>, <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	setResultAndFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个AppPermissions 其实就是单个应用所拥有的所有的group permission 的统计，详细看<br>private final ArrayList<AppPermissionGroup> mGroups = new ArrayList&lt;&gt;();</AppPermissionGroup></p>
<p>5、showNextPermissionGroupGrantRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mViewHandler.updateUi(groupState.mGroup.getName(), groupCount, currentIndex,</span><br><span class="line">	Icon.createWithResource(resources, icon), message,</span><br><span class="line">	groupState.mGroup.isUserSet());</span><br></pre></td></tr></table></figure>


<p>6、点击界面按钮</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.permission_allow_button:</span><br><span class="line">            <span class="keyword">if</span> (mResultListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view.performAccessibilityAction(</span><br><span class="line">                        AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS, <span class="keyword">null</span>);</span><br><span class="line">                mResultListener.onPermissionGrantResult(mGroupName, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.permission_deny_button:</span><br><span class="line">            mAllowButton.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (mResultListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view.performAccessibilityAction(</span><br><span class="line">                        AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS, <span class="keyword">null</span>);</span><br><span class="line">                mResultListener.onPermissionGrantResult(mGroupName, <span class="keyword">false</span>,</span><br><span class="line">                        AppPermissionGroup.isStrictOpEnable() ? <span class="keyword">false</span> : mShowDonNotAsk</span><br><span class="line">                                &amp;&amp; mDoNotAskCheckbox.isChecked());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.permission_more_info_button:</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_PACKAGE_NAME, mAppPackageName);</span><br><span class="line">            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, <span class="keyword">true</span>);</span><br><span class="line">            mActivity.startActivity(intent);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.do_not_ask_checkbox:</span><br><span class="line">            mAllowButton.setEnabled(!mDoNotAskCheckbox.isChecked());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>7、onPermissionGrantResult</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPermissionGrantResult</span><span class="params">(String name, <span class="keyword">boolean</span> granted, <span class="keyword">boolean</span> doNotAskAgain)</span> </span>&#123;</span><br><span class="line">    GroupState groupState = mRequestGrantPermissionGroups.get(name);</span><br><span class="line">    <span class="keyword">if</span> (groupState.mGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted) &#123;</span><br><span class="line">            groupState.mGroup.grantRuntimePermissions(doNotAskAgain,</span><br><span class="line">                    groupState.affectedPermissions);</span><br><span class="line">            groupState.mState = GroupState.STATE_ALLOWED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!AppPermissionGroup.isStrictOpEnable()) &#123;</span><br><span class="line">                groupState.mGroup.revokeRuntimePermissions(doNotAskAgain,</span><br><span class="line">                        groupState.affectedPermissions);</span><br><span class="line">            &#125;</span><br><span class="line">            groupState.mState = GroupState.STATE_DENIED;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> numRequestedPermissions = mRequestedPermissions.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRequestedPermissions; i++) &#123;</span><br><span class="line">                String permission = mRequestedPermissions[i];</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (groupState.mGroup.hasPermission(permission)) &#123;</span><br><span class="line">                    EventLogger.logPermissionDenied(<span class="keyword">this</span>, permission,</span><br><span class="line">                            mAppPermissions.getPackageInfo().packageName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        updateGrantResults(groupState.mGroup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!showNextPermissionGroupGrantRequest()) &#123;</span><br><span class="line">        setResultAndFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的callback 是从GrantPermissionsViewHandlerImpl 回来，确定执行grant 还是revoke。</p>
<h4 id="4-grantRuntimePermission-授权流程"><a href="#4-grantRuntimePermission-授权流程" class="headerlink" title="4.grantRuntimePermission 授权流程"></a>4.grantRuntimePermission 授权流程</h4><p>在PackageManager提供了grantRuntimePermission给某个应用授权。该API是@SystemApi，需要有平台签名的应用才能调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission(android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(<span class="meta">@NonNull</span> String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="meta">@NonNull</span> String permissionName, <span class="meta">@NonNull</span> UserHandle user)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最终会调到PKMS中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">   grantRuntimePermission(packageName, name, userId, <span class="keyword">false</span> <span class="comment">/* Only if not fixed by policy */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">final</span> <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> overridePolicy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) &#123;<span class="comment">//确认user id存在</span></span><br><span class="line">        Log.e(TAG, <span class="string">&quot;No such user:&quot;</span> + userId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();<span class="comment">//确定调用端app 的uid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要app端注册GRANT_RUNTIME_PERMISSIONS 权限，不然会抛出exception</span></span><br><span class="line">    mContext.enforceCallingOrSelfPermission(</span><br><span class="line">        android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS,</span><br><span class="line">        <span class="string">&quot;grantRuntimePermission&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要INTERACT_ACROSS_USERS_FULL 权限，也会抛出exception</span></span><br><span class="line">    enforceCrossUserPermission(callingUid, userId,</span><br><span class="line">                               <span class="keyword">true</span> <span class="comment">/* requireFullPermission */</span>, <span class="keyword">true</span> <span class="comment">/* checkShell */</span>,</span><br><span class="line">                               <span class="string">&quot;grantRuntimePermission&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">final</span> PackageSetting ps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">// //packageName 正确性</span></span><br><span class="line">        <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(packageName);</span><br><span class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown package: &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//permission name 正确性</span></span><br><span class="line">        <span class="keyword">final</span> BasePermission bp = mSettings.mPermissions.get(name);</span><br><span class="line">        <span class="keyword">if</span> (bp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown permission: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取ps，可以从里面拿到PermissionsState</span></span><br><span class="line">        ps = (PackageSetting) pkg.mExtras;</span><br><span class="line">        <span class="keyword">if</span> (ps == <span class="keyword">null</span></span><br><span class="line">            || filterAppAccessLPr(ps, callingUid, userId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown package: &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);</span><br><span class="line">        <span class="comment">//app将该permission 注册到AndroidManifest中</span></span><br><span class="line">        <span class="comment">//并且该permission 是Runtime 或者是development permission</span></span><br><span class="line">        <span class="comment">// If a permission review is required for legacy apps we represent</span></span><br><span class="line">        <span class="comment">// their permissions as always granted runtime ones since we need</span></span><br><span class="line">        <span class="comment">// to keep the review required permission flag per user while an</span></span><br><span class="line">        <span class="comment">// install permission&#x27;s state is shared across all users.</span></span><br><span class="line">        <span class="keyword">if</span> (mPermissionReviewRequired <span class="comment">//对于legacy apps不做处理</span></span><br><span class="line">            &amp;&amp; pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M</span><br><span class="line">            &amp;&amp; bp.isRuntime()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uid = UserHandle.getUid(userId, pkg.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PermissionsState permissionsState = ps.getPermissionsState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = permissionsState.getPermissionFlags(name, userId);</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Cannot grant system fixed permission &quot;</span></span><br><span class="line">                                        + name + <span class="string">&quot; for package &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!overridePolicy &amp;&amp; (flags &amp; PackageManager.FLAG_PERMISSION_POLICY_FIXED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Cannot grant policy fixed permission &quot;</span></span><br><span class="line">                                        + name + <span class="string">&quot; for package &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bp.isDevelopment()) &#123;</span><br><span class="line">            <span class="comment">// Development permissions must be handled specially, since they are not</span></span><br><span class="line">            <span class="comment">// normal runtime permissions.  For now they apply to all users.</span></span><br><span class="line">            <span class="keyword">if</span> (permissionsState.grantInstallPermission(bp) !=</span><br><span class="line">                PermissionsState.PERMISSION_OPERATION_FAILURE) &#123;</span><br><span class="line">                scheduleWriteSettingsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ps.getInstantApp(userId) &amp;&amp; !bp.isInstant()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Cannot grant non-ephemeral permission&quot;</span></span><br><span class="line">                                        + name + <span class="string">&quot; for package &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Cannot grant runtime permission to a legacy app&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对当前用户授权</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> result = permissionsState.grantRuntimePermission(bp, userId);</span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">            <span class="keyword">case</span> PermissionsState.PERMISSION_OPERATION_FAILURE: &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> appId = UserHandle.getAppId(pkg.applicationInfo.uid);</span><br><span class="line">                mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bp.isRuntime()) &#123;</span><br><span class="line">            logPermissionGranted(mContext, name, packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mOnPermissionChangeListeners.onPermissionsChanged(uid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not critical if that is lost - app has to request again.</span></span><br><span class="line">        mSettings.writeRuntimePermissionsForUserLPr(userId, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only need to do this if user is initialized. Otherwise it&#x27;s a new user</span></span><br><span class="line">    <span class="comment">// and there are no processes running as the user yet and there&#x27;s no need</span></span><br><span class="line">    <span class="comment">// to make an expensive call to remount processes for the changed permissions.</span></span><br><span class="line">    <span class="keyword">if</span> (READ_EXTERNAL_STORAGE.equals(name)</span><br><span class="line">        || WRITE_EXTERNAL_STORAGE.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sUserManager.isInitialized(userId)) &#123;</span><br><span class="line">                StorageManagerInternal storageManagerInternal = LocalServices.getService(</span><br><span class="line">                    StorageManagerInternal.class);</span><br><span class="line">                storageManagerInternal.onExternalStoragePolicyChanged(uid, packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要注意 3 个地方：</p>
<p>1、permissionsState.grantRuntimePermission(bp, userId);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">grantRuntimePermission</span><span class="params">(BasePermission permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceValidUserId(userId);</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;<span class="comment">//这个操作不能针对所有用户，只能针对当前用户</span></span><br><span class="line">    	<span class="keyword">return</span> PERMISSION_OPERATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grantPermission(permission, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">grantPermission</span><span class="params">(BasePermission permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasPermission(permission.name, userId)) &#123;<span class="comment">//确认是否已经grant</span></span><br><span class="line">        <span class="keyword">return</span> PERMISSION_OPERATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId));</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] oldGids = hasGids ? computeGids(userId) : NO_GIDS;</span><br><span class="line"></span><br><span class="line">    PermissionData permissionData = ensurePermissionData(permission);</span><br><span class="line">	<span class="comment">//这里就是终点，修改PermissionData 中PermissionState 的 mGranted属性</span></span><br><span class="line">    <span class="keyword">if</span> (!permissionData.grant(userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> PERMISSION_OPERATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasGids) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] newGids = computeGids(userId);</span><br><span class="line">        <span class="keyword">if</span> (oldGids.length != newGids.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PERMISSION_OPERATION_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2、mOnPermissionChangeListeners.onPermissionsChanged(uid);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleOnPermissionsChanged</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mPermissionListeners.beginBroadcast();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            IOnPermissionsChangeListener callback = mPermissionListeners</span><br><span class="line">                    .getBroadcastItem(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onPermissionsChanged(uid);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Permission listener is dead&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mPermissionListeners.finishBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给客户端注册I OnPermissionsChangeListener 的callback 用，提示grant 成功。</p>
<p>3、mSettings.writeRuntimePermissionsForUserLPr(userId, false);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRuntimePermissionsForUserLPr</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">boolean</span> sync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sync) &#123;</span><br><span class="line">        mRuntimePermissionsPersistence.writePermissionsForUserSyncLPr(userId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRuntimePermissionsPersistence.writePermissionsForUserAsyncLPr(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writePermissionsForUserAsyncLPr</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mWriteScheduled.get(userId)) &#123;</span><br><span class="line">        mHandler.removeMessages(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If enough time passed, write without holding off anymore.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> lastNotWrittenMutationTimeMillis = mLastNotWrittenMutationTimesMillis</span><br><span class="line">                .get(userId);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLastNotWrittenMutationMillis = currentTimeMillis</span><br><span class="line">                - lastNotWrittenMutationTimeMillis;</span><br><span class="line">        <span class="keyword">if</span> (timeSinceLastNotWrittenMutationMillis &gt;= MAX_WRITE_PERMISSIONS_DELAY_MILLIS) &#123;</span><br><span class="line">            mHandler.obtainMessage(userId).sendToTarget();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hold off a bit more as settings are frequently changing.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> maxDelayMillis = Math.max(lastNotWrittenMutationTimeMillis</span><br><span class="line">                + MAX_WRITE_PERMISSIONS_DELAY_MILLIS - currentTimeMillis, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> writeDelayMillis = Math.min(WRITE_PERMISSIONS_DELAY_MILLIS,</span><br><span class="line">                maxDelayMillis);</span><br><span class="line"></span><br><span class="line">        Message message = mHandler.obtainMessage(userId);</span><br><span class="line">        mHandler.sendMessageDelayed(message, writeDelayMillis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLastNotWrittenMutationTimesMillis.put(userId, currentTimeMillis);</span><br><span class="line">        Message message = mHandler.obtainMessage(userId);</span><br><span class="line">        mHandler.sendMessageDelayed(message, WRITE_PERMISSIONS_DELAY_MILLIS);</span><br><span class="line">        mWriteScheduled.put(userId, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要异步处理，首先确认mWriteScheduled 是否在处理userId，如果没有就添加进去，200ms 后发出消息开始处理；如果已经在处理，计算出最合适的delay 处理，可以看出系统给定的一次操作最长是2秒。</p>
<p>最后会在mHandler 中的handleMessage 中处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = message.what;</span><br><span class="line">    Runnable callback = (Runnable) message.obj;</span><br><span class="line">    <span class="comment">// 写各个应用的运行时权限到文件中</span></span><br><span class="line">    writePermissionsSync(userId);</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">  	  callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>writePermissionsSync方法中从permissionsForPackage和permissionsForSharedUser 中将各个应用运行时权限获取出来，调用writePermissions()将对应的runtime permission 存放在runtime-permissions.xml 中，主要就是将之前保存的PermissionStates中的mGranted属性和mFlags属性存放在这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writePermissions</span><span class="params">(XmlSerializer serializer,</span></span></span><br><span class="line"><span class="function"><span class="params">	List&lt;PermissionState&gt; permissionStates)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (PermissionState permissionState : permissionStates) &#123;</span><br><span class="line">        serializer.startTag(<span class="keyword">null</span>, TAG_ITEM);</span><br><span class="line">        serializer.attribute(<span class="keyword">null</span>, ATTR_NAME,permissionState.getName());</span><br><span class="line">        serializer.attribute(<span class="keyword">null</span>, ATTR_GRANTED,</span><br><span class="line">                String.valueOf(permissionState.isGranted()));</span><br><span class="line">        serializer.attribute(<span class="keyword">null</span>, ATTR_FLAGS,</span><br><span class="line">                Integer.toHexString(permissionState.getFlags()));</span><br><span class="line">        serializer.endTag(<span class="keyword">null</span>, TAG_ITEM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的xml 如下（详见/data/system/users/0/runtime-permissions.xml）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&#x27;1.0&#x27;</span> encoding=<span class="string">&#x27;UTF-8&#x27;</span> standalone=<span class="string">&#x27;yes&#x27;</span> ?&gt;</span><br><span class="line">&lt;runtime-permissions fingerprint=<span class="string">&quot;qti/msmnile_gvmq/msmnile_gvmq:9/PQ1A.190105.004/jieou05250205:userdebug/test-keys&quot;</span>&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.android.car.messenger&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_SMS&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.SEND_SMS&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_CONTACTS&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.appservice.weather&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.android.car.trust&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.app.settings&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.app.music&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.app.raido&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">    </span><br><span class="line">.......</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>权限管理分析--AppOps对Normal Permission控制</title>
    <url>/2021/06/03/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-AppOps%E5%AF%B9Normal-Permission%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h4 id="1-App-ops作用"><a href="#1-App-ops作用" class="headerlink" title="1.App-ops作用"></a>1.App-ops作用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * App-ops are used for two purposes: Access control and tracking.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;App-ops cover a wide variety of functionality from helping with runtime permissions access</span></span><br><span class="line"><span class="comment"> * control and tracking to battery consumption tracking.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h2&gt;Access control&lt;/h2&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;App-ops can either be controlled for each uid or for each package. Which one is used depends</span></span><br><span class="line"><span class="comment"> * on the API provider maintaining this app-op. For any security or privacy related app-op the</span></span><br><span class="line"><span class="comment"> * provider needs to control the app-op for per uid as all security and privacy is based on uid in</span></span><br><span class="line"><span class="comment"> * Android.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To control access the app-op can be set to a mode to:</span></span><br><span class="line"><span class="comment"> * &lt;dl&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_DEFAULT&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Default behavior, might differ from app-op or app-op</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_ALLOWED&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Allow the access</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_IGNORED&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Don&#x27;t allow the access, i.e. don&#x27;t perform the requested action or return no or dummy</span></span><br><span class="line"><span class="comment"> *     data</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_ERRORED&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Throw a &#123;<span class="doctag">@link</span> SecurityException&#125; on access. This can be suppressed by using a</span></span><br><span class="line"><span class="comment"> *     &#123;<span class="doctag">@code</span> ...noThrow&#125; method to check the mode</span></span><br><span class="line"><span class="comment"> * &lt;/dl&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>从AppOpsManager注解可以看出，App-Ops主要用于权限控制和追述一些重要事件。</p>
<p>App-Ops可以对每一个uid或者每一个应用程序进行操作权限控制，此接入控制可以被设置成一下四种模式：</p>
<ul>
<li>MODE_DEFAULT：默认行为，用于区分不同app-op</li>
<li>MODE_ALLOWED: 运行操作</li>
<li>MODE_IGNORED:  不允许操作。不执行请求操作，或者返回空或者虚拟数据</li>
<li>MODE_ERRORED：此操作发生之后，抛SecurityException异常。</li>
</ul>
<p>每个平台会给每一个运行时权限定义一个app-op，用于追述和运行异常操作。如果运行时权限被拒绝，系统将抛SecurityException异常，但是如果权限被授予并且app op是MODE_IGNORED，那么调用者将获得虚拟数据。</p>
<p>如果被平台定义的App-ops被覆盖，app-op权限将被设置成MODE_DEFAULT，如果希望将app-ops设置成MODE_ALLOWED或者MODE_IGNORED，都需要校验之后再赋值。</p>
<h4 id="2-AppopsService分析"><a href="#2-AppopsService分析" class="headerlink" title="2.AppopsService分析"></a>2.AppopsService分析</h4><h5 id="2-1-AppopsService启动和数据结构分析"><a href="#2-1-AppopsService启动和数据结构分析" class="headerlink" title="2.1 AppopsService启动和数据结构分析"></a>2.1 AppopsService启动和数据结构分析</h5><p>AppOpsService的启动是再ActivityManagerService中启动的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data/system/appops.xml文件</span></span><br><span class="line">mAppOpsService = <span class="keyword">new</span> AppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">&quot;appops.xml&quot;</span>), mHandler);</span><br><span class="line"></span><br><span class="line">mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">new</span> IAppOpsCallback.Stub() &#123;</span><br><span class="line">         <span class="meta">@Override</span> </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opChanged</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAppOpsService.checkOperation(op, uid, packageName)</span><br><span class="line">                         != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                     runInBackgroundDisabled(uid);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AppOpsService</span><span class="params">(File storagePath, Handler handler)</span> </span>&#123;</span><br><span class="line">    mFile = <span class="keyword">new</span> AtomicFile(storagePath);</span><br><span class="line">    mHandler = handler;</span><br><span class="line">    readState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AppOpsService初始化的时候，通过readState()去读取data/system/appops.xml文件把他保存在内存中。</p>
<p>appops.xml文件大致如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-ops</span> <span class="attr">v</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">pkg</span> <span class="attr">n</span>=<span class="string">&quot;com.ts.appservice.settings&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uid</span> <span class="attr">n</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">p</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;59&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129003446&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;60&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129003446&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uid</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">pkg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pkg</span> <span class="attr">n</span>=<span class="string">&quot;com.ts.appservice.mediacenterservice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uid</span> <span class="attr">n</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">p</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;59&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622128997408&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;60&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622128997408&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pkg</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">pkg</span> <span class="attr">n</span>=<span class="string">&quot;com.iflytek.autofly.systemserver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uid</span> <span class="attr">n</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">p</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;2&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1577845829783&quot;</span> <span class="attr">d</span>=<span class="string">&quot;182727&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;41&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006431&quot;</span> <span class="attr">d</span>=<span class="string">&quot;9182935&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;42&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006431&quot;</span> <span class="attr">d</span>=<span class="string">&quot;9182935&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;59&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006246&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;60&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006246&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;76&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1577837011354&quot;</span> <span class="attr">d</span>=<span class="string">&quot;9001156&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pkg</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">app-ops</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最外层用app-ops标签，里面包裹了<pkg>，再里面包裹了<uid>，最里面包裹各式各样不同的操作。每个uid可能存在于多个包中。</uid></pkg></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mFile) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//1 打开文件</span></span><br><span class="line">                FileInputStream stream;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stream = mFile.openRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">&quot;No existing app ops &quot;</span> + mFile.getBaseFile() + <span class="string">&quot;; starting empty&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                mUidStates.clear();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">                    parser.setInput(stream, StandardCharsets.UTF_8.name());</span><br><span class="line">                    <span class="keyword">int</span> type;</span><br><span class="line">                    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                            &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;no start tag found&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">                    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String tagName = parser.getName();</span><br><span class="line">                        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;pkg&quot;</span>)) &#123;</span><br><span class="line">                            <span class="comment">//2 解析package数据</span></span><br><span class="line">                            readPackage(parser);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;uid&quot;</span>)) &#123;</span><br><span class="line">                            <span class="comment">//3解析uid数据</span></span><br><span class="line">                            readUidOps(parser);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;app-ops&gt;: &quot;</span></span><br><span class="line">                                    + parser.getName());</span><br><span class="line">                            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                        mUidStates.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        stream.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法中主要关注<code>readPackage(parser)</code>和<code>readUidOps(parser)</code>函数，先看看readUidOps(parser)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readUidOps</span><span class="params">(XmlPullParser parser)</span> <span class="keyword">throws</span> NumberFormatException,</span></span><br><span class="line"><span class="function">XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1 读取n节点，也就是name 代表uid</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> uid = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="comment">//2 下面读取uid下面的节点</span></span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">           &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tagName = parser.getName();</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;op&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//3 解析op节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> code = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>));</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> mode = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;m&quot;</span>));</span><br><span class="line">            <span class="comment">// 创建UidState并且放入mUidStates集合中</span></span><br><span class="line">            UidState uidState = getUidStateLocked(uid, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (uidState.opModes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                uidState.opModes = <span class="keyword">new</span> SparseIntArray();</span><br><span class="line">            &#125;</span><br><span class="line">            uidState.opModes.put(code, mode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4 未知节点直接跳过</span></span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;uid-ops&gt;: &quot;</span></span><br><span class="line">                   + parser.getName());</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是创建一个UidState。然后创建opModes，之后将code和mode关系保存在opModes中。</p>
<p>然后再分析一下<code>readPackage(parser)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readPackage</span><span class="params">(XmlPullParser parser)</span> <span class="keyword">throws</span> NumberFormatException,</span></span><br><span class="line"><span class="function">           XmlPullParserException, IOException </span>&#123;</span><br><span class="line">       <span class="comment">//1 n代表name ,也就是包名</span></span><br><span class="line">       String pkgName = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">       <span class="keyword">int</span> type;</span><br><span class="line">       <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">               &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String tagName = parser.getName();</span><br><span class="line">           <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;uid&quot;</span>)) &#123;</span><br><span class="line">               <span class="comment">//2 解析uid相关数据，这里是uid在pkg内的情况</span></span><br><span class="line">               readUid(parser, pkgName);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;pkg&gt;: &quot;</span></span><br><span class="line">                       + parser.getName());</span><br><span class="line">               XmlUtils.skipCurrentTag(parser);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从上面看解释pkg只是解析package name,然后解析uid的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readUid</span><span class="params">(XmlPullParser parser, String pkgName)</span> <span class="keyword">throws</span> NumberFormatException,</span></span><br><span class="line"><span class="function">XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1 n代表uid</span></span><br><span class="line">    <span class="keyword">int</span> uid = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>));</span><br><span class="line">    <span class="comment">//2 p代表是否预装在/system/priv-app/下</span></span><br><span class="line">    String isPrivilegedString = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;p&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> isPrivileged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//3 如果xml里面没有写这个pkg是否是priv-app就使用PMS查询，最终确定isPrivileged变量</span></span><br><span class="line">    <span class="keyword">if</span> (isPrivilegedString == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IPackageManager packageManager = ActivityThread.getPackageManager();</span><br><span class="line">            <span class="keyword">if</span> (packageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ApplicationInfo appInfo = ActivityThread.getPackageManager()</span><br><span class="line">                    .getApplicationInfo(pkgName, <span class="number">0</span>, UserHandle.getUserId(uid));</span><br><span class="line">                <span class="keyword">if</span> (appInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    isPrivileged = (appInfo.privateFlags</span><br><span class="line">                                    &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Could not load data, don&#x27;t add to cache so it will be loaded later.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Could not contact PackageManager&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isPrivileged = Boolean.parseBoolean(isPrivilegedString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">           &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4解析op标签</span></span><br><span class="line">        String tagName = parser.getName();</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;op&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//5 创建op数据结构，这里可以看到op包含的数据结构有uid,包名，name,我们在xml中看到op的name全都是数字，从Integer.parseInt来看也是这么实现的</span></span><br><span class="line">            Op op = <span class="keyword">new</span> Op(uid, pkgName, Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>)));</span><br><span class="line">            String mode = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">            <span class="comment">//6 设置op的mode</span></span><br><span class="line">            <span class="keyword">if</span> (mode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.mode = Integer.parseInt(mode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//7 设置时间</span></span><br><span class="line">            String time = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (time != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.time = Long.parseLong(time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//8 获取拒绝时间</span></span><br><span class="line">            time = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (time != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.rejectTime = Long.parseLong(time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9 获取间隔</span></span><br><span class="line">            String dur = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (dur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.duration = Integer.parseInt(dur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//10代理uid</span></span><br><span class="line">            String proxyUid = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;pu&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyUid != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.proxyUid = Integer.parseInt(proxyUid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//11 代理报名</span></span><br><span class="line">            String proxyPackageName = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;pp&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyPackageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.proxyPackageName = proxyPackageName;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//12 这里和readUidOps函数是一样的，创建UidState和pkgOps集合</span></span><br><span class="line">            UidState uidState = getUidStateLocked(uid, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (uidState.pkgOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">                uidState.pkgOps = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//13 创建Ops数据结构，添加到uidState</span></span><br><span class="line">            Ops ops = uidState.pkgOps.get(pkgName);</span><br><span class="line">            <span class="keyword">if</span> (ops == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ops = <span class="keyword">new</span> Ops(pkgName, uidState, isPrivileged);</span><br><span class="line">                uidState.pkgOps.put(pkgName, ops);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//14添加Op到ops中</span></span><br><span class="line">            ops.put(op.op, op);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;pkg&gt;: &quot;</span></span><br><span class="line">                   + parser.getName());</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看出Ops数据结构分为三层：</p>
<p>1 SparseArray mUidStates　用于存放uid和对应的uid下的状态，用UidState变量代表<br>2 UidState,一个uid对应一个UidState，然而一个uid可以对应多个package， 每个package下面都有一个Ops代表一组操作<br>3 每个Ops下又有多个op<br>另外每个UidState下还有一组opModes，分别保存code和mode的对应管理。</p>
<p>到这里就分析完成了解析，和数据结构的组织。　我们来线下AppOps如何检查权限。</p>
<h5 id="2-2-Appops权限校验"><a href="#2-2-Appops权限校验" class="headerlink" title="2.2 Appops权限校验"></a>2.2 Appops权限校验</h5><p>我们以AppOpsManager类的checkOp和checkOpNoThrow为例子说明AppOps的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOp</span><span class="params">(String op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkOp(strOpToOp(op), uid, packageName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOp</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mode = mService.checkOperation(op, uid, packageName);</span><br><span class="line">        <span class="keyword">if</span> (mode == MODE_ERRORED) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(buildSecurityExceptionMsg(op, uid, packageName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOpNoThrow</span><span class="params">(String op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> checkOpNoThrow(strOpToOp(op), uid, packageName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOpNoThrow</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mService.checkOperation(op, uid, packageName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法的区别在于，如果mode是MODE_ERRORED抛不抛异常。</p>
<p>当我们看到strOpToOp(op)似乎就可以猜到是把一个字符串转为从一个整形，就是转化成op code，似乎瞬间明白op标签的n是数字的原因了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strOpToOp</span><span class="params">(String op)</span> </span>&#123;</span><br><span class="line">   Integer val = sOpStrToOp.get(op);</span><br><span class="line">   <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown operation string: &quot;</span> + op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;_NUM_OP; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (sOpToString[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">       sOpStrToOp.put(sOpToString[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] sOpToString = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">    OPSTR_COARSE_LOCATION,</span><br><span class="line">    OPSTR_FINE_LOCATION,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AppOpsManager中有op的名字对应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> No operation specified. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_NONE = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> Access to coarse location information. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_COARSE_LOCATION = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> Access to fine location information. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_FINE_LOCATION = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> Causing GPS to run. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_GPS = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_VIBRATE = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ_CONTACTS = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE_CONTACTS = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ_CALL_LOG = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE_CALL_LOG = <span class="number">7</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ_CALENDAR = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE_CALENDAR = <span class="number">9</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WIFI_SCAN = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_POST_NOTIFICATION = <span class="number">11</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_NEIGHBORING_CELLS = <span class="number">12</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CALL_PHONE = <span class="number">13</span>;</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>sOpStrToOp是使用sOpToString所维护的字符串作为key,数组下标作为value去维护关系，所以这里的code就是数组下表，看来要加AppOps还要注意和google的兼容性。其实都是使用AppOpsService的checkOperation函数来检查的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOperation</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 检查uid是否具有UPDATE_APP_OPS_STATS权限</span></span><br><span class="line">        verifyIncomingUid(uid);</span><br><span class="line">        <span class="comment">//2 检查code是否合理</span></span><br><span class="line">        verifyIncomingOp(code);</span><br><span class="line">        <span class="comment">//3 根据uid和包名获取包名</span></span><br><span class="line">        String resolvedPackageName = resolvePackageName(uid, packageName);</span><br><span class="line">        <span class="keyword">if</span> (resolvedPackageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AppOpsManager.MODE_IGNORED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//4 检查user多用户相关的权限</span></span><br><span class="line">            <span class="keyword">if</span> (isOpRestrictedLocked(uid, code, resolvedPackageName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> AppOpsManager.MODE_IGNORED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5 根据code转换为op code,这里又进行了一个转换的操作</span></span><br><span class="line">            code = AppOpsManager.opToSwitch(code);</span><br><span class="line">            <span class="comment">//6 获取UidState</span></span><br><span class="line">            UidState uidState = getUidStateLocked(uid, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (uidState != <span class="keyword">null</span> &amp;&amp; uidState.opModes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//7 检查opModes下维护的code权限</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> uidMode = uidState.opModes.get(code);</span><br><span class="line">                <span class="keyword">if</span> (uidMode != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> uidMode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//8 获取pkg下的Op</span></span><br><span class="line">            Op op = getOpLocked(code, uid, resolvedPackageName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//9 op不存在使用默认规则</span></span><br><span class="line">                <span class="keyword">return</span> AppOpsManager.opToDefaultMode(code);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9op 存在返回op下的mode</span></span><br><span class="line">            <span class="keyword">return</span> op.mode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">opToSwitch</span><span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sOpToSwitch[op];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sOpToSwitch = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">            OP_COARSE_LOCATION,</span><br><span class="line">            OP_COARSE_LOCATION,</span><br><span class="line">            OP_COARSE_LOCATION,</span><br><span class="line">            OP_VIBRATE,</span><br><span class="line">            OP_READ_CONTACTS,</span><br><span class="line">            OP_WRITE_CONTACTS,</span><br><span class="line">            OP_READ_CALL_LOG,</span><br><span class="line">            OP_WRITE_CALL_LOG,</span><br><span class="line">            OP_READ_CALENDAR,</span><br><span class="line">            OP_WRITE_CALENDAR,</span><br><span class="line">   　　　　　....</span><br><span class="line">   　　　　　&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android.os.Process.java</span></span><br><span class="line"><span class="comment">// UID定义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the root UID.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ROOT_UID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID under which system code runs.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYSTEM_UID = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID under which the telephony code runs.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PHONE_UID = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID for the user shell.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHELL_UID = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID for the log group.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOG_UID = <span class="number">1007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID for the WIFI supplicant process.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WIFI_UID = <span class="number">1010</span>;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the start of a range of UIDs (and GIDs), going from this</span></span><br><span class="line"><span class="comment">* number to &#123;<span class="doctag">@link</span> #LAST_APPLICATION_UID&#125; that are reserved for assigning</span></span><br><span class="line"><span class="comment">* to applications.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_UID = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Last of application-specific UIDs starting at</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #FIRST_APPLICATION_UID&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_UID = <span class="number">19999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* First uid used for fully isolated sandboxed processes (with no permissions of their own)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_ISOLATED_UID = <span class="number">99000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Last uid used for fully isolated sandboxed processes (with no permissions of their own)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_ISOLATED_UID = <span class="number">99999</span>;</span><br></pre></td></tr></table></figure>
<p>函数很简单，使用注释中的九个步骤去判断op code对应的授权模式。　<br>1,2,3 三个步骤都是检查参数和调用者的合理性，这里需要说明的是如果resolvedPackageName不存在的时候返回AppOpsManager.MODE_IGNORED，看来这就是一种op对应的mode,这里对mode做一下说明</p>
<blockquote>
<p>//1 操作允许<br>public static final int MODE_ALLOWED = 0;<br>//操作不允许，但是checkOp不会抛出安全异常，表示忽略<br>public static final int MODE_IGNORED = 1;<br>//3 表示操作不允许，checkOp操作会抛出安全异常<br>public static final int MODE_ERRORED = 2;<br>//4　默认行为，可能进一步检查权限<br>public static final int MODE_DEFAULT = 3;</p>
</blockquote>
<p>步骤４检查多用户相关的授权，我们先放一下再来分析<br>步骤５根据code转换为op code,这里又进行了一个转换的操作,对于这里的转换，注释里面说的比较清楚，就是多个code可能对应同一个op code,所以这里要进行一次转换。大多数时候code都是和opcode相同的。　<br>步骤７　首先检查uid下的opModes，我们在分析读取appops.xml文件的时候，有时候一个uid标签是不在pkg内部的，这种uid标签下申明的mode,优先级要高于pkg下的op,所以在这里先去判断uid的op code 对应的mode.<br>步骤８　则是当uid下的规则不存在，继而检查pkg下的op<br>步骤９是如果没有指定规则，则采用默认规则，opToDefaultMode函数也是使用查表的方式确定默认规则，表则AppOpsManager类的sOpDefaultMode变量中维护。</p>
<h5 id="2-3-AppOpsManager下一个方法"><a href="#2-3-AppOpsManager下一个方法" class="headerlink" title="2.3 AppOpsManager下一个方法"></a>2.3 AppOpsManager下一个方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkPackage</span><span class="params">(<span class="keyword">int</span> uid, String packageName)</span> </span></span><br></pre></td></tr></table></figure>
<p>这个方法会在uid下创建对应的uidState和一个Ops返回给用户，创建成功返回说明uid和packagename是对应的上的，返回AppOpsManager.MODE_ALLOWED，否则返回AppOpsManager.MODE_ERRORED</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noteOp</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span></span></span><br></pre></td></tr></table></figure>
<p>noteOp 函数比checkOp函数额外多出的功能就是会创建对应的op,另外会更新一些op操作的时间用于统计信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startOp</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span></span><br></pre></td></tr></table></figure>
<p>表示一个长时间运行的操作，比noteOp增加了一个统计信息，放在一个叫starting的集合里可以dump到，调用finishOp结束操作。</p>
<h5 id="2-4-多用户检测"><a href="#2-4-多用户检测" class="headerlink" title="2.4 多用户检测"></a>2.4 多用户检测</h5><p>AppOps的另外一个功能是针对多用户的授权检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRestriction</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">boolean</span> restricted, IBinder token, <span class="keyword">int</span> userHandle, String[] exceptionPackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 不是针对自己进程的首先规则，要检查MANAGE_APP_OPS_RESTRICTIONS权限</span></span><br><span class="line">    <span class="keyword">if</span> (Binder.getCallingPid() != Process.myPid()) &#123;</span><br><span class="line">    	mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,</span><br><span class="line">    		Binder.getCallingPid(), Binder.getCallingUid(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 跨用户的调用检查INTERACT_ACROSS_USERS_FULL　权限</span></span><br><span class="line">    <span class="keyword">if</span> (userHandle != UserHandle.getCallingUserId()) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (mContext.checkCallingOrSelfPermission(Manifest.permission</span><br><span class="line">    		.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">    		&amp;&amp; mContext.checkCallingOrSelfPermission(Manifest.permission</span><br><span class="line">    		.INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Need INTERACT_ACROSS_USERS_FULL or&quot;</span></span><br><span class="line">    		+ <span class="string">&quot; INTERACT_ACROSS_USERS to interact cross user &quot;</span>);</span><br><span class="line">   		 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 检查code合理性</span></span><br><span class="line">    verifyIncomingOp(code);</span><br><span class="line">    Preconditions.checkNotNull(token);</span><br><span class="line">    setUserRestrictionNoCheck(code, restricted, token, userHandle, exceptionPackages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了一系列检查后进入setUserRestrictionNoCheck真正的创先相应的受限规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUserRestrictionNoCheck</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">boolean</span> restricted, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> userHandle, String[] exceptionPackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> notifyChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1 获取token所对应的ClientRestrictionState，这代表一个用户应用进程，用户应用进程会发布一些针对某些user的限制</span></span><br><span class="line">    <span class="keyword">synchronized</span> (AppOpsService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        ClientRestrictionState restrictionState = mOpUserRestrictions.get(token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (restrictionState == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                restrictionState = <span class="keyword">new</span> ClientRestrictionState(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 不存在的情况创建，放入mOpUserRestrictions集合</span></span><br><span class="line">            mOpUserRestrictions.put(token, restrictionState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3给userHandle添加一个受限规则，其中code为op,restricted为是否收到限制，真为是，exceptionPackages</span></span><br><span class="line">        <span class="comment">//是指白名单的包，这些包属于userHandle这个用户。</span></span><br><span class="line">        <span class="keyword">if</span> (restrictionState.setRestriction(code, restricted, exceptionPackages, userHandle)) &#123;</span><br><span class="line">            notifyChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4　没有任何授权需要创建，直接销毁</span></span><br><span class="line">        <span class="keyword">if</span> (restrictionState.isDefault()) &#123;</span><br><span class="line">            mOpUserRestrictions.remove(token);</span><br><span class="line">            restrictionState.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (notifyChange) &#123;</span><br><span class="line">        <span class="comment">//5 通知监听者</span></span><br><span class="line">        notifyWatchersOfChange(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setRestriction</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">boolean</span> restricted,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] excludedPackages, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1 创建user数据结构，维护每个user的授权情况</span></span><br><span class="line">    <span class="keyword">if</span> (perUserRestrictions == <span class="keyword">null</span> &amp;&amp; restricted) &#123;</span><br><span class="line">        perUserRestrictions = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perUserRestrictions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] userRestrictions = perUserRestrictions.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (userRestrictions == <span class="keyword">null</span> &amp;&amp; restricted) &#123;</span><br><span class="line">            <span class="comment">//２创建每种权限的受限情况</span></span><br><span class="line">            userRestrictions = <span class="keyword">new</span> <span class="keyword">boolean</span>[AppOpsManager._NUM_OP];</span><br><span class="line">            perUserRestrictions.put(userId, userRestrictions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3 如果设置完成后，对所有op的操作都是不受限制的，则清除该限制的数据结构</span></span><br><span class="line">        <span class="keyword">if</span> (userRestrictions != <span class="keyword">null</span> &amp;&amp; userRestrictions[code] != restricted) &#123;</span><br><span class="line">            userRestrictions[code] = restricted;</span><br><span class="line">            <span class="keyword">if</span> (!restricted &amp;&amp; isDefault(userRestrictions)) &#123;</span><br><span class="line">                perUserRestrictions.remove(userId);</span><br><span class="line">                userRestrictions = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 创建excludedPackages相关信息</span></span><br><span class="line">        <span class="keyword">if</span> (userRestrictions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> noExcludedPackages = ArrayUtils.isEmpty(excludedPackages);</span><br><span class="line">            <span class="keyword">if</span> (perUserExcludedPackages == <span class="keyword">null</span> &amp;&amp; !noExcludedPackages) &#123;</span><br><span class="line">                perUserExcludedPackages = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (perUserExcludedPackages != <span class="keyword">null</span> &amp;&amp; !Arrays.equals(excludedPackages,</span><br><span class="line">                    perUserExcludedPackages.get(userId))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (noExcludedPackages) &#123;</span><br><span class="line">                    perUserExcludedPackages.remove(userId);</span><br><span class="line">                    <span class="keyword">if</span> (perUserExcludedPackages.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        perUserExcludedPackages = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    perUserExcludedPackages.put(userId, excludedPackages);</span><br><span class="line">                &#125;</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个api的作用就是限制一个user去做某件事情。</p>
<h5 id="2-4-限制用户操作例子"><a href="#2-4-限制用户操作例子" class="headerlink" title="2.4 限制用户操作例子"></a>2.4 限制用户操作例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverlayTouchActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mToken = <span class="keyword">new</span> Binder();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        setOverlayAllowed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        setOverlayAllowed(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOverlayAllowed</span><span class="params">(<span class="keyword">boolean</span> allowed)</span> </span>&#123;</span><br><span class="line">        AppOpsManager appOpsManager = getSystemService(AppOpsManager.class);</span><br><span class="line">        <span class="keyword">if</span> (appOpsManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            appOpsManager.setUserRestriction(AppOpsManager.OP_SYSTEM_ALERT_WINDOW,</span><br><span class="line">                    !allowed, mToken);</span><br><span class="line">            appOpsManager.setUserRestriction(AppOpsManager.OP_TOAST_WINDOW,</span><br><span class="line">                    !allowed, mToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入OverlayTouchActivity这个页面时候就不允许这个用户弹出window，除非弹框来自Privileged的包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOpRestrictedLocked</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> code, String packageName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> userHandle = UserHandle.getUserId(uid);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> restrictionSetCount = mOpUserRestrictions.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; restrictionSetCount; i++) &#123;</span><br><span class="line">        <span class="comment">// For each client, check that the given op is not restricted, or that the given</span></span><br><span class="line">        <span class="comment">// package is exempt from the restriction.</span></span><br><span class="line">        ClientRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (restrictionState.hasRestriction(code, packageName, userHandle)) &#123;</span><br><span class="line">            <span class="comment">// opAllowSystemBypassRestriction检查一些op code是否对Privileged开放</span></span><br><span class="line">            <span class="keyword">if</span> (AppOpsManager.opAllowSystemBypassRestriction(code)) &#123;</span><br><span class="line">                <span class="comment">// If we are the system, bypass user restrictions for certain codes</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    Ops ops = getOpsRawLocked(uid, packageName, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> ((ops != <span class="keyword">null</span>) &amp;&amp; ops.isPrivileged) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>this原理与友元函数</title>
    <url>/2021/06/06/this%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1-可变参数"><a href="#1-可变参数" class="headerlink" title="1.可变参数"></a>1.可变参数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java的可变参数: int ...</span></span><br><span class="line"><span class="comment">// C++的可变参数写法：...</span></span><br><span class="line"><span class="comment">// count的第一个用处：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息</span></span><br><span class="line"><span class="comment">// count主要还是用于记录可变参数个数，方便内部存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp; <span class="comment">// 可变参数的动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数一：可变参数开始的动作vp</span></span><br><span class="line">    <span class="comment">// 参数二：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息</span></span><br><span class="line">    va_start(vp, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里后：vp就已经有丰富的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值</span></span><br><span class="line">    <span class="keyword">int</span> number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值</span></span><br><span class="line">    number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值</span></span><br><span class="line">    number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 越界 系统值 乱码</span></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值 【娶不到后，会取系统值 乱码】</span></span><br><span class="line">    number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭阶段</span></span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sum(<span class="number">3</span>, <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2.static关键字"></a>2.static关键字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态的总结：</span></span><br><span class="line"><span class="comment"> * 1.可以直接通过类名::静态成员（字段/函数）</span></span><br><span class="line"><span class="comment"> * 2.静态的属性必须要初始化，然后再实现（规则）</span></span><br><span class="line"><span class="comment"> * 3.静态的函数只能取操作静态的属性和方法（Java）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * info;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 报错:静态函数不能调用非静态函数（Java）</span></span><br><span class="line">        <span class="comment">// update2();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再实现</span></span><br><span class="line"><span class="keyword">int</span> Dog::id = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    dog.update2(); <span class="comment">// 普通函数</span></span><br><span class="line">    Dog::update(); <span class="comment">// 静态函数</span></span><br><span class="line">    dog.update(); <span class="comment">// 对象名.静态函数（一般都是使用::调用静态成员，这种方式可以 知道就行）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Dog::id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-友元函数"><a href="#3-友元函数" class="headerlink" title="3.友元函数"></a>3.友元函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有的age，外界不能访问</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义友元函数 (声明，没有实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person * person, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的实现，可以访问所以私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person* person, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认情况下：不能修改 私有的age</span></span><br><span class="line">    <span class="comment">// 通过友元函数可以修改私有成员，java反射是这样实现的么？</span></span><br><span class="line">    person-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = Person(<span class="number">9</span>);</span><br><span class="line">    updateAge(&amp;person, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-友元类"><a href="#4-友元类" class="headerlink" title="4.友元类"></a>4.友元类</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageView</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> viewSize;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>;</span> <span class="comment">// 友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java每个类，都会有一个Class，此Class可以操作 ImageView私有成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ImageView imageView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeViewSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        imageView.viewSize = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getViewSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imageView.viewSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class mImageViewClass;</span><br><span class="line"></span><br><span class="line">    mImageViewClass.changeViewSize(<span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mImageViewClass.getViewSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-各种定义和方法的区别"><a href="#5-各种定义和方法的区别" class="headerlink" title="5.各种定义和方法的区别"></a>5.各种定义和方法的区别</h4><p>静态函数，友元函数，普通函数，构造函数，析构函数，拷贝构造函数，有什么区别。</p>
<p>头文件定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PIG_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIG_H <span class="comment">// 定义这个宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数的声明系列</span></span><br><span class="line">    Pig();</span><br><span class="line">    Pig(<span class="keyword">char</span> *);</span><br><span class="line">    Pig(<span class="keyword">char</span> *,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Pig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Pig(<span class="keyword">const</span> Pig &amp; pig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数 set get</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPigInfo</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 常量指针常量 只读</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态函数的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeTag</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要这样干</span></span><br><span class="line">    <span class="comment">// void changeTag(int age);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">changeAge</span><span class="params">(Pig * pig, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 关闭/结尾</span></span></span><br></pre></td></tr></table></figure>


<p>实现类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Pig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO  ======================  下面是 普普通通 常规操作 对象::</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现构造函数</span></span><br><span class="line">Pig::Pig() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pig::Pig(<span class="keyword">char</span> * name) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1个参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pig::Pig(<span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2个参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现析构函数</span></span><br><span class="line">Pig::~Pig() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 拷贝构造函数</span></span><br><span class="line">Pig::Pig(<span class="keyword">const</span> Pig &amp;pig) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pig::getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Pig::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::setName</span><span class="params">(<span class="keyword">char</span> * name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::showPigInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 常量指针常量 只读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====  静态 和 友元   ==============</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 静态属性【不需要增加 static关键字】</span></span><br><span class="line"><span class="keyword">int</span> Pig::id = <span class="number">878</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现静态函数，【不需要增加 static关键字】</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::changeTag</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元的实现</span></span><br><span class="line"><span class="comment">// 友元特殊：不需要关键字，也不需要 对象:: ,只需要保证 函数名（参数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeAge</span><span class="params">(Pig * pig, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-this关键字存在的意义"><a href="#6-this关键字存在的意义" class="headerlink" title="6.this关键字存在的意义"></a>6.this关键字存在的意义</h4><p>this关键字可以表示该对象的暴露地址，让执行器知道调用那个对象的某个属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id; <span class="comment">// 先声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认的构造函数 栈区开辟空间 暴露 地址 == this指针 (和Java一致的思路)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再实现</span></span><br><span class="line"><span class="keyword">int</span> Student::id = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ======= 常规使用下而已</span></span><br><span class="line">    Student student;</span><br><span class="line">    student.setAge(<span class="number">99</span>);</span><br><span class="line">    student.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; student.getName() &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; student.getAge()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==========  this 的意义</span></span><br><span class="line">    Student student1;</span><br><span class="line">    <span class="comment">// 设置值的时候，它知道是给student1的age赋值</span></span><br><span class="line">    student1.setAge(<span class="number">88</span>);</span><br><span class="line">    student1.id = <span class="number">880</span>;</span><br><span class="line"></span><br><span class="line">    Student student2;</span><br><span class="line">    <span class="comment">// 设置值的时候，它知道是给student2的age赋值</span></span><br><span class="line">    student2.setAge(<span class="number">99</span>);</span><br><span class="line">    student2.id = <span class="number">990</span>;</span><br><span class="line"></span><br><span class="line">    Student::id = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this关键字能够知道获取student1的age</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; student1.getAge:&quot;</span> &lt;&lt; student1.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它怎么知道是获取student2的age</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; student2.getAge:&quot;</span> &lt;&lt; student2.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;student1.id:&quot;</span> &lt;&lt; student1.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;student2.id:&quot;</span> &lt;&lt; student2.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student:::&quot;</span> &lt;&lt; Student::id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// main函数弹栈会 隐士代码：（栈区：delete student ...， 堆区需要自己手动delete）</span></span><br></pre></td></tr></table></figure>


<h4 id="7-const修饰函数"><a href="#7-const修饰函数" class="headerlink" title="7.const修饰函数"></a>7.const修饰函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="literal">NULL</span>; <span class="comment">// C++中不像Java，Java有默认值， 如果你不给默认值，那么就是系统值 -64664</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int * const  指针常量 指针常量【地址对应的值能改，地址不可以修改】</span></span><br><span class="line">    <span class="comment">// const int *  常量指针 常量指针【地址可以修改，地址对应的值不能改】</span></span><br><span class="line">    <span class="comment">// const 离谁近，谁就不能改！！！！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纠结：原理：为什么可以修改age</span></span><br><span class="line">    <span class="comment">// 默认持有隐士的this【类型 * const this】</span></span><br><span class="line">    <span class="comment">// 类型 * const 指针常量：代表指针地址不能被修改，但是指针地址的值是可以修改的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代表指针地址不能被修改</span></span><br><span class="line">        <span class="comment">// this = 0x6546;  // 编译不通过，地址不能被修改，因为是指针常量</span></span><br><span class="line">        <span class="comment">// 地址不可以修改</span></span><br><span class="line">        <span class="comment">// this = 0x43563;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 隐士的this</span></span><br><span class="line">        <span class="comment">// 但是指针地址的值是可以修改的</span></span><br><span class="line">        <span class="comment">// 地址对应的值能改</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">&quot;JJJ&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认现在：this 等价于 const Student * const  常量指针常量（地址不能改，地址对应的值不能改）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeAction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 地址不能改</span></span><br><span class="line">        <span class="comment">// this = 0x43563;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 地址对应的值不能改</span></span><br><span class="line">        <span class="comment">// this-&gt;age = 100;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原理：修改隐士代码  const 类型 * const 常量指针常量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;name = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">// this-&gt;age = 88;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只读的</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多态、虚函数、纯虚函数、模板函数</title>
    <url>/2021/06/10/%E5%A4%9A%E6%80%81%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1-属性初始化"><a href="#1-属性初始化" class="headerlink" title="1. 属性初始化"></a>1. 属性初始化</h4><p>第一种方式：直接在构造函数后面给对象赋值</p>
<p>第二种方式：在构造函数后面调对象属性构造函数进行赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// 已经声明了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 注意：string 是 std 命名空间里面的成员，C++源码是这种写法std::string</span></span><br><span class="line">    <span class="comment">// string内部其实就是对 char*的封装</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) :name(name), age(age) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 课程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Course(<span class="built_in">string</span> name) :name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 如果定义的是对象成员，必须这样初始化(构造函数的后面 : 对象成员(内容))  使用我们的第二种方式</span></span><br><span class="line">    Course course; <span class="comment">// 对象成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, Course course1, <span class="built_in">string</span> courseNameInfo)</span><br><span class="line">    :Person(name, age) <span class="comment">// 既然继承了父类就必须给父类的构造函数初始化</span></span><br><span class="line">    <span class="comment">// course(course1) // 第二种方式，编译阶段认可的 对象=对象   对象直接的赋值而已</span></span><br><span class="line">    ,</span><br><span class="line">     course(courseNameInfo) <span class="comment">// 第三种方式， 对象(string内容)  直接初始化Course对象 --- 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// this-&gt;course = course1; // 第一种方式（对象=对象） 编译阶段不认可，无法监测到你是否真的给course对象成员初始化了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Course <span class="title">c</span><span class="params">(<span class="string">&quot;C++&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">student</span><span class="params">(<span class="string">&quot;Jack&quot;</span>, <span class="number">30</span>, c, <span class="string">&quot;NDK内容真多&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h4><p><strong>重写属于动态多态，重载属于静态多态</strong>。同一个方法有不同的实现。</p>
<h5 id="2-1-动态多态"><a href="#2-1-动态多态" class="headerlink" title="2.1 动态多态"></a>2.1 动态多态</h5><p>动态多态是只有在运行时才知道调用那个方法。</p>
<blockquote>
<p>Java语言默认支持多态<br>C++默认关闭多态，怎么开启多态？ 虚函数  在父类上给函数增加 virtual关键字</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android标准</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加上virtual关键字之后，C++就支持多态了</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写父类的函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;HomeActivity onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写父类的函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LoginActivity onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此函数 体现多态，例如：你传入HomeActivity，我就帮你运行HomeActivity</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startToActivity</span><span class="params">(BaseActivity * baseActivity)</span> </span>&#123;</span><br><span class="line">    baseActivity-&gt;onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 第一个版本</span></span><br><span class="line">    HomeActivity *homeActivity = <span class="keyword">new</span> HomeActivity();</span><br><span class="line">    LoginActivity *loginActivity = <span class="keyword">new</span> LoginActivity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如下调用输出BaseActivity的onstart()</span></span><br><span class="line">    <span class="comment">// 因此C++默认不支持多态</span></span><br><span class="line">    startToActivity(homeActivity);</span><br><span class="line">    startToActivity(loginActivity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (homeActivity &amp;&amp; loginActivity) <span class="keyword">delete</span> homeActivity; <span class="keyword">delete</span> loginActivity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二个版本</span></span><br><span class="line">    BaseActivity * activity1 = <span class="keyword">new</span> HomeActivity();</span><br><span class="line">    BaseActivity * activity2 = <span class="keyword">new</span> LoginActivity();</span><br><span class="line">    startToActivity(activity1);</span><br><span class="line">    startToActivity(activity2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-2-静态多态"><a href="#2-2-静态多态" class="headerlink" title="2.2 静态多态"></a>2.2 静态多态</h5><p>在编译器就确定调用某个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number1 + number2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> number1, <span class="keyword">float</span> number2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number1 + number2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> number1, <span class="keyword">double</span> number2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number1 + number2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add(<span class="number">10000</span>, <span class="number">10000</span>);</span><br><span class="line">    add(<span class="number">1.9f</span>, <span class="number">2.8f</span>);</span><br><span class="line">    add(<span class="number">545.4</span>, <span class="number">654.54</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-纯虚函数"><a href="#3-纯虚函数" class="headerlink" title="3. 纯虚函数"></a>3. 纯虚函数</h4><p>在C++中不支持抽象类和接口的定义，所以就引出了纯虚函数和全纯虚函数。</p>
<p><strong>纯虚函数相等于JAVA中的抽象类；全纯虚函数相当于JAVA中的接口。</strong></p>
<p>纯虚函数定义最后要有 “= 0”字样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类/纯虚函数： 分为：1.普通函数， 2.抽象函数/纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="built_in">string</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;XmlResourceParser解析布局文件信息... 反射&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1.普通函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setContentView(getLayoutID());</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line">        initData();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数是必须继承的（如果子类没有重写纯虚函数，子类就是抽象类）， 虚函数是不是不必须的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.抽象函数/纯虚函数</span></span><br><span class="line">    <span class="comment">// virtual string getLayoutID(); // 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getLayoutID</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initListener</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 MainActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123; <span class="comment">// MainActivity如果没有重新父类的纯虚函数，自己就相当于 抽象类了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getLayoutID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;R.layout.activity_main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// Button btLogin = findViewById(R.id.bt_login);</span></span><br><span class="line">        <span class="comment">// Button btRegister = findViewById(R.id.bt_register);</span></span><br><span class="line">        <span class="comment">// TextView tvInfo = findViewById(R.id.tv_info);</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tvInfo.setText(&quot;info...&quot;);</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*btLogin.setOnClickListener(new View.OnClickListener() &#123;</span></span><br><span class="line"><span class="comment">                   @Override</span></span><br><span class="line"><span class="comment">                   public void onClick(View v) &#123;</span></span><br><span class="line"><span class="comment">                       // 点击做事情</span></span><br><span class="line"><span class="comment">                   &#125;</span></span><br><span class="line"><span class="comment">               &#125;);*/</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：抽象类型 MainActivity 绝对不能实例化</span></span><br><span class="line">    <span class="comment">// MainActivity mainActivity;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新了父类所有的纯虚函数</span></span><br><span class="line">    MainActivity mainActivity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全纯虚函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此类所有的函数 ，都是纯虚函数，就相当于 Java的接口了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISudent_DB</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">(<span class="keyword">int</span> _id)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(<span class="keyword">int</span> _id, Student student)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Student <span class="title">queryByStudent</span><span class="params">(Student student)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_DBImpl1</span> :</span> <span class="keyword">public</span> ISudent_DB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">(<span class="keyword">int</span> _id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(<span class="keyword">int</span> _id, Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">queryByStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student_DBImpl1 studentDbImpl1;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-模板函数"><a href="#4-模板函数" class="headerlink" title="4. 模板函数"></a>4. 模板函数</h4><p>C++中模板函数非常类似JAVA中泛型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加分合集  int double float ... 你都要考虑，你是不是要定义很多的 函数</span></span><br><span class="line"><span class="comment">/*void addAction(int n1, int n2) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;addAction(int n1, int n2):&quot; &lt;&lt; n1 + n1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void addAction(float n1, float n2) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;addAction(int n1, int n2):&quot; &lt;&lt; n1 + n1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void addAction(double n1, double n2) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;addAction(int n1, int n2):&quot; &lt;&lt; n1 + n1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数  == Java的泛型解决此问题</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAction</span><span class="params">(TT n1, TT n2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;模板函数：&quot;</span> &lt;&lt; n1 + n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addAction(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addAction(<span class="number">10.2f</span>, <span class="number">20.3f</span>);</span><br><span class="line">    addAction(<span class="number">545.34</span>, <span class="number">324.3</span>);</span><br><span class="line">    addAction&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为是一个TT，类型必须要统一</span></span><br><span class="line">    <span class="comment">/*addAction(2, 324.3);</span></span><br><span class="line"><span class="comment">    addAction(54, 324.3f);*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-继承关系中构造函数和析构函数调用顺序"><a href="#5-继承关系中构造函数和析构函数调用顺序" class="headerlink" title="5.继承关系中构造函数和析构函数调用顺序"></a>5.继承关系中构造函数和析构函数调用顺序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name) : name(name) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    ~Person()  &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父 test...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    Student(<span class="built_in">string</span> name) : Person(name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Person::test();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Student()  &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;子 test...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">student</span><span class="params">(<span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Person构造函数</span></span><br><span class="line">    <span class="comment">// Student构造函数</span></span><br><span class="line">    <span class="comment">// Student析构函数</span></span><br><span class="line">    <span class="comment">// Person析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">student1</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line">    student1.test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>对象继承和操作符重载</title>
    <url>/2021/06/07/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="1-重载运算符"><a href="#1-重载运算符" class="headerlink" title="1. 重载运算符"></a>1. 重载运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类里重载操作符</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(Person person2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + person2.getX();</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + person2.getY();</span><br><span class="line"></span><br><span class="line">        <span class="function">Person <span class="title">res</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正规写法</span></span><br><span class="line">    <span class="comment">// 使用const person2为只读</span></span><br><span class="line">    <span class="comment">// 使用&amp; 直接引用，不构建新副本</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person &amp; person2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + person2.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + person2.y;</span><br><span class="line"></span><br><span class="line">        <span class="function">Person <span class="title">res</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 ++</span></span><br><span class="line">    <span class="comment">// ++对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++ ()&#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象++</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++ (<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义输出对象</span></span><br><span class="line">    <span class="comment">// istream 输入</span></span><br><span class="line">    <span class="comment">// ostream 输出</span></span><br><span class="line">    <span class="comment">// 输出单个</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (ostream &amp; _START, <span class="keyword">const</span> Person &amp; person) &#123;</span><br><span class="line">        _START &lt;&lt; person.x &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; person.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出多个对象</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; _START, <span class="keyword">const</span> Person &amp; person) &#123;</span><br><span class="line">        _START &lt;&lt; person.x &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; person.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> _START;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载加号  operator重载关键字</span></span><br><span class="line">Person operato+(Person person1, Person person2) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = person1.getX() + person2.getX();</span><br><span class="line">    <span class="keyword">int</span> y = person1.getY() + person2.getY();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">res</span><span class="params">(x,y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">person2</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person person3 = person1 + person2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x:&quot;</span> &lt;&lt; person3.getX() &lt;&lt; <span class="string">&quot;y:&quot;</span> &lt;&lt; person3.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义输出对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-括号运算符重载"><a href="#2-括号运算符重载" class="headerlink" title="2. 括号运算符重载"></a>2. 括号运算符重载</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.括号运算符。   数组 系统源码把此括号[i]给重载，  系统重载后的样子 *(arr+i)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个小容器，模拟容器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// C++ 默认都是系统值  size 系统值 -13275</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">// 大小  开发过程中，给size赋默认值，不然会出现，后患无穷的问题</span></span><br><span class="line">    <span class="keyword">int</span> * arrayValue; <span class="comment">// 数组存放 int 类型的很多值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arrayValue[index] = value; <span class="comment">// []目前不是我的</span></span><br><span class="line">        size+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="comment">// size成员的目标：是为了循环可以遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运算符重载 [index]</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;arrayValue[index]; <span class="comment">// 此[]是系统的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出容器的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfArryClass</span><span class="params">(ArrayClass arrayClass)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arrayClass.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayClass.getSize(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arrayClass[i] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// []是我们自己的 重载符号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 能在栈区的，尽量在栈区</span></span><br><span class="line">    <span class="comment">// 1.代码量少</span></span><br><span class="line">    <span class="comment">// 2.避免麻烦</span></span><br><span class="line">    <span class="comment">// 3.怕有问题</span></span><br><span class="line">    <span class="comment">// 4.栈区的回收，不是你负责的，责任推卸</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//目前arrayClass对象是在栈区    实例出来的对象，是在堆区了</span></span><br><span class="line">    ArrayClass arrayClass;  </span><br><span class="line"></span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">1</span>, <span class="number">2000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">2</span>, <span class="number">3000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">3</span>, <span class="number">4000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">4</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    printfArryClass(arrayClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-对象继承"><a href="#3-对象继承" class="headerlink" title="3. 对象继承"></a>3. 对象继承</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">int</span> age) : name(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person 构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.默认是 隐式代码： : private Person</span></span><br><span class="line"><span class="comment">// 2.私有继承：在子类里面是可以访问父类的成员，但是在类的外面不行</span></span><br><span class="line"><span class="comment">// 3.必须公开继承，才可以访问父类的成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 默认是私有的，在子类内部可以对父类进行访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * course;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// :父类 , 给自己子类成员初始化</span></span><br><span class="line">    Student(<span class="keyword">char</span> * name, <span class="keyword">int</span> age, <span class="keyword">char</span>* course) : Person(name, age) , course(course) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student 构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;李元霸&quot;</span>, <span class="number">99</span>, <span class="string">&quot;C++&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公开继承，才可以拿父类的成员</span></span><br><span class="line">    stu.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-C-多继承"><a href="#4-C-多继承" class="headerlink" title="4. C++多继承"></a>4. C++多继承</h4><p>在JAVA语言中只能单继承，可以多实现，很好解决了二义性。但是在C++中是支持多继承的，因此就会出现二义性，下面我们来看一下C++中是如何解决二义性的。</p>
<h5 id="4-1-明确指定对象的方法"><a href="#4-1-明确指定对象的方法" class="headerlink" title="4.1 明确指定对象的方法"></a>4.1 明确指定对象的方法</h5><p>方案一是明确指定要调用某个对象的方法；</p>
<p>方案二是在子类中实现父类的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity1 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity1 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity2 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity2 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity2 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity3 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity3 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity3 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 继承 三个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity1</span> :</span> <span class="keyword">public</span> BaseActivity1, <span class="keyword">public</span> BaseActivity2, <span class="keyword">public</span> BaseActivity3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showSonInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 showSonInfo&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案二： 子类上 重写父类的show函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个是优先寻找子类的函数，因为特别明确，没有问题，还没有产生歧义（二义性）</span></span><br><span class="line">    MainActivity1 mainActivity1; <span class="comment">// 子类</span></span><br><span class="line">    mainActivity1.onCreate();</span><br><span class="line">    mainActivity1.onStart();</span><br><span class="line">    mainActivity1.showSonInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: request for member &#x27;show&#x27; is ambiguous</span></span><br><span class="line">    <span class="comment">// 不明确，二义性，歧义</span></span><br><span class="line">    <span class="comment">// mainActivity1.show();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案一： 明确指定父类 ::</span></span><br><span class="line">    mainActivity1.BaseActivity3::show();</span><br><span class="line">    mainActivity1.BaseActivity2::show();</span><br><span class="line">    mainActivity1.BaseActivity1::show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案二： 子类上 重写父类的show函数</span></span><br><span class="line">    mainActivity1.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2重写成员属性"><a href="#4-2重写成员属性" class="headerlink" title="4.2重写成员属性"></a>4.2重写成员属性</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 祖父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity1</span> :</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity2</span> :</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> BaseActivity1, <span class="keyword">public</span> BaseActivity2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种解决方案： 在类中定义同名成员，覆盖掉父类的相关成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: request for member &#x27;show&#x27; is ambiguous  二义性 歧义</span></span><br><span class="line">    <span class="comment">// son.number = 2000;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种解决方案： :: 明确指定</span></span><br><span class="line">    son.BaseActivity1::number  = <span class="number">1000</span>;</span><br><span class="line">    son.BaseActivity2::number  = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种解决方案： 在类中定义同名成员，覆盖掉父类的相关成员</span></span><br><span class="line">    son.number = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-3使用虚函数来过渡继承"><a href="#4-3使用虚函数来过渡继承" class="headerlink" title="4.3使用虚函数来过渡继承"></a>4.3使用虚函数来过渡继承</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 祖父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object show run...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="comment">// public:int number; // 人为制作二义性  error: request for member &#x27;number&#x27; is ambiguous</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="comment">// public:int number;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> BaseActivity1, <span class="keyword">public</span> BaseActivity2 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line">    BaseActivity1 baseActivity1;</span><br><span class="line">    BaseActivity2 baseActivity2;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    object.number = <span class="number">100</span>;</span><br><span class="line">    baseActivity1.number = <span class="number">200</span>;</span><br><span class="line">    baseActivity2.number = <span class="number">300</span>;</span><br><span class="line">    son.number = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    object.show();</span><br><span class="line">    baseActivity1.show();</span><br><span class="line">    baseActivity2.show();</span><br><span class="line">    son.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; object.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; baseActivity1.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; baseActivity2.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; son.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>容器与函数谓词</title>
    <url>/2021/06/13/%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%93%E8%AF%8D/</url>
    <content><![CDATA[<p>STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。</p>
<h4 id="1-Vector"><a href="#1-Vector" class="headerlink" title="1. Vector"></a>1. Vector</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 引入 vector 容器的支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;标准模板库&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vector2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 指定10的空间大小</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vector3</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 有了10个值了 每个值都是0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector4.begin() 迭代器 插入到前面</span></span><br><span class="line">    <span class="comment">// vector4.end() 迭代器 插入到后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">40</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">60</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">80</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">100</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前：vector4.front():&quot;</span> &lt;&lt; vector4.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    vector4.front() = <span class="number">99</span>; <span class="comment">// 默认修改第一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后：vector4.front():&quot;</span> &lt;&lt; vector4.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前：vector4.back():&quot;</span> &lt;&lt; vector4.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    vector4.back() = <span class="number">777</span>; <span class="comment">// 默认修改最后</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后：vector4.back():&quot;</span> &lt;&lt; vector4.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    vector4.erase(vector4.begin()); <span class="comment">// 移除第一个元素（内部：通过迭代器的位置 进行移除）  删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环打印，默认 从大到小输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector4.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;item:&quot;</span> &lt;&lt; vector4[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KT的类型推到  相当于 C++ auto</span></span><br><span class="line">    <span class="comment">/*var a = 10;</span></span><br><span class="line"><span class="comment">    var b = 30.4f;</span></span><br><span class="line"><span class="comment">    var c = &quot;&quot;;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器 循环遍历</span></span><br><span class="line">    <span class="comment">// auto Kotlin自带类型推到</span></span><br><span class="line">    <span class="comment">// for (vector&lt;int&gt;::iterator iteratorVar = vector4.begin(); iteratorVar != vector4.end(); iteratorVar++) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iteratorVar = vector4.begin(); iteratorVar != vector4.end(); iteratorVar++) &#123;</span><br><span class="line">        <span class="comment">// 迭代器 当中指针操作  iteratorVar++</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;迭代器：&quot;</span> &lt;&lt; *iteratorVar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈（注意：stack无法指定那个位置去压栈）</span></span><br><span class="line">    stackVar.push(<span class="number">30</span>);</span><br><span class="line">    stackVar.push(<span class="number">60</span>);</span><br><span class="line">    stackVar.push(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请问那个元素，在最上面（看图）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [] 角标是不行的，内部没有重载此运算符</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; stackVar.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">        // cout &lt;&lt; stackVar[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        // cout &lt;&lt; stackVar.at() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 他根本就没有迭代器</span></span><br><span class="line">    <span class="comment">// 开发者 自己组装 迭代器 遍历</span></span><br><span class="line">    <span class="comment">/*for (stack&lt;int&gt;::iterator; i &lt; ; ++i) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慎用，为什么？ 元素被弹完了</span></span><br><span class="line">    <span class="comment">// 这种方式是可以的，手枪把子弹全部打完【会把元素清空】</span></span><br><span class="line">    <span class="keyword">while</span> (!stackVar.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = stackVar.top(); <span class="comment">// top == 获取栈顶的元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;获取栈顶的元素：&quot;</span> &lt;&lt; top &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 永远拿 90</span></span><br><span class="line"></span><br><span class="line">        stackVar.pop(); <span class="comment">// 把栈顶的元素 弹出去  【删除】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int top = stackVar.top();</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; top &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; // 队列支持（内部：基本上 链表 、 数组 ）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器 + 数据结构</span></span><br><span class="line"><span class="comment">// 音视频： 压缩格式音频数据（push） 保存       pop消费最前面的 音频格式数据 获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queueVar;</span><br><span class="line"></span><br><span class="line">    queueVar.push(<span class="number">20</span>);</span><br><span class="line">    queueVar.push(<span class="number">40</span>);</span><br><span class="line">    queueVar.push(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个元素是谁 20  FIFO 原则</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前： queueVar.front():&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    queueVar.front() = <span class="number">88</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后： queueVar.front():&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前： queueVar.back():&quot;</span> &lt;&lt; queueVar.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    queueVar.back() = <span class="number">88</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后： queueVar.back():&quot;</span> &lt;&lt; queueVar.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到 角标</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; 9; ++i) &#123;</span></span><br><span class="line"><span class="comment">        queueVar[i];</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 他根本就没有迭代器</span></span><br><span class="line">    <span class="comment">/*for (queue&lt;int&gt;::iterator; i &lt; ; ++i) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慎用，为什么？ 前面的元素全部被消费完了</span></span><br><span class="line">    <span class="keyword">while</span> (!queueVar.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;while1:&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        queueVar.pop(); <span class="comment">// 把前面的元素 给消费掉  【删除】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处队列中元素已经被清空了</span></span><br><span class="line">    <span class="keyword">while</span> (!queueVar.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;while2:&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        queueVar.pop(); <span class="comment">// 把前面的元素 给消费掉  【删除】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-优先级队列"><a href="#4-优先级队列" class="headerlink" title="4. 优先级队列"></a>4. 优先级队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// priority_queue 内部对我们前面的vector 有一定的封装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque 跟 queue  有什么区别啊   双端队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 优先级队列，默认做了 从大到小 60 50 40 ...</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;int&gt; priorityQueue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式代码： vector&lt;int&gt;, less&lt;int&gt;  </span></span><br><span class="line">    <span class="comment">// priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; priorityQueue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// less  </span></span><br><span class="line">    <span class="comment">// less&lt;int&gt; return __x &lt; __y;  上一个元素和当前元素 比较，返回ture false  从大到小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// less return __x &lt; __y;  // 从大到小</span></span><br><span class="line">    <span class="comment">// greater return __x &gt; __y; // 从小到大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个参数：他内部需要vector，你就给他</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; priorityQueue;</span><br><span class="line">    <span class="comment">// priority_queue&lt;int ,vector&lt;int&gt;, greater&lt;int&gt;&gt; priorityQueue;</span></span><br><span class="line"></span><br><span class="line">    priorityQueue.push(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">20</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">30</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">40</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">50</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; priorityQueue.top() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环代码</span></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;while1:&quot;</span> &lt;&lt; priorityQueue.top() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 一直是60</span></span><br><span class="line">        priorityQueue.pop(); <span class="comment">// 最前面的元素消费掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-List容器"><a href="#5-List容器" class="headerlink" title="5. List容器"></a>5. List容器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java：ArrayList采用Object[]数组，   C++的list 内部：采用链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt; // list容器的支持</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; listVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    listVar.push_front(<span class="number">50</span>); <span class="comment">// 插入到前面   明确</span></span><br><span class="line">    listVar.push_back(<span class="number">60</span>); <span class="comment">// 插入到后面</span></span><br><span class="line">    listVar.insert(listVar.begin(), <span class="number">70</span>); <span class="comment">// 插入到前面  灵活</span></span><br><span class="line">    listVar.insert(listVar.end(), <span class="number">80</span>); <span class="comment">// 插入到后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改操作</span></span><br><span class="line">    listVar.back() = <span class="number">88</span>;</span><br><span class="line">    listVar.front() = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    listVar.erase(listVar.begin()); <span class="comment">// 删除最前面的 55</span></span><br><span class="line">    listVar.erase(listVar.end()); <span class="comment">// 删除最后面的 88</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 迭代器</span></span><br><span class="line">    <span class="comment">// 不用通过角标去访问，也不能修改   遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listVar.begin(); it != listVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-set容器"><a href="#6-set容器" class="headerlink" title="6. set容器"></a>6. set容器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set（内部：红黑树结构），会对你存入的数据进行排序，但是绝对不允许元素相同</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, less&lt;<span class="keyword">int</span>&gt;&gt; setVar; <span class="comment">//  __x &lt; __y 从大到小，默认情况下 就是 less</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加参数，不需要用迭代器，也不需要指定位置</span></span><br><span class="line">    setVar.insert(<span class="number">1</span>);</span><br><span class="line">    setVar.insert(<span class="number">3</span>);</span><br><span class="line">    setVar.insert(<span class="number">2</span>);</span><br><span class="line">    setVar.insert(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复插入，并不会报错  std::pair&lt;iterator, bool&gt;</span></span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>, less&lt;<span class="keyword">int</span>&gt;&gt;::iterator, <span class="keyword">bool</span>&gt; res = setVar.insert(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.first 获取第一个元素 迭代器   当前迭代器   最后一个位置</span></span><br><span class="line">    <span class="comment">// res.second 获取第二个元素 bool</span></span><br><span class="line">    <span class="keyword">bool</span> insert_success = res.second;</span><br><span class="line">    <span class="keyword">if</span> (insert_success) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;恭喜你，插入成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入成功后，我用第一个元素遍历</span></span><br><span class="line">        <span class="keyword">for</span> (; res.first != setVar.end(); res.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *res.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;哎，插入失败..&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部遍历  auto 自动推到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setVar.begin(); it != setVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-函数谓词"><a href="#7-函数谓词" class="headerlink" title="7. 函数谓词"></a>7. 函数谓词</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set（内部：红黑树结构），会对你存入的数据自动进行排序，但是绝对不允许元素相同</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> id) : name(name), id(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 都是一些常规的 谓词  不能满足功能， 模仿C++源码的谓词 自定义谓词 解决这个问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++缔造者写的这个源码 没有对象比较的功能 【系统源码谓词 做不到对象比较功能】</span></span><br><span class="line"><span class="comment">// bool operator()(const _Tp&amp; __x, const _Tp&amp; __y) const &#123; return __x &lt; __y; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们就自定义这个功能  【自定义谓词 没有达到谓词的标准】</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doCompareAction</span><span class="params">(<span class="keyword">const</span> Person&amp; person1, <span class="keyword">const</span> Person&amp; person2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person1.id &lt; person2.id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doCompareAction2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Person&amp; __x, <span class="keyword">const</span> Person&amp; __y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.id &lt; __y.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class doCompareAction3也是可以的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doCompareAction3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Person&amp; __x, <span class="keyword">const</span> Person&amp; __y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.id &gt; __y.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认是 less  return 对象1 &lt; 对象2;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;Person, doCompareAction2&gt; setVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set&lt;Person, doCompareAction3&gt; setVar;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span> <span class="params">(<span class="string">&quot;Snake&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span> <span class="params">(<span class="string">&quot;kevin&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span> <span class="params">(<span class="string">&quot;Jack&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把构建的对象 插入到 set 容器里面去</span></span><br><span class="line">    setVar.insert(p1);</span><br><span class="line">    setVar.insert(p2);</span><br><span class="line">    setVar.insert(p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name string  ---  c_str() ----&gt;   char *</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person&gt;::iterator it = setVar.begin(); it != setVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;name.c_str() &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; it-&gt;id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-Map-与-multimap"><a href="#8-Map-与-multimap" class="headerlink" title="8. Map 与 multimap"></a>8. Map 与 multimap</h4><ul>
<li>map中insert()插入之后会对key进行排序，key不能重复，如果采用覆盖的方式插入值，使用<code>arr[]</code>方式</li>
<li>multimap中key可以重复</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：map会对key进行排序，默认 key不能重复</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 添加数据</span></span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    mapVar.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&quot;一&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    mapVar.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;二&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种方式</span></span><br><span class="line">    mapVar.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">&quot;三&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面三种方式 key不能重复</span></span><br><span class="line">    <span class="comment">// 思考：既然会对key进行排序，那么key是不能重复的（会插入失败）</span></span><br><span class="line">    mapVar.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&quot;三3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种方式:key可以重复，相当于覆盖    mapVar[key]=Value</span></span><br><span class="line">    mapVar[<span class="number">4</span>] = <span class="string">&quot;四&quot;</span>;</span><br><span class="line">    mapVar[<span class="number">4</span>] = <span class="string">&quot;肆&quot;</span>; <span class="comment">// 第四种方式覆盖/替换（常用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  typedef typename _Rep_type::iterator		 iterator;  之前常规的迭代器</span></span><br><span class="line"><span class="comment">        typedef typename _Rep_type::const_iterator	 const_iterator;  只读的，只能读，不能修改 的迭代器</span></span><br><span class="line"><span class="comment">        typedef typename _Rep_type::reverse_iterator	 reverse_iterator;  倒序打印的迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环打印，迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mapVar.begin() ; it != mapVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it-&gt;second.c_str() &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Jack想知道，怎么判断插入成功、失败</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = mapVar.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">6</span>, <span class="string">&quot;66三san&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (result.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我想知道插入后的 数据</span></span><br><span class="line">    <span class="keyword">for</span> (result.first == mapVar.begin(); result.first != mapVar.end() ; result.first++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result.first-&gt;first &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; result.first-&gt;second &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找，操作</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; ::iterator findResult = mapVar.find(<span class="number">3</span>); <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">if</span> (findResult != mapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;恭喜，找到了&quot;</span> &lt;&lt; findResult-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; findResult-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不恭喜，没找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multimap 主要使用他的分组特性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.key可以重复， 2.key重复的数据可以分组,  3.key会排序，  4.value不会排序</span></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; multimapVar;</span><br><span class="line"></span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;十个1&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;十个2&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;十个3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&quot;三十1&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&quot;三十3&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&quot;三十2&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;二十1&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;二十2&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;二十3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iteratorVar = multimapVar.begin(); iteratorVar != multimapVar.end() ; iteratorVar ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iteratorVar-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; iteratorVar-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 核心功能是分组</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你要查询的key，为int类型:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iteratorVar = multimapVar.find(result);</span><br><span class="line">    <span class="keyword">while</span> (iteratorVar != multimapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iteratorVar-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; iteratorVar-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iteratorVar-&gt;first != result) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 严谨性</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorVar == multimapVar.end()) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处写匹配到的逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要自己做逻辑控制，不然死循环了</span></span><br><span class="line">        iteratorVar++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="9-一元谓词（仿函数）"><a href="#9-一元谓词（仿函数）" class="headerlink" title="9. 一元谓词（仿函数）"></a>9. 一元谓词（仿函数）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt; &#x2F;&#x2F; STL包</span><br><span class="line">#include &lt;algorithm&gt; &#x2F;&#x2F; 算法包</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 谓词相当于仿函数</span><br><span class="line">&#x2F;&#x2F; 通常叫法叫仿函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO 第一版: 为什么叫仿函数 （空谓词 一元谓词 二元谓词 三元谓词）</span><br><span class="line">class ComPareObject &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; void operator()(int id) &#123;&#125; 一元谓词</span><br><span class="line">    &#x2F;&#x2F; void operator()(int id,string name) &#123;&#125; 二元谓词</span><br><span class="line">    void operator()() &#123; &#x2F;&#x2F; 重装了括号运算符</span><br><span class="line">        cout &lt;&lt; &quot;仿函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 普通函数</span><br><span class="line">void fun2() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ComPareObject fun1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 非常像函数的调用，很像函数 &#x3D; （仿函数）</span><br><span class="line">    fun1();</span><br><span class="line"></span><br><span class="line">    fun2();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="10-引入算法包"><a href="#10-引入算法包" class="headerlink" title="10. 引入算法包"></a>10. 引入算法包</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // STL包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我如何阅读C++源码，来写我们的仿函数</span></span><br><span class="line"><span class="comment">// 明明白白的仿函数（一元谓词==一元函数对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">showActionObj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;自定义仿函数&quot;</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简洁方式（回调函数、一元谓词      但是不能称为 仿函数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAction</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;自定义 一元谓词&quot;</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setVar;</span><br><span class="line"></span><br><span class="line">    setVar.insert(<span class="number">10</span>);</span><br><span class="line">    setVar.insert(<span class="number">20</span>);</span><br><span class="line">    setVar.insert(<span class="number">30</span>);</span><br><span class="line">    setVar.insert(<span class="number">40</span>);</span><br><span class="line">    setVar.insert(<span class="number">50</span>);</span><br><span class="line">    setVar.insert(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用一元谓词，注意：有括号</span></span><br><span class="line">    <span class="comment">// for_each(setVar.begin(), setVar.end(), showActionObj());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    for_each(setVar.begin(), setVar.end(), showAction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="11-仿函数"><a href="#11-仿函数" class="headerlink" title="11. 仿函数"></a>11. 仿函数</h4><p>回调函数扩展性不高，一般用于简单逻辑，写法也比较简单；仿函数扩展性更强，写法稍微复杂一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // STL包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数 (功能够简单)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAction</span><span class="params">(<span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一元谓词&quot;</span> &lt;&lt; __first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数(扩展性强) C++内置源码使用仿函数频率高，扩展性强</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">showActionObj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> _count() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;本次输出次数是:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;count &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;仿函数&quot;</span> &lt;&lt; __first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 理解：类型传递</span></span><br><span class="line">    <span class="comment">// set&lt;int, showActionObj&gt; setVar; 这样写的语法是OK的，不能加括号</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setVar;</span><br><span class="line"></span><br><span class="line">    setVar.insert(<span class="number">10</span>);</span><br><span class="line">    setVar.insert(<span class="number">20</span>);</span><br><span class="line">    setVar.insert(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种方式</span></span><br><span class="line">    for_each(setVar.begin(), setVar.end(), showAction);</span><br><span class="line">    <span class="comment">// 请你统计打印次数？ 答：做不到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种方式</span></span><br><span class="line">    <span class="comment">// 此处s相当于showActionObj()</span></span><br><span class="line">    showActionObj s; <span class="comment">// 理解：值传递</span></span><br><span class="line">    <span class="comment">// for_each第三个参数传入s,会拷贝一个副本，运算结束需要接收回来。</span></span><br><span class="line">    s = for_each(setVar.begin(), setVar.end(), s); <span class="comment">// 传入进去的s是新的副本，我们外面的s是旧地址</span></span><br><span class="line">    <span class="comment">// 请你统计打印次数？ 答：OK</span></span><br><span class="line">    s._count();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="12-对象生命周期"><a href="#12-对象生命周期" class="headerlink" title="12. 对象生命周期"></a>12. 对象生命周期</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // set 存入对象 奔溃（set会自动排序，对象没法排序，所以奔溃）  解决方案：自定义仿函数解决</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  // 存入对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name) : name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;person) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = person.name; <span class="comment">// 浅拷贝</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person拷贝构造函数执行了...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person析构函数执行了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Java：把对象存入 添加到 集合</span></span><br><span class="line">    <span class="comment">// C++: 调用拷贝构造函数，存进去的是另一个新的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; vectorVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// person 被main函数弹栈 析构一次</span></span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Jack&quot;</span>)</span></span>; <span class="comment">// 2  Jack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 里面的insert函数弹栈 析构一次</span></span><br><span class="line">    vectorVar.insert(vectorVar.begin(), person); <span class="comment">// 外面的person是旧地址，到insert函数里面的person就是新地址（拷贝构造函数 一次）</span></span><br><span class="line"></span><br><span class="line">    person.setName(<span class="string">&quot;Kevin&quot;</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newPerson 被main函数弹栈 析构一次</span></span><br><span class="line">    Person newPerson =</span><br><span class="line">            vectorVar.front(); <span class="comment">// front里面的person是旧地址， 外面的newPerson就是新地址（拷贝构造函数 一次）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;newPerson:&quot;</span> &lt;&lt; newPerson.getName().c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3次析构函数   两次拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// main弹栈</span></span><br></pre></td></tr></table></figure>


<h4 id="13-预定义函数"><a href="#13-预定义函数" class="headerlink" title="13. 预定义函数"></a>13. 预定义函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // STL包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &quot;Jack&quot; + &quot;AAAA&quot; // 运算符重载</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++已经提供了 预定义函数  plus,minus,multiplies,divides,modulus ...</span></span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; add_func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = add_func(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    plus&lt;<span class="built_in">string</span>&gt; add_func2;</span><br><span class="line">    <span class="built_in">string</span> r2 = add_func2(<span class="string">&quot;AAAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    plus&lt;<span class="keyword">float</span>&gt; add_func3;</span><br><span class="line">    <span class="keyword">float</span> r3 = add_func3(<span class="number">4354.45f</span>, <span class="number">34.3f</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="14-手写预定义函数"><a href="#14-手写预定义函数" class="headerlink" title="14. 手写预定义函数"></a>14. 手写预定义函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt; &#x2F;&#x2F; STL包</span><br><span class="line">#include &lt;algorithm&gt; &#x2F;&#x2F; 算法包</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename Arg1, typename Arg2, typename Result&gt;</span><br><span class="line">struct binary_function</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 第一个参数类型 是底一个参数的类型</span><br><span class="line">    typedef Arg1 	first_argument_type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;econd_argument_type是第二个参数的类型</span><br><span class="line">    typedef Arg2 	second_argument_type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @c result_type是返回类型</span><br><span class="line">    typedef Result 	result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO 对象 + 对象</span><br><span class="line">&#x2F;&#x2F; 1.运算符重载</span><br><span class="line">&#x2F;&#x2F; 2.对象+对象 自己去写仿函数</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct plus_d &#x2F;*: public binary_function&lt;T, T, T&gt;*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    T operator() (const T &amp; x, const T &amp; y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    plus_d&lt;int&gt; add_func;</span><br><span class="line">    int r &#x3D; add_func(1, 1);</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    plus_d&lt;string&gt; add_func2;</span><br><span class="line">    string r2 &#x3D; add_func2(&quot;AAAA&quot;, &quot;BBB&quot;);</span><br><span class="line">    cout &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    plus_d&lt;float&gt; add_func3;</span><br><span class="line">    float r3 &#x3D; add_func3(4354.45f, 34.3f);</span><br><span class="line">    cout &lt;&lt; r3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>引用进阶与多线程</title>
    <url>/2021/06/14/%E5%BC%95%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="1-引用进阶"><a href="#1-引用进阶" class="headerlink" title="1. 引用进阶"></a>1. 引用进阶</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO ============================ [左值 右值 引用]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span>  info = <span class="string">&quot;AAA&quot;</span>; <span class="comment">// 旧变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种情况【getInfo函数的info 与 main函数的result 是旧与新的两个变量而已，他们是值传递，所以右值修改时，影响不了里面的旧变量】</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种情况【getInfo函数的info 与 main函数的result 是引用关系，一块内存空间 有多个别名而已，所以右值修改时，直接影响旧变量】</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回引用可以直接修改</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> &amp; <span class="title">getInfo_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*vector&lt;int&gt; v;</span></span><br><span class="line"><span class="comment">    int r = v.front(); // 左值 获取</span></span><br><span class="line"><span class="comment">    v.front() = 88; // 右值 修改*/</span></span><br><span class="line"></span><br><span class="line">    Student student;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种情况</span></span><br><span class="line">    student.getInfo() = <span class="string">&quot;九阳神功&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> result = student.getInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一种情况:&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种情况</span></span><br><span class="line">    student.getInfo_front() = <span class="string">&quot;三分归元气&quot;</span>; <span class="comment">// 右值 修改内容</span></span><br><span class="line">    result = student.getInfo_front(); <span class="comment">// 左值 获取内容</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二种情况:&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-thread"><a href="#2-thread" class="headerlink" title="2. thread"></a>2. thread</h4><p>thread是C++ 11引入的一个线程类，主要也是封装pthread类，用起来更简单，但是阉割了部分功能，日常开发中主要还是使用pthread。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步线程 子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runAction</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="comment">// 相当于 Java的 run函数一样</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;runAction：&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 方式一  main只等3秒钟，</span></span><br><span class="line">    <span class="comment">/*thread thread1(runAction, 100);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // sleep(3); // 我只等你三秒钟</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;main弹栈了&quot; &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 方式二  我等你执行完成后，我再执行</span></span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(runAction, <span class="number">100</span>)</span></span>;</span><br><span class="line">    thread2.join(); <span class="comment">// 我等runAction执行完成后，我再继续执行下面代码..</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main弹栈了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    main弹栈了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-pthread用法"><a href="#3-pthread用法" class="headerlink" title="3. pthread用法"></a>3. pthread用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // Cygwin 有 pthreads支持</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customPthreadTask</span><span class="params">(<span class="keyword">void</span> * pVoid)</span> </span>&#123; <span class="comment">// 异步线程  相当于Java的Thread.run函数一样</span></span><br><span class="line">    <span class="comment">// C++转换static_cast  转换指针操作的</span></span><br><span class="line">    <span class="keyword">int</span> * number = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid); <span class="comment">// pVoid==number int的地址，所以我用int*接收，很合理</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程执行了:&quot;</span> &lt;&lt; *number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 坑 坑 坑，必须返回，否则有错误，不好查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      int pthread_create (pthread_t *,  // 参数一：线程ID</span></span><br><span class="line"><span class="comment">                        const pthread_attr_t *, // 参数二：线程属性</span></span><br><span class="line"><span class="comment">		                void *(*)(void *), // 参数三：函数指针的规则</span></span><br><span class="line"><span class="comment">		                void *); // 参数四：给函数指针传递的内容，void * 可以传递任何内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadID; <span class="comment">// 线程ID，每个线程都需要有的线程ID</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pthreadID, <span class="number">0</span>, customPthreadTask, &amp;number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-pthread的三种状态"><a href="#4-pthread的三种状态" class="headerlink" title="4. pthread的三种状态"></a>4. pthread的三种状态</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  pthread 的 三种情况分析 的</span></span><br><span class="line"><span class="comment">//  第一种情况，main函数只要结束，不等异步线程，全部结束</span></span><br><span class="line"><span class="comment">//  第二种情况，我们开发者，千万不要让 main函数睡眠的方式，去等待异步线程</span></span><br><span class="line"><span class="comment">//  第三种情况，main函数一直等待 异步线程，只有异步线程执行完成后，我在执行 join后面的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // Derry Cygwin 有 pthreads支持</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runTask</span><span class="params">(<span class="keyword">void</span> * pVoid)</span> </span>&#123; <span class="comment">// 异步线程  子线程</span></span><br><span class="line">    <span class="keyword">int</span> number = *<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程执行了:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;run:&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span>  pthreadID;</span><br><span class="line">    pthread_create(&amp;pthreadID, <span class="number">0</span>, runTask, &amp;number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了演示第二种情况</span></span><br><span class="line">    <span class="comment">// sleep(3); // main函数只 异步线程三秒钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步线程在执行的过程中，我们的main函数 相当于 阻塞在这里不动了，只有异步线程执行完成后，我才开始执行join后面的代码</span></span><br><span class="line">    pthread_join(pthreadID, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数即将弹栈...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-分离线程与非分离线程区别"><a href="#5-分离线程与非分离线程区别" class="headerlink" title="5. 分离线程与非分离线程区别"></a>5. 分离线程与非分离线程区别</h4><ul>
<li>分离线程： 各个线程都是自己运行自己的，老死不相往来，例如：main函数结束，全部结束，不会等待异步线程 【多线程独立计算情况下场景】</li>
<li>非分离线程： 线程有协作的能力，例如：main函数线程会等待 异步线程执行完成后，我再执行 后面main函数的代码【协作，顺序执行 场景】</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // Derry Cygwin 有 pthreads支持</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runTask</span><span class="params">(<span class="keyword">void</span> * pVoid)</span> </span>&#123; <span class="comment">// 异步线程  子线程</span></span><br><span class="line">    <span class="keyword">int</span> number = *<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程执行了:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;run:&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span>  pthreadID; <span class="comment">// Cygwin允许有野指针</span></span><br><span class="line">    pthread_create(&amp;pthreadID, <span class="number">0</span>, runTask, &amp;number);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthreadID, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数即将弹栈...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-互斥锁"><a href="#6-互斥锁" class="headerlink" title="6. 互斥锁"></a>6. 互斥锁</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // sleep（秒）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queueData; <span class="comment">// 定义一个全局的队列，用于 存储/获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">// 定义一个互斥锁，注意：（Cygwin平台 此互斥锁，不能有野指针，坑）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">task</span><span class="params">(<span class="keyword">void</span> *pVoid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*synchronize(锁) &#123;</span></span><br><span class="line"><span class="comment">        // code</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 锁住</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程-当前线程的标记是:&quot;</span> &lt;&lt; *<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid) &lt;&lt; <span class="string">&quot;异步线程&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queueData.empty()) &#123; <span class="comment">// 有元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;异步线程-获取队列的数据:%d\n&quot;</span>, queueData.front());</span><br><span class="line">        queueData.pop(); <span class="comment">// 把数据弹出去，删除的意思</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;异步线程-队列中没有数据了\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给队列 初始化数据 手动增加数据进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10001</span>; i &lt; <span class="number">10011</span>; ++i) &#123;</span><br><span class="line">        queueData.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性定义10个线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadIDArray[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;pthreadIDArray[i], <span class="number">0</span>, task, &amp;i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能使用 join，如果使用（就变成顺序的方式，就没有多线程的意义了，所以不能写join）</span></span><br><span class="line">        <span class="comment">// pthread_join(pthreadIDArray[i], 0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main函数等 异步线程</span></span><br><span class="line">    sleep(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁 互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数即将弹栈...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次运行 效果都不同：1，8，9，10，3，2，5，8</span></span><br><span class="line">    <span class="comment">// 每次运行 效果都是错乱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-多线程通知机制实现生产者消费者模型"><a href="#7-多线程通知机制实现生产者消费者模型" class="headerlink" title="7.  多线程通知机制实现生产者消费者模型"></a>7.  多线程通知机制实现生产者消费者模型</h4><p>建立一个队列，在get()，set()方法中使用互斥锁对队列存元素和元素进行加锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据工程实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">// 防止重复写 include 的控制</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模版函数 int double float == Java的泛型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueueClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;T&gt; <span class="built_in">queue</span>; <span class="comment">// 定义队列</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span>  mutex; <span class="comment">// 定义互斥锁（不允许有野指针）</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 条件变量，为了实现 等待 读取 等功能 （不允许有野指针）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SafeQueueClass() &#123;</span><br><span class="line">        <span class="comment">// 初始化 互斥锁</span></span><br><span class="line">        pthread_mutex_init(&amp;mutex, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 条件变量</span></span><br><span class="line">        pthread_cond_init(&amp;cond, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~SafeQueueClass() &#123;</span><br><span class="line">        <span class="comment">// 回收 互斥锁</span></span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收 条件变量</span></span><br><span class="line">        pthread_cond_destroy(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 加入到队列中（进行生成）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了安全 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>.push(t); <span class="comment">// 把数据加入到队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉消费者，我已经生产好了</span></span><br><span class="line">        <span class="comment">// pthread_cond_signal(&amp;cond) // Java notify 单个的</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond); <span class="comment">// Java notifyAll 所有的的</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;add queue.push 我已经notifyAll所有等待线程了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 从队列中获取（进行消费） 外面的人消费 你可以直接返回，你也可以采用引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(T &amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了安全 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get empty 我已经乖乖等待中..&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// 相当于 Java的 wait 等待了[有可能被系统唤醒]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 证明被唤醒了</span></span><br><span class="line">        t = <span class="built_in">queue</span>.front(); <span class="comment">// 得到 队列中的元素数据 仅此而已</span></span><br><span class="line">        <span class="built_in">queue</span>.pop(); <span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;safe_queue_too.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">SafeQueueClass&lt;<span class="keyword">int</span>&gt; sq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 模拟演示 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">getMethod</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getMethod\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  value;</span><br><span class="line">        sq.get(value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者get 得到的数据:%d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你只要传入 -1 就结束当前循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == value) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消费者get 全部执行完毕\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 模拟演示 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">setMethod</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;setMethod\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你要生成的信息:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你只要传入 -1 就结束当前循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == value) &#123;</span><br><span class="line">            sq.add(value); <span class="comment">// 为了让消费者 可以结束循环</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消费者get 全部执行完毕\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sq.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadGet;</span><br><span class="line">    <span class="comment">//分别新建一个生产者消费者线程</span></span><br><span class="line">    pthread_create(&amp;pthreadGet, <span class="number">0</span>, getMethod, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// pthread_join(pthreadGet, 0); 不能这样写，否则，下面的代码，可能无法有机会执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadSet;</span><br><span class="line">    pthread_create(&amp;pthreadSet, <span class="number">0</span>, setMethod, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthreadGet, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthreadSet, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法包</title>
    <url>/2021/06/14/%E7%AE%97%E6%B3%95%E5%8C%85/</url>
    <content><![CDATA[<h4 id="1-函数适配器-bind2nd"><a href="#1-函数适配器-bind2nd" class="headerlink" title="1. 函数适配器(bind2nd)"></a>1. 函数适配器(bind2nd)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;算法包&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>, less&lt;<span class="built_in">string</span>&gt;&gt; setVar;</span><br><span class="line">    setVar.insert(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    setVar.insert(<span class="string">&quot;BBBB&quot;</span>);</span><br><span class="line">    setVar.insert(<span class="string">&quot;CCCC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iteratorVar = setVar.begin(); iteratorVar != setVar.end() ; iteratorVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iteratorVar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find_if</span></span><br><span class="line">    <span class="comment">// equal_to 比较用的</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>, less&lt;<span class="built_in">string</span>&gt;&gt;::iterator iteratorResult =</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解决尴尬的问题  equal_to 需要比较的 内容没有 使用 函数适配器 解决</span></span><br><span class="line">            <span class="comment">// 现在的问题是： 没有办法把 CCCC 传递给 const _Tp&amp; __y，就没法去比较</span></span><br><span class="line">            <span class="comment">// find_if(setVar.begin(), setVar.end(), equal_to&lt;string&gt;(&quot;CCCC&quot;), &quot;CCCC&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// bind2nd作用是讲第二个参数注入func的第二个参数。</span></span><br><span class="line">            <span class="comment">// 使用函数适配器后，就能够 CCCC 传递给了  const _Tp&amp; __y，</span></span><br><span class="line">            <span class="comment">// setVar.begin(), setVar.end() 会把这些元素取出来 const _Tp&amp; __x</span></span><br><span class="line">            <span class="comment">// x == y 的比较</span></span><br><span class="line">            find_if(setVar.begin(), setVar.end(), bind2nd(equal_to&lt;<span class="built_in">string</span>&gt;(), <span class="string">&quot;CCCC&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iteratorResult != setVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有查找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>


<h4 id="2-for-each遍历"><a href="#2-for-each遍历" class="headerlink" title="2. for_each遍历"></a>2. for_each遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">F</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;自定义一元谓词:&quot;</span> &lt;&lt; __first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">50000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">    for_each(vectorVar.begin(), vectorVar.end(), __F());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-transform变换操作符"><a href="#3-transform变换操作符" class="headerlink" title="3. transform变换操作符"></a>3. transform变换操作符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">unary_op</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __first + <span class="number">9</span>; <span class="comment">// 修改每个元素 +9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种方式  类似于 RxJava map 变化操作符  【不看API，直接看算法包源码 印象非常深刻的】</span></span><br><span class="line">    <span class="comment">// 迭代器 result == 参数三</span></span><br><span class="line">    transform(vectorVar.begin(), vectorVar.end(), vectorVar.begin(), __unary_op());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vectorVar.begin(); it != vectorVar.end() ; it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一种方式:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个参数接收返回值有啥用？没感受出来</span></span><br><span class="line">    <span class="comment">// ==================================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种方式</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVarResult; <span class="comment">// vectorVarResult 大小空间</span></span><br><span class="line">    vectorVarResult.resize(vectorVar.size());</span><br><span class="line">    transform(vectorVar.begin(), vectorVar.end(), vectorVarResult.begin(), __unary_op());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vectorVarResult.begin(); it != vectorVarResult.end() ; it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二种方式:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-查找函数"><a href="#4-查找函数" class="headerlink" title="4.查找函数"></a>4.查找函数</h4><h5 id="4-1-find函数"><a href="#4-1-find函数" class="headerlink" title="4.1 find函数"></a>4.1 find函数</h5><p>find函数直接接受需要查找的内容，不接收仿函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find 没有自定义仿函数</span></span><br><span class="line">    <span class="keyword">auto</span> iteratorVar = find(vectorVar.begin(), vectorVar.end(), <span class="number">40000</span>);</span><br><span class="line">    <span class="keyword">if</span> (iteratorVar != vectorVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    find(_InputIterator __first,  开始位置 迭代器</span></span><br><span class="line"><span class="comment">     _InputIterator __last, 结束位置 迭代器</span></span><br><span class="line"><span class="comment">         const _Tp&amp; __val) 需要查找的元素 40000</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ....</span></span><br><span class="line"><span class="comment">        结论：对__find_if的封装而已</span></span><br><span class="line"><span class="comment">        return std::__find_if(__first, __last,</span></span><br><span class="line"><span class="comment">                              __gnu_cxx::__ops::__iter_equals_val(__val));</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-find-if函数"><a href="#4-2-find-if函数" class="headerlink" title="4.2 find_if函数"></a>4.2 find_if函数</h5><p>find_if函数可以接收一个仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">pred</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    __pred(<span class="keyword">int</span> number) : number(number) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number == value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(vectorVar.begin(), vectorVar.end(), __pred(<span class="number">30000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vectorVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  知道怎么阅读算法包源码 1</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    find_if(_InputIterator __first,  开始位置 迭代器</span></span><br><span class="line"><span class="comment">      _InputIterator __last, 结束位置 迭代器</span></span><br><span class="line"><span class="comment">	    _Predicate __pred)  自定义仿函数</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">     ... 监测工作而已</span></span><br><span class="line"><span class="comment">      return std::__find_if(__first, __last,</span></span><br><span class="line"><span class="comment">			    __gnu_cxx::__ops::__pred_iter(__pred));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    __find_if(_InputIterator __first, 开始位置 迭代器</span></span><br><span class="line"><span class="comment">           _InputIterator __last, 结束位置 迭代器</span></span><br><span class="line"><span class="comment">	      _Predicate __pred,   TODO 自定义仿函数</span></span><br><span class="line"><span class="comment">	      ....)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      while (__first != __last &amp;&amp; !__pred(__first)) //  __pred(__first)  自定义仿函数 怎么写  返回值bool 传入int类型</span></span><br><span class="line"><span class="comment">		++__first;  // 迭代器从开始位置挪动     算法思路： 指针++</span></span><br><span class="line"><span class="comment">      return __first;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-统计元素个数"><a href="#5-统计元素个数" class="headerlink" title="5. 统计元素个数"></a>5. 统计元素个数</h4><h5 id="5-1-count函数和count-if函数"><a href="#5-1-count函数和count-if函数" class="headerlink" title="5.1 count函数和count_if函数"></a>5.1 count函数和count_if函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count 没有自定义仿函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.push_back(<span class="number">1</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">2</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">3</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">2</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">4</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">6</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">8</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number = count(vectorVar.begin(), vectorVar.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;等于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++ 源码 函数适配器</span></span><br><span class="line">    number = count_if(vectorVar.begin(), vectorVar.end(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)); <span class="comment">// 函数适配器 配合 less   &lt;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    number = count_if(vectorVar.begin(), vectorVar.end(), bind2nd(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)); <span class="comment">// 函数适配器 配合 less &gt;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    number = count_if(vectorVar.begin(), vectorVar.end(), bind2nd(equal_to&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)); <span class="comment">// 函数适配器 配合 less =</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;等于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count_if 源码分析...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    count_if(_InputIterator __first,   迭代器 开始位置</span></span><br><span class="line"><span class="comment">      _InputIterator __last,  迭代器 结束位置</span></span><br><span class="line"><span class="comment">      _Predicate __pred) 自定义仿函数  __pred在源码里面可以知道 我们去写自定义仿函数的规则</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">       .... 省略  监测工作而已</span></span><br><span class="line"><span class="comment">      return std::__count_if(__first, __last,</span></span><br><span class="line"><span class="comment">			     __gnu_cxx::__ops::__pred_iter(__pred));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    __count_if(_InputIterator __first,</span></span><br><span class="line"><span class="comment">     _InputIterator __last,</span></span><br><span class="line"><span class="comment">     _Predicate __pred)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      typename iterator_traits&lt;_InputIterator&gt;::difference_type __n = 0;  int __n</span></span><br><span class="line"><span class="comment">      for (; __first != __last; ++__first)  思路：迭代器 ++ 挪动位置</span></span><br><span class="line"><span class="comment">	    if (__pred(__first))  自定义仿函数  返回bool类型   ？？？ 迭代器类型</span></span><br><span class="line"><span class="comment">	    ++__n;</span></span><br><span class="line"><span class="comment">        return __n; // 最终 count_if 是返回int类型   __n  ++后的  统计元素的个数</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-合并函数-merge"><a href="#6-合并函数-merge" class="headerlink" title="6. 合并函数(merge)"></a>6. 合并函数(merge)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar1;</span><br><span class="line">    vectorVar1.push_back(<span class="number">10</span>);</span><br><span class="line">    vectorVar1.push_back(<span class="number">20</span>);</span><br><span class="line">    vectorVar1.push_back(<span class="number">30</span>);</span><br><span class="line">    vectorVar1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar2;</span><br><span class="line">    vectorVar2.push_back(<span class="number">50</span>);</span><br><span class="line">    vectorVar2.push_back(<span class="number">60</span>);</span><br><span class="line">    vectorVar2.push_back(<span class="number">70</span>);</span><br><span class="line">    vectorVar2.push_back(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并成一个容器 result</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorResult;</span><br><span class="line">    vectorResult.resize(vectorVar1.size() + vectorVar2.size());</span><br><span class="line"></span><br><span class="line">    merge(vectorVar1.begin(), vectorVar1.end(), vectorVar2.begin(), vectorVar2.end(), vectorResult.begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorResult.begin(); itVar != vectorResult.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    merge(_InputIterator1 __first1, _InputIterator1 __last1,  第一个容器 位置</span></span><br><span class="line"><span class="comment">	  _InputIterator2 __first2, _InputIterator2 __last2,  第二个容器 位置</span></span><br><span class="line"><span class="comment">	  _OutputIterator __result) 最终合并后的结果</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      .... 监测工作而已</span></span><br><span class="line"><span class="comment">      return _GLIBCXX_STD_A::__merge(__first1, __last1,</span></span><br><span class="line"><span class="comment">				     __first2, __last2, __result,</span></span><br><span class="line"><span class="comment">				     __gnu_cxx::__ops::__iter_less_iter());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    template&lt;typename _InputIterator1, typename _InputIterator2,</span></span><br><span class="line"><span class="comment">	   typename _OutputIterator, typename _Compare&gt;</span></span><br><span class="line"><span class="comment">    _GLIBCXX20_CONSTEXPR</span></span><br><span class="line"><span class="comment">    _OutputIterator</span></span><br><span class="line"><span class="comment">    __merge(_InputIterator1 __first1, _InputIterator1 __last1, 第一个容器 位置</span></span><br><span class="line"><span class="comment">	    _InputIterator2 __first2, _InputIterator2 __last2, 第二个容器 位置</span></span><br><span class="line"><span class="comment">	    _OutputIterator __result, 最终合并后的结果</span></span><br><span class="line"><span class="comment">       _Compare __comp)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      while (__first1 != __last1 &amp;&amp; __first2 != __last2)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      做 合并 算法处理工作</span></span><br><span class="line"><span class="comment">	  if (__comp(__first2, __first1))</span></span><br><span class="line"><span class="comment">	    &#123;</span></span><br><span class="line"><span class="comment">	      *__result = *__first2;</span></span><br><span class="line"><span class="comment">	      ++__first2;</span></span><br><span class="line"><span class="comment">	    &#125;</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">	    &#123;</span></span><br><span class="line"><span class="comment">	      *__result = *__first1;</span></span><br><span class="line"><span class="comment">	      ++__first1;</span></span><br><span class="line"><span class="comment">	    &#125;</span></span><br><span class="line"><span class="comment">	  ++__result;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      // 拷贝剩余数组1的值然后拷贝数组2的值</span></span><br><span class="line"><span class="comment">      return std::copy(__first2, __last2,</span></span><br><span class="line"><span class="comment">		       std::copy(__first1, __last1, __result));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-对容器进行排序"><a href="#7-对容器进行排序" class="headerlink" title="7. 对容器进行排序"></a>7. 对容器进行排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.push_back(<span class="number">10</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">30</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (__comp(__i, __first)) 自定义仿函数规则  返回值 bool     第一个参数int    第二个参数 是int 吗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内置 的 仿函数 less&lt;int&gt;()</span></span><br><span class="line">    <span class="comment">// less&lt;int&gt;() 里面泛型==函数模版  没法确定好 第二个参数的类型【到底是什么类型？】</span></span><br><span class="line"></span><br><span class="line">     sort(vectorVar.begin(), vectorVar.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">//    sort(vectorVar.begin(), vectorVar.end(), greater&lt;int&gt;());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorVar.begin(); itVar != vectorVar.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-对容器元素进行打乱"><a href="#8-对容器元素进行打乱" class="headerlink" title="8. 对容器元素进行打乱"></a>8. 对容器元素进行打乱</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar; <span class="comment">// vector默认是没有排序功能的，默认输出： 65 53 84</span></span><br><span class="line">    vectorVar.push_back(<span class="number">65</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">53</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">84</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">11</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">22</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">33</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sort(vectorVar.begin(), vectorVar.end(), less&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 排序后 53 65 82</span></span><br><span class="line"></span><br><span class="line">    random_shuffle(vectorVar.begin(), vectorVar.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorVar.begin(); itVar != vectorVar.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        <span class="comment">// 84	65	53</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="9-复制"><a href="#9-复制" class="headerlink" title="9. 复制"></a>9. 复制</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar; <span class="comment">// vector默认是没有排序功能的，默认输出： 65 53 84</span></span><br><span class="line">    vectorVar.push_back(<span class="number">100</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">200</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">300</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">400</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">500</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">600</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorResult;</span><br><span class="line">    vectorResult.resize(vectorVar.size());</span><br><span class="line"></span><br><span class="line">    copy(vectorVar.begin(), vectorVar.end(), vectorResult.begin());</span><br><span class="line">    <span class="comment">// 100	200	300	400	500	600	700</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorResult.begin(); itVar != vectorResult.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="10-替换"><a href="#10-替换" class="headerlink" title="10. 替换"></a>10. 替换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    ::age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar; <span class="comment">// vector默认是没有排序功能的，默认输出： 65 53 84</span></span><br><span class="line">    vectorVar.push_back(<span class="number">100</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">200</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">300</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">400</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">500</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 100 ~ 200 范围</span></span><br><span class="line">    <span class="comment">// replace(vectorVar.begin(), vectorVar.begin() + 2, 200, 222);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有范围</span></span><br><span class="line">    replace(vectorVar.begin(), vectorVar.end(), <span class="number">300</span>, <span class="number">333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorVar.begin(); itVar != vectorVar.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2021/06/19/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>自C++11起，C++标准库提供了智能指针</p>
</blockquote>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><blockquote>
<p>操作引用计数实现共享式拥有的概念。多个智能指针可以指向相同的对象，这个对象和其相关资源会在最后一个被销毁时释放。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自动释放 引用计数为1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="comment">//退出方法 shared_ptr a本身释放，对内部的 A 对象引用计数减1 则为0 释放new 出来的A 对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然使用shared_ptr能够非常方便的为我们自动释放对象，但是还是会出现一些问题。最典型的就是循环引用问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~B() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自动释放</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">//A引用计数为1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">//B引用计数为1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//查看内部对象引用计数</span></span><br><span class="line">	a-&gt;b = b;			<span class="comment">//A 引用计数为2</span></span><br><span class="line">	b-&gt;a = a;			<span class="comment">//B 引用计数为2</span></span><br><span class="line">	<span class="comment">//退出方法，a释放，A引用计数-1结果为1 不会释放 B也一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><blockquote>
<p>weak_ptr是为配合shared_ptr而引入的一种智能指针。主要用于观测资源的引用情况。</p>
<p>它的构造和析构不会引起引用记数的增加或减少。没有重载*和-&gt;但可以使用lock获得一个可用的shared_ptr对象。</p>
</blockquote>
<blockquote>
<p>配合shared_ptr解决循环引用问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	weak_ptr&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~B() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	weak_ptr&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自动释放</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">//A引用计数为1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">//B引用计数为1</span></span><br><span class="line"></span><br><span class="line">	a-&gt;b = b;			<span class="comment">//weak_ptr 引用计数不增加</span></span><br><span class="line">	b-&gt;a = a;			<span class="comment">//weak_ptr 引用计数不增加</span></span><br><span class="line">	<span class="comment">//退出方法，A B释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>weak_ptr 提供expired 方法等价于 use_count == 0，当expired为true时，lock返回一个存储空指针的shared_ptr </p>
</blockquote>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><blockquote>
<p>实现独占式引用，保证同一时间只有一个智能指针指向内部对象。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>auto_ptr已经不推荐使用</p>
</blockquote>
<h3 id="手写智能指针"><a href="#手写智能指针" class="headerlink" title="手写智能指针"></a>手写智能指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Ptr() &#123;</span><br><span class="line">		count = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Ptr(T *t):t(t) &#123;</span><br><span class="line">		<span class="comment">//引用计数为1</span></span><br><span class="line">		count = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Ptr() &#123;</span><br><span class="line">		<span class="comment">//引用计数-1 为0表示可以释放T了</span></span><br><span class="line">		<span class="keyword">if</span> (--(*count) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (t) &#123;</span><br><span class="line">				<span class="keyword">delete</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> count;</span><br><span class="line">			t = <span class="number">0</span>;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	Ptr(<span class="keyword">const</span> Ptr&lt;T&gt; &amp;p) &#123;</span><br><span class="line">		<span class="comment">//引用计数+1</span></span><br><span class="line">		++(*p.count);</span><br><span class="line">		t = p.t;</span><br><span class="line">		count = p.count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ptr&lt;T&gt;&amp; p) &#123;</span><br><span class="line">		++(*p.count);</span><br><span class="line">		<span class="comment">//检查老的数据是否需要删除</span></span><br><span class="line">		<span class="keyword">if</span> (--(*count) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (t) &#123;</span><br><span class="line">				<span class="keyword">delete</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> count;</span><br><span class="line">		&#125;</span><br><span class="line">		t = p.t;</span><br><span class="line">		count = p.count;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载-&gt; 操作T 类</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *t;</span><br><span class="line">	<span class="keyword">int</span> *count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重载=为什么返回引用，而不是对象？</p>
<p>return *this后马上就调用拷贝构造函数，将*this拷贝给一个匿名临时对象，然后在把临时对象拷贝给外部的左值(a=b,a为左值)，再释放临时对象。这样首先会造成不必要的开销。</p>
</blockquote>
<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><blockquote>
<p> nullptr 出现的目的是为了替代 NULL。 同时拥有更多的特性 例如：可以调用到指针参数的函数。 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>* i)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在调用哪一个test？ test(int)</span></span><br><span class="line">test(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用test(int* i)</span></span><br><span class="line">test(<span class="literal">nullptr</span>); </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>fmod变声测试demo</title>
    <url>/2021/06/19/fmod%E5%8F%98%E5%A3%B0%E6%B5%8B%E8%AF%95demo/</url>
    <content><![CDATA[<h4 id="1-查看手机架构"><a href="#1-查看手机架构" class="headerlink" title="1. 查看手机架构"></a>1. 查看手机架构</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure>


<h4 id="2-解析CMakeList"><a href="#2-解析CMakeList" class="headerlink" title="2. 解析CMakeList"></a>2. 解析CMakeList</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)  #最低支持的Cmake版本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO 引入头文件,该头文件是相对CMakeList.txt的</span></span><br><span class="line">include_directories(&quot;inc&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量导入所有源文件</span></span><br><span class="line">file(GLOB allCpp *.c *.h *.cpp)</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">        native-lib</span><br><span class="line"></span><br><span class="line">        # Sets the library as a shared library.</span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        # Provides a relative path to your source file(s).</span><br><span class="line">        $&#123;allCpp&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入库文件,设置环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入的库一定放在jniLibs目录中</span></span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找库，防止多次寻找库</span></span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">        log-lib</span><br><span class="line"></span><br><span class="line">        # Specifies the name of the NDK library that</span><br><span class="line">        # you want CMake to locate.</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">        #总库名字</span><br><span class="line">        native-lib</span><br><span class="line"></span><br><span class="line">        # Links the target library to the log library</span><br><span class="line">        # included in the NDK.</span><br><span class="line">        $&#123;log-lib&#125;</span><br><span class="line">        fmod</span><br><span class="line">        fmodL #链接到总so库中</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>


<h4 id="3-调用fmod库"><a href="#3-调用fmod库" class="headerlink" title="3. 调用fmod库"></a>3. 调用fmod库</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> FMOD;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">&quot;Jack_Ou&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_example_practicemethod_MainActivity_changeVoiceNative</span><br><span class="line">        (JNIEnv *env, jobject thiz, jint mode, jstring path) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *content_ = <span class="string">&quot;播放完毕&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取C能识别的path</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path_ = env-&gt;GetStringUTFChars(path, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 音效引擎系统</span></span><br><span class="line">    System *system = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声音</span></span><br><span class="line">    Sound *sound = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声道，音轨</span></span><br><span class="line">    Channel *channel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DSP</span></span><br><span class="line">    DSP *dsp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建系统</span></span><br><span class="line">    System_Create(&amp;system);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统初始化</span></span><br><span class="line">    <span class="comment">// 参数1：最大声道数；</span></span><br><span class="line">    <span class="comment">// 参数2：初始化标记</span></span><br><span class="line">    system-&gt;init(<span class="number">32</span>, FMOD_INIT_NORMAL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建声音</span></span><br><span class="line">    <span class="comment">// 参数1：音频文件路基</span></span><br><span class="line">    <span class="comment">// 参数2：初始化音频标记</span></span><br><span class="line">    <span class="comment">// 参数3：额外参数</span></span><br><span class="line">    <span class="comment">// 参数4：声音</span></span><br><span class="line">    system-&gt;createSound(path_, FMOD_DEFAULT, <span class="number">0</span>, &amp;sound);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放</span></span><br><span class="line">    <span class="comment">// 参数1：声音</span></span><br><span class="line">    <span class="comment">// 参数2：通道分组</span></span><br><span class="line">    <span class="comment">// 参数3：是否暂停</span></span><br><span class="line">    <span class="comment">// 参数4：声道</span></span><br><span class="line">    system-&gt;playSound(sound, <span class="number">0</span>, <span class="literal">false</span>, &amp;channel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换音效</span></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_NORMAL:</span><br><span class="line">            content_ = <span class="string">&quot;原生 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_GIRL:</span><br><span class="line">            <span class="comment">// 音调调高</span></span><br><span class="line">            <span class="comment">// 创建DPS</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);</span><br><span class="line">            <span class="comment">// 设置pitch</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, <span class="number">2.0f</span>);</span><br><span class="line">            <span class="comment">// 添加dsp</span></span><br><span class="line">            <span class="comment">// 参数1：通道编号</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;女声 播放完毕&quot;</span>;</span><br><span class="line">            LOGE(<span class="string">&quot;%s&quot;</span>, content_);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_UNCLE:</span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, <span class="number">0.7f</span>);</span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;大叔 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_HORROR:</span><br><span class="line">            <span class="comment">// 音量调低</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, <span class="number">0.7f</span>);</span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp); <span class="comment">// 配置第一个音轨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加回声</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, <span class="number">200</span>); <span class="comment">// 回音延时</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, <span class="number">10</span>);  <span class="comment">// 回音衰减度</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">1</span>, dsp);  <span class="comment">// 配置第二个音轨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加颤抖</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_TREMOLO, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_FREQUENCY, <span class="number">20</span>);  <span class="comment">// 颤抖</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_SKEW, <span class="number">0.8f</span>);  <span class="comment">// 颤抖停顿</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">2</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;惊悚 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_FUN:</span><br><span class="line">            <span class="keyword">float</span> freq;</span><br><span class="line">            channel-&gt;getFrequency(&amp;freq);</span><br><span class="line"></span><br><span class="line">            channel-&gt;setFrequency(freq * <span class="number">1.5f</span>);</span><br><span class="line">            content_ = <span class="string">&quot;搞怪 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_ETHEREAL:</span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, <span class="number">200</span>); <span class="comment">// 回音延时</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, <span class="number">0</span>);  <span class="comment">// 回音衰减度</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;空灵 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待播放完毕</span></span><br><span class="line">    <span class="keyword">bool</span> isPlay = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (isPlay) &#123;</span><br><span class="line">        channel-&gt;isPlaying(&amp;isPlay);  <span class="comment">// 声道知道是否播放完毕</span></span><br><span class="line">        LOGE(<span class="string">&quot;%s&quot;</span>, content_);</span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调结果</span></span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(thiz);</span><br><span class="line">    jmethodID endMethod = env-&gt;GetMethodID(clazz, <span class="string">&quot;playEnd&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jstring value = env-&gt;NewStringUTF(content_);</span><br><span class="line">    env-&gt;CallVoidMethod(thiz, endMethod, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收资源</span></span><br><span class="line">    sound-&gt;release();</span><br><span class="line">    system-&gt;close();</span><br><span class="line">    system-&gt;release();</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(path, path_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>预编译与常用jni函数</title>
    <url>/2021/06/25/%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B8%B8%E7%94%A8jni%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1-预编译器"><a href="#1-预编译器" class="headerlink" title="1. 预编译器"></a>1. 预编译器</h4><p>预处理器不是编译器，预处理器主要完成文本替换的操作，主要完成文本拷贝或者替换工作。预处理器都是用 #xxx 的写法，并不是注释。预处理器主要对<code>#</code>标记的内容进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include  导入头文件</span><br><span class="line">#if       if判断操作  【if的范畴 必须endif】</span><br><span class="line">#elif     else if</span><br><span class="line">#else     else</span><br><span class="line">#endif    结束if</span><br><span class="line">#define   定义一个宏</span><br><span class="line">#ifdef    如果定义了这个宏 【if的范畴 必须endif】</span><br><span class="line">#ifndef   如果没有定义这个宏 【if的范畴 必须endif】</span><br><span class="line">#undef    取消宏定义</span><br><span class="line">#pragma   设定编译器的状态</span><br></pre></td></tr></table></figure>


<h5 id="1-1-宏函数的优缺点"><a href="#1-1-宏函数的优缺点" class="headerlink" title="1.1 宏函数的优缺点"></a>1.1 宏函数的优缺点</h5><ul>
<li>优点：文本替换，不会造成函数的调用开销(开辟栈空间，形参压栈，函数弹栈释放。</li>
<li>缺点：会导致代码体积增大</li>
</ul>
<h5 id="1-2-宏函数"><a href="#1-2-宏函数" class="headerlink" title="1.2 宏函数"></a>1.2 宏函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(V) cout &lt;&lt; V &lt;&lt; endl; <span class="comment">// 参数列表 无需类型  返回值 看不到</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(n1, n2) n1 + n2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHE(n1, n2) n1 * n2 <span class="comment">// 故意制作问题 ，宏函数的注意事项,*可能替换后会优先运算乘积</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂的宏函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGIN(V) <span class="meta-keyword">if</span>(V==1) &#123;                         \</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;满足 你输入的是:&quot;</span> &lt;&lt; V &lt;&lt; <span class="built_in">endl</span>;        \</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                                             \</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不满足 你输入的是:&quot;</span> &lt;&lt; V &lt;&lt; <span class="built_in">endl</span>;       \</span><br><span class="line">&#125; <span class="comment">// 这个是结尾，不需要加 \</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SHOW(<span class="number">8</span>);</span><br><span class="line">    SHOW(<span class="number">8.8f</span>);</span><br><span class="line">    SHOW(<span class="number">8.99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = ADD(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    r = ADD(<span class="number">1</span>+<span class="number">1</span>, <span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r = CHE(1+1, 2+2);</span></span><br><span class="line">    r = <span class="number">1</span>+<span class="number">1</span> * <span class="number">2</span>+<span class="number">2</span>; <span class="comment">// 文本替换：1+1 * 2+2  先算乘法  最终等于 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 我们认为的是8，   但是打印5</span></span><br><span class="line"></span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 会导致代码体积增大</span></span><br><span class="line"></span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    <span class="comment">// 普通函数，每次都会进栈 弹栈 ，不会导致代码体积增大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-操作java对象"><a href="#2-操作java对象" class="headerlink" title="2. 操作java对象"></a>2. 操作java对象</h4><h5 id="2-1-函数签名"><a href="#2-1-函数签名" class="headerlink" title="2.1 函数签名"></a>2.1 函数签名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;签名规则 大写</span><br><span class="line">&#x2F;&#x2F; MainActivity必须是.class</span><br><span class="line">javap -s -p MainActivity     </span><br><span class="line"></span><br><span class="line">Java的boolean  --- Z  注意点</span><br><span class="line">Java的byte  --- B</span><br><span class="line">Java的char  --- C</span><br><span class="line">Java的short  --- S</span><br><span class="line">Java的int  --- I</span><br><span class="line">Java的long  --- J     注意点</span><br><span class="line">Java的float  --- F</span><br><span class="line">Java的double  --- D</span><br><span class="line">Java的void  --- V</span><br><span class="line">Java的引用类型  --- Lxxx&#x2F;xxx&#x2F;xx&#x2F;类名;</span><br><span class="line">Java的String  --- Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">Java的array  int[]  --- [I         double[][][][]  --- [[[D</span><br><span class="line">int add(char c1, char c2) ---- (CC)I</span><br><span class="line">void a()     &#x3D;&#x3D;&#x3D;  ()V</span><br><span class="line"></span><br><span class="line">javap -s -p xxx.class    -s 输出xxxx.class的所有属性和方法的签名，   -p 忽略私有公开的所有属性方法全部输出</span><br></pre></td></tr></table></figure>


<h5 id="2-2-log工具宏"><a href="#2-2-log工具宏" class="headerlink" title="2.2 log工具宏"></a>2.2 log工具宏</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NDK工具链里面的 log 库 引入过来</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">&quot;JACK&quot;</span></span></span><br><span class="line"><span class="comment">// ... 我都不知道传入什么  借助JNI里面的宏来自动帮我填充</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>


<h5 id="2-3-方法定义说明"><a href="#2-3-方法定义说明" class="headerlink" title="2.3 方法定义说明"></a>2.3 方法定义说明</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extern &quot;C&quot;： 必须采用C的编译方式，为什么，请看JNIEnv内部源码</span></span><br><span class="line"><span class="comment">// // 无论是C还是C++ 最终是调用到 C的JNINativeInterface，所以必须采用C的方式 extern &quot;C&quot;</span></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT  <span class="comment">// 标记该方法可以被外部调用（VS上不加入 运行会报错， AS上不加入运行没有问题）</span></span><br><span class="line"><span class="comment">// Linux运行不加入，不报错,  Win 你必须加入 否则运行报错</span></span><br><span class="line"></span><br><span class="line">jstring <span class="comment">// Java &lt;---&gt; native 转换用的</span></span><br><span class="line"></span><br><span class="line">JNICALL <span class="comment">// 代表是 JNI标记，可以少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java_包名_类名_方法名  ，注意：我们的包名 _     native _1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JNIEnv * env  JNI：的桥梁环境    300多个函数，所以的JNI操作，必须靠他</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jobject jobj  谁调用，就是谁的实例  MainActivity this</span></span><br><span class="line"><span class="comment">// jclass clazz 谁调用，就是谁的class MainActivity.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包名代下划线，声明出来的函数名会以“1 2 3”表示包名中下划线个数</span></span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_getStringPwd</span><br><span class="line">        (JNIEnv * env, jobject jobj) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-4-静态函数定义"><a href="#2-4-静态函数定义" class="headerlink" title="2.4 静态函数定义"></a>2.4 静态函数定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数2是jclass</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_getStringPwd2(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement getStringPwd2()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-5-普通函数"><a href="#2-5-普通函数" class="headerlink" title="2.5 普通函数"></a>2.5 普通函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是jobject</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jcak_as_1jni_1project_MainActivity_changeName(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">   <span class="comment">// 获取class</span></span><br><span class="line">   jclass j_cls = env-&gt;GetObjectClass(thiz);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取属性  L对象类型 都需要L</span></span><br><span class="line">   <span class="comment">// jfieldID GetFieldID(MainActivity.class, 属性名, 属性的签名)</span></span><br><span class="line">   jfieldID j_fid = env-&gt;GetFieldID(j_cls, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 转换工作 jobject转化jstring从父转化成子使用静态转化</span></span><br><span class="line">   jstring j_str = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;GetObjectField(thiz ,j_fid));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打印字符串目标，GetStringUTFChars返回const char *，接收需要常量转化</span></span><br><span class="line">   <span class="keyword">char</span> * c_str = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(env-&gt;GetStringUTFChars(j_str, <span class="literal">NULL</span>));</span><br><span class="line">    LOGD(<span class="string">&quot;native : %s\n&quot;</span>, c_str);</span><br><span class="line">    LOGE(<span class="string">&quot;native : %s\n&quot;</span>, c_str);</span><br><span class="line">    LOGI(<span class="string">&quot;native : %s\n&quot;</span>, c_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改成 Beyond</span></span><br><span class="line">    jstring jName = env-&gt;NewStringUTF(<span class="string">&quot;Beyond&quot;</span>);</span><br><span class="line">    env-&gt;SetObjectField(thiz, j_fid, jName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// printf()  C</span></span><br><span class="line">   <span class="comment">// cout &lt;&lt; &lt;&lt; endl; // C++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-6-修改静态变量"><a href="#2-6-修改静态变量" class="headerlink" title="2.6 修改静态变量"></a>2.6 修改静态变量</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_changeAge(JNIEnv *env, jclass jcls) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> * sig = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	<span class="comment">//获取静态变量</span></span><br><span class="line">   jfieldID j_fid = env-&gt;GetStaticFieldID(jcls, <span class="string">&quot;age&quot;</span>, sig);</span><br><span class="line">	<span class="comment">// 获取值</span></span><br><span class="line">   jint age = env-&gt;GetStaticIntField(jcls, j_fid);</span><br><span class="line"></span><br><span class="line">   age += <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 修改值</span></span><br><span class="line">   env-&gt;SetStaticIntField(jcls, j_fid, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-7-C调用java方法"><a href="#2-7-C调用java方法" class="headerlink" title="2.7 C调用java方法"></a>2.7 C调用java方法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_callAddMethod(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    <span class="comment">// 自己得到 MainActivity.class</span></span><br><span class="line">    jclass  mainActivityClass = env-&gt;GetObjectClass(job);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetMethodID(MainActivity.class, 方法名, 方法的签名)</span></span><br><span class="line">   jmethodID j_mid = env-&gt;GetMethodID(mainActivityClass, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;(II)I&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 Java的方法</span></span><br><span class="line">   jint sum = env-&gt;CallIntMethod(job, j_mid, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">   LOGE(<span class="string">&quot;sum result:%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-8-操作数组"><a href="#2-8-操作数组" class="headerlink" title="2.8 操作数组"></a>2.8 操作数组</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jint == int</span></span><br><span class="line"><span class="comment">// jstring == String</span></span><br><span class="line"><span class="comment">// jintArray == int[]</span></span><br><span class="line"><span class="comment">// jobjectArray == 引用类型对象，例如 String[]   Test[]   Student[]  Person[]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_testArrayAction(JNIEnv *env, jobject thiz,</span><br><span class="line">                                                             jint count,</span><br><span class="line">                                                             jstring text_info,</span><br><span class="line">                                                             jintArray ints,</span><br><span class="line">                                                             jobjectArray strs) &#123;</span><br><span class="line">    <span class="comment">// ① 基本数据类型  jint count， jstring text_info， 最简单的</span></span><br><span class="line">    <span class="keyword">int</span> countInt = count; <span class="comment">// jint本质是int，所以可以用int接收</span></span><br><span class="line">    LOGI(<span class="string">&quot;参数一 countInt:%d\n&quot;</span>, countInt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const char* GetStringUTFChars(jstring string, jboolean* isCopy)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * textInfo = env-&gt;GetStringUTFChars(text_info, <span class="literal">NULL</span>);</span><br><span class="line">    LOGI(<span class="string">&quot;参数二 textInfo:%s\n&quot;</span>, textInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 把int[] 转成 int*</span></span><br><span class="line">    <span class="comment">// jint* GetIntArrayElements(jintArray array, jboolean* isCopy)</span></span><br><span class="line">    <span class="keyword">int</span>* jintArray = env-&gt;GetIntArrayElements(ints, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java层数组的长度</span></span><br><span class="line">    <span class="comment">// jsize GetArrayLength(jarray array) // jintArray ints 可以放入到 jarray的参数中去</span></span><br><span class="line">    jsize size = env-&gt;GetArrayLength(ints);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        *(jintArray+i) += <span class="number">100</span>; <span class="comment">// C++的修改，影响不了Java层</span></span><br><span class="line">        LOGI(<span class="string">&quot;参数三 int[]:%d\n&quot;</span>, *jintArray+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目前无法控制Java的数组 变化 +100</span></span><br><span class="line">    <span class="comment">// 操作杆 ----&gt; JMV</span></span><br><span class="line">    <span class="comment">// env-&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0:           刷新Java数组，并 释放C++层数组</span></span><br><span class="line"><span class="comment">     * JNI_COMMIT:  只提交 只刷新Java数组，不释放C++层数组</span></span><br><span class="line"><span class="comment">     * JNI_ABORT:   只释放C++层数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    env-&gt;ReleaseIntArrayElements(ints, jintArray, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③：jobjectArray 代表是Java的引用类型数组，不一样</span></span><br><span class="line">    jsize  strssize = env-&gt;GetArrayLength(strs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strssize; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        jstring jobj = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;GetObjectArrayElement(strs, i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模糊：isCopy内部启动的机制</span></span><br><span class="line">        <span class="comment">// const char* GetStringUTFChars(jstring string, jboolean* isCopy)</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * jobjCharp = env-&gt;GetStringUTFChars(jobj, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        LOGI(<span class="string">&quot;参数四 引用类型String 具体的：%s\n&quot;</span>, jobjCharp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放jstring</span></span><br><span class="line">        env-&gt;ReleaseStringUTFChars(jobj, jobjCharp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-9-对象处理"><a href="#2-9-对象处理" class="headerlink" title="2.9 对象处理"></a>2.9 对象处理</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jobject student == Student</span></span><br><span class="line"><span class="comment">// jstring str  == String</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_putObject(JNIEnv *env,</span><br><span class="line">                                                       jobject thiz,</span><br><span class="line">                                                       jobject student,</span><br><span class="line">                                                       jstring str) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * strChar = env-&gt;GetStringUTFChars(str, <span class="literal">NULL</span>);</span><br><span class="line">    LOGI(<span class="string">&quot;strChar：%s\n&quot;</span>, strChar);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(str, strChar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------</span></span><br><span class="line">    <span class="comment">// 1.寻找类 Student</span></span><br><span class="line">    <span class="comment">// jclass studentClass = env-&gt;FindClass(&quot;com/jack/as_jni_project/Student&quot;); // 第一种</span></span><br><span class="line">    jclass studentClass =  env-&gt;GetObjectClass(student); <span class="comment">// 第二种</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.Student类里面的函数规则  签名</span></span><br><span class="line">    jmethodID setName = env-&gt;GetMethodID(studentClass, <span class="string">&quot;setName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jmethodID getName = env-&gt;GetMethodID(studentClass, <span class="string">&quot;getName&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    jmethodID showInfo = env-&gt;GetStaticMethodID(studentClass, <span class="string">&quot;showInfo&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.调用 setName</span></span><br><span class="line">    jstring value = env-&gt;NewStringUTF(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(student, setName, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.调用 getName</span></span><br><span class="line">    jstring getNameResult = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(student, getName));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * getNameValue = env-&gt;GetStringUTFChars(getNameResult, <span class="literal">NULL</span>);</span><br><span class="line">    LOGE(<span class="string">&quot;调用到getName方法，值是:%s\n&quot;</span>, getNameValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.调用静态showInfo</span></span><br><span class="line">    jstring  jstringValue = env-&gt;NewStringUTF(<span class="string">&quot;静态方法你好，我是C++&quot;</span>);</span><br><span class="line">    env-&gt;CallStaticVoidMethod(studentClass, showInfo, jstringValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-10-对象处理进阶"><a href="#2-10-对象处理进阶" class="headerlink" title="2.10 对象处理进阶"></a>2.10 对象处理进阶</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_insertObject(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    <span class="comment">// 1.通过包名+类名的方式 拿到 Student class  凭空拿class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *studentstr = <span class="string">&quot;com/jack/as_jni_project/Student&quot;</span>;</span><br><span class="line">    jclass studentClass = env-&gt;FindClass(studentstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过student的class  实例化此Student对象   C++ new Student</span></span><br><span class="line">    jobject studentObj = env-&gt;AllocObject(studentClass); <span class="comment">// AllocObject 只实例化对象，不会调用对象的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法签名的规则</span></span><br><span class="line">    jmethodID setName = env-&gt;GetMethodID(studentClass, <span class="string">&quot;setName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jmethodID setAge = env-&gt;GetMethodID(studentClass, <span class="string">&quot;setAge&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    jstring strValue = env-&gt;NewStringUTF(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(studentObj, setName, strValue);</span><br><span class="line">    env-&gt;CallVoidMethod(studentObj, setAge, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// env-&gt;NewObject() // NewObject 实例化对象，会调用对象的构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ====================  下面是 Person对象  调用person对象的  setStudent 函数等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通过包名+类名的方式 拿到 Student class  凭空拿class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *personstr = <span class="string">&quot;com/jack/as_jni_project/Person&quot;</span>;</span><br><span class="line">    jclass personClass = env-&gt;FindClass(personstr);</span><br><span class="line"></span><br><span class="line">    jobject personObj = env-&gt;AllocObject(personClass); <span class="comment">// AllocObject 只实例化对象，不会调用对象的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setStudent 此函数的 签名 规则</span></span><br><span class="line">    jmethodID setStudent = env-&gt;GetMethodID(personClass, <span class="string">&quot;setStudent&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(Lcom/jack/as_jni_project/Student;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env-&gt;CallVoidMethod(personObj, setStudent, studentObj);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 第一类</span></span><br><span class="line">    env-&gt;DeleteLocalRef(studentClass);</span><br><span class="line">    env-&gt;DeleteLocalRef(personClass);</span><br><span class="line">    env-&gt;DeleteLocalRef(studentObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(personObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二类</span></span><br><span class="line">    <span class="comment">// env-&gt;ReleaseStringUTFChars()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 局部引用： jobject jclass jstring ...  【函数结束后，会自动释放】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-11-全局引用与局部引用理解"><a href="#2-11-全局引用与局部引用理解" class="headerlink" title="2.11 全局引用与局部引用理解"></a>2.11 全局引用与局部引用理解</h5><p>使用NewGlobalRef创建全局引用，否者都是局部引用，出栈之后，dogclass会成为悬空指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">jclass dogClass; <span class="comment">// 你以为这个是全局引用，实际上他还是局部引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_testQuote(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dogClass) &#123;</span><br><span class="line">        <span class="comment">/*const char * dogStr = &quot;com/jack/as_jni_project/Dog&quot;;</span></span><br><span class="line"><span class="comment">        dogClass = env-&gt;FindClass(dogStr);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 升级全局引用： JNI函数结束也不释放，反正就是不释放，必须手动释放   ----- 相当于： C++ 对象 new、手动delete</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * dogStr = <span class="string">&quot;com/jack/as_jni_project/Dog&quot;</span>;</span><br><span class="line">        jclass temp = env-&gt;FindClass(dogStr);</span><br><span class="line">        dogClass = <span class="keyword">static_cast</span>&lt;jclass&gt;(env-&gt;NewGlobalRef(temp)); <span class="comment">// 提升全局引用</span></span><br><span class="line">        <span class="comment">// 记住：用完了，如果不用了，马上释放</span></span><br><span class="line">        env-&gt;DeleteLocalRef(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;init&gt; V  是构造函数名不会变的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数一</span></span><br><span class="line">    jmethodID init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    jobject dog = env-&gt;NewObject(dogClass, init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数2</span></span><br><span class="line">    init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    dog = env-&gt;NewObject(dogClass, init, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数3</span></span><br><span class="line">    init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(II)V&quot;</span>);</span><br><span class="line">    dog = env-&gt;NewObject(dogClass, init, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数4</span></span><br><span class="line">    init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(III)V&quot;</span>);</span><br><span class="line">    dog = env-&gt;NewObject(dogClass, init, <span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    env-&gt;DeleteLocalRef(dog); <span class="comment">// 释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JNI函数结束，会释放局部引用   dogClass虽然被释放，但是还不等于NULL，只是一个悬空指针而已，所以第二次进不来IF，会奔溃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非常方便，可以使用了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> age; <span class="comment">// 声明age</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>; <span class="comment">// 声明show函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动释放全局引用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_delQuote(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">   <span class="keyword">if</span> (dogClass != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       LOGE(<span class="string">&quot;全局引用释放完毕，上面的按钮已经失去全局引用，再次点击会报错&quot;</span>);</span><br><span class="line">       env-&gt;DeleteGlobalRef(dogClass);</span><br><span class="line">       dogClass = <span class="literal">NULL</span>; <span class="comment">// 最好给一个NULL，指向NULL的地址，不要去成为悬空指针</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 测试下</span></span><br><span class="line">   show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI动态注册与线程理解</title>
    <url>/2021/06/29/JNI%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="1-静态注册与动态注册函数"><a href="#1-静态注册与动态注册函数" class="headerlink" title="1. 静态注册与动态注册函数"></a>1. 静态注册与动态注册函数</h4><h5 id="1-1-静态注册函数"><a href="#1-1-静态注册函数" class="headerlink" title="1.1 静态注册函数"></a>1.1 静态注册函数</h5><p>在开发默认情况下，就是静态注册，静态注册是最简单的方式，NDK开发过程中，基本上使用静态注册，但是Android 系统的C++源码：基本上都是动态注册。</p>
<blockquote>
<p>静态注册： 优点：开发简单<br>缺点<br>1.JNI函数名非常长<br>2.捆绑 上层 包名 + 类名<br>3.运行期 才会去 匹配JNI函数，性能上 低于 动态注册</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日志输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">&quot;JNISTUDY&quot;</span></span></span><br><span class="line"><span class="comment">// __VA_ARGS__ 代表 ...的可变参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG,  __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // 在AS上 pthread不需要额外配置，默认就有</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;默认就是静态注册哦&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_staticRegister(JNIEnv *env, jobject thiz) &#123;&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-2-动态注册函数"><a href="#1-2-动态注册函数" class="headerlink" title="1.2 动态注册函数"></a>1.2 动态注册函数</h5><blockquote>
<p> JavaVM、JNIEnv、jobject 域的结论：</p>
<ol>
<li><p>JavaVM全局，绑定当前进程， 只有一个地</p>
</li>
<li><p>JNIEnv线程绑定， 绑定主线程，绑定子线程</p>
</li>
<li><p>jobject 谁调用JNI函数，谁的实例会给jobject</p>
</li>
</ol>
<ol>
<li><p>JNIEnv *env 不能跨越线程，否则奔溃，  他可以跨越函数<br>【解决方式：使用全局的JavaVM附加当前异步线程 得到权限env操作】</p>
</li>
<li><p>jobject thiz 不能跨越线程，否则奔溃，不能跨越函数，否则奔溃<br>【解决方式：默认是局部引用，提升全局引用，可解决此问题】</p>
</li>
<li><p>JavaVM 能够跨越线程，能够跨越函数</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">JavaVM *jVm = <span class="literal">nullptr</span>; <span class="comment">// 0x003545 系统乱值，C++11后，取代NULL，作用是可以初始化指针赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mainActivityClassName = <span class="string">&quot;com/jack/as_jni_project/MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native 真正的执行函数</span></span><br><span class="line"><span class="comment">// void dynamicMethod01(JNIEnv *env, jobject thiz) &#123; // OK的</span></span><br><span class="line"><span class="comment">// 如果你用不到  JNIEnv jobject ，可以不用写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicMethod01</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    LOGD(<span class="string">&quot;我是动态注册的函数 dynamicMethod01...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dynamicMethod02</span><span class="params">(JNIEnv *env, jobject thiz, jstring valueStr)</span> </span>&#123; <span class="comment">// 也OK</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *text = env-&gt;GetStringUTFChars(valueStr, <span class="literal">nullptr</span>);</span><br><span class="line">    LOGD(<span class="string">&quot;我是动态注册的函数 dynamicMethod02... %s&quot;</span>, text);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(valueStr, text);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     typedef struct &#123;</span></span><br><span class="line"><span class="comment">        const char* name;       // 函数名</span></span><br><span class="line"><span class="comment">        const char* signature; // 函数的签名</span></span><br><span class="line"><span class="comment">        void*       fnPtr;     // 函数指针</span></span><br><span class="line"><span class="comment">     &#125; JNINativeMethod;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod jniNativeMethod[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;dynamicJavaMethod01&quot;</span>, <span class="string">&quot;()V&quot;</span>,                   (<span class="keyword">void</span> *) (dynamicMethod01)&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;dynamicJavaMethod02&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)I&quot;</span>, (<span class="keyword">int</span> *) (dynamicMethod02)&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java：像 Java的构造函数，如果你不写构造函数，默认就有构造函数，如果你写构造函数 覆写默认的构造函数</span></span><br><span class="line"><span class="comment">// JNI JNI_OnLoad函数，如果你不写JNI_OnLoad，默认就有JNI_OnLoad，如果你写JNI_OnLoad函数 覆写默认的JNI_OnLoad函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *javaVm, <span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this.javaVm = javaVm;</span></span><br><span class="line">    <span class="comment">// javaVm全局唯一</span></span><br><span class="line">    ::jVm = javaVm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做动态注册 全部做完</span></span><br><span class="line">	<span class="comment">// JNIEnv线程唯一</span></span><br><span class="line">    JNIEnv *jniEnv = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> result = javaVm-&gt;GetEnv(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(&amp;jniEnv), JNI_VERSION_1_6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// result 等于0  就是成功</span></span><br><span class="line">    <span class="keyword">if</span> (result != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 会奔溃，故意奔溃</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;System.loadLibrary ---》 JNI Load init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jclass mainActivityClass = jniEnv-&gt;FindClass(mainActivityClassName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jint RegisterNatives(Class, 我们的数组==jniNativeMethod， 注册的数量 = 2)</span></span><br><span class="line">    jniEnv-&gt;RegisterNatives(mainActivityClass,</span><br><span class="line">                            jniNativeMethod,</span><br><span class="line">                            <span class="keyword">sizeof</span>(jniNativeMethod) / <span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;动态 注册没有毛病&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6; <span class="comment">//  // AS的JDK在JNI默认最高1.6      存Java的JDKJNI 1.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-JNI子线程中，对JniEnv的理解"><a href="#2-JNI子线程中，对JniEnv的理解" class="headerlink" title="2.  JNI子线程中，对JniEnv的理解"></a>2.  JNI子线程中，对JniEnv的理解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContext</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    JNIEnv *jniEnv = <span class="literal">nullptr</span>;  <span class="comment">// 不能跨线程 ，会奔溃</span></span><br><span class="line">    jobject instance = <span class="literal">nullptr</span>; <span class="comment">// 不能跨线程 ，会奔溃</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子线程中跨线程对JniEnv的使用</span></span><br><span class="line"><span class="comment">// 方法1，在子线程中使用AttachCurrentThread来获取jnienv</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myThreadTaskAction</span><span class="params">(<span class="keyword">void</span> *pVoid)</span> </span>&#123; <span class="comment">// 当前是异步线程</span></span><br><span class="line">    LOGE(<span class="string">&quot;myThreadTaskAction run&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求：有这样的场景，</span></span><br><span class="line">    <span class="comment">// 例如：下载完成 ，下载失败，等等，必须告诉Activity UI端，所以需要在子线程调用UI端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个是必须要的</span></span><br><span class="line">    <span class="comment">// JNIEnv *env</span></span><br><span class="line">    <span class="comment">// jobject thiz   OK</span></span><br><span class="line"></span><br><span class="line">    MyContext * myContext = <span class="keyword">static_cast</span>&lt;MyContext *&gt;(pVoid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jclass mainActivityClass = myContext-&gt;jniEnv-&gt;FindClass(mainActivityClassName); // 不能跨线程 ，会奔溃</span></span><br><span class="line">    <span class="comment">// mainActivityClass = myContext-&gt;jniEnv-&gt;GetObjectClass(myContext-&gt;instance); // 不能跨线程 ，会奔溃</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 解决方式 （安卓进程只有一个 JavaVM，是全局的，是可以跨越线程的）</span></span><br><span class="line">    JNIEnv * jniEnv = <span class="literal">nullptr</span>; <span class="comment">// 全新的JNIEnv  异步线程里面操作</span></span><br><span class="line">    jint attachResult = ::jVm-&gt;AttachCurrentThread(&amp;jniEnv, <span class="literal">nullptr</span>); <span class="comment">// 附加当前异步线程后，会得到一个全新的 env，此env相当于是子线程专用env</span></span><br><span class="line">    <span class="keyword">if</span> (attachResult != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 附加失败，返回了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.拿到class</span></span><br><span class="line">    jclass mainActivityClass = jniEnv-&gt;GetObjectClass(myContext-&gt;instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.拿到方法</span></span><br><span class="line">    jmethodID updateActivityUI = jniEnv-&gt;GetMethodID(mainActivityClass, <span class="string">&quot;updateActivityUI&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.调用</span></span><br><span class="line">    jniEnv-&gt;CallVoidMethod(myContext-&gt;instance, updateActivityUI);</span><br><span class="line"></span><br><span class="line">    ::jVm-&gt;DetachCurrentThread(); <span class="comment">// 必须解除附加，否则报错</span></span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;C++ 异步线程OK&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过创建MyContext并且把</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_naitveThread(JNIEnv *env, jobject job) &#123; <span class="comment">// 当前是主线程</span></span><br><span class="line">    <span class="comment">/*pthread_t pid;</span></span><br><span class="line"><span class="comment">    pthread_create(&amp;pid, nullptr, myThreadTaskAction, nullptr);</span></span><br><span class="line"><span class="comment">    pthread_join(pid, nullptr);*/</span></span><br><span class="line"></span><br><span class="line">    MyContext * myContext = <span class="keyword">new</span> MyContext;</span><br><span class="line">    myContext-&gt;jniEnv = env;</span><br><span class="line">    <span class="comment">// myContext-&gt;instance = job; // 默认是局部引用，会奔溃</span></span><br><span class="line">    myContext-&gt;instance = env-&gt;NewGlobalRef(job); <span class="comment">// 提升全局引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">nullptr</span>, myThreadTaskAction, myContext);</span><br><span class="line">    pthread_join(pid, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_closeThread(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    <span class="comment">// 做释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三部分 纠结纠结细节 区域 ==================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_nativeFun1(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数job地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun1 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数job地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, job, ::jVm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_nativeFun2(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数job地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun2 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数job地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, job, ::jVm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">run</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123; <span class="comment">// native的子线程 env地址  和  Java的子线程env地址，一样吗  不一样的</span></span><br><span class="line">    JNIEnv * newEnv = <span class="literal">nullptr</span>;</span><br><span class="line">    ::jVm-&gt;AttachCurrentThread(&amp;newEnv, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;run jvm地址:%p,  当前run函数的newEnv地址:%p \n&quot;</span>, ::jVm, newEnv);</span><br><span class="line"></span><br><span class="line">    ::jVm-&gt;DetachCurrentThread();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_staticFun3(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun3 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数clazz地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, clazz, ::jVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用run</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java子线程调用的</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_staticFun4(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun4 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数clazz地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, clazz, ::jVm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_nativeFun5(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun5 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数job地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, job, ::jVm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI对象共享内存与Parcel实现分析</title>
    <url>/2021/07/01/JNI%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8EParcel%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="1-nativePtr作用"><a href="#1-nativePtr作用" class="headerlink" title="1. nativePtr作用"></a>1. nativePtr作用</h4><ul>
<li>Java层：nativePtr long类型的 保存 C++ 对象指针的地址</li>
<li>C++层：nativePtr —&gt; C++ 对象</li>
</ul>
<h5 id="1-1-理解源码中nativePtr"><a href="#1-1-理解源码中nativePtr" class="headerlink" title="1.1 理解源码中nativePtr"></a>1.1 理解源码中nativePtr</h5><p>在openCV中有个<a href="https://github.com/opencv/opencv/blob/master/modules/core/misc/java/src/java/core%2BMat.java">Mat.java</a>，<a href="https://github.com/opencv/opencv/blob/fc1a15626226609babd128e043cf7c4e32f567ca/modules/java/generator/src/cpp/Mat.cpp">Mat.cpp(Java_org_opencv_core_Mat_n_1Mat__DDI)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> nativeObj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mat</span><span class="params">(<span class="keyword">long</span> addr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Native object address is NULL&quot;</span>);</span><br><span class="line">        nativeObj = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// javadoc: Mat::Mat()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nativeObj = n_Mat();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// C++: Mat::Mat()</span></span><br><span class="line">    <span class="comment">// 调入到native初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">n_Mat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++: Mat::Mat(int rows, int cols, int type)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">n_Mat</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的声明</span></span><br><span class="line">JNIEXPORT jlong JNICALL Java_org_opencv_core_Mat_n_1Mat__DDI</span><br><span class="line">  (JNIEnv* env, jclass, jdouble size_width, jdouble size_height, jint type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line">JNIEXPORT jlong JNICALL Java_org_opencv_core_Mat_n_1Mat__DDI</span><br><span class="line">  (JNIEnv* env, jclass, jdouble size_width, jdouble size_height, jint type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> method_name[] = <span class="string">&quot;Mat::n_1Mat__DDI()&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LOGD(<span class="string">&quot;%s&quot;</span>, method_name);</span><br><span class="line">        <span class="function">Size <span class="title">size</span><span class="params">((<span class="keyword">int</span>)size_width, (<span class="keyword">int</span>)size_height)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new Mat.cpp 实例 强行 转换</span></span><br><span class="line">        <span class="comment">//【重点这一句，new Mat(); C++对象，把此对象的首地址返回给Java==nativeObj】</span></span><br><span class="line">        <span class="keyword">return</span> (jlong) <span class="keyword">new</span> Mat( size, type ); </span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e) &#123;</span><br><span class="line">        throwJavaException(env, &amp;e, method_name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        throwJavaException(env, <span class="number">0</span>, method_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>结论：</strong>Java层拿到nativeObj就是 Native层C++对象的指针，也就是对象的首地址，下次想去使用Native层的功能时，就可以使用首地址寻找C++对象，并让他干活即可。</p>
<h4 id="2-Parcel源码分析"><a href="#2-Parcel源码分析" class="headerlink" title="2. Parcel源码分析"></a>2. Parcel源码分析</h4><h5 id="2-1-Parcel初始化流程"><a href="#2-1-Parcel初始化流程" class="headerlink" title="2.1 Parcel初始化流程"></a>2.1 Parcel初始化流程</h5><p><strong>java端初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于初始化 Parcel对象的函数</span></span><br><span class="line"><span class="comment">     * Retrieve a new Parcel object from the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Parcel <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Parcel[] pool = sOwnedPool;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            Parcel p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">                p = pool[i];</span><br><span class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pool[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">                        p.mStack = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    p.mReadWriteHelper = ReadWriteHelper.DEFAULT;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：这里的 new Parcel(0); 操作，会进入下面代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parcel(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Parcel</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">		mStack = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Log.i(TAG, &quot;Initializing obj=0x&quot; + Integer.toHexString(obj), mStack</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意：这里的 init函数，会继续你下面代码</span></span><br><span class="line">	init(nativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123; <span class="comment">// mNativePtr == Parcel.cpp 对象指针地址</span></span><br><span class="line">	<span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">		mNativePtr = nativePtr;</span><br><span class="line">		mOwnsNativeParcelObject = <span class="keyword">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mNativePtr = nativeCreate(); <span class="comment">// 注意：这里的nativeCreate();会返回C++的头指针内存地址</span></span><br><span class="line">		mOwnsNativeParcelObject = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeCreate</span><span class="params">()</span></span>; <span class="comment">// 注意：从这里进入Native层代码</span></span><br></pre></td></tr></table></figure>


<p><strong>native代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gParcelMethods[] = &#123;</span><br><span class="line">    <span class="comment">//动态注册各种方法</span></span><br><span class="line">    ......</span><br><span class="line">    &#123;<span class="string">&quot;openFileDescriptor&quot;</span>,        <span class="string">&quot;(Ljava/lang/String;I)Ljava/io/FileDescriptor;&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_openFileDescriptor&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dupFileDescriptor&quot;</span>,         <span class="string">&quot;(Ljava/io/FileDescriptor;)Ljava/io/FileDescriptor;&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_dupFileDescriptor&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;closeFileDescriptor&quot;</span>,       <span class="string">&quot;(Ljava/io/FileDescriptor;)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_closeFileDescriptor&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里就找到了，【nativeCreate】</span></span><br><span class="line">    &#123;<span class="string">&quot;nativeCreate&quot;</span>,              <span class="string">&quot;()J&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_create&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeFreeBuffer&quot;</span>,          <span class="string">&quot;(J)J&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_freeBuffer&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeDestroy&quot;</span>,             <span class="string">&quot;(J)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_destroy&#125;,</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正在的实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化C++ 对象，此对象 就是一个 内存地址指针</span></span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> Parcel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回：内存地址指针，并且用reinterpret_cast 转换jlong类型，这代码一看就知道比OpenCV写得好</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-2-写数据"><a href="#2-2-写数据" class="headerlink" title="2.2 写数据"></a>2.2 写数据</h5><p><strong>Parcel.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Write an integer value into the parcel at the current dataPosition(),</span></span><br><span class="line"><span class="comment">    * growing dataCapacity() if needed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 注意：这里会调用native层，下面就会分析这个代码</span></span><br><span class="line">       nativeWriteInt(mNativePtr, val);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FastNative</span> <span class="comment">// 思考：行参一的作用是可以通过此内存地址去寻找native层的C++对象</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteInt</span><span class="params">(<span class="keyword">long</span> nativePtr, <span class="keyword">int</span> val)</span></span>; <span class="comment">// 下面进入native</span></span><br></pre></td></tr></table></figure>


<p><strong>android_os_Parcel.cpp 的 nativeWriteInt:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;nativeWriteByteArray&quot;</span>,      <span class="string">&quot;(J[BII)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeByteArray&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteBlob&quot;</span>,           <span class="string">&quot;(J[BII)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeBlob&#125;,</span><br><span class="line">  <span class="comment">// @FastNative</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 还是采用动态注册的方式，搜索函数实现 android_os_Parcel_writeInt 即可</span></span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteInt&quot;</span>,            <span class="string">&quot;(JI)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeInt&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @FastNative</span></span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteLong&quot;</span>,           <span class="string">&quot;(JJ)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeLong&#125;,</span><br><span class="line">  <span class="comment">// @FastNative</span></span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteFloat&quot;</span>,          <span class="string">&quot;(JF)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeFloat&#125;,</span><br></pre></td></tr></table></figure>


<p><strong>实现函数android_os_Parcel_writeInt</strong> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeInt</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jint val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过在Java层保存的，C++对象首地址，来查找到C++对象 Parcel* parcel</span></span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 把内容写入进去，这里是调用到哪里去？ 看下面代码...</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">status_t</span> err = parcel-&gt;writeInt32(val); </span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Parcel.cpp 的 writeInt32:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::writeInt32</span><span class="params">(<span class="keyword">int32_t</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writeAligned(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="comment">// 相当于Java的泛型</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::writeAligned</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mDataPos：内存首地址的当前挪动位置</span></span><br><span class="line">    <span class="comment">// mDataCapacity：共享内存的总大小</span></span><br><span class="line">    <span class="comment">// mData：共享内存的首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就相当于，指针++ 挪动好位置 然后存放刚刚挪动的位置</span></span><br><span class="line">        <span class="comment">// * mData共享内存的首地址 = val赋值给左边;</span></span><br><span class="line">        restart_write: *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面分析 finsihWrite函数</span></span><br><span class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = growData(<span class="keyword">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>finsihWrite函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::finishWrite</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; INT32_MAX) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t accept size_t values which may have come from an</span></span><br><span class="line">        <span class="comment">// inadvertent conversion from a negative int.</span></span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;Finish write of %d\n&quot;, len);</span></span><br><span class="line">    mDataPos += len; <span class="comment">// 【上面函数存值后，把指针位置进行挪动一次，方便后续的值 存放】</span></span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;finishWrite Setting data pos of %p to %zu&quot;</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    <span class="keyword">if</span> (mDataPos &gt; mDataSize) &#123;</span><br><span class="line">        mDataSize = mDataPos;</span><br><span class="line">        ALOGV(<span class="string">&quot;finishWrite Setting data size of %p to %zu&quot;</span>, <span class="keyword">this</span>, mDataSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;New pos=%d, size=%d\n&quot;, mDataPos, mDataSize);</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>读的流程是一样的，按照顺序一个类型一个类型读出来。最核心的思想就是共享内存写数据和读数据。</p>
<h5 id="2-3-CMakeList配置导入全部-cpp"><a href="#2-3-CMakeList配置导入全部-cpp" class="headerlink" title="2.3 CMakeList配置导入全部.cpp"></a>2.3 CMakeList配置导入全部.cpp</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">file(GLOB allSource *.c *.cpp)</span><br><span class="line">add_library(</span><br><span class="line">	native-lib</span><br><span class="line">	SHARED</span><br><span class="line">	$&#123;allSource&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h4 id="3-自定义Parcelable"><a href="#3-自定义Parcelable" class="headerlink" title="3. 自定义Parcelable"></a>3. 自定义Parcelable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Student</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        in.readInt(); <span class="comment">// 顺序不能乱</span></span><br><span class="line">        in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(<span class="number">10</span>); <span class="comment">// 顺序不能乱</span></span><br><span class="line">        dest.writeString(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Student&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Student[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =========================  源码分析</span></span><br><span class="line">        Parcel parcel = Parcel.obtain();</span><br><span class="line"></span><br><span class="line">        parcel.writeInt(<span class="number">50</span>);</span><br><span class="line">        parcel.writeInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mDataPos = 8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么要修改成0,将内存地址还原</span></span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = parcel.readInt();</span><br><span class="line">        Log.d(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;onCreate: 系统的：&quot;</span> + r);</span><br><span class="line">        r = parcel.readInt();</span><br><span class="line">        Log.d(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;onCreate: 系统的：&quot;</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-Parcelable为什么比Serializable高效"><a href="#4-Parcelable为什么比Serializable高效" class="headerlink" title="4.Parcelable为什么比Serializable高效"></a>4.Parcelable为什么比Serializable高效</h4><p>Serializable IO流完成的(存储到磁盘)，   Parcelable C++ 对象指针 共享内存 指针挪动报错数据。</p>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>静态缓存与Native异常</title>
    <url>/2021/06/29/%E9%9D%99%E6%80%81%E7%BC%93%E5%AD%98%E4%B8%8ENative%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h4 id="1-非静态缓存案例分析"><a href="#1-非静态缓存案例分析" class="headerlink" title="1.非静态缓存案例分析"></a>1.非静态缓存案例分析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_localCache(JNIEnv *env, jclass clazz, jstring name) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态缓存</span></span><br><span class="line">    jfieldID f_id = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f_id == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次调用localCache方法都会获取一次jfieldID，如果频繁调用该方法会影响性能</span></span><br><span class="line">        f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name1&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;空的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_id, name); <span class="comment">// 修改 AAA</span></span><br><span class="line"></span><br><span class="line">    f_id = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-静态缓存"><a href="#2-静态缓存" class="headerlink" title="2. 静态缓存"></a>2. 静态缓存</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在方法外定义需要静态缓存的变量</span></span><br><span class="line"><span class="keyword">static</span> jfieldID f_name1_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name2_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name3_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name4_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name5_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name6_id = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化缓存变量，</span></span><br><span class="line"><span class="comment">// 先缓存。此方法应该在java构造方法中调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_initStaticCache(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    f_name1_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name1&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name2_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name2&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name3_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name3&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name4_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name4&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name5_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name5&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name6_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name6&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用缓存变量</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_staticCache(JNIEnv *env, jclass clazz, jstring name) &#123;</span><br><span class="line">    <span class="comment">// 不会反复 GetStaticFieldID 提供性能</span></span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name1_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name2_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name3_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name4_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name5_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name6_id, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.清除缓存变量</span></span><br><span class="line"><span class="comment">// 清除，此方法应该在onDestory中调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_clearStaticCache(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    f_name1_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name2_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name3_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name4_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name5_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name6_id = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-Native异常监测"><a href="#3-Native异常监测" class="headerlink" title="3. Native异常监测"></a>3. Native异常监测</h4><h5 id="3-1-方法内部补救"><a href="#3-1-方法内部补救" class="headerlink" title="3.1 方法内部补救"></a>3.1 方法内部补救</h5><p>native方法中监控异常，如果有的话就处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_derry_as_1jni_1project_MainActivity3_exception(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    <span class="comment">// 假设现在想操作 name999 ，没有name999就会在native层奔溃掉</span></span><br><span class="line">    jfieldID f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name999&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1 补救措施</span></span><br><span class="line">	<span class="comment">// 监测本次执行，到底有没有异常   JNI函数里面代码有问题</span></span><br><span class="line">    jthrowable thr =  env-&gt;ExceptionOccurred(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(thr) &#123; <span class="comment">// 非0 进去，监测到有异常</span></span><br><span class="line">        LOGD(<span class="string">&quot;C++层有异常 监测到了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env-&gt;ExceptionClear(); <span class="comment">// 此异常被清除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 补救措施</span></span><br><span class="line">        jfieldID f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name1&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-2-向java层抛异常"><a href="#3-2-向java层抛异常" class="headerlink" title="3.2 向java层抛异常"></a>3.2 向java层抛异常</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_derry_as_1jni_1project_MainActivity3_exception2(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    <span class="comment">// 假设现在想操作 name999 ，没有name999就会在native层奔溃掉</span></span><br><span class="line">    jfieldID f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name8888&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2 往Java层抛</span></span><br><span class="line"></span><br><span class="line">    jthrowable jthrowable = env-&gt;ExceptionOccurred(); <span class="comment">// 监测本次执行，到底有没有异常   JNI函数里面代码有问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(jthrowable) &#123; <span class="comment">// 非0 进去，监测到有异常</span></span><br><span class="line">        LOGD(<span class="string">&quot;C++层有异常 监测到了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env-&gt;ExceptionClear(); <span class="comment">// 此异常被清除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Throw抛一个 Java的对象     java/lang/String    java/xxxxx/xxx/NullExxx</span></span><br><span class="line">        jclass clz = env-&gt;FindClass(<span class="string">&quot;java/lang/NoSuchFieldException&quot;</span>);</span><br><span class="line">        env-&gt;ThrowNew(clz, <span class="string">&quot;NoSuchFieldException 实在是找不到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-Native监控java抛的异常"><a href="#3-3-Native监控java抛的异常" class="headerlink" title="3.3 Native监控java抛的异常"></a>3.3 Native监控java抛的异常</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java直接抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> throws Exception </span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;show: 1111&quot;</span>);</span><br><span class="line">    Log.d(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;show: 1111&quot;</span>);</span><br><span class="line">    Log.d(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;show: 1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;我是Java中抛出的异常，我的show方法里面发送了Java逻辑错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_Jack_as_1jni_1project_MainActivity3_exception3(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    jmethodID showID = env-&gt;GetStaticMethodID(clazz, <span class="string">&quot;show&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="comment">// 会不会立马崩溃？</span></span><br><span class="line">    <span class="comment">// 不会，只是CallStaticVoidMethod调用引起的，但是不会崩溃，因为ExceptionCheck()会监测此处崩溃，并且打出日志</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(clazz, showID); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExceptionCheck 《==》 慢慢的奔溃的，相当于给了你空余时间，既然不是马上奔溃，我就可以检测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JNI函数里面代码有问题 没有问题，给你空余时间，慢慢的奔溃的</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        env-&gt;ExceptionDescribe(); <span class="comment">// 输出描述 信息</span></span><br><span class="line">        env-&gt;ExceptionClear(); <span class="comment">// 此异常被清除    业务逻辑控制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意实现：</span></span><br><span class="line">    <span class="comment">/*// 奔溃后，下面的语句，照样打印</span></span><br><span class="line"><span class="comment">    LOGI(&quot;C++层&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1&quot;);</span></span><br><span class="line"><span class="comment">    LOGI(&quot;C++层&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;2&quot;);</span></span><br><span class="line"><span class="comment">    LOGI(&quot;C++层&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;3&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    env-&gt;NewStringUTF(&quot;AAAA&quot;); // 局部引用 崩溃被消除*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用指令集</title>
    <url>/2021/07/02/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<h4 id="1-指令集"><a href="#1-指令集" class="headerlink" title="1.指令集"></a>1.指令集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 光标移到命令行最前端</span></span><br><span class="line">ctrl + A </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 光标移到命令行最后面</span></span><br><span class="line">ctrl + E</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前命令行指令</span></span><br><span class="line">ctrl + U</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有详情</span></span><br><span class="line">ls -all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看文件大小</span></span><br><span class="line">ls -lh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归查看文件夹内容</span></span><br><span class="line">ls -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看磁盘大小</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件属性介绍</span></span><br><span class="line">-rw-r--r--    1     root     root     0      Apr 25 20:33</span><br><span class="line">文件权限    软连接数  当前用户  用户组   文件大小    日期</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件权限</span></span><br><span class="line">- 【普通文件】 </span><br><span class="line">d 【目录】 </span><br><span class="line">l 【软链接（Win快捷方式】 </span><br><span class="line">c 【字符设备文件】 </span><br><span class="line">b 【块设备文件】 </span><br><span class="line">p 【管道】 </span><br><span class="line">s 【套接字】</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> root用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 普通用户</span></span><br><span class="line"></span><br><span class="line">chmod u+rwx 111.txt  第一组可读可写可执行【u当前用户 g当前组 o其他组 a代表所有组】</span><br><span class="line"></span><br><span class="line">adduser jack   添加名为jack这个组</span><br><span class="line">chown aaa 1.txt  把1.txt修改aaa当前用户组</span><br><span class="line">chgrp aaa 1.txt  将1.txt的组权限改成aaa同组</span><br><span class="line"></span><br><span class="line">tac倒序查看</span><br><span class="line">more 1.txt 分页查看</span><br><span class="line">head -2 1.txt 查看前两行</span><br><span class="line">tail -3 1.txt 查看后三行</span><br><span class="line"></span><br><span class="line">shift+zz  命令行模式退出</span><br><span class="line">u撤销</span><br><span class="line"></span><br><span class="line">i当前光标字符输入</span><br><span class="line">I当前光标所在行头</span><br><span class="line">a当前光标后一个字符输入</span><br><span class="line">A当前光标所在行尾输入</span><br><span class="line"></span><br><span class="line">h:左  j:下  k:右  l:上</span><br><span class="line">gg跳到第一行</span><br><span class="line">G调到最后一行</span><br><span class="line">：set number 查看行号</span><br><span class="line"><span class="meta">$</span><span class="bash">回到行尾部</span></span><br><span class="line">0回到行首</span><br><span class="line">dw删除单词</span><br><span class="line">dd删除本行</span><br><span class="line">yy复制光标所在行</span><br><span class="line">p粘贴到当前行</span><br><span class="line">P粘贴到下一行</span><br><span class="line"></span><br><span class="line">r+字符，替换光标当前字符</span><br><span class="line">：s  /123/456   当前所在行的123替换成456</span><br><span class="line">：1.6s /123/456/g 1—6行中123换成456</span><br><span class="line">：%s /123/456/g 全文123替换成456</span><br><span class="line"></span><br><span class="line">分屏：</span><br><span class="line">：vsp 左右分屏</span><br><span class="line">： sp上下分屏</span><br><span class="line">ctrl+ww 切换分屏</span><br><span class="line"></span><br><span class="line">echo $?  监测上一个命令是否执行成功，0为成功，其他为失败</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换字符串</span></span><br><span class="line">sed -i &quot;s/com.gxa.sdk/com.gxa.service/g&quot; `grep -rl &quot;com.gxa.sdk&quot; ./`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有进程</span></span><br><span class="line">PS -A</span><br></pre></td></tr></table></figure>


<h4 id="2-SHELL脚本"><a href="#2-SHELL脚本" class="headerlink" title="2. SHELL脚本"></a>2. SHELL脚本</h4><h5 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义变量(符号之间不能有空格)</span></span><br><span class="line">A=10</span><br><span class="line"></span><br><span class="line">echo A==$A</span><br></pre></td></tr></table></figure>


<h5 id="2-2-参数"><a href="#2-2-参数" class="headerlink" title="2.2 参数"></a>2.2 参数</h5><table>
<thead>
<tr>
<th>$0</th>
<th>当前脚本的文件名</th>
</tr>
</thead>
<tbody><tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td>$$</td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody></table>
<p>$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<p>但是当它们被双引号(“ “)包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；”$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。<br>对于（””）双引号中带$符号的非参数前面必须加’ \ ‘</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打印当前路径,注意是大写</span></span><br><span class="line">echo PWD: $PWD</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取参数</span></span><br><span class="line">echo 当前shell脚本名称是: $0</span><br><span class="line">echo 参数一: $1</span><br><span class="line">echo 参数二: $2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看执行状态</span></span><br><span class="line"><span class="meta">if(($</span><span class="bash">?));<span class="keyword">then</span></span></span><br><span class="line">	echo 执行失败</span><br><span class="line">else</span><br><span class="line">	echo 执行成功</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看外界传入的参数</span></span><br><span class="line">echo 外界传入参数内容: $*</span><br><span class="line">echo 外界传入参数个数: $#</span><br></pre></td></tr></table></figure>


<h5 id="2-3-循环"><a href="#2-3-循环" class="headerlink" title="2.3 循环"></a>2.3 循环</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> seq 1 20是循环遍历1到20</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行命令使用``</span></span><br><span class="line">for i in `seq 1 20`</span><br><span class="line">do</span><br><span class="line">	echo &quot;the number:$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<h5 id="2-4-计算器工具"><a href="#2-4-计算器工具" class="headerlink" title="2.4 计算器工具"></a>2.4 计算器工具</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line">for f in `seq 1 100`</span><br><span class="line">do</span><br><span class="line">	a=`expr $f + $a`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;total: $a&quot;</span><br></pre></td></tr></table></figure>


<h5 id="2-5-查找文件并打包"><a href="#2-5-查找文件并打包" class="headerlink" title="2.5 查找文件并打包"></a>2.5 查找文件并打包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -czf output.tgz *.txt</span><br></pre></td></tr></table></figure>


<h5 id="2-6-读文件"><a href="#2-6-读文件" class="headerlink" title="2.6 读文件"></a>2.6 读文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line">while read readline</span><br><span class="line">do</span><br><span class="line">	echo $readline</span><br><span class="line">done&lt;`pwd`/1.txt</span><br></pre></td></tr></table></figure>


<h5 id="2-7-shell函数"><a href="#2-7-shell函数" class="headerlink" title="2.7 shell函数"></a>2.7 shell函数</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function test01() &#123; </span><br><span class="line">	echo &quot;我是一个函数&quot; </span><br><span class="line">&#125; </span><br><span class="line">test01 # 调用此函数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数里面是可以定义变量的，不要去考虑，堆，栈，弹栈，他就是脚本</span> </span><br><span class="line">function test02() &#123; </span><br><span class="line">    var1=&quot;Kevin&quot; </span><br><span class="line">    var2=&quot;Derry&quot; </span><br><span class="line">    echo $var1 </span><br><span class="line">    echo $var2 </span><br><span class="line">    echo &quot;我是一个函数&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数传递参数</span></span><br><span class="line">function test03() &#123; </span><br><span class="line">	echo &quot;我是一个函数，参数是:`expr $1`&quot; </span><br><span class="line">&#125; </span><br><span class="line">test03 99999 # 内置传递参数</span><br><span class="line"></span><br><span class="line">function test04() &#123; </span><br><span class="line">	echo &quot;我是一个函数，参数是:`expr $1`&quot; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">test04 $1 # 脚本配合    内置传递参数</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>指令集</tag>
      </tags>
  </entry>
  <entry>
    <title>调查Launcher无法启动原因</title>
    <url>/2021/07/09/%E8%B0%83%E6%9F%A5Launcher%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>车机启动之后，Launcher应用无法展示，导致车机桌面乃至依赖UI-Framework的应用都无法启动。</p>
<h4 id="2-问题调查"><a href="#2-问题调查" class="headerlink" title="2.问题调查"></a>2.问题调查</h4><p>取日志如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-79885217ee44d54b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apk中找不到需要的类.png"></p>
<p>从日志中我们可以看出应用的BaseClassLoader无法从<code>DexPathList</code>中加载到<code>com.gxa.sdk.weather.WeatherChangeListener</code>类。</p>
<h4 id="3-分析原因"><a href="#3-分析原因" class="headerlink" title="3.分析原因"></a>3.分析原因</h4><h5 id="3-1分析类加载流程"><a href="#3-1分析类加载流程" class="headerlink" title="3.1分析类加载流程"></a>3.1分析类加载流程</h5><p>一看着ClassLoader就会联想到JAVA中类是如何加载的。一共分为七个步骤：</p>
<blockquote>
<p>类加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p>
<p>链接过程主要是将Java类的二进制代码合并到JVM的运行状态之中。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d8f7dfa7d6733e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类加载过程.png"></p>
<h5 id="3-1-1-类加载"><a href="#3-1-1-类加载" class="headerlink" title="3.1.1 类加载"></a>3.1.1 类加载</h5><p>​    将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。</p>
<h5 id="3-1-2-验证"><a href="#3-1-2-验证" class="headerlink" title="3.1 .2 验证"></a>3.1 .2 验证</h5><p>​    确保加载的类信息符合JVM规范，没有安全方面的问题。</p>
<h5 id="3-1-3-准备"><a href="#3-1-3-准备" class="headerlink" title="3.1 .3 准备"></a>3.1 .3 准备</h5><p>​    正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。</p>
<h5 id="3-1-4-解析"><a href="#3-1-4-解析" class="headerlink" title="3.1 .4 解析"></a>3.1 .4 解析</h5><p>​    虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。</p>
<h5 id="3-1-5-初始化"><a href="#3-1-5-初始化" class="headerlink" title="3.1 .5 初始化"></a>3.1 .5 初始化</h5><p>​    初始化阶段是执行类构造器<init>()方法的过程。类构造器<init>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和**静态语句块(static块)**中的语句合并产生的。</init></init></p>
<ul>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。</li>
<li>虚拟机会保证一个类的<init>()方法在多线程环境中被正确加锁和同步。</init></li>
</ul>
<h5 id="3-2-类初始化顺序"><a href="#3-2-类初始化顺序" class="headerlink" title="3.2 类初始化顺序"></a>3.2 类初始化顺序</h5><p>1、父类的静态变量<br> 2、父类的静态代码块<br> 3、子类的静态变量<br> 4、子类的静态代码块<br> 5、父类的非静态变量<br> 6、父类的非静态代码块<br> 7、父类的构造方法<br> 8、子类的非静态变量<br> 9、子类的非静态代码块<br> 10、子类的构造方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f4a83dac14f43c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WeatherTimePresenter构造函数.png"></p>
<p>从第二小节可以看出是初始化WeatherTimePresenter报的异常。然后细化分析，是初始化WeatherTimeModel报的异常。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e8f65e87a9923c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WetherTimeModel.png"></p>
<p>我们反编Launcher应用可以看到，WeatherChangeListener属于WeatherTimeModel的成员变量，会在类调用构造方法之前初始化。并且看左边框图目录树，并没有看到com.gxa.sdk.weather.WeatherChangeListener这个类。因此结合类加载<code>双亲委托机制</code>，可以判断到WeatherChangeListener即没有从<code>根（Bootstrap）类加载</code>中加载到，也没有从<code>应用类加载器</code>中加载到。</p>
<h5 id="3-3-双亲委托机制"><a href="#3-3-双亲委托机制" class="headerlink" title="3.3 双亲委托机制"></a>3.3 双亲委托机制</h5><p><strong>ClassLoader的双亲委托模式</strong>：classloader 按级别分为三个级别：最上级 ： bootstrap classLoader（根类加载器） ； 中间级：extension classLoader （扩展类加载器）  最低级 app classLoader（应用类加载器）。</p>
<ul>
<li><p><strong>根（Bootstrap）类加载器</strong>：该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。例如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。</p>
</li>
<li><p><strong>扩展（Extension）类加载器</strong>：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库，如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类。</p>
</li>
<li><p><strong>系统（System）类加载器</strong>：也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// classloader类</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    		<span class="comment">// 检查类是不是已经被加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有父亲就一直往上找</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 递归找父亲加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 根就是祖宗了，没有父亲了。</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//如果父亲和祖宗都没有加载到</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="comment">// 调用自己的findclass加载.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h4><p>我们知道了<code>双亲委托机制</code>,对于该问题就有了解决办法: </p>
<ul>
<li>父亲或者祖宗帮我把类找到</li>
<li>我自定义classloader去加载类</li>
</ul>
<h5 id="4-1-祖宗加载法"><a href="#4-1-祖宗加载法" class="headerlink" title="4.1 祖宗加载法"></a>4.1 祖宗加载法</h5><p>如果是自己做系统,有办法修改到祖宗的东西,我们就可以改为祖宗加载(bootstrap classLoader, 根加载器)。其实根加载器就是从**系统环境变量(BOOTCLASSPATH)**中定义的路径中去加载。</p>
<p>ui-framework属于系统包，最合理的方式还是系统加载。</p>
<p>因此，我们把自己需要加载的包(例如ui-framework)加入到环境变量区即可。</p>
<h5 id="4-1-1-BOOTCLASSPATH被赋值流程分析"><a href="#4-1-1-BOOTCLASSPATH被赋值流程分析" class="headerlink" title="4.1.1 BOOTCLASSPATH被赋值流程分析"></a>4.1.1 BOOTCLASSPATH被赋值流程分析</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在system/core/rootdir/init.environ.rc.in中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> up the global environment</span></span><br><span class="line">on init</span><br><span class="line">    export ANDROID_BOOTLOGO 1</span><br><span class="line">    export ANDROID_ROOT /system</span><br><span class="line">    export ANDROID_ASSETS /system/app</span><br><span class="line">    export ANDROID_DATA /data</span><br><span class="line">    export ANDROID_STORAGE /storage</span><br><span class="line">    export EXTERNAL_STORAGE /sdcard</span><br><span class="line">    export ASEC_MOUNTPOINT /mnt/asec</span><br><span class="line">    export BOOTCLASSPATH %BOOTCLASSPATH%</span><br><span class="line">    export SYSTEMSERVERCLASSPATH %SYSTEMSERVERCLASSPATH%</span><br><span class="line">    %EXPORT_GLOBAL_ASAN_OPTIONS%</span><br><span class="line">    %EXPORT_GLOBAL_GCOV_OPTIONS%</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们知道BOOTCLASSPATH环境变量等于%BOOTCLASSPATH%，那%BOOTCLASSPATH%是谁赋的值呢？难道是在Android.mk编译脚本中赋值的么，继续看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> system/core/rootdir/Android.mk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Regenerate init.environ.rc <span class="keyword">if</span> PRODUCT_BOOTCLASSPATH has changed.</span></span><br><span class="line">bcp_md5 := $(word 1, $(shell echo $(PRODUCT_BOOTCLASSPATH) $(PRODUCT_SYSTEM_SERVER_CLASSPATH) | $(MD5SUM)))</span><br><span class="line">bcp_dep := $(intermediates)/$(bcp_md5).bcp.dep</span><br><span class="line"><span class="meta">$</span><span class="bash">(bcp_dep) :</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) mkdir -p $(dir <span class="variable">$@</span>) &amp;&amp; rm -rf $(dir <span class="variable">$@</span>)*.bcp.dep &amp;&amp; touch <span class="variable">$@</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(LOCAL_BUILT_MODULE): $(LOCAL_PATH)/init.environ.rc.in $(bcp_dep)</span></span><br><span class="line">	@echo &quot;Generate: $&lt; -&gt; $@&quot;</span><br><span class="line">	@mkdir -p $(dir $@)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -e <span class="string">&#x27;s?%BOOTCLASSPATH%?$(PRODUCT_BOOTCLASSPATH)?g&#x27;</span> $&lt; &gt;<span class="variable">$@</span></span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -i -e <span class="string">&#x27;s?%SYSTEMSERVERCLASSPATH%?$(PRODUCT_SYSTEM_SERVER_CLASSPATH)?g&#x27;</span> <span class="variable">$@</span></span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -i -e <span class="string">&#x27;s?%EXPORT_GLOBAL_ASAN_OPTIONS%?$(EXPORT_GLOBAL_ASAN_OPTIONS)?g&#x27;</span> <span class="variable">$@</span></span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -i -e <span class="string">&#x27;s?%EXPORT_GLOBAL_GCOV_OPTIONS%?$(EXPORT_GLOBAL_GCOV_OPTIONS)?g&#x27;</span> <span class="variable">$@</span></span></span><br></pre></td></tr></table></figure>
<p>从注解可以看出如果<code>PRODUCT_BOOTCLASSPATH</code>变化了，init.environ.rc会重新生成。那么继续挖<code>PRODUCT_BOOTCLASSPATH</code>在哪里改变的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在build/make/core/dex_preopt.mk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> list of boot classpath jars <span class="keyword">for</span> dexpreopt</span></span><br><span class="line">DEXPREOPT_BOOT_JARS := $(subst $(space),:,$(PRODUCT_BOOT_JARS))</span><br><span class="line">DEXPREOPT_BOOT_JARS_MODULES := $(PRODUCT_BOOT_JARS)</span><br><span class="line">PRODUCT_BOOTCLASSPATH := $(subst $(space),:,$(foreach m,$(DEXPREOPT_BOOT_JARS_MODULES),/system/framework/$(m).jar))</span><br></pre></td></tr></table></figure>
<p>虽然看不大懂，但是从PRODUCT_BOOTCLASSPATH这一行我们大概都可以猜到逻辑，foreach遍历/system/framework/下的所有jar包，并且subst将遍历到的包名之间<strong>空格</strong>替换成**’ : ‘**。</p>
<p>从<code>PRODUCT_BOOTCLASSPATH</code>可以看到我们在系统中看到的环境遍历表示方式就类似于：**/system/framework/xx.jar:/system/framework/yy.jar:/system/framework/zz.jar**</p>
<p>然后看<code>DEXPREOPT_BOOT_JARS</code>猜这个标签就是<strong>收集所有的启动jar文件</strong>。继续顺藤grep。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在build/make/target/product/core_minimal.mk中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The order of PRODUCT_BOOT_JARS matters.</span></span><br><span class="line">PRODUCT_BOOT_JARS := \</span><br><span class="line">    core-oj \</span><br><span class="line">    core-libart \</span><br><span class="line">    conscrypt \</span><br><span class="line">    okhttp \</span><br><span class="line">    legacy-test \</span><br><span class="line">    bouncycastle \</span><br><span class="line">    ext \</span><br><span class="line">    framework \</span><br><span class="line">    telephony-common \</span><br><span class="line">    voip-common \</span><br><span class="line">    ims-common \</span><br><span class="line">    apache-xml \</span><br><span class="line">    org.apache.http.legacy.boot \</span><br><span class="line">    android.hidl.base-V1.0-java \</span><br><span class="line">    android.hidl.manager-V1.0-java</span><br></pre></td></tr></table></figure>
<p><strong>总结：在该文件里面定义那些module.jar需要放入环境变量中。后面根加载器就从环境变量中加载类。</strong>配置好之后，重新编系统试试吧。</p>
<h4 id="看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！"><a href="#看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！" class="headerlink" title="看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！"></a>看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！</h4><h5 id="4-2-自定义加载器"><a href="#4-2-自定义加载器" class="headerlink" title="4.2 自定义加载器"></a>4.2 自定义加载器</h5><p>自定义加载器其基本原来就是替换app中的pathclassloader。将需要加载的dex包路径告诉自定义加载器去加载。</p>
<p>该方案也可以用于应用热修复。</p>
<p><strong>该方案是20年了解热修复框架的时候写的demo代码。</strong>经过呕心吐血调试，终于将ui-framework没有加载到的WeatherChangeListener类加载到了。</p>
<p>测试结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6cbe934a5bd9d0b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dex中获取.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-95061835acd368ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从jar中获取.png"></p>
<p>该工程代码开源到我的github《<a href="https://github.com/oujie123/JVMClassLoader">JVMClassLoader</a>》上了，明天下来集成试试。</p>
<h4 id="注意：自定义加载器的方案应该是项目备选方案。"><a href="#注意：自定义加载器的方案应该是项目备选方案。" class="headerlink" title="注意：自定义加载器的方案应该是项目备选方案。"></a><strong>注意：自定义加载器的方案应该是项目备选方案。</strong></h4><p><strong>自定义加载器方案优点</strong>：稳定好使，但是需要应用集成<code>HotFix.installPatchDex(this,new File(patchPath));</code>这么一句代码。<br><strong>根加载器方案：</strong>ui-framework，car-framework作为公共组件库，还是应该采用4.1中描述的祖宗加载法，系统自动加载类，让应用零代码集成。</p>
<h4 id="自定义加载器代码：https-github-com-oujie123-JVMClassLoader"><a href="#自定义加载器代码：https-github-com-oujie123-JVMClassLoader" class="headerlink" title="自定义加载器代码：https://github.com/oujie123/JVMClassLoader"></a><strong>自定义加载器代码：</strong><a href="https://github.com/oujie123/JVMClassLoader">https://github.com/oujie123/JVMClassLoader</a></h4>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>桌面无法启动</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubunt下NDK编译手顺</title>
    <url>/2021/07/10/Ubunt%E4%B8%8BNDK%E7%BC%96%E8%AF%91%E6%89%8B%E9%A1%BA/</url>
    <content><![CDATA[<h4 id="1-安装sz和rz"><a href="#1-安装sz和rz" class="headerlink" title="1.安装sz和rz"></a>1.安装sz和rz</h4><blockquote>
<p>root 账号登陆后，依次执行以下命令：<br>wget <a href="http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz">http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</a><br>tar zxvf lrzsz-0.12.20.tar.gz<br>cd lrzsz-0.12.20<br>./configure &amp;&amp; make &amp;&amp; make install</p>
</blockquote>
<blockquote>
<p>上面安装过程默认把lsz和lrz安装到了/usr/local/bin/目录下，现在我们并不能直接使用， 下面创建软链接，并命名为rz/sz：<br>cd /usr/local/bin 【安装到这里来】<br>ln -s /usr/local/bin/lrz rz 【设置快捷方式    相当于win】<br>ln -s /usr/local/bin/lsz sz 【设置快捷方式    相当于win】</p>
</blockquote>
<h4 id="2-下载NDK"><a href="#2-下载NDK" class="headerlink" title="2.下载NDK"></a>2.下载NDK</h4><blockquote>
<p>//下载<br>wget <a href="https://dl.google.com/android/repository/android-ndk-r17c-linux-x86_64.zip">https://dl.google.com/android/repository/android-ndk-r17c-linux-x86_64.zip</a>? hl=zh_cn</p>
<p>//改名字<br>mv android-ndk-r17c-linux-x86_64.zip?hl=zh_cn  android-ndk-r17c-linux- x86_64.zip</p>
<p>// 解压<br>unzip android-ndk-r17c-linux- x86_64.zip</p>
</blockquote>
<h4 id="3-交叉编译"><a href="#3-交叉编译" class="headerlink" title="3.交叉编译"></a>3.交叉编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc</span></span><br><span class="line">export NDK_GCC=&quot;/home/jackou/tools/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-gcc&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --sysroot=路径（自动寻找    头文件，库文件.h/.a/.so）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -isystem 路径（自动寻找    头文件）</span></span><br><span class="line">export GCC_PATH=&quot;--sysroot=/home/jackou/tools/android-ndk-r17c/platforms/android-21/arch-arm64 -isystem /home/jackou/tools/android-ndk-r17c/sysroot/usr/include -isystem /home/jackou/tools/android-ndk-r17c/sysroot/usr/include/aarch64-linux-android&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_GCC -pie <span class="variable">$GCC_PATH</span> main.c -o mainexe</span></span><br></pre></td></tr></table></figure>


<h4 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4.配置环境变量"></a>4.配置环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">vim /etc/profile</span></span><br><span class="line"></span><br><span class="line">export NDK=&quot;/home/jackou/tools/android-ndk-r17c&quot;</span><br><span class="line"></span><br><span class="line">export PATH=$NDK:$PATH</span><br><span class="line"></span><br><span class="line">export NDK_GCC_arm_64=&quot;$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-gcc&quot;</span><br><span class="line"></span><br><span class="line">export NCK_CFIG_arm_64=&quot;--sysroot=$NDK/platforms/android-21/arch-arm64 -isystem $NDK/sysroot/usr/include -isystem $NDK/sysroot/usr/include/aarch64-linux-android&quot;</span><br></pre></td></tr></table></figure>


<h4 id="5-编译动态库"><a href="#5-编译动态库" class="headerlink" title="5.编译动态库"></a>5.编译动态库</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get.h 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;studio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;get.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">666</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_GCC_arm_64 <span class="variable">$NCK_CFIG_arm_64</span> -fPIC -shared get.c -o libgetndk.so</span></span><br></pre></td></tr></table></figure>


<h4 id="6-编译静态库"><a href="#6-编译静态库" class="headerlink" title="6.编译静态库"></a>6.编译静态库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置环境</span></span><br><span class="line">export NDK_AR_arm_64=&quot;$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux- x86_64/bin/aarch64-linux-android-ar&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成目标文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_GCC_arm_64 <span class="variable">$NCK_CFIG_arm_64</span> -fPIC -c get.c -o getndk.o</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成静态库</span></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_AR_arm_64 rcs -o libgetndk.a getndk.o</span> </span><br></pre></td></tr></table></figure>


<h4 id="7-AS引入库"><a href="#7-AS引入库" class="headerlink" title="7.AS引入库"></a>7.AS引入库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量导入</span> </span><br><span class="line">file(GLOB allCPP *.cpp) </span><br><span class="line">add_library( </span><br><span class="line">    native-lib </span><br><span class="line">    SHARED </span><br><span class="line">    $&#123;allCPP&#125;</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">find_library( </span><br><span class="line">    log-lib </span><br><span class="line">    log</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入静态库</span></span><br><span class="line">add_library(getndk STATIC IMPORTED) </span><br><span class="line"><span class="meta">#</span><span class="bash"> 真正导入    静态库</span> </span><br><span class="line">set_target_properties(getndk PROPERTIES IMPORTED_LOCATION </span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;CMAKE_SOURCE_DIR&#125;/libgetndk.a)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入动态库</span></span><br><span class="line">add_library(getndk SHARED IMPORTED) </span><br><span class="line">set_target_properties(getndk PROPERTIES IMPORTED_LOCATION </span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libgetndk.so)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>(CMAKE_CXX_FLAGS )</span> </span><br><span class="line"></span><br><span class="line">target_link_libraries( </span><br><span class="line">    native-lib </span><br><span class="line">    $&#123;log-lib&#125; </span><br><span class="line">    getndk # 链接此静态库到总库    libnative-lib.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>数字证书_证书格式说明_keystore</title>
    <url>/2021/07/08/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6-%E8%AF%81%E4%B9%A6%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E-keystore/</url>
    <content><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>X509就是数字证书的标准，规定了数字证书的格式。</p>
<p>PKCS，全称是公钥密码标准。</p>
<p>keystore是存放应用签名的文件，包含两个部分：</p>
<ul>
<li>密钥实体(key entity),私钥(secret key)或者私钥与配对的公钥。</li>
<li>可信任的证书实体（trusted certificate entries）——只包含公钥</li>
</ul>
<h4 id="2-证书格式"><a href="#2-证书格式" class="headerlink" title="2.证书格式"></a>2.证书格式</h4><p>[PKCS（Public-Key Cryptography Standards）](<a href="https://www.rsa.com/en-us/company/insight">RSA Insight and Thought Leadership – RSA Security</a>)是由美国RSA<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/3204964">数据安全</a>公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">数字签名</a>、<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81">数字信封</a>的格式等方面的一系列相关协议。</p>
<blockquote>
<p>PKCS 目前共发布过 15 个标准：</p>
<p>（1）PKCS#1：RSA加密标准。PKCS#1定义了RSA公钥函数的基本格式标准，特别是数字签名。它定义了数字签名如何计算，包括待签名数据和签名本身的格式；它也定义了PSA公/私钥的语法。</p>
<p>（2）PKCS#2：涉及了RSA的消息摘要加密，这已被并入PKCS#1中。</p>
<p>（3）PKCS#3：Diffie-Hellman密钥协议标准。PKCS#3描述了一种实现Diffie- Hellman密钥协议的方法。</p>
<p>（4）PKCS#4：最初是规定RSA密钥语法的，现已经被包含进PKCS#1中。</p>
<p>（5）PKCS#5：基于口令的加密标准。PKCS#5描述了使用由口令生成的密钥来加密8位位组串并产生一个加密的8位位组串的方法。PKCS#5可以用于加密私钥，以便于密钥的安全传输（这在PKCS#8中描述）。</p>
<p>（6）PKCS#6：扩展证书语法标准。PKCS#6定义了提供附加实体信息的X.509证书属性扩展的语法（当PKCS#6第一次发布时，X.509还不支持扩展。这些扩展因此被包括在X.509中）。</p>
<p>（7）PKCS#7：密码消息语法标准。PKCS#7为使用密码算法的数据规定了通用语法，比如数字签名和数字信封。PKCS#7提供了许多格式选项，包括未加密或签名的格式化消息、已封装（加密）消息、已签名消息和既经过签名又经过加密的消息。</p>
<p>（8）PKCS#8：私钥信息语法标准。PKCS#8定义了私钥信息语法和加密私钥语法，其中私钥加密使用了PKCS#5标准。</p>
<p>（9）PKCS#9：可选属性类型。PKCS#9定义了PKCS#6扩展证书、PKCS#7数字签名消息、PKCS#8私钥信息和PKCS#10证书签名请求中要用到的可选属性类型。已定义的证书属性包括E-mail地址、无格式姓名、内容类型、消息摘要、签名时间、签名副本（counter signature）、质询口令字和扩展证书属性。</p>
<p>（10）PKCS#10：证书请求语法标准。PKCS#10定义了证书请求的语法。证书请求包含了一个唯一识别名、公钥和可选的一组属性，它们一起被请求证书的实体签名（证书管理协议中的PKIX证书请求消息就是一个PKCS#10）。</p>
<p>（11）PKCS#11：密码令牌接口标准。PKCS#11或“Cryptoki”为拥有密码信息（如加密密钥和证书）和执行密码学函数的单用户设备定义了一个应用程序接口（API）。智能卡就是实现Cryptoki的典型设备。注意：Cryptoki定义了密码函数接口，但并未指明设备具体如何实现这些函数。而且Cryptoki只说明了密码接口，并未定义对设备来说可能有用的其他接口，如访问设备的文件系统接口。</p>
<p>（12）PKCS#12：个人信息交换语法标准。PKCS#12定义了个人身份信息（包括私钥、证书、各种秘密和扩展字段）的格式。PKCS#12有助于传输证书及对应的私钥，于是用户可以在不同设备间移动他们的个人身份信息。</p>
<p>（13）PDCS#13：椭圆曲线密码标准。PKCS#13标准当前正在完善之中。它包括椭圆曲线参数的生成和验证、密钥生成和验证、数字签名和公钥加密，还有密钥协定，以及参数、密钥和方案标识的ASN.1语法。</p>
<p>（14）PKCS#14：伪随机数产生标准。PKCS#14标准当前正在完善之中。为什么随机数生成也需要建立自己的标准呢？PKI中用到的许多基本的密码学函数，如密钥生成和Diffie-Hellman共享密钥协商，都需要使用随机数。然而，如果“随机数”不是随机的，而是取自一个可预测的取值集合，那么密码学函数就不再是绝对安全了，因为它的取值被限于一个缩小了的值域中。因此，安全伪随机数的生成对于PKI的安全极为关键。</p>
<p>（15）PKCS#15：密码令牌信息语法标准。PKCS#15通过定义令牌上存储的密码对象的通用格式来增进密码令牌的互操作性。在实现PKCS#15的设备上存储的数据对于使用该设备的所有应用程序来说都是一样的，尽管实际上在内部实现时可能所用的格式不同。PKCS#15的实现扮演了翻译家的角色，它在卡的内部格式与应用程序支持的数据格式间进行转换。</p>
</blockquote>
<p>X.509是一种非常通用的证书格式，X509就是数字证书的标准，规定了数字证书的格式。</p>
<blockquote>
<p>在一份证书中，必须证明<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%85%AC%E9%92%A5">公钥</a>及其所有者的姓名是一致的。对X.509证书来说，认证者总是<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/CA">CA</a>或由CA指定的人，一份X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。X.509标准定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的(即数据格式)。</p>
</blockquote>
<p>PKCS#7 常用的后缀是： .P7B .P7C .SPC<br>PKCS#12 常用的后缀有： .P12 .PFX<br>X.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT<br>X.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT<br>.cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥。<br>.pem跟crt/cer的区别是它以Ascii来表示。<br>pfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式<br>p10是证书请求<br>p7r是CA对证书请求的回复，只用于导入<br>p7b以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。</p>
<h4 id="3-证书生成方式"><a href="#3-证书生成方式" class="headerlink" title="3.证书生成方式"></a>3.证书生成方式</h4><p>3.1 用openssl创建CA证书的RSA密钥(PEM格式)：<br>openssl genrsa -des3 -out ca.key 1024</p>
<p>3.2 用openssl创建CA证书(PEM格式,假如有效期为一年)：<br>openssl req -new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf<br>openssl是可以生成DER格式的CA证书的，最好用IE将PEM格式的CA证书转换成DER格式的CA证书。</p>
<p>3.3 x509到pfx<br>pkcs12 -export –in keys/client1.crt -inkey keys/client1.key -out keys/client1.pfx</p>
<p>3.4  PEM格式的ca.key转换为Microsoft可以识别的pvk格式。<br> pvk -in ca.key -out ca.pvk -nocrypt -topvk</p>
<p>3.5 PKCS#12 到 PEM 的转换<br>openssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem<br>验证 openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</p>
<p>3.6 从 PFX 格式文件中提取私钥格式文件 (.key)<br>openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key</p>
<p>3.7 转换 pem 到到 spc<br>openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc<br>用 -outform -inform 指定 DER 还是 PAM 格式。例如：<br>openssl x509 -in Cert.pem -inform PEM -out cert.der -outform DER</p>
<p>3.8 PEM 到 PKCS#12 的转换，<br>openssl pkcs12 -export -in Cert.pem -out Cert.p12 -inkey key.pem</p>
<h4 id="4-密钥库文件格式【Keystore】"><a href="#4-密钥库文件格式【Keystore】" class="headerlink" title="4.密钥库文件格式【Keystore】"></a>4.密钥库文件格式【Keystore】</h4><p> 格式   : JKS<br> 扩展名 : .jks/.ks<br> 描述   : 【Java Keystore】密钥库的Java实现版本，provider为SUN<br> 特点   : 密钥库和私钥用不同的密码进行保护</p>
<p> 格式   : JCEKS<br> 扩展名 : .jce<br> 描述   : 【JCE Keystore】密钥库的JCE实现版本，provider为SUN JCE<br> 特点   : 相对于JKS安全级别更高，保护Keystore私钥时采用TripleDES</p>
<p> 格式   : PKCS12<br> 扩展名 : .p12/.pfx<br> 描述   : 【PKCS #12】个人信息交换语法标准<br> 特点   : 1、包含私钥、公钥及其证书<br>        2、密钥库和私钥用相同密码进行保护</p>
<p> 格式   : BKS<br> 扩展名 : .bks<br> 描述   : Bouncycastle Keystore】密钥库的BC实现版本，provider为BC<br> 特点   : 基于JCE实现</p>
<p> 格式   : UBER<br> 扩展名 : .ubr<br> 描述   : 【Bouncycastle UBER Keystore】密钥库的BC更安全实现版本，provider为BC</p>
<h4 id="5-证书文件格式【Certificate】"><a href="#5-证书文件格式【Certificate】" class="headerlink" title="5.证书文件格式【Certificate】"></a>5.证书文件格式【Certificate】</h4><p>格式     : DER<br>扩展名    : .cer/.crt/.rsa</p>
<p>描述     : 【ASN .1 DER】用于存放证书<br>特点     : 不含私钥、二进制</p>
<p>格式     : PKCS7<br>扩展名    : .p7b/.p7r<br>描述     : 【PKCS #7】加密信息语法标准</p>
<p>特点     : 1、p7b以树状展示证书链，不含私钥<br>         2、p7r为CA对证书请求签名的回复，只能用于导入</p>
<p>格式     : CMS<br>扩展名    : .p7c/.p7m/.p7s<br>描述     : 【Cryptographic Message Syntax】<br>特点     : 1、p7c只保存证书<br>         2、p7m：signature with enveloped data<br>         3、p7s：时间戳签名文件</p>
<p>格式     : PEM<br>扩展名    : .pem<br>描述     : 【Printable Encoded Message】<br>特点     : 1、该编码格式在RFC1421中定义，其实PEM是【Privacy-Enhanced Mail】的简写，但他也同样广泛运用于密钥管理<br>         2、ASCII文件<br>         3、一般基于base 64编码</p>
<p>格式     :  PKCS10<br>扩展名   : .p10/.csr<br>描述     : 【PKCS #10】公钥加密标准【Certificate Signing Request】<br>特点     : 1、证书签名请求文件<br>         2、ASCII文件<br>         3、CA签名后以p7r文件回复</p>
<p>格式     : SPC<br>扩展名   : .pvk/.spc<br>描述     : 【Software Publishing Certificate】<br>特点     : 微软公司特有的双证书文件格式，经常用于代码签名，其中<br>         1、pvk用于保存私钥<br>         2、spc用于保存公钥</p>
<h4 id="6-生成证书"><a href="#6-生成证书" class="headerlink" title="6.生成证书"></a>6.生成证书</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./development/tools/make_key  mytest &#x27;/C=CN/ST=YourProvince/L=YourLocation/O=YourOrganization/OU=YourOrganizationalUnit/CN=YourName&#x27;</span><br></pre></td></tr></table></figure>
<p>使用如上命令会在当前目录下生成一个二进制形式（DER）的私钥文件“mytest.pk8”和一个对应的公钥证书文件“mytest.x509.pem”。</p>
<p>其中，/C表示“Country Code”，/ST表示“State or Province”，/L表示“City or Locality”，/O表示“Organization”，/OU表示“Organizational Unit”，/CN表示“Name”</p>
<p>生成.pk8和.pem之后就可以使用如下指令对apk进行签名</p>
<blockquote>
<p>签名：java -jar signapk.jar platform.x509.pem platform.pk8 Gaei_Setting.apk Gaei_Setting_sign.apk<br>验证签名：jarsigner -verify -verbose -certs *.apk</p>
</blockquote>
<p>也可以制作keystore直接在android studio中签名</p>
<blockquote>
<p>(1) 生成platform.pem文件<br>openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out platform.pem<br>(2) 生成platform.p12文件，设置别名和密码，即AS打包APK时输入的别名和密码<br>openssl pkcs12 -export -in platform.x509.pem -out platform.p12 -inkey platform.pem -password pass:android -name key<br>(3) 生成platform.jks(钥匙文件) （-srcstorepass android）是.jks文件的密码<br>keytool -importkeystore -deststorepass android -destkeystore ./platform.jks -srckeystore ./platform.p12 -srcstoretype PKCS12 -srcstorepass android<br>(4) 生成PKCS12格式的jks<br>keytool -importkeystore -srckeystore ./platform.jks -destkeystore ./platform.jks -deststoretype pkcs12</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>编译集成ffmpeg</title>
    <url>/2021/07/12/%E7%BC%96%E8%AF%91%E9%9B%86%E6%88%90ffmpeg/</url>
    <content><![CDATA[<h4 id="1-下载ffmpeg"><a href="#1-下载ffmpeg" class="headerlink" title="1.下载ffmpeg"></a>1.下载ffmpeg</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://www.ffmpeg.org/releases/ffmpeg-4.0.2.tar.bz2</span><br><span class="line">tar -xjf ffmpeg-4.0.2.tar.bz2</span><br></pre></td></tr></table></figure>


<h4 id="2-编译选项说明"><a href="#2-编译选项说明" class="headerlink" title="2.编译选项说明"></a>2.编译选项说明</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存选项到本地</span></span><br><span class="line">./configure --help -&gt; ffmpeg_help.txt</span><br><span class="line"></span><br><span class="line">Help options: </span><br><span class="line">–help print this message # 帮助选项 </span><br><span class="line">–quiet Suppress showing informative output # 信息输出显示 </span><br><span class="line">–list-decoders show all available decoders # 可用解码器 </span><br><span class="line">–list-encoders show all available encoders # 可用编码器 </span><br><span class="line">–list-hwaccels show all available hardware accelerators # 可用硬件编解码器 </span><br><span class="line">–list-demuxers show all available demuxers # 可用解复用 </span><br><span class="line">–list-muxers show all available muxers # 可用复用器 </span><br><span class="line">–list-parsers show all available parsers # 可用解析器 </span><br><span class="line">–list-protocols show all available protocols # 可用协议 </span><br><span class="line">–list-bsfs show all available bitstream filters # 可用比特流过滤器 </span><br><span class="line">–list-indevs show all available input devices # 可用输入设备 </span><br><span class="line">–list-outdevs show all available output devices # 可用输出设备 </span><br><span class="line">–list-filters show all available filters # 可用过滤器 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一般选项</span> </span><br><span class="line">Standard options: </span><br><span class="line">–logfile=FILE log tests and output to FILE [config.log] # 生成指定的log文件 </span><br><span class="line">–disable-logging do not log configure debug information # 禁止调试信息 </span><br><span class="line">–fatal-warnings fail if any configure warning is generated # 任何警告则失败 </span><br><span class="line">–prefix=PREFIX install in PREFIX [$prefix_default] # 安装目录 </span><br><span class="line">–bindir=DIR install binaries in DIR [PREFIX/bin] # exe和dll安装目录 </span><br><span class="line">–datadir=DIR install data files in DIR [PREFIX/share/ffmpeg] # 数据安装目录 </span><br><span class="line">–docdir=DIR install documentation in DIR [PREFIX/share/doc/ffmpeg]# 文档安装目录 –libdir=DIR install libs in DIR [PREFIX/lib] # 静态库安装目录 </span><br><span class="line">–shlibdir=DIR install shared libs in DIR [LIBDIR] # 共享库安装目录 </span><br><span class="line">–incdir=DIR install includes in DIR [PREFIX/include] # 头文件安装目录 </span><br><span class="line">–mandir=DIR install man page in DIR [PREFIX/share/man] # 帮助文档安装目录 </span><br><span class="line">–pkgconfigdir=DIR install pkg-config files in DIR [LIBDIR/pkgconfig] # pkg- config安装目录 </span><br><span class="line">–enable-rpath use rpath to allow installing libraries in paths # 调用程序所用目录 not part of the dynamic linker search path </span><br><span class="line">use rpath when linking programs (USE WITH CARE) </span><br><span class="line">–install-name-dir=DIR Darwin directory name for installed targets </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 许可选项</span> </span><br><span class="line">Licensing options: </span><br><span class="line">–enable-gpl allow use of GPL code, the resulting libs # 允许使用GPL </span><br><span class="line">and binaries will be under GPL [no] </span><br><span class="line">–enable-version3 upgrade (L)GPL to version 3 [no] # 更新GPL版本 </span><br><span class="line">–enable-nonfree allow use of nonfree code, the resulting libs # 允许使用非免费程序 and binaries will be unredistributable [no] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置选项</span> </span><br><span class="line">Configuration options: </span><br><span class="line">–disable-static do not build static libraries [no] # 禁止静态库 </span><br><span class="line">–enable-shared build shared libraries [no] # 启用共享库 </span><br><span class="line">–enable-small optimize for size instead of speed # 启用最小尺寸而非速度</span><br><span class="line">–disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary) # 禁用实时的CPU效率检测 </span><br><span class="line">–enable-gray enable full grayscale support (slower color) # 启用灰度(颜色、空间转换) –disable-swscale-alpha disable alpha channel support in swscale # 禁用swscale中的 透明度 </span><br><span class="line">–disable-all disable building components, libraries and programs # 禁用所有，包括组 件、库、程序 </span><br><span class="line">–enable-raise-major increase major version numbers in sonames [no] # 提升版本号 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 项目选项</span> </span><br><span class="line">Program options: </span><br><span class="line">–disable-programs do not build command line programs # 禁止生成所有exe </span><br><span class="line">–disable-ffmpeg disable ffmpeg build # 禁止生成ffmpeg.exe </span><br><span class="line">–disable-ffplay disable ffplay build # 禁止生成ffplay.exe </span><br><span class="line">–disable-ffprobe disable ffprobe build # 禁止生成ffprobe.exe </span><br><span class="line">–disable-ffserver disable ffserver build # 禁止生成ffserver.exe </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文档选项</span> </span><br><span class="line">Documentation options: </span><br><span class="line">–disable-doc do not build documentation # 禁止生成doc文件 </span><br><span class="line">–disable-htmlpages do not build HTML documentation pages # 禁止生成HTML文档页 </span><br><span class="line">–disable-manpages do not build man documentation pages # 禁止生成帮助文档页 </span><br><span class="line">–disable-podpages do not build POD documentation pages # 禁止生成POD文档页 </span><br><span class="line">–disable-txtpages do not build text documentation pages # 禁止生成txt文档页 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 组件选项</span> </span><br><span class="line">Component options: </span><br><span class="line">–disable-avdevice disable libavdevice build # 禁止libavdevice构造 </span><br><span class="line">–disable-avcodec disable libavcodec build # 禁止libavcodec构造 </span><br><span class="line">–disable-avformat disable libavformat build # 禁止libavformat构造 </span><br><span class="line">–disable-swresample disable libswresample build # 禁止libswresample构造 </span><br><span class="line">–disable-swscale disable libswscale build # 禁止libswscale构造 </span><br><span class="line">–disable-postproc disable libpostproc build # 禁止libpostproc构造 </span><br><span class="line">–disable-avfilter disable libavfilter build # 禁止libavfilter构造 </span><br><span class="line">–enable-avresample enable libavresample build [no] # 允许libavresample构造 </span><br><span class="line">–disable-pthreads disable pthreads [autodetect] # 禁止pthread构造 </span><br><span class="line">–disable-w32threads disable Win32 threads [autodetect] # 禁止使用win32线程 </span><br><span class="line">–disable-os2threads disable OS/2 threads [autodetect] # 禁止使用OS/2线程 </span><br><span class="line">–disable-network disable network support [no] # 禁止网络支持 </span><br><span class="line">–disable-dct disable DCT code # 禁止DCT代码 </span><br><span class="line">–disable-dwt disable DWT code # 禁止DWT代码 </span><br><span class="line">–disable-error-resilience disable error resilience code # 禁止纠错 </span><br><span class="line">–disable-lsp disable LSP code # 禁止行同步脉冲 </span><br><span class="line">–disable-lzo disable LZO decoder code # 禁止LZO压缩编码 </span><br><span class="line">–disable-mdct disable MDCT code # 禁止修正离散余弦变换 </span><br><span class="line">–disable-rdft disable RDFT code # 禁止实数离散傅里叶变换 </span><br><span class="line">–disable-fft disable FFT code # 禁止快速傅氏变换算法 </span><br><span class="line">–disable-faan disable floating point AAN (I)DCT code # 禁止AAN DCT变换 </span><br><span class="line">–disable-pixelutils disable pixel utils in libavutil # 禁用avutil中的像素单元 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单个组件选项</span> </span><br><span class="line">Individual component options: </span><br><span class="line">–disable-everything disable all components listed below # 禁用下面已列出的全部组件 –disable-encoder=NAME disable encoder NAME # 禁用指定的编码器 </span><br><span class="line">–enable-encoder=NAME enable encoder NAME # 启用指定的编码器 </span><br><span class="line">–disable-encoders disable all encoders # 禁用所有的编码器 </span><br><span class="line">–disable-decoder=NAME disable decoder NAME # 禁用指定的解码器 </span><br><span class="line">–enable-decoder=NAME enable decoder NAME # 启用指定的解码器</span><br><span class="line">–disable-decoders disable all decoders # 禁用所有的解码器 </span><br><span class="line">–disable-hwaccel=NAME disable hwaccel NAME # 禁用指定的硬件加速 </span><br><span class="line">–enable-hwaccel=NAME enable hwaccel NAME # 启用指定的硬件加速 </span><br><span class="line">–disable-hwaccels disable all hwaccels # 禁用全部的硬件加速 </span><br><span class="line">–disable-muxer=NAME disable muxer NAME # 禁用指定的混合器 </span><br><span class="line">–enable-muxer=NAME enable muxer NAME # 启用指定的混合器 </span><br><span class="line">–disable-muxers disable all muxers # 禁用所有的混合器 </span><br><span class="line">–disable-demuxer=NAME disable demuxer NAME # 禁用指定的解复用器 </span><br><span class="line">–enable-demuxer=NAME enable demuxer NAME # 启用指定的解复用器 </span><br><span class="line">–disable-demuxers disable all demuxers # 禁用所有的解复用器 </span><br><span class="line">–enable-parser=NAME enable parser NAME # 启用指定的分析器 </span><br><span class="line">–disable-parser=NAME disable parser NAME # 禁用指定的分析器 </span><br><span class="line">–disable-parsers disable all parsers # 禁用所有的分析器 </span><br><span class="line">–enable-bsf=NAME enable bitstream filter NAME # 启用指定的流过滤器 </span><br><span class="line">–disable-bsf=NAME disable bitstream filter NAME # 禁用指定的流过滤器 </span><br><span class="line">–disable-bsfs disable all bitstream filters # 禁用所有的流过滤器 </span><br><span class="line">–enable-protocol=NAME enable protocol NAME # 启用指定的协议 </span><br><span class="line">–disable-protocol=NAME disable protocol NAME # 禁用指定的协议 </span><br><span class="line">–disable-protocols disable all protocols # 禁用所有的协议 </span><br><span class="line">–enable-indev=NAME enable input device NAME # 启用指定的输入设备 </span><br><span class="line">–disable-indev=NAME disable input device NAME # 禁用指定的输入设备 </span><br><span class="line">–disable-indevs disable input devices # 禁用输入设备 </span><br><span class="line">–enable-outdev=NAME enable output device NAME # 启用指定的输出设备 </span><br><span class="line">–disable-outdev=NAME disable output device NAME# 禁用指定的输出设备 </span><br><span class="line">–disable-outdevs disable output devices # 禁用输出设备 </span><br><span class="line">–disable-devices disable all devices # 禁用所有设备 </span><br><span class="line">–enable-filter=NAME enable filter NAME # 启用指定的过滤器 </span><br><span class="line">–disable-filter=NAME disable filter NAME # 禁用指定的过滤器 </span><br><span class="line">–disable-filters disable all filters # 禁用所有的过滤器 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加依赖库支持</span> </span><br><span class="line">External library support: </span><br><span class="line">Using any of the following switches will allow FFmpeg to link to the corresponding external library. All the components depending on that library will become enabled, if all their other dependencies are met and they are not explicitly disabled. E.g. –enable-libwavpack will enable linking to libwavpack and allow the libwavpack encoder to be built, unless it is specifically disabled with  –disable-encoder=libwavpack.</span><br><span class="line">Note that only the system libraries are auto-detected. All the other external libraries must be explicitly enabled. </span><br><span class="line">Also note that the following help text describes the purpose of the libraries themselves, not all their features will necessarily be usable by FFmpeg. </span><br><span class="line">–enable-avisynth enable reading of AviSynth script files [no] # 启用读取AVISynth脚 本文件 </span><br><span class="line">–disable-bzlib disable bzlib [autodetect] # 启用bzlib </span><br><span class="line">–enable-chromaprint enable audio fingerprinting with chromaprint [no] # 启用音频指 纹技术 </span><br><span class="line">–enable-frei0r enable frei0r video filtering [no] # 启用frei0r视频筛选 </span><br><span class="line">–enable-gcrypt enable gcrypt, needed for rtmp(t)e support # 启用加密 </span><br><span class="line">if openssl, librtmp or gmp is not used [no] </span><br><span class="line">–enable-gmp enable gmp, needed for rtmp(t)e support # 启用gmp </span><br><span class="line">if openssl or librtmp is not used [no] </span><br><span class="line">–enable-gnutls enable gnutls, needed for https support # 启用gnutls </span><br><span class="line">if openssl is not used [no]</span><br><span class="line">–disable-iconv disable iconv [autodetect] # 禁用iconv </span><br><span class="line">–enable-jni enable JNI support [no] # 启用JNI支持 </span><br><span class="line">–enable-ladspa enable LADSPA audio filtering [no] # 启用LADSPA音频过滤 </span><br><span class="line">–enable-libass enable libass subtitles rendering, # 启用libass </span><br><span class="line">needed for subtitles and ass filter [no] </span><br><span class="line">–enable-libbluray enable BluRay reading using libbluray [no] # 启用libbluray </span><br><span class="line">–enable-libbs2b enable bs2b DSP library [no] # 启用bs2b DSP库 </span><br><span class="line">–enable-libcaca enable textual display using libcaca [no] # 启用libcaca用于文本显示 –enable-libcelt enable CELT decoding via libcelt [no] # 启用CEKT解码 </span><br><span class="line">–enable-libcdio enable audio CD grabbing with libcdio [no] # 通过libcdio启用音频CD –enable-libdc1394 enable IIDC-1394 grabbing using libdc1394 # 启用libdc1394 </span><br><span class="line">and libraw1394 [no] </span><br><span class="line">–enable-libfdk-aac enable AAC de/encoding via libfdk-aac [no] # 启用libfdk-aac解 码/编码 </span><br><span class="line">–enable-libflite enable flite (voice synthesis) support via libflite [no] # 启用 libflite </span><br><span class="line">–enable-libfontconfig enable libfontconfig, useful for drawtext filter [no] # 启 用libfontconfig </span><br><span class="line">–enable-libfreetype enable libfreetype, needed for drawtext filter [no]# 启用 libfreetype </span><br><span class="line">–enable-libfribidi enable libfribidi, improves drawtext filter [no] # 启用 libfribidi，改善绘画过滤 </span><br><span class="line">–enable-libgme enable Game Music Emu via libgme [no] # 启用libgme </span><br><span class="line">–enable-libgsm enable GSM de/encoding via libgsm [no] # 启用libgsm做GSM编/解码 </span><br><span class="line">–enable-libiec61883 enable iec61883 via libiec61883 [no] # 启用libiec61883 </span><br><span class="line">–enable-libilbc enable iLBC de/encoding via libilbc [no] # 启用libilbc做iLBC编/解码 –enable-libkvazaar enable HEVC encoding via libkvazaar [no] # 启用libkvazaar做HEVC 编码 </span><br><span class="line">–enable-libmodplug enable ModPlug via libmodplug [no] # 启用ModPlug通过libmodplug –enable-libmp3lame enable MP3 encoding via libmp3lame [no] # 启用MP3编码通过 </span><br><span class="line">libmp3lame </span><br><span class="line">–enable-libnut enable NUT (de)muxing via libnut, # 启用NUT解复用通过libnut </span><br><span class="line">native (de)muxer exists [no] </span><br><span class="line">–enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no] # 启用ARN-NB解/编码 </span><br><span class="line">–enable-libopencore-amrwb enable AMR-WB decoding via libopencore-amrwb [no] # 启 用ARM-WB解码 </span><br><span class="line">–enable-libopencv enable video filtering via libopencv [no] # 启用视频过滤通过 opencv </span><br><span class="line">–enable-libopenh264 enable H.264 encoding via OpenH264 [no] # 启用H.264编码 </span><br><span class="line">–enable-libopenjpeg enable JPEG 2000 de/encoding via OpenJPEG [no] # 启用JPEG编解 码 </span><br><span class="line">–enable-libopenmpt enable decoding tracked files via libopenmpt [no] # 启用解码文件 通过libopenmpt </span><br><span class="line">–enable-libopus enable Opus de/encoding via libopus [no] # 启用Oplus编解码 </span><br><span class="line">–enable-libpulse enable Pulseaudio input via libpulse [no] # 启用Pulse输入 </span><br><span class="line">–enable-librubberband enable rubberband needed for rubberband filter [no] # 启用 rubberband </span><br><span class="line">–enable-librtmp enable RTMP[E] support via librtmp [no] # 启用RTMP支持通过librtmp –enable-libschroedinger enable Dirac de/encoding via libschroedinger [no] # 启用 Dirac编解码通过libschroedinger </span><br><span class="line">–enable-libshine enable fixed-point MP3 encoding via libshine [no] # 启用libshine 固定MP3点 </span><br><span class="line">–enable-libsmbclient enable Samba protocol via libsmbclient [no] # 启用Samba协议 –enable-libsnappy enable Snappy compression, needed for hap encoding [no] # 启用 Snappy压缩 </span><br><span class="line">–enable-libsoxr enable Include libsoxr resampling [no] # 启用libsoxr采样 </span><br><span class="line">–enable-libspeex enable Speex de/encoding via libspeex [no] # 启用Speex编解码</span><br><span class="line">–enable-libssh enable SFTP protocol via libssh [no] # 启用SFTP协议 </span><br><span class="line">–enable-libtesseract enable Tesseract, needed for ocr filter [no] # 启用Tesseract –enable-libtheora enable Theora encoding via libtheora [no] # 启用Theora编码 </span><br><span class="line">–enable-libtwolame enable MP2 encoding via libtwolame [no] # 启用MP2编码 </span><br><span class="line">–enable-libv4l2 enable libv4l2/v4l-utils [no] # 启用libv412 </span><br><span class="line">–enable-libvidstab enable video stabilization using vid.stab [no] # 启用 libvidstab </span><br><span class="line">–enable-libvo-amrwbenc enable AMR-WB encoding via libvo-amrwbenc [no] # 启用AMR- WB </span><br><span class="line">–enable-libvorbis enable Vorbis en/decoding via libvorbis, # 启用Vorbis编解码 native implementation exists [no] </span><br><span class="line">–enable-libvpx enable VP8 and VP9 de/encoding via libvpx [no] # 启用VP8/VP9编解码 –enable-libwavpack enable wavpack encoding via libwavpack [no] # 启用wavpack编码 –enable-libwebp enable WebP encoding via libwebp [no] # 启用WbebP编码 </span><br><span class="line">–enable-libx264 enable H.264 encoding via x264 [no] # 启用H.264编码 </span><br><span class="line">–enable-libx265 enable HEVC encoding via x265 [no] # 启用HEVC编码 </span><br><span class="line">–enable-libxavs enable AVS encoding via xavs [no] # 启用AVS编码 </span><br><span class="line">–enable-libxcb enable X11 grabbing using XCB [autodetect] # 启用X11 </span><br><span class="line">–enable-libxcb-shm enable X11 grabbing shm communication [autodetect] # 启用X11 –enable-libxcb-xfixes enable X11 grabbing mouse rendering [autodetect] # 启用X11 –enable-libxcb-shape enable X11 grabbing shape rendering [autodetect] # 启用X11 –enable-libxvid enable Xvid encoding via xvidcore, # 启用Xvid编码 </span><br><span class="line">native MPEG-4/Xvid encoder exists [no] </span><br><span class="line">–enable-libzimg enable z.lib, needed for zscale filter [no] # 启用z.lib </span><br><span class="line">–enable-libzmq enable message passing via libzmq [no] # 启用消息传递通过libzmq </span><br><span class="line">–enable-libzvbi enable teletext support via libzvbi [no] # 启用文本支持 </span><br><span class="line">–disable-lzma disable lzma [autodetect] # 禁用lzma </span><br><span class="line">–enable-decklink enable Blackmagic DeckLink I/O support [no] # 启用阻塞IO支持 </span><br><span class="line">–enable-mediacodec enable Android MediaCodec support [no] # 启用安卓MediaCodec支持 –enable-netcdf enable NetCDF, needed for sofalizer filter [no] # 启用NetCDF </span><br><span class="line">–enable-openal enable OpenAL 1.1 capture support [no] # 启用OpenAL1.1采集支持 </span><br><span class="line">–enable-opencl enable OpenCL code # 启用OpenCL代码 </span><br><span class="line">–enable-opengl enable OpenGL rendering [no] # 启用OpenGL </span><br><span class="line">–enable-openssl enable openssl, needed for https support # 启用openssl，需支持https if gnutls is not used [no] </span><br><span class="line">–disable-schannel disable SChannel SSP, needed for TLS support on # 启用SSP Windows if openssl and gnutls are not used [autodetect] </span><br><span class="line">–disable-sdl2 disable sdl2 [autodetect] # 禁用sdl2 </span><br><span class="line">–disable-securetransport disable Secure Transport, needed for TLS support # 禁用安 全传输 </span><br><span class="line">on OSX if openssl and gnutls are not used [autodetect] </span><br><span class="line">–disable-xlib disable xlib [autodetect] # 禁用xlib </span><br><span class="line">–disable-zlib disable zlib [autodetect] # 禁用zlib </span><br><span class="line">The following libraries provide various hardware acceleration features: </span><br><span class="line">–disable-audiotoolbox disable Apple AudioToolbox code [autodetect] # 禁用苹果音频工 具箱 </span><br><span class="line">–disable-cuda disable dynamically linked Nvidia CUDA code [autodetect] # 禁用CUDA 编程 </span><br><span class="line">–disable-cuvid disable Nvidia CUVID support [autodetect] # 启用Nvidia CUVID </span><br><span class="line">–disable-d3d11va disable Microsoft Direct3D 11 video acceleration code </span><br><span class="line">[autodetect] # 禁用微软Direct3D 11视频加速 </span><br><span class="line">–disable-dxva2 disable Microsoft DirectX 9 video acceleration code [autodetect] # 禁用微软錎irectX视频加速 </span><br><span class="line">–enable-libmfx enable Intel MediaSDK (AKA Quick Sync Video) code via libmfx [no] # 启用Intel音频SDk </span><br><span class="line">–enable-libnpp enable Nvidia Performance Primitives-based code [no] # 启用Nvidia性 能代码</span><br><span class="line">–enable-mmal enable Broadcom Multi-Media Abstraction Layer (Raspberry Pi) via MMAL [no] # 启用网络多媒体结构层 </span><br><span class="line">–disable-nvenc disable Nvidia video encoding code [autodetect] # 禁用Nvidia视频编码 –enable-omx enable OpenMAX IL code [no] # 启用OpenMAX IL代码 </span><br><span class="line">–enable-omx-rpi enable OpenMAX IL code for Raspberry Pi [no] # 启用OpenMAX IL代码 –disable-vaapi disable Video Acceleration API (mainly Unix/Intel) code </span><br><span class="line">[autodetect] # 禁用视频加速API </span><br><span class="line">–disable-vda disable Apple Video Decode Acceleration code [autodetect] # 禁用苹果 视频解码加速代码 </span><br><span class="line">–disable-vdpau disable Nvidia Video Decode and Presentation API for Unix code </span><br><span class="line">[autodetect] # 禁用Nvidia视频编码和表达API </span><br><span class="line">–disable-videotoolbox disable VideoToolbox code [autodetect] # 禁用视频工具箱代码 编译工具选项 </span><br><span class="line">Toolchain options: </span><br><span class="line">–arch=ARCH select architecture [$arch] # 选择架构 </span><br><span class="line">–cpu=CPU select the minimum required CPU (affects instruction selection, may crash on older CPUs) # 选择CPU </span><br><span class="line">–cross-prefix=PREFIX use PREFIX for compilation tools [$cross_prefix] # 交叉编译工 具目录 </span><br><span class="line">–progs-suffix=SUFFIX program name suffix [] # 程序后缀名 </span><br><span class="line">–enable-cross-compile assume a cross-compiler is used # 启用交叉编译 </span><br><span class="line">–sysroot=PATH root of cross-build tree # 交叉编译根目录 </span><br><span class="line">–sysinclude=PATH location of cross-build system headers # 交叉编译头文件目录 </span><br><span class="line">–target-os=OS compiler targets OS [$target_os] # 交叉编译的目标系统 </span><br><span class="line">–target-exec=CMD command to run executables on target # 交叉编译启动程序命令 </span><br><span class="line">–target-path=DIR path to view of build directory on target # 交叉编译的安装目录 </span><br><span class="line">–target-samples=DIR path to samples directory on target # 交叉编译samples存放目录 –tempprefix=PATH force fixed dir/prefix instead of mktemp for checks # 交叉编译的 temp目录 </span><br><span class="line">–toolchain=NAME set tool defaults according to NAME # 编译工具 </span><br><span class="line">–nm=NM use nm tool NM [$nm_default] </span><br><span class="line">–ar=AR use archive tool AR [$ar_default] </span><br><span class="line">–as=AS use assembler AS [$as_default] </span><br><span class="line">–ln_s=LN_S use symbolic link tool LN_S [$ln_s_default] </span><br><span class="line">–strip=STRIP use strip tool STRIP [$strip_default] </span><br><span class="line">–windres=WINDRES use windows resource compiler WINDRES [$windre_default] </span><br><span class="line">–yasmexe=EXE use yasm-compatible assembler EXE [$yasmexe_default]# 使用yasm编译 –cc=CC use C compiler CC [$cc_default] # 使用gcc编译 </span><br><span class="line">–cxx=CXX use C compiler CXX [$cxx_default] # 使用g++编译 </span><br><span class="line">–objcc=OCC use ObjC compiler OCC [$cc_default] # 使用object C编译工具occ编译 </span><br><span class="line">–dep-cc=DEPCC use dependency generator DEPCC [$cc_default] # 使用依赖生成DEPCC </span><br><span class="line">–ld=LD use linker LD [$ld_default] # 使用连接LD </span><br><span class="line">–pkg-config=PKGCONFIG use pkg-config tool PKGCONFIG [$pkg_config_default] # 使用 pkg-config工具 </span><br><span class="line">–pkg-config-flags=FLAGS pass additional flags to pkgconf [] # 传递额外标志到pkg- config </span><br><span class="line">–ranlib=RANLIB use ranlib RANLIB [$ranlib_default] # 使用RANLIB </span><br><span class="line">–doxygen=DOXYGEN use DOXYGEN to generate API doc [$doxygen_default] # 生成doxygen 文档 </span><br><span class="line">–host-cc=HOSTCC use host C compiler HOSTCC # 使用HOST c编译 </span><br><span class="line">–host-cflags=HCFLAGS use HCFLAGS when compiling for host # 使用HCFLAGS </span><br><span class="line">–host-cppflags=HCPPFLAGS use HCPPFLAGS when compiling for host # 使用HCPPFLAGSS –host-ld=HOSTLD use host linker HOSTLD # 使用host连接器 </span><br><span class="line">–host-ldflags=HLDFLAGS use HLDFLAGS when linking for host # 使用HLDFLAGS </span><br><span class="line">–host-libs=HLIBS use libs HLIBS when linking for host # 使用HLIBS </span><br><span class="line">–host-os=OS compiler host OS [$target_os] # 编译主机系统 </span><br><span class="line">–extra-cflags=ECFLAGS add ECFLAGS to CFLAGS [$CFLAGS] # 添加ECFLAGS到CFLAGS</span><br><span class="line">–extra-cxxflags=ECFLAGS add ECFLAGS to CXXFLAGS [$CXXFLAGS] # 添加ECFLAGS到 CXXFLAGS </span><br><span class="line">–extra-objcflags=FLAGS add FLAGS to OBJCFLAGS [$CFLAGS] # 添加FLAGS到OBJCFLAGS –extra-ldflags=ELDFLAGS add ELDFLAGS to LDFLAGS [\$LDFLAGS] # 添加ELDFLAGS到 LDFLAGS </span><br><span class="line">–extra-ldexeflags=ELDFLAGS add ELDFLAGS to LDEXEFLAGS [\$LDEXEFLAGS] # 添加 ELDFLAGS到LDEXEFLAGS </span><br><span class="line">–extra-ldlibflags=ELDFLAGS add ELDFLAGS to LDLIBFLAGS [\$LDLIBFLAGS] # 添加 ELDFLAGS到LDLIBFLAGS </span><br><span class="line">–extra-libs=ELIBS add ELIBS [\$ELIBS] # 添加ELIBS </span><br><span class="line">–extra-version=STRING version string suffix [] # 添加版本 </span><br><span class="line">–optflags=OPTFLAGS override optimization-related compiler flags # 重写优化编译标志 –build-suffix=SUFFIX library name suffix [] # 添加库名字路径 </span><br><span class="line">–enable-pic build position-independent code # 添加位置独立代码 </span><br><span class="line">–enable-thumb compile for Thumb instruction set # 编译錞humb指令集 </span><br><span class="line">–enable-lto use link-time optimization # 使用连接时优化 </span><br><span class="line">–env=”ENV=override” override the environment variables # 重写环境变量 </span><br><span class="line">高级选项 </span><br><span class="line">Advanced options (experts only): </span><br><span class="line">–malloc-prefix=PREFIX prefix malloc and related names with PREFIX # 申请路径 </span><br><span class="line">–custom-allocator=NAME use a supported custom allocator # 申请名字 </span><br><span class="line">–disable-symver disable symbol versioning # 禁用symver </span><br><span class="line">–enable-hardcoded-tables use hardcoded tables instead of runtime generation # 启 用硬件编码表 </span><br><span class="line">–disable-safe-bitstream-reader # 禁用安全流阅读器 </span><br><span class="line">disable buffer boundary checking in bitreaders </span><br><span class="line">(faster, but may crash) </span><br><span class="line">–sws-max-filter-size=N the max filter size swscale uses </span><br><span class="line"><span class="meta">[$</span><span class="bash">sws_max_filter_size_default] <span class="comment"># 最大过滤器大小N</span></span> </span><br><span class="line">优化选项 </span><br><span class="line">Optimization options (experts only): </span><br><span class="line">–disable-asm disable all assembly optimizations # 禁用全部汇编程序优化 </span><br><span class="line">–disable-altivec disable AltiVec optimizations # 禁用邋AltiVec优化 </span><br><span class="line">–disable-vsx disable VSX optimizations # 急用VSX优化 </span><br><span class="line">–disable-power8 disable POWER8 optimizations # 禁用power8优化 </span><br><span class="line">–disable-amd3dnow disable 3DNow! optimizations # 禁用3D Now!优化 </span><br><span class="line">–disable-amd3dnowext disable 3DNow! extended optimizations # 禁用3D Now!扩展优化 –disable-mmx disable MMX optimizations # 禁用MMX优化 </span><br><span class="line">–disable-mmxext disable MMXEXT optimizations # 禁用MMXEXT优化 </span><br><span class="line">–disable-sse disable SSE optimizations # 禁用SSE优化 </span><br><span class="line">–disable-sse2 disable SSE2 optimizations # 禁用SSE2优化 </span><br><span class="line">–disable-sse3 disable SSE3 optimizations # 禁用SSE3优化 </span><br><span class="line">–disable-ssse3 disable SSSE3 optimizations # 禁用SSSE3优化 </span><br><span class="line">–disable-sse4 disable SSE4 optimizations # 禁用SSE4优化 </span><br><span class="line">–disable-sse42 disable SSE4.2 optimizations # 禁用SSE4.2优化 </span><br><span class="line">–disable-avx disable AVX optimizations # 禁用AVX优化 </span><br><span class="line">–disable-xop disable XOP optimizations # 禁用XOP优化 </span><br><span class="line">–disable-fma3 disable FMA3 optimizations # 禁用FMA3优化 </span><br><span class="line">–disable-fma4 disable FMA4 optimizations # 禁用FMA4优化 </span><br><span class="line">–disable-avx2 disable AVX2 optimizations # 禁用AVX2优化 </span><br><span class="line">–disable-aesni disable AESNI optimizations # 禁用AESNI优化 </span><br><span class="line">–disable-armv5te disable armv5te optimizations # 禁用armv5te优化 </span><br><span class="line">–disable-armv6 disable armv6 optimizations # 禁用armv6优化 </span><br><span class="line">–disable-armv6t2 disable armv6t2 optimizations # 禁用armv6t2优化 </span><br><span class="line">–disable-vfp disable VFP optimizations # 禁用VFP优化 </span><br><span class="line">–disable-neon disable NEON optimizations # 禁用NEON优化</span><br><span class="line">–disable-inline-asm disable use of inline assembly # 禁用内部组合优化 </span><br><span class="line">–disable-yasm disable use of nasm/yasm assembly # 禁用nasm/yasm组合 </span><br><span class="line">–disable-mipsdsp disable MIPS DSP ASE R1 optimizations # 禁用MIPS DSP ASE R1优化 –disable-mipsdspr2 disable MIPS DSP ASE R2 optimizations # 禁用MIPS DSP ASE R2优化 –disable-msa disable MSA optimizations # 禁用MSA优化 </span><br><span class="line">–disable-mipsfpu disable floating point MIPS optimizations # 禁用浮点MIPS优化 </span><br><span class="line">–disable-mmi disable Loongson SIMD optimizations # 禁用长SIMD优化 </span><br><span class="line">–disable-fast-unaligned consider unaligned accesses slow # 禁用快速非对齐，非对齐速度 慢 </span><br><span class="line">开发选项 </span><br><span class="line">Developer options (useful when working on FFmpeg itself): </span><br><span class="line">–disable-debug disable debugging symbols # 禁用调试符号 </span><br><span class="line">–enable-debug=LEVEL set the debug level [$debuglevel] # 禁用调试等级 </span><br><span class="line">–disable-optimizations disable compiler optimizations # 禁用编译器优化 </span><br><span class="line">–enable-extra-warnings enable more compiler warnings # 启用编译器警告 </span><br><span class="line">–disable-stripping disable stripping of executables and shared libraries # 禁用可 执行程序剥脱共享库 </span><br><span class="line">–assert-level=level 0(default), 1 or 2, amount of assertion testing, # 启用段保护等 级 </span><br><span class="line">2 causes a slowdown at runtime. </span><br><span class="line">–enable-memory-poisoning fill heap uninitialized allocated space with arbitrary data # 启用内存填充，用任意数填充 </span><br><span class="line">–valgrind=VALGRIND run “make fate” tests through valgrind to detect memory # 启用 内存检测 </span><br><span class="line">leaks and errors, using the specified valgrind binary. </span><br><span class="line">Cannot be combined with –target-exec </span><br><span class="line">–enable-ftrapv Trap arithmetic overflows # 启用算术运算溢出 </span><br><span class="line">–samples=PATH location of test samples for FATE, if not set use # 指定测试示例位置 \$FATE_SAMPLES at make invocation time. </span><br><span class="line">–enable-neon-clobber-test check NEON registers for clobbering (should be # 启用 neon clobber测试 </span><br><span class="line">used only for debugging purposes) </span><br><span class="line">–enable-xmm-clobber-test check XMM registers for clobbering (Win64-only; # 启用 xmm clobber测试 </span><br><span class="line">should be used only for debugging purposes) </span><br><span class="line">–enable-random randomly enable/disable components # 启用组件随机开启或关闭 </span><br><span class="line">–disable-random # 禁用组件随机开启或关闭 </span><br><span class="line">–enable-random=LIST randomly enable/disable specific components or # 启用随机列表 –disable-random=LIST component groups. LIST is a comma-separated list # 禁用随机列 表 </span><br><span class="line">of NAME[:PROB] entries where NAME is a component </span><br><span class="line">(group) and PROB the probability associated with </span><br><span class="line">NAME (default 0.5). </span><br><span class="line">–random-seed=VALUE seed value for –enable/disable-random # 启用随机种子值 </span><br><span class="line">–disable-valgrind-backtrace do not print a backtrace under Valgrind </span><br><span class="line">(only applies to –disable-optimizations builds) # 禁用valgrind内存分析追踪</span><br></pre></td></tr></table></figure>


<h4 id="3-FFMPEG各模块简述"><a href="#3-FFMPEG各模块简述" class="headerlink" title="3.FFMPEG各模块简述"></a>3.FFMPEG各模块简述</h4><blockquote>
<p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了领先的 音/视频编码库libavcodec等。<br>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取 音视频帧等功能；<br>libavcodec：用于各种类型声音/图像编解码；<br>libavutil：包含一些公共的工具函数；<br>libswscale：用于视频场景比例缩放、色彩映射转换；<br>libpostproc：用于后期效果处理；</p>
</blockquote>
<h4 id="4-编译ffmpeg"><a href="#4-编译ffmpeg" class="headerlink" title="4.编译ffmpeg"></a>4.编译ffmpeg</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --disable-x86asm</span><br></pre></td></tr></table></figure>


<p>编译成功后的脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先定义一个NDK目录的变量 NDK_ROOT</span></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此变量执行ndk中的交叉编译gcc所在目录</span></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从as的 externalNativeBuild/xxx/build.ninja，  反正下面的配置，可以压制警告的意思</span></span><br><span class="line"><span class="meta">#</span><span class="bash">FLAGS=<span class="string">&quot;-isystem <span class="variable">$NDK_ROOT</span>/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=arm64-v8a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC&quot;</span></span></span><br><span class="line"></span><br><span class="line">FLAGS=&quot;-isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv8-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">INCLUDES=&quot; -isystem $NDK_ROOT/sources/android/support/include&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.定义编译后，所存放的目录</span></span><br><span class="line">PREFIX=./android/arm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.--enable-small 优化大小 非常重要，必须优化才行的哦</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.--disable-programs 不编译ffmpeg程序（命令行工具），我们是需要获取静态、动态库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.--disable-avdevice 关闭avdevice模块，此模块在android中无用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.--disable-encoders 关闭所有编码器（播放不需要编码）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.--disable-muxers 关闭所有复用器（封装器），不需要生成mp4这样的文件，所有关闭</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7.--disable-filters 关闭所有滤镜</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8.--enable-cross-compile 开启交叉编译（ffmpeg是跨平台的，注意：并不是所有库都有这么happy的选项）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9.--cross-prefix 看右边的值就知道是干嘛的，gcc的前缀..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.disable-shared / enable-static 这个不写也可以，默认就是这样的，（代表关闭动态库，开启静态库）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 11.--sysroot 寻找NDK所有的库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 12.--extra-cflags 会传给gcc的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13.--arch  --target-os</span> </span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/aarch64-linux-android- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-21/arch-arm64 \</span><br><span class="line">--extra-cflags=&quot;$FLAGS $INCLUDES&quot; \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot&quot; \</span><br><span class="line">--arch=aarch64 \</span><br><span class="line">--extra-libs=-lgcc \</span><br><span class="line">--target-os=android</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>导入AS中Cmakelist编译脚本</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB allCpp *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        SHARED</span><br><span class="line">        <span class="variable">$&#123;allCpp&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(</span><br><span class="line">        log-lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入FFmpeg的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入FFmpeg的库文件，设置内部的方式引入，指定库的目录是 -L  指定具体的库-l</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        native-lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 具体的库文件，链接到总库</span></span><br><span class="line">        <span class="comment"># 这样写会报错，有坑</span></span><br><span class="line">        <span class="comment"># avcodec avfilter avformat avutil swresample swscale</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先把有依赖的库，先依赖进来</span></span><br><span class="line">        avformat avcodec avfilter avutil swresample swscale</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="5-Makefile构建系统"><a href="#5-Makefile构建系统" class="headerlink" title="5.Makefile构建系统"></a>5.Makefile构建系统</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里面能够决定编译 Login.c Test.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.源文件在的位置。宏函数 my-dir 返回当前目录（包含 Android.mk 文件本身的目录）的路径。</span></span><br><span class="line"><span class="comment"># LOCAL_PATH 其实就是Android.mk文件本身的目录的路径</span></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(info &quot;LOCAL_PATH:======== $&#123;LOCAL_PATH&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.清理</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO 预编译库的引入 == 提前编译好的库</span></span><br><span class="line">LOCAL_MODULE := getndk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定静态库</span></span><br><span class="line"><span class="comment"># LOCAL_SRC_FILES := libgetndk.a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定动态库</span></span><br><span class="line">LOCAL_SRC_FILES := libgetndk.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译静态库的Makeifle脚本</span></span><br><span class="line"><span class="comment"># include $(PREBUILT_STATIC_LIBRARY)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译共享库的Makeifle脚本</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(PREBUILT_SHARED_LIBRARY)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引入其他makefile文件。CLEAR_VARS 变量指向特殊 GNU Makefile，可为您清除许多 LOCAL_XXX 变量</span></span><br><span class="line"><span class="comment">#不会清理 LOCAL_PATH 变量</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"><span class="comment"># TODO end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.指定库名字  apk/lib/libMyLoginJar.so  == 总库</span></span><br><span class="line"><span class="comment">#存储您要构建的模块的名称 每个模块名称必须唯一，且不含任何空格</span></span><br><span class="line"><span class="comment">#如果模块名称的开头已是 lib，则构建系统不会附加额外的前缀 lib；而是按原样采用模块名称，并添加 .so 扩展名。</span></span><br><span class="line">LOCAL_MODULE := MyLoginJar</span><br><span class="line"></span><br><span class="line"><span class="comment">#包含要构建到模块中的 C 和/或 C++ 源文件列表 以空格分开</span></span><br><span class="line">LOCAL_SRC_FILES := Login.c \</span><br><span class="line">Test.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO 开始链接进来</span></span><br><span class="line"><span class="comment"># 静态库的链接</span></span><br><span class="line"><span class="comment"># LOCAL_STATIC_LIBRARIES := getndk</span></span><br><span class="line"><span class="comment"># 动态库链接</span></span><br><span class="line">LOCAL_SHARED_LIBRARIES := getndk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 log</span></span><br><span class="line"><span class="comment">#LOCAL_LDLIBS := -llog</span></span><br><span class="line"><span class="comment"># 链接数学库和log库</span></span><br><span class="line">LOCAL_LDLIBS  := -lm -llog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.动态库</span></span><br><span class="line"><span class="comment">#构建动态库BUILD_SHARED_LIBRARY 最后生成总动态库  ---&gt; apk/lib/armeabi-v7a/libMyLoginJar.so</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br><span class="line"><span class="comment"># 静态库</span></span><br><span class="line"><span class="comment"># include $(BUILD_STATIC_LIBRARY)</span></span><br></pre></td></tr></table></figure>


<h4 id="6-Cmake构建工程"><a href="#6-Cmake构建工程" class="headerlink" title="6.Cmake构建工程"></a>6.Cmake构建工程</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;ndk28_cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量导入 cpp c源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/*.cpp <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/*.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个库（动态库SHARED，静态库STATIC）</span></span><br><span class="line"><span class="keyword">add_library</span>(native-lib <span class="comment"># 库的名字 ---&gt; libnative-lib.so</span></span><br><span class="line">             SHARED  <span class="comment"># 动态库</span></span><br><span class="line">            <span class="comment"># cpp的源文件：把cpp源文件编译成 libnative-lib.so 库</span></span><br><span class="line">             <span class="variable">$&#123;SOURCE&#125;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 预编译库（已经有了 xxx.so / xxx.a）的导入方式</span></span><br><span class="line"><span class="comment"># TODO 方式一：推荐的方式</span></span><br><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment"># 第一步：导入fmod头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cpp/inc&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：导入库文件 （方式一）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/jniLibsaaa/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 第三步链接到总库中去</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmod <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmodL <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO 方式二：以前更多使用的方式</span></span><br><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment"># 第一步：导入fmod头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cpp/inc&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：导入库文件 （方式二）</span></span><br><span class="line"><span class="keyword">add_library</span>(fmod SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmod PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmod.so)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(fmodL SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmodL PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmodL.so)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步链接到总库中去</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmod <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmodL <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br><span class="line"><span class="comment">#]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 判断静态库还是动态库 (静态库会直接Copy到总库，动态库则不会)</span></span><br><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 下面代码不参与 判断 start</span></span><br><span class="line"><span class="comment"># 第一步：导入fmod头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cpp/inc&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：导入库文件 （方式二）</span></span><br><span class="line"><span class="keyword">add_library</span>(fmod SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmod PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmod.so)</span><br><span class="line"><span class="keyword">add_library</span>(fmodL SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmodL PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmodL.so)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 上面代码不参与 判断 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## OFF=0=false    ON=1=true</span></span><br><span class="line"><span class="comment"># set(isSTATIC OFF)</span></span><br><span class="line"><span class="keyword">set</span>(isSTATIC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;isSTATIC&#125;</span>)</span><br><span class="line">    <span class="comment"># 导入静态库</span></span><br><span class="line">    <span class="keyword">add_library</span>(getndk STATIC IMPORTED)</span><br><span class="line">    <span class="comment"># 开始真正导入 静态库   System.loadLibrary(&quot;getndk&quot;); // 如果是动态库，这里需要加载，否则注释</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(getndk PROPERTIES IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/libgetndk.a)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;isSTATIC == static&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>(<span class="variable">$&#123;isSTATIC&#125;</span>)</span><br><span class="line">    <span class="comment"># 导入动态库</span></span><br><span class="line">    <span class="keyword">add_library</span>(getndk SHARED IMPORTED)</span><br><span class="line">    <span class="comment"># 开始真正导入 动态库  System.loadLibrary(&quot;getndk&quot;); // 如果是动态库，这里需要加载，否则注释</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(getndk PROPERTIES</span><br><span class="line">            IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libgetndk.so)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;isSTATIC == shared&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>(<span class="variable">$&#123;isSTATIC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        getndk <span class="comment"># TODO 具体的库 链接到 libnative-lib.so里面去【这个库，有可能是静态库，有可能是动态库】</span></span><br><span class="line">        fmod <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmodL <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rtmp的时候，就全盘采用 源码构建方式</span></span><br><span class="line"><span class="comment"># TODO &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 依赖源码的方式（已经有了 xxxc / xxx.c / xxx.c ...）的导入方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引入get子目录下的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/libget)</span><br><span class="line"></span><br><span class="line"><span class="comment">#引入count子目录下的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/libcount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        get <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        count <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>


<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 子目录下的cmakelist</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        count</span><br><span class="line">        SHARED <span class="comment"># 最终生成 libcount.so</span></span><br><span class="line">        <span class="variable">$&#123;SOURCE&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE *.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        get</span><br><span class="line">        STATIC <span class="comment"># 最终生成 libget.a</span></span><br><span class="line">        <span class="variable">$&#123;SOURCE&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旧版本日志输出到output.txt中，新版本输出到/.cxx/cmake/debug/armeabi-v7a/metadata_generation_stderr.txt或者cmake_server_log.txt中</span></span><br><span class="line"><span class="comment"># (无) = 重要消息；</span></span><br><span class="line"><span class="comment"># STATUS = 非重要消息；</span></span><br><span class="line"><span class="comment"># WARNING = CMake 警告, 会继续执行；</span></span><br><span class="line"><span class="comment"># AUTHOR_WARNING = CMake 警告 (dev), 会继续执行；</span></span><br><span class="line"><span class="comment"># SEND_ERROR = CMake 错误, 继续执行，但是会跳过生成的步骤；</span></span><br><span class="line"><span class="comment"># FATAL_ERROR = CMake 错误, 终止所有处理过程；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;this print message!&quot;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="7-Cmake变量"><a href="#7-Cmake变量" class="headerlink" title="7. Cmake变量"></a>7. Cmake变量</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#申明变量</span></span><br><span class="line"><span class="keyword">set</span>(var jack)</span><br><span class="line">messgae(STATUS <span class="variable">$&#123;var&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CMake中所有变量都是string类型。可以使用set()和unset()命令来声明或移除一个变量 </span></span><br><span class="line"><span class="comment"># 移除变量 </span></span><br><span class="line"><span class="keyword">unset</span>(var) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;my_var = $&#123;var&#125;&quot;</span>) <span class="comment"># 会取不到值，因为被移除了 </span></span><br><span class="line"><span class="comment"># TODO CMake列表（lists） </span></span><br><span class="line"><span class="comment"># 声明列表：set(列表名    值1 值2 ... 值N) 或    set(列表名    &quot;值1;值2;...;值N&quot;) </span></span><br><span class="line"><span class="keyword">set</span>(list_var <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="comment"># 字符串列表呢？    CMake中所有变量都是string类型 </span></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line"><span class="keyword">set</span>(list_var2 <span class="string">&quot;1;2;3;4;5&quot;</span>) <span class="comment"># 字符串列表呢？         CMake中所有变量都是string类型 message(&quot;list_var = $&#123;list_var&#125;&quot;) </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;list_var2 = $&#123;list_var2&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake流程控制-条件命令 </span></span><br><span class="line"><span class="comment"># true(1，ON，YES，TRUE，Y，非0的值) </span></span><br><span class="line"><span class="comment"># false(0，OFF，NO，FALSE，N，IGNORE，NOTFOUND) </span></span><br><span class="line"><span class="keyword">set</span>(if_tap <span class="keyword">OFF</span>) <span class="comment"># 定义一个变量if_tap，值为false </span></span><br><span class="line"><span class="keyword">set</span>(elseif_tap <span class="keyword">ON</span>) <span class="comment"># 定义一个变量elseif_tap，值为ture </span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;if_tap&#125;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;if&quot;</span>) </span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$&#123;elseif_tap&#125;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;elseif&quot;</span>) </span><br><span class="line"><span class="keyword">else</span>(<span class="variable">$&#123;if_tap&#125;</span>) <span class="comment"># 可以不加入    $&#123;if_tap&#125; </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;else&quot;</span>) </span><br><span class="line"><span class="comment"># endif($&#123;if_tap&#125;) # 结束if </span></span><br><span class="line"><span class="keyword">endif</span>() <span class="comment"># 结束if 可以不加 </span></span><br><span class="line"><span class="comment"># 注意：elseif和else部分是可选的，也可以有多个elseif部分，缩进和空格对语句解析没有影响</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake流程控制-循环命令 </span></span><br><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;&quot;</span>) </span><br><span class="line"><span class="comment">#  a STREQUAL &quot;xxx&quot;（a等不等xxx，不等于） </span></span><br><span class="line"><span class="comment">#  NOT == ! </span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">NOT</span> a <span class="keyword">STREQUAL</span> <span class="string">&quot;xxx&quot;</span>) </span><br><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;$&#123;a&#125;x&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;a = $&#123;a&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endwhile</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># break()命令可以跳出整个循环 </span></span><br><span class="line"><span class="comment"># continue()可以继续当前循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;1item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item) <span class="comment"># 结束for</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">2</span>) <span class="comment"># RANGE 默认从0开始，    所以是：0 1 2 </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;2item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">1</span> <span class="number">6</span> <span class="number">2</span>) <span class="comment">#  1 3 5 每次跳级2 </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;3item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(list_va3 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment"># 列表 </span></span><br><span class="line"><span class="comment"># foreach(item IN LISTS $&#123;list_va3&#125;) 没有报错，没有循环 </span></span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS list_va3) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;4item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="comment"># TODO CMake自定义函数         Shell的函数很类似 </span></span><br><span class="line"><span class="comment">#[[ </span></span><br><span class="line">ARGC：表示传入参数的个数 </span><br><span class="line">ARGV0：表示第一个参数，ARGV1、ARGV2以此类推即可 </span><br><span class="line">ARGV：表示所有参数 </span><br><span class="line"><span class="comment">#]] </span></span><br><span class="line"><span class="keyword">function</span>(num_method n1 n2 n3) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;call num_method method&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;n1 = $&#123;n1&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;n2 = $&#123;n2&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;n3 = $&#123;n3&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;ARGC = $&#123;ARGC&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;arg1 = $&#123;ARGV0&#125; arg2 = $&#123;ARGV1&#125; arg3 = $&#123;ARGV2&#125;&quot;</span>) <span class="keyword">message</span>(<span class="string">&quot;all args = $&#123;ARGV&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endfunction</span>(num_method) </span><br><span class="line">num_method(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment"># 调用num_method函数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频基础</title>
    <url>/2021/07/19/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="1-音视频解码播放流程"><a href="#1-音视频解码播放流程" class="headerlink" title="1.音视频解码播放流程"></a>1.音视频解码播放流程</h4><p>.mp4、.avi、.rmvb等格式文件是用于封装音频流和视频流的。ffmpeg在处理该类视频的流程如下，首先会解封装，将封装格式的音视频文件分成音频压缩数据和视频压缩数据。音频压缩数据然后通过解码转化为音频原始数据，最后通过音频重采样，将双声道音频转化为单声道经过扬声器播放出来；视频压缩数据通过视频解码转化为视频原始数据，然后将YUV格式的原始数据转化为RGBA通过显示器显示出来。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-28385ad168b34cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="音视频解码播放流程.png"></p>
<h4 id="2-音视频录制过程"><a href="#2-音视频录制过程" class="headerlink" title="2.音视频录制过程"></a>2.音视频录制过程</h4><p>音视频录制过程和播放过程是恰恰相反的过程。麦克风采集到pcm原始数据之后经过音频编码成acc压缩文件；原始视频文件通过编码成H.264格式的压缩数据。最后通过封包封装成mp4等视频格式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bd137e7a0ebb77e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="音视频录制编码流程.png"></p>
<h4 id="3-视频源码原理"><a href="#3-视频源码原理" class="headerlink" title="3.视频源码原理"></a>3.视频源码原理</h4><p>​    视频是连续的图像序列，由连续的帧构成，一帧即为一幅图像。由于人眼的视觉暂留效应，当帧序列以一定的速率播放时，我们看到的就是动作连续的视频。这么多连续的图像数据如果不经过编码的数据量太大了。<br>比如一个1920x1080分辨率，32位,四个字节(RGBA)，每秒30帧的视频，一秒钟需要1920x1080x4x30，大小大概为243MB数据。因此，视频需要编码压缩后保存。</p>
<h5 id="3-1-空间冗余"><a href="#3-1-空间冗余" class="headerlink" title="3.1 空间冗余"></a>3.1 空间冗余</h5><p>空间冗余：图像内部相邻像素之间存在较强的相关性多造成的冗余。</p>
<h5 id="3-2-时间冗余"><a href="#3-2-时间冗余" class="headerlink" title="3.2 时间冗余"></a>3.2 时间冗余</h5><p>时间冗余：视频图像序列中的不同帧之间的相关性所造成的冗余。</p>
<h5 id="3-3-视觉冗余"><a href="#3-3-视觉冗余" class="headerlink" title="3.3 视觉冗余"></a>3.3 视觉冗余</h5><p>视觉冗余：是指人眼不能感知或不敏感的那部分图像信息。人类对颜色的亮度不敏感，对颜色值敏感。</p>
<h5 id="3-4-信息熵冗余"><a href="#3-4-信息熵冗余" class="headerlink" title="3.4 信息熵冗余"></a>3.4 信息熵冗余</h5><p>信息熵冗余：也称编码冗余，人们用于表达某一信息所需要的比特数总比理论上表示该信息所需要的最少比特 数要大，它们之间的差距就是信息熵冗余，或称编码冗余。</p>
<h5 id="3-5-知识冗余"><a href="#3-5-知识冗余" class="headerlink" title="3.5 知识冗余"></a>3.5 知识冗余</h5><p>知识冗余：是指在有些图像中还包含与某些验证知识有关的信息</p>
<h4 id="4-帧的概念"><a href="#4-帧的概念" class="headerlink" title="4.帧的概念"></a>4.帧的概念</h4><p>视频中的帧分为I帧、B帧、P帧</p>
<ul>
<li>I帧：帧内编码帧，关键帧，I帧可以看作一个图像经过压缩之后的产物，可以单独解码出一个完整的图像； （压缩率最低）</li>
<li>P帧：前向预测/参考编码帧，记录了本帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画 面叠加上本帧定义的差别，生成最终画面。    （压缩率比I帧高，比B帧低，属于适中情况）</li>
<li>B帧：双向预测/参考    编码帧，记录了本帧与前后帧的差别，解码需要参考前面一个I帧或者P帧，同时也需要 后面的P帧才能解码一张完整的图像。    （参考前后的预测得到的，压缩率是最高，但是耗时）</li>
</ul>
<h4 id="5-H-264数据分析"><a href="#5-H-264数据分析" class="headerlink" title="5. H.264数据分析"></a>5. H.264数据分析</h4><h5 id="5-1-H-264分层结构-VCL与NAL"><a href="#5-1-H-264分层结构-VCL与NAL" class="headerlink" title="5.1 H.264分层结构(VCL与NAL)"></a>5.1 H.264分层结构(VCL与NAL)</h5><ul>
<li>VCL（Video Coding Layer，视频编码层）：负责高效的视频内容表示， VCL数据即编码处理的输出，它表示被压缩编码后的视频数据序列。</li>
<li>NAL（Network Abstraction Layer，网络提取层）：负责以网络所要求的恰当的方式对数据进行打包和 传送， 是传输层。不管在本地播放还是网络播放，都要通过这一层来传输。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-35e8bc4f754ba1b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VCL与NAL的关系图.png"></p>
<p>NAL片：一帧图片经过 H.264 编码器之后，NAL单元就是装载着这些片（被编码为一个或多个片 slice）, 每片包<br>含整数个宏块（至少一个宏块，最多包含整个图像宏块）。</p>
<p>H.264编码器的默认输出为：起始码+NALU（Nal单元）。起始码为：0x00000001或者0x000001，可以通过010editor工具看到。一个NALU包含：PPS, I帧，B帧，P帧。</p>
<p><strong>起始码主要用于每一个NALU之间的分割：</strong></p>
<ul>
<li>0x00000001 起始码代表：一个NALU里面有很多片。</li>
<li>0x000001 起始码代表：    一个NALU里面一个片。</li>
</ul>
<p>每一个NALU包含：<code>起始码</code> + <code>1个字节的Nal Header</code> + <code>若干整数字节的负荷数据EBSP</code>构成。</p>
<table>
<thead>
<tr>
<th>nal_unit_type</th>
<th>nal类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>未使用</td>
</tr>
<tr>
<td>1</td>
<td>不分区，非IDR图像的片</td>
</tr>
<tr>
<td>2</td>
<td>片分区A</td>
</tr>
<tr>
<td>3</td>
<td>片分区B</td>
</tr>
<tr>
<td>4</td>
<td>片分区C</td>
</tr>
<tr>
<td>5</td>
<td>IDR图像中的片</td>
</tr>
<tr>
<td>6</td>
<td>补充增强信息单元（SEI）</td>
</tr>
<tr>
<td>7</td>
<td>序列参数集(SPS)</td>
</tr>
<tr>
<td>8</td>
<td>图像参数集(PPS)</td>
</tr>
<tr>
<td>9</td>
<td>分隔符</td>
</tr>
<tr>
<td>10</td>
<td>序列结束</td>
</tr>
<tr>
<td>11</td>
<td>码流结束</td>
</tr>
<tr>
<td>12</td>
<td>填充</td>
</tr>
<tr>
<td>13-23</td>
<td>保留</td>
</tr>
<tr>
<td>14-31</td>
<td>未使用</td>
</tr>
</tbody></table>
<p>nal头部分为八位：01100111</p>
<ul>
<li><p>第1位禁止位，值为1表示语法出错</p>
</li>
<li><p>第2~3位为参考级别(重要级别)</p>
</li>
<li><p>第4~8为是nal单元类型</p>
</li>
</ul>
<p><strong>其中0x67的二进制码为：</strong><br>0110 0111<br>4-8为00111，转为十进制7，7对应序列参数集SPS</p>
<p><strong>其中0x68的二进制码为：</strong><br>0110 1000<br>4-8为01000，转为十进制8，8对应图像参数集PPS</p>
<p><strong>其中0x65的二进制码为：</strong><br>0110 0101<br>4-8为00101，转为十进制5，6代表重要，5对应IDR图像中的片(I帧)</p>
<p><strong>其中0x61/0x41的二进制码为：</strong><br>0110 0001 / 0100 0001<br>4-8为00001，转为十进制1，6和4代表重要，1对应非IDR图像中的片(P帧)</p>
<p><strong>其中0x01的二进制码为：</strong><br>0000 0001<br>4-8为00001，转为十进制1，0代表不重要，1对应非IDR图像中的片(B帧)</p>
<h4 id="6-PTS与DTS"><a href="#6-PTS与DTS" class="headerlink" title="6.PTS与DTS"></a>6.PTS与DTS</h4><p>DTS表示解码时间戳，在什么时候解码这一帧的数据；PTS表示显示时间戳，在什么时候显示这一帧。</p>
<p>在没有B帧的情况下，DTS和PTS的输出顺序是一样的。因为B帧打乱了解码和显示的顺序（要解码B帧需要先解码后面的P帧），所以一旦存在B帧，PTS和DTS就会不同。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-726f6b29680fe2fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GOP.jpg"></p>
<p>GOP是用于表示两个I帧之间的分组。例如：I P B P B P B P B I 一组</p>
<h4 id="7-ffmpeg解封装解码流程"><a href="#7-ffmpeg解封装解码流程" class="headerlink" title="7.ffmpeg解封装解码流程"></a>7.ffmpeg解封装解码流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-e22d2c930bb8ee84.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ffmpeg解封装解码流程API概况.jpg"></p>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>调查ADB突然异常问题</title>
    <url>/2021/07/27/%E8%B0%83%E6%9F%A5ADB%E7%AA%81%E7%84%B6%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1. 问题现象"></a>1. 问题现象</h4><p>​    adb用着用着就不好使了，然后出现黑屏，伴随着有时候串口也不好使。</p>
<h4 id="2-应急补救措施"><a href="#2-应急补救措施" class="headerlink" title="2.应急补救措施"></a>2.应急补救措施</h4><p>​    测试同学如果遇到adb用着用着突然不好使了，请使用如下手顺首先恢复串口或者adb口好使，然后取一下相关日志给到开发。<br>![adb突然不好使应急措施]<img src="https://upload-images.jianshu.io/upload_images/13838098-835ec93a64822a64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="adb突然不好使应急措施.png"></p>
<h4 id="3-问题调查"><a href="#3-问题调查" class="headerlink" title="3.问题调查"></a>3.问题调查</h4><p>​    经过上面手顺发现是</p>
<ul>
<li>有一台车机是adbd服务挂掉了，通过<code>start adbd</code>重启adb服务之后就可以恢复正常使用了。导出tombstone文件，分析问题发生原因。</li>
<li>有一台车是adb口的模式属性值被设置成host模式。</li>
</ul>
<p>​    </p>
<h5 id="3-1-查看tombstone日志"><a href="#3-1-查看tombstone日志" class="headerlink" title="3.1 查看tombstone日志"></a>3.1 查看tombstone日志</h5><p>为什么看tombstone日志呢，因为logcat中着实看不出什么问题来。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">Build fingerprint: <span class="string">&#x27;qti/msmnile_gvmq/msmnile_gvmq:9/PQ1A.190105.004/root07251158:userdebug/test-keys&#x27;</span></span><br><span class="line">Revision: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">ABI: <span class="string">&#x27;arm64&#x27;</span></span><br><span class="line">pid: <span class="number">6911</span>, tid: <span class="number">6911</span>, name: cockpit.settings  &gt;&gt;&gt; com.gxatek.cockpit.settings &lt;&lt;&lt;</span><br><span class="line">signal <span class="number">11</span> (SIGSEGV), code <span class="number">1</span> (SEGV_MAPERR), fault addr <span class="number">0x19</span></span><br><span class="line">Cause: <span class="keyword">null</span> pointer dereference    <span class="comment">// 空指针异常</span></span><br><span class="line">    x0  <span class="number">00000000000003e7</span>  x1  0000000000000018  x2  <span class="number">0000000000000000</span>  x3  <span class="number">0000000000000001</span></span><br><span class="line">    x4  <span class="number">0000000000000000</span>  x5  0000007ff5c5b180  x6  64636e4c3c04ff3c  x7  <span class="number">0000000000000000</span></span><br><span class="line">    x8  <span class="number">00000000000003e7</span>  x9  0000000000007ffe  x10 <span class="number">0000000000000000</span>  x11 0000007258614c00</span><br><span class="line">    x12 <span class="number">0000000000000000</span>  x13 <span class="number">0000000000000001</span>  x14 0000007ff5c5af94  x15 <span class="number">0000000000000000</span></span><br><span class="line">    x16 <span class="number">0000007257e48080</span>  x17 <span class="number">0000007257e40880</span>  x18 <span class="number">0000000000000000</span>  x19 0000007ff5c5b018</span><br><span class="line">    x20 0000007240f83d08  x21 0000007ff5c5afd0  x22 0000007258614c00  x23 00000000000010ef</span><br><span class="line">    x24 <span class="number">0000007257e40900</span>  x25 0000007ff5c5afd8  x26 <span class="number">00000000000003e7</span>  x27 0000007ff5c5af98</span><br><span class="line">    x28 0000007257f31048  x29 0000007ff5c5ae40</span><br><span class="line">    sp  0000007ff5c5ae00  lr  0000007257e408d0  pc  <span class="number">0000007257e48094</span></span><br><span class="line"></span><br><span class="line">backtrace:</span><br><span class="line">    #00 pc 000000000054b094  /system/lib64/libart.so (ExecuteMterpImpl+30740)</span><br><span class="line">    <span class="comment">// NestedScrollingChildHelper报空指针</span></span><br><span class="line">    #01 pc 00000000000f1d08  /system/framework/oat/arm64/ui-framework.vdex (android.support.v4.view.NestedScrollingChildHelper.isNestedScrollingEnabled)</span><br><span class="line">    #02 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #03 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #04 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #05 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #06 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #07 pc 000000000012dd58  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (android.support.v7.widget.RecyclerView.setNestedScrollingEnabled+8)</span><br><span class="line">    #08 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #09 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #10 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #11 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #12 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #13 pc 000000000012b302  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (android.support.v7.widget.RecyclerView.&lt;init&gt;+674)</span><br><span class="line">    #14 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #15 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #16 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #17 pc 0000000000525a50  /system/lib64/libart.so (MterpInvokeDirect+296)</span><br><span class="line">    #18 pc 0000000000547114  /system/lib64/libart.so (ExecuteMterpImpl+14484)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 在CarplayFragment中inflate创建Fragment布局</span></span><br><span class="line">    #41 pc 000000000017300c  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.fragment.internet.CarplayFragment.onCreateView+8)</span><br><span class="line">    #42 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #43 pc 0000000000514fa4  /system/lib64/libart.so (artQuickToInterpreterBridge+1020)</span><br><span class="line">    #44 pc 000000000055dafc  /system/lib64/libart.so (art_quick_to_interpreter_bridge+92)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 懒加载机制加载fragment</span></span><br><span class="line">    #68 pc 000000000015a276  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.adapter.FragmentAdapter.finishUpdate+8)</span><br><span class="line">    #69 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #70 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #71 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #72 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #73 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #74 pc 000000000015e11c  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.custom.NoPreloadViewPager.populate+436)</span><br><span class="line">    #75 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #76 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #77 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #78 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #79 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #80 pc 000000000015e410  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.custom.NoPreloadViewPager.setCurrentItemInternal+184)</span><br><span class="line">    #81 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #82 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #83 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #84 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">        </span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 点击item，切换到fragment</span></span><br><span class="line">   #98 pc 000000000013e91e  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.MainActivity.switchToFragment+16)</span><br><span class="line">    #99 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #100 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #101 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #102 pc 0000000000525a50  /system/lib64/libart.so (MterpInvokeDirect+296)</span><br><span class="line">    #103 pc 0000000000547114  /system/lib64/libart.so (ExecuteMterpImpl+14484)</span><br><span class="line">    #104 pc 000000000013e4ae  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.MainActivity.onClick+94)</span><br><span class="line">    #105 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #106 pc 0000000000514fa4  /system/lib64/libart.so (artQuickToInterpreterBridge+1020)</span><br><span class="line">    #107 pc 000000000055dafc  /system/lib64/libart.so (art_quick_to_interpreter_bridge+92)</span><br><span class="line">    #108 pc 0000000000c7dee4  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.view.View.performClick+148)</span><br><span class="line">    #109 pc 0000000000554988  /system/lib64/libart.so (art_quick_invoke_stub+584)</span><br><span class="line">    #110 pc 00000000000cf6c8  /system/lib64/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+200)</span><br><span class="line">    #111 pc 000000000027f2b4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+344)</span><br><span class="line">    #112 pc 00000000002792bc  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+968)</span><br><span class="line">    #113 pc 0000000000524da8  /system/lib64/libart.so (MterpInvokeSuper+1420)</span><br><span class="line">    #114 pc 0000000000547094  /system/lib64/libart.so (ExecuteMterpImpl+14356)</span><br><span class="line">    #115 pc 0000000000d5aa92  /system/framework/boot-framework.vdex (android.widget.CompoundButton.performClick+6)</span><br><span class="line">    #116 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #117 pc 0000000000514fa4  /system/lib64/libart.so (artQuickToInterpreterBridge+1020)</span><br><span class="line">    #118 pc 000000000055dafc  /system/lib64/libart.so (art_quick_to_interpreter_bridge+92)</span><br><span class="line">    #119 pc 0000000000b83484  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.view.View$PerformClick.run+84)</span><br><span class="line">    #120 pc 0000000000aacccc  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.os.Handler.dispatchMessage+76)</span><br><span class="line">    #121 pc 0000000000aafe30  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.os.Looper.loop+1264)</span><br><span class="line">    #122 pc 000000000087c378  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.app.ActivityThread.main+664)        </span><br></pre></td></tr></table></figure>
<p><strong>从调用栈分析调度过程如下：</strong></p>
<ol>
<li>用户点击CarSettingHMI的界面某个item(最终调查到时carplayfragment)切换Fragment</li>
<li>懒加载加载carplayfragment</li>
<li>在递归加载RecycleView中子item的时候，NestedScrollingChildHelper处获得的时空指针</li>
</ol>
<h5 id="3-2-反编译CarSettingHMI-apk跟踪代码"><a href="#3-2-反编译CarSettingHMI-apk跟踪代码" class="headerlink" title="3.2 反编译CarSettingHMI.apk跟踪代码"></a>3.2 反编译CarSettingHMI.apk跟踪代码</h5><p>从CarplayFragment开始看，当然也可以从更早时机开始看，但是前面都是正常的，就直接接近真相便捷一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CarplayFragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater paramLayoutInflater, ViewGroup paramViewGroup, Bundle paramBundle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paramLayoutInflater.inflate(<span class="number">2131361842</span>, paramViewGroup, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当加载CarplayFragment的时候，系统回调onCreateView取加载布局文件。<strong>此处无异常代码</strong>，继续跟踪</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RecyclerView.setNestedScrollingEnabled</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> paramBoolean)</span></span>&#123;</span><br><span class="line">    getScrollingChildHelper().setNestedScrollingEnabled(paramBoolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着setNestedScrollingEnabled()就是真相，前面的ScrollingChildHelper是null，然后调用报空指针异常。继续跟进。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NestedScrollingChildHelper <span class="title">getScrollingChildHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mScrollingChildHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">this</span>.mScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mScrollingChildHelper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处看也是常规构建对象的方法，感觉也没有错，除了加锁可以防止，但是这个android.support.v7.widget支持包，是错也不应该我先发现，所有还是先从自身原因着手。</p>
<p>现在问题原因是找到了，就是：getScrollingChildHelper()返回了一个空对象，导致空指针异常。</p>
<h5 id="3-3-猜测问题原因"><a href="#3-3-猜测问题原因" class="headerlink" title="3.3 猜测问题原因"></a>3.3 猜测问题原因</h5><p>感觉调查到上面在不改支持库的前提下就没辙了。不过细心看tombstone日志，发现调用栈是CarSettingHMI.vdex 中的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#01 pc 00000000000f1d08  &#x2F;system&#x2F;framework&#x2F;oat&#x2F;arm64&#x2F;ui-framework.vdex (android.support.v4.view.NestedScrollingChildHelper.isNestedScrollingEnabled)</span><br><span class="line">   ......</span><br><span class="line">   #07 pc 000000000012dd58  &#x2F;system&#x2F;app&#x2F;CarSettingHMI&#x2F;oat&#x2F;arm64&#x2F;CarSettingHMI.vdex (android.support.v7.widget.RecyclerView.setNestedScrollingEnabled+8)</span><br></pre></td></tr></table></figure>
<p>可以看到是ui-framework.vdex和CarSettingHMI.vdex，让我不由想到之前遇到过的System-UI应用方法调用的内存地址错位的问题。</p>
<p>于是顺着经验，开始验证猜想，首先点击设置<code>系统设置应用</code>的carplayfragment界面，现象：<strong>必崩</strong>；删掉包含CarSettingHMI.vdex和CarSettingHMI.odex的oat目录，然后在点击carplayfragment界面，就好使了。</p>
<h5 id="3-4-临时解决办法"><a href="#3-4-临时解决办法" class="headerlink" title="3.4 临时解决办法"></a>3.4 临时解决办法</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">++ b/Feiyu/CarSettingHMI/Android.mk</span><br><span class="line">@@ -17,6 +17,7 @@ LOCAL_SRC_FILES := <span class="variable">$(LOCAL_MODULE)</span>.apk</span><br><span class="line"> LOCAL_MODULE_CLASS := APPS</span><br><span class="line"> LOCAL_MODULE_SUFFIX := <span class="variable">$(COMMON_ANDROID_PACKAGE_SUFFIX)</span></span><br><span class="line"> LOCAL_CERTIFICATE := platform</span><br><span class="line">+LOCAL_DEX_PREOPT := false</span><br></pre></td></tr></table></figure>
<p>取消优化项，在系统编译的时候，取消CarSettingHMI的优化项，让系统不生成CarSettingHMI.odex和CarSettingHMI.vdex文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">临时解决办法手顺：</span><br><span class="line">1、通过串口线进入Android系统</span><br><span class="line">   输入指令：dtach -a &#x2F;tmp&#x2F;android</span><br><span class="line">2、通过串口打开ADB：先通过串口进入Android系统，再输入以下指令：</span><br><span class="line">   echo peripheral &gt; &#x2F;sys&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;ee080200.usb-phy&#x2F;role</span><br><span class="line">3、getprop persist.vendor.usb.mode   查看是否是host，是host执行步骤4即可</span><br><span class="line">4、setprop persist.vendor.usb.mode adb</span><br><span class="line">5、&#x2F;data&#x2F;tombstones    &#x2F;data&#x2F;system&#x2F;dropbox    &#x2F;log</span><br></pre></td></tr></table></figure>


<p><strong>3.5 终极解决办法</strong></p>
<p>建立maven仓库，或者artifactory仓库，让应用在Android Studio编译的时候，始终是最新的ui-framework和car-framework。然后在打开各个应用的预编译优化项。</p>
<h4 id="4-回溯问题"><a href="#4-回溯问题" class="headerlink" title="4.回溯问题"></a>4.回溯问题</h4><p>上面一顿操作猛如虎，但是还没有回答为什么ADB口用着用着一会儿就用不了。</p>
<p>其实系统设置里面有个工程模式，工程模式里面有个usb口模式切换。当系统设置崩溃之后，再启动起来，usb口的模式自动切回模式的模式了。usb口默认模式是：host模式。</p>
<p>当工程模式崩溃之后，可以通过如下指令查看usb的模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getprop persist.vendor.usb.mode</span><br><span class="line">setprop persist.vendor.usb.mode host</span><br><span class="line">setprop persist.vendor.usb.mode adb</span><br></pre></td></tr></table></figure>




<p><strong>参考文档：</strong></p>
<p><a href="https://www.cnblogs.com/CoderTian/p/5980426.html">1. Android Tombstone 分析</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>ADB无法使用</tag>
      </tags>
  </entry>
  <entry>
    <title>调查车机重启_RescueParty机制</title>
    <url>/2021/07/27/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E9%87%8D%E5%90%AF-RescueParty%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>​    车机开启之后，一直重启，仪表屏幕正常。通过CAN工具可以和仪表交互。</p>
<h4 id="2-问题定位"><a href="#2-问题定位" class="headerlink" title="2.问题定位"></a>2.问题定位</h4><p>​    因为我们车机是QNX和Android双系统，从现象来看，仪表正常，说明QNX是正常的，初步定位是Android系统重启。拼手速导出log/log中的日志开始分析。</p>
<pre><code> 首先一想Android系统重启，必然是系统服务出了问题，一般应用重启不会导致系统重启。Android O中增加了一个新的功能，当核心系统组件发生循环崩溃的时候，就会触发“救援程序”。</code></pre>
<p>搜先搜索：<strong>“AndroidRuntime”</strong>可以看到哪些进程出问题了，被系统杀掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> I/CarAudioManager( <span class="number">1599</span>): reconnect service</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): FATAL EXCEPTION: main</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): Process: com.android.car, PID: <span class="number">2632</span></span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): java.lang.RuntimeException: Unable to create service com.android.car.CarService: java.lang.IllegalStateException: Vehicle HAL service is not available.</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3582</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.access$<span class="number">1300</span>(ActivityThread.java:<span class="number">200</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">1672</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.os.Handler.dispatchMessage(Handler.java:<span class="number">106</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.os.Looper.loop(Looper.java:<span class="number">193</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6718</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">493</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">858</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): Caused by: java.lang.IllegalStateException: Vehicle HAL service is not available.</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at com.android.car.CarService.onCreate(CarService.java:<span class="number">82</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3570</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): ... <span class="number">8</span> more</span><br></pre></td></tr></table></figure>
<p>从上面日志可以看出CarService一直再重启，但是服务一直重启为什么会导致系统重启呢？</p>
<p>为了方便观看，省略时间戳等非必要信息，搜索:”RescueParty”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">0</span> in last <span class="number">7</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">12</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">13</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">13</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">13</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level RESET_SETTINGS_UNTRUSTED_DEFAULTS</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level RESET_SETTINGS_UNTRUSTED_CHANGES</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level RESET_SETTINGS_TRUSTED_DEFAULTS</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level FACTORY_RESET</span><br><span class="line"><span class="number">1</span> I<span class="comment">//system/bin/uncrypt( 2649): --reason=RescueParty</span></span><br></pre></td></tr></table></figure>
<p>原因就在这里，Android从O版本之后退出了系统救援机制，当系统关键服务或者重启之后都会做一个标记，如果超过阈值了，就会恢复出厂设置，重启车机。</p>
<h4 id="3-RescueParty机制"><a href="#3-RescueParty机制" class="headerlink" title="3.RescueParty机制"></a>3.RescueParty机制</h4><p>先把结论说出来，然后一一代码证实。</p>
<p><strong>结论：</strong>救援机制把救援事件分成5类，每次应用或者systemserver在一定时间重启5次，救援级别就会加一，当达到4级救援，就恢复出厂设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 救援级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_NONE = <span class="number">0</span>;   <span class="comment">// 默认救援为0级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_FACTORY_RESET = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>上述的一定时间是：SystemServer在5分钟内重启五次触发一次救援。persistent app在30秒内重启5次触发一次救援。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BootThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We&#x27;re interested in 5 events in any 300 second period; this</span></span><br><span class="line">    <span class="comment">// window is super relaxed because booting can take a long time if</span></span><br><span class="line">    <span class="comment">// forced to dexopt things.</span></span><br><span class="line">    <span class="comment">// 5代表5次，300代表300s</span></span><br><span class="line">    <span class="keyword">super</span>(android.os.Process.ROOT_UID, <span class="number">5</span>, <span class="number">300</span> * DateUtils.SECOND_IN_MILLIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AppThreshold</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We&#x27;re interested in 5 events in any 30 second period; apps crash</span></span><br><span class="line">    <span class="comment">// pretty quickly so we can keep a tight leash on them.</span></span><br><span class="line">    <span class="comment">// 5代表5次，30代表30s</span></span><br><span class="line">    <span class="keyword">super</span>(uid, <span class="number">5</span>, <span class="number">30</span> * DateUtils.SECOND_IN_MILLIS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>好了，阈值我们设置好了，那我们来看看在哪里标记的呢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app crash</span></span><br><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/AppErrors.java中 </span></span><br><span class="line"><span class="comment">// crashApplicationInner()方法，当应用crash了就判断是不是persistent应用，如果是就标记一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If a persistent app is stuck in a crash loop, the device isn&#x27;t very</span></span><br><span class="line"><span class="comment">// usable, so we want to consider sending out a rescue party.</span></span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.persistent) &#123;</span><br><span class="line">	RescueParty.notePersistentAppCrash(mContext, r.uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemServer.java</span></span><br><span class="line"><span class="comment">// 当SystemServer启动的时候，调用救援服务做一个标记</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	.....</span><br><span class="line">	<span class="comment">// Now that we have the bare essentials of the OS up and running, take</span></span><br><span class="line">    <span class="comment">// note that we just booted, which might send out a rescue party if</span></span><br><span class="line">    <span class="comment">// we&#x27;re stuck in a runtime restart loop.</span></span><br><span class="line">    RescueParty.noteBoot(mSystemContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以看到当应用crash和SystemServer重启都会调用到RescueParty的方法取做标记。</p>
<p>下面我们来看一下RescueParty的两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noteBoot</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDisabled()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// incrementAndTest()判断是否需要提升救援级别。如果在上诉的时间内启动达到5次就提升救援级别</span></span><br><span class="line">    <span class="keyword">if</span> (sBoot.incrementAndTest()) &#123;</span><br><span class="line">        sBoot.reset();</span><br><span class="line">        <span class="comment">//提升救援级别</span></span><br><span class="line">        incrementRescueLevel(sBoot.uid);</span><br><span class="line">        <span class="comment">// 执行救援级别，当达到4级就恢复出厂设置</span></span><br><span class="line">        executeRescueLevel(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notePersistentAppCrash</span><span class="params">(Context context, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDisabled()) <span class="keyword">return</span>;</span><br><span class="line">    Threshold t = sApps.get(uid);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> AppThreshold(uid);</span><br><span class="line">        sApps.put(uid, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无论app还是systemserver都会调到这里面去。</span></span><br><span class="line">    <span class="keyword">if</span> (t.incrementAndTest()) &#123;</span><br><span class="line">        t.reset();</span><br><span class="line">        incrementRescueLevel(t.uid);</span><br><span class="line">        executeRescueLevel(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从上面方法看到，无论app crash还是systemserver启动都会调到以下三个方法：</p>
<ul>
<li>incrementAndTest()：判断是否需要提升救援级别。如果在上诉的时间内启动达到5次就提升救援级别</li>
<li>incrementRescueLevel(t.uid)：提升指定UID的救援级别</li>
<li>executeRescueLevel(context)：执行救援服务</li>
</ul>
<p>下面我们分别分析上诉三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">incrementAndTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> window = now - getStart();</span><br><span class="line">    <span class="comment">// 如果小于阈值时间，更新时间</span></span><br><span class="line">    <span class="keyword">if</span> (window &gt; triggerWindow) &#123;</span><br><span class="line">        setCount(<span class="number">1</span>);</span><br><span class="line">        setStart(now);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> count = getCount() + <span class="number">1</span>;</span><br><span class="line">        setCount(count);  <span class="comment">// 设置阈值次数</span></span><br><span class="line">        EventLogTags.writeRescueNote(uid, count, window);</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Noticed &quot;</span> + count + <span class="string">&quot; events for UID &quot;</span> + uid + <span class="string">&quot; in last &quot;</span></span><br><span class="line">        + (window / <span class="number">1000</span>) + <span class="string">&quot; sec&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (count &gt;= triggerCount);  <span class="comment">// 如果大于阈值次数返回true，提升救援级别</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrementRescueLevel</span><span class="params">(<span class="keyword">int</span> triggerUid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前级别并且级别加1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> level = MathUtils.constrain(</span><br><span class="line">    	SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE) + <span class="number">1</span>,</span><br><span class="line">   		LEVEL_NONE, LEVEL_FACTORY_RESET);</span><br><span class="line">    <span class="comment">// 设置到属性服务中</span></span><br><span class="line">    SystemProperties.set(PROP_RESCUE_LEVEL, Integer.toString(level));</span><br><span class="line"></span><br><span class="line">    EventLogTags.writeRescueLevel(level, triggerUid);</span><br><span class="line">    logCriticalInfo(Log.WARN, <span class="string">&quot;Incremented rescue level to &quot;</span></span><br><span class="line">    	+ levelToString(level) + <span class="string">&quot; triggered by UID &quot;</span> + triggerUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeRescueLevel</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 从属性服务中获取救援级别</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> level = SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE);</span><br><span class="line">        <span class="keyword">if</span> (level == LEVEL_NONE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Attempting rescue level &quot;</span> + levelToString(level));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 救援级别执行对应任务</span></span><br><span class="line">            executeRescueLevelInternal(context, level);</span><br><span class="line">            EventLogTags.writeRescueSuccess(level);</span><br><span class="line">            logCriticalInfo(Log.DEBUG,</span><br><span class="line">                    <span class="string">&quot;Finished rescue level &quot;</span> + levelToString(level));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">final</span> String msg = ExceptionUtils.getCompleteMessage(t);</span><br><span class="line">            EventLogTags.writeRescueFailure(level, msg);</span><br><span class="line">            logCriticalInfo(Log.ERROR,</span><br><span class="line">                    <span class="string">&quot;Failed rescue level &quot;</span> + levelToString(level) + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeRescueLevelInternal</span><span class="params">(Context context, <span class="keyword">int</span> level)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS:</span><br><span class="line">                <span class="comment">// 单纯更新状态</span></span><br><span class="line">                resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_DEFAULTS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES:</span><br><span class="line">                resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_CHANGES);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS:</span><br><span class="line">                resetAllSettings(context, Settings.RESET_MODE_TRUSTED_DEFAULTS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_FACTORY_RESET:</span><br><span class="line">                <span class="comment">// 达到恢复出厂级别，才真正有事情干</span></span><br><span class="line">                RecoverySystem.rebootPromptAndWipeUserData(context, TAG);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>从executeRescueLevelInternal方法中可以看到，真正干事的是达到<code>LEVEL_FACTORY_RESET</code>级别，才有事情干。因此直接分析rebootPromptAndWipeUserData()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建重启指令，调用bootCommand()重启车机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebootPromptAndWipeUserData</span><span class="params">(Context context, String reason)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String reasonArg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">            reasonArg = <span class="string">&quot;--reason=&quot;</span> + sanitizeArg(reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String localeArg = <span class="string">&quot;--locale=&quot;</span> + Locale.getDefault().toString();</span><br><span class="line">        bootCommand(context, <span class="keyword">null</span>, <span class="string">&quot;--prompt_and_wipe_data&quot;</span>, reasonArg, localeArg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bootCommand</span><span class="params">(Context context, String... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        LOG_FILE.delete();</span><br><span class="line">        StringBuilder command = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] var3 = args;</span><br><span class="line">        <span class="keyword">int</span> var4 = args.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String arg = var3[var5];</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(arg)) &#123;</span><br><span class="line">                command.append(arg);</span><br><span class="line">                command.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 重启车机</span></span><br><span class="line">        RecoverySystem rs = (RecoverySystem)context.getSystemService(<span class="string">&quot;recovery&quot;</span>);</span><br><span class="line">        rs.rebootRecoveryWithCommand(command.toString());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Reboot failed (no permissions?)&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-问题回溯"><a href="#4-问题回溯" class="headerlink" title="4.问题回溯"></a>4.问题回溯</h4><p>可以从第二节看到，CarService发生crash，触发了<code>FACTORY_RESET</code>救援，所以车机恢复出厂设置，然后重启了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>系统重启</tag>
      </tags>
  </entry>
  <entry>
    <title>RTMP与FFmpeg编译问题集</title>
    <url>/2021/07/29/RTMP%E4%B8%8EFFmpeg%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<h3 id="1-error-undefined-reference-to-‘av-version-info-’"><a href="#1-error-undefined-reference-to-‘av-version-info-’" class="headerlink" title="1.error: undefined reference to ‘av_version_info()’"></a>1.error: undefined reference to ‘av_version_info()’</h3><blockquote>
<p>出错原因：  ffmpeg是纯C的库，头文件没有做好C++调用的准备  用extern “C”{}套住ffmpeg头文件，用C 语言的编译规则来编译ffmpeg代码，就可以了</p>
<p>解决办法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-libavutil-log-c-186-error-undefined-reference-to-‘stderr’"><a href="#2-libavutil-log-c-186-error-undefined-reference-to-‘stderr’" class="headerlink" title="2.libavutil/log.c:186: error: undefined reference to ‘stderr’"></a>2.libavutil/log.c:186: error: undefined reference to ‘stderr’</h4><blockquote>
<p>出错原因：<br>代码中使用了大量的标准IO设备：stderr 等，这些在NDK15以后，这些都不被支持了，代码本身 没问题，只是编译器链接时找不到对应的静态库定义了； </p>
<p>解决方案：<br>在编译选项中添加语句-DANDROID_API=[你的android API版本号]即可；  比如我的测试手机为 android 5.1.1 对应 API = 22，编译选项中应该添加：-DANDROID_API=22<br>adb shell 获取 android 系统版本：   adb shell getprop ro.build.version.release adb shell 获取 android 系统 API 版本：   adb shell getprop ro.build.version.sdk</p>
</blockquote>
<h4 id="3-libavformat-utils-c-513-error-undefined-reference-to-‘av-parser-close’"><a href="#3-libavformat-utils-c-513-error-undefined-reference-to-‘av-parser-close’" class="headerlink" title="3.libavformat/utils.c:513: error: undefined reference to ‘av_parser_close’"></a>3.libavformat/utils.c:513: error: undefined reference to ‘av_parser_close’</h4><blockquote>
<p>出错原因：  链接静态库先后顺序不正确，引起的符号定义找不到。<br>解决方案： </p>
<ol>
<li><p>修改静态库的链接顺序。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">	native-lib </span><br><span class="line">	avfilter avformat avcodec avutil swresample swscale log</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略静态库的链接顺序。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">    native-lib </span><br><span class="line">    -Wl,--start-group </span><br><span class="line">    avcodec avfilter avformat avutil swresample swscale -Wl,--end-group </span><br><span class="line">    log</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</blockquote>
<h4 id="4-libavformat-http-c-1649-error-undefined-reference-to-‘inflateEnd’"><a href="#4-libavformat-http-c-1649-error-undefined-reference-to-‘inflateEnd’" class="headerlink" title="4.libavformat/http.c:1649: error: undefined reference to ‘inflateEnd’"></a>4.libavformat/http.c:1649: error: undefined reference to ‘inflateEnd’</h4><blockquote>
<p>出错原因：  找不到的z库中的函数的实现。因为 ffmpeg 依赖了z库。编译ffmpeg的时候如果仔细看编译 时输出的日志，就可以看到   External libraries: zlib<br>解决方案：添加z库的依赖。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">    native-lib </span><br><span class="line">    -Wl,--start-group </span><br><span class="line">    avcodec avfilter avformat avutil swresample swscale -Wl,--end-group </span><br><span class="line">    log </span><br><span class="line">    z </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-libavformat-hls-c-845-error-undefined-reference-to-‘atof’"><a href="#5-libavformat-hls-c-845-error-undefined-reference-to-‘atof’" class="headerlink" title="5.libavformat/hls.c:845: error: undefined reference to ‘atof’"></a>5.libavformat/hls.c:845: error: undefined reference to ‘atof’</h3><blockquote>
<p>出错原因：<br>Google have moved some of the C standard library functions like atof() from being inline functions in header files to normal functions. The latest NDKs will default to building a .so that is only compatible with the latest Android devices that have the atof() function in the device’s standard C library (libc.so). This means if you run a library on an older device that has an older version of the C library, you will get an error loading the dll as the expected atof() function will not exist.<br>解决方案：  修改ffmpeg编译脚本，指定Android API版本为17，重新编译。 </p>
<p>这里又有一个问题：<br>libavcodec/v4l2_buffers.c:434:44: error: call to ‘mmap’ declared with attribute error: mmap is not available &gt; with _FILE_OFFSET_BITS=64 when using GCC until android-21. Either raise your minSdkVersion, disable &gt; _FILE_OFFSET_BITS=64, or switch to Clang.</p>
<p>所以21版本以下，需要取消 _FILE_OFFSET_BITS宏定义。添加编译参数：   -U_FILE_OFFSET_BITS</p>
</blockquote>
<h4 id="6-混合编译FFmpeg和Rtmp"><a href="#6-混合编译FFmpeg和Rtmp" class="headerlink" title="6.混合编译FFmpeg和Rtmp"></a>6.混合编译FFmpeg和Rtmp</h4><h5 id="6-1-下载最新库"><a href="#6-1-下载最新库" class="headerlink" title="6.1 下载最新库"></a>6.1 下载最新库</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载rtmp</span></span><br><span class="line">wget https:<span class="comment">//codeload.github.com/yixia/librtmp/zip/refs/heads/master</span></span><br><span class="line">unzip master</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 下载最新ffmpeg</span></span><br><span class="line">wget https:<span class="comment">//ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2</span></span><br><span class="line">tar -xvf ffmpeg-<span class="number">4.2</span><span class="number">.2</span>.tar.bz2</span><br></pre></td></tr></table></figure>


<h5 id="6-2-单编rtmp脚本"><a href="#6-2-单编rtmp脚本" class="headerlink" title="6.2 单编rtmp脚本"></a>6.2 单编rtmp脚本</h5><p>编译androideabi架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">export XCFLAGS=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=17&quot;</span><br><span class="line">export XLDFLAGS=&quot;--sysroot=$&#123;NDK_ROOT&#125;/platforms/android-17/arch-arm &quot;</span><br><span class="line">export CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-</span><br><span class="line"></span><br><span class="line">make install SYS=android prefix=`pwd`/result CRYPTO= SHARED=  XDEF=-DNO_SSL </span><br></pre></td></tr></table></figure>


<p>编译arm64-v8a架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=aarch64-linux-android</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">export XCFLAGS=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=17&quot;</span><br><span class="line">export XLDFLAGS=&quot;--sysroot=$&#123;NDK_ROOT&#125;/platforms/android-17/arch-arm &quot;</span><br><span class="line">export CROSS_COMPILE=$TOOLCHAIN/bin/aarch64-linux-android-</span><br><span class="line"></span><br><span class="line">make install SYS=android prefix=`pwd`/result CRYPTO= SHARED=  XDEF=-DNO_SSL</span><br></pre></td></tr></table></figure>


<h5 id="6-2混编FFmpeg和rtmp"><a href="#6-2混编FFmpeg和rtmp" class="headerlink" title="6.2混编FFmpeg和rtmp"></a>6.2混编FFmpeg和rtmp</h5><p>6.2.1 修改configure文件</p>
<p>6.2.1.1 最新版本的ffmpeg默认使用clang编译，可以修改configure文件来关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">注释4210-4213行，关闭掉： </span><br><span class="line">4209 </span><br><span class="line">4210 #set_default target_os </span><br><span class="line">4211 #if test &quot;$target_os&quot; = android; then 4212 #   cc_default=&quot;clang&quot; </span><br><span class="line">4213 #fi </span><br><span class="line">4214</span><br></pre></td></tr></table></figure>
<p>6.2.1.2 由于ffmpeg 默认开启librtmp需要pkgconfig，这里我们手动关闭，修改ffmpeg的configure文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#注解掉6256行</span></span></span><br><span class="line">6254 enabled libpulse          &amp;&amp; require_pkg_config libpulse libpulse pulse/pulseaudio.h pa_context_new</span><br><span class="line">6255 enabled librsvg           &amp;&amp; require_pkg_config librsvg librsvg-2.0 librsvg-2.0/librsvg/rsvg.h rsvg_handle_render_cairo</span><br><span class="line">6256 # enabled librtmp           &amp;&amp; require_pkg_config librtmp librtmp librtmp/rtmp.h RTMP_Socket</span><br><span class="line">6257 enabled librubberband     &amp;&amp; require_pkg_config librubberband &quot;rubberband &gt;= 1.8.1&quot; rubberband/rubberband-c.h rubberband_new -lstdc++ &amp;&amp; append librubberband_extralibs &quot;-lstdc++&quot;</span><br><span class="line">6258 enabled libshine          &amp;&amp; require_pkg_config libshine shine shine/layer3.h shine_encode_buffer</span><br></pre></td></tr></table></figure>


<p>6.2.2 编译androideabi架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">ANDROID_API=17</span><br><span class="line"></span><br><span class="line">PREFIX=./android/armeabi-v7a/ffmpeg_rtmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rtmp路径</span></span><br><span class="line">RTMP=/root/KevinStudyNDK/MyFFmpeg3/librtmp/result</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-librtmp \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/$CPU- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC -I$RTMP/include&quot; \</span><br><span class="line">--extra-ldflags=&quot;-L$RTMP/lib&quot; \</span><br><span class="line">--extra-libs=&quot;-lrtmp&quot; \</span><br><span class="line">--arch=arm \</span><br><span class="line">--target-os=android </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>编译arm64-v8a架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=aarch64-linux-android</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">ANDROID_API=21</span><br><span class="line"></span><br><span class="line">PREFIX=./android/arm64-v8a/ffmpeg_rtmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rtmp路径</span></span><br><span class="line">RTMP=/home/jackou/ndk/ffmpeg/librtmp-master/result</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-librtmp \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/$CPU- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm64 \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=arm64-v8a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC -I$RTMP/include&quot; \</span><br><span class="line">--extra-ldflags=&quot;-L$RTMP/lib&quot; \</span><br><span class="line">--extra-libs=&quot;-lrtmp&quot; \</span><br><span class="line">--arch=aarch64 \</span><br><span class="line">--target-os=android </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>6.2.3 集成到AS中CMakelist脚本</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入FFmpeg的头文件 </span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/ffmpeg/<span class="keyword">include</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入FFmpeg的库文件 </span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; - </span></span><br><span class="line"><span class="string">L$&#123;CMAKE_SOURCE_DIR&#125;/ffmpeg/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>) <span class="comment"># 导入Rtmp的库文件 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS  <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; - </span></span><br><span class="line"><span class="string">L$&#123;CMAKE_SOURCE_DIR&#125;/rtmp/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">    my-player </span><br><span class="line">    <span class="variable">$&#123;log-lib&#125;</span> </span><br><span class="line">    -Wl,</span><br><span class="line">    --start-group </span><br><span class="line">    avcodec avfilter avformat avutil swresample swscale -Wl,</span><br><span class="line">    --end-group </span><br><span class="line">    z </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h4 id="7-搭建rtmp服务器"><a href="#7-搭建rtmp服务器" class="headerlink" title="7.搭建rtmp服务器"></a>7.搭建rtmp服务器</h4><h5 id="7-1-下载Nginx和rtmp-module"><a href="#7-1-下载Nginx和rtmp-module" class="headerlink" title="7.1 下载Nginx和rtmp-module"></a>7.1 下载Nginx和rtmp-module</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载Nginx</span></span><br><span class="line">wget http://nginx.org/download/nginx-1.15.3.tar.gz tar xvf nginx-1.15.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下载rtmp-module</span></span><br><span class="line">wget https://codeload.github.com/arut/nginx-rtmp-module/tar.gz/v1.2.1</span><br></pre></td></tr></table></figure>


<h5 id="7-2-执行配置和安装"><a href="#7-2-执行配置和安装" class="headerlink" title="7.2 执行配置和安装"></a>7.2 执行配置和安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成makefile</span></span><br><span class="line">./configure --prefix=./bin --add-module=../nginx-rtmp-module-1.2.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成结果在bin</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>成功之后，会在/bin下生成conf  html  logs  sbin几个文件。</p>
<h5 id="7-3-配置Nginx"><a href="#7-3-配置Nginx" class="headerlink" title="7.3 配置Nginx"></a>7.3 配置Nginx</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入到成果目录，并且配置nginx</span></span><br><span class="line">cd /bin/conf</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动nginx服务器就会报错，权限被拒绝</span></span><br><span class="line">user root;</span><br><span class="line"></span><br><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果启动错误，这个就是错误日志详情</span></span><br><span class="line">error_log logs/error.log debug;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">	worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;</span><br><span class="line">	server &#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">注意端口占用  流媒体服务器的端口</span></span><br><span class="line">		listen 1935;</span><br><span class="line">		</span><br><span class="line"><span class="meta">		#</span><span class="bash">如果不加，可能会失败</span></span><br><span class="line">		application myapp &#123;</span><br><span class="line">			live on;</span><br><span class="line"><span class="meta">			#</span><span class="bash">丢弃闲置5s的连接</span></span><br><span class="line">			drop_idle_publisher 5s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下面就是为了测试 http://139.224.136.101:8080/<span class="built_in">stat</span> 控制面板的意思</span></span><br><span class="line">http &#123;</span><br><span class="line">	server &#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">注意端口占用</span></span><br><span class="line">		listen 8080;</span><br><span class="line">		location /stat &#123;</span><br><span class="line">			rtmp_stat all;</span><br><span class="line">			rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /stat.xsl</span><br><span class="line">		&#123; </span><br><span class="line">			root /home/jackou/ndk/Nginx_RTMP/nginx-rtmp-module-1.2.1/;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /control</span><br><span class="line">		&#123; </span><br><span class="line">			rtmp_control all;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /rtmp-publisher</span><br><span class="line">		&#123; </span><br><span class="line">			root /home/jackou/ndk/Nginx_RTMP/nginx-rtmp-module-1.2.1/test;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location / &#123;</span><br><span class="line">			root /home/jackou/ndk/Nginx_RTMP/nginx-rtmp-module-1.2.1/test/www;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-4-启动服务"><a href="#7-4-启动服务" class="headerlink" title="7.4 启动服务"></a>7.4 启动服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jackou@ubuntu:~/ndk/Nginx_RTMP/nginx-1.15.3$ sudo bin/sbin/nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] still could not bind()</span><br><span class="line"><span class="meta">#</span><span class="bash">端口被占用需要停止服务</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line">sudo bin/sbin/nginx -s stop</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启后输入如下域名查看是否启动成功</span></span><br><span class="line">http://139.224.136.101:8080/stat</span><br></pre></td></tr></table></figure>
<p>启动成功之后，就会出现这种情况，139.224.136.101是一个共有云服务器，需要自己买。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-19b73c7af1ac4eef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ngnix启动成功.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>RTMP</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>调查应用无辜被kill问题</title>
    <url>/2021/07/29/%E8%B0%83%E6%9F%A5%E5%BA%94%E7%94%A8%E6%97%A0%E8%BE%9C%E8%A2%ABkill%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>​    VPA应用经常崩溃，从日志中看com.iflytek.autofly.avatar 进程经常被kill。</p>
<h4 id="2-问题定位"><a href="#2-问题定位" class="headerlink" title="2.问题定位"></a>2.问题定位</h4><h5 id="2-1-搜索AndroidRuntime"><a href="#2-1-搜索AndroidRuntime" class="headerlink" title="2.1 搜索AndroidRuntime"></a>2.1 搜索<code>AndroidRuntime</code></h5><p>查看进程有没有被系统杀死，从log中看到,系统杀死的是<code>com.gxa.service.btcall</code>，并不是我们希望的<code>com.iflytek.autofly.avatar</code>应用，因此此线索结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">E AndroidRuntime: Process: com.gxa.service.btcall, PID: <span class="number">16399</span></span><br><span class="line">E AndroidRuntime: java.lang.RuntimeException: Unable to create service com.gxa.service.btcall.BtCallService: java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">&#x27;boolean ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager.registerCallback(ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager$BluetoothPhoneBookCallBack)&#x27;</span> on a <span class="keyword">null</span> object reference</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3582</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.access$<span class="number">1300</span>(ActivityThread.java:<span class="number">200</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">1672</span>)</span><br><span class="line">E AndroidRuntime: 	at android.os.Handler.dispatchMessage(Handler.java:<span class="number">106</span>)</span><br><span class="line">E AndroidRuntime: 	at android.os.Looper.loop(Looper.java:<span class="number">193</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6718</span>)</span><br><span class="line">E AndroidRuntime: 	at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">E AndroidRuntime: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">493</span>)</span><br><span class="line">E AndroidRuntime: 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">858</span>)</span><br><span class="line">E AndroidRuntime: Caused by: java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">&#x27;boolean ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager.registerCallback(ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager$BluetoothPhoneBookCallBack)&#x27;</span> on a <span class="keyword">null</span> object reference</span><br><span class="line">E AndroidRuntime: 	at com.gxa.service.btcall.model.adapter.BtPhoneAdapter.init(BtPhoneAdapter.java:<span class="number">282</span>)</span><br><span class="line">E AndroidRuntime: 	at com.gxa.service.btcall.model.adapter.BtPhoneAdapter.&lt;init&gt;(BtPhoneAdapter.java:<span class="number">249</span>)</span><br><span class="line">E AndroidRuntime: 	at com.gxa.service.btcall.BtCallService.onCreate(BtCallService.java:<span class="number">101</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3570</span>)</span><br><span class="line">E AndroidRuntime: 	... <span class="number">8</span> more</span><br></pre></td></tr></table></figure>


<h5 id="2-2-直接搜索com-iflytek-autofly-avatar"><a href="#2-2-直接搜索com-iflytek-autofly-avatar" class="headerlink" title="2.2 直接搜索com.iflytek.autofly.avatar"></a>2.2 直接搜索<code>com.iflytek.autofly.avatar</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Line <span class="number">13098</span>: <span class="number">07</span>-<span class="number">28</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">06.089</span>   <span class="number">782</span> <span class="number">17518</span> I am_kill : [<span class="number">0</span>,<span class="number">28090</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]</span><br><span class="line">Line <span class="number">13098</span>: <span class="number">07</span>-<span class="number">28</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">06.089</span>   <span class="number">782</span> <span class="number">17518</span> I am_kill : [<span class="number">0</span>,<span class="number">28090</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]</span><br></pre></td></tr></table></figure>
<p>从日志中看到我们关注的应用确实有被kill的足迹。然后顺腾摸瓜，搜索“782”,看看这个进程是为什么kill VPA进程。</p>
<h5 id="2-3-搜索782"><a href="#2-3-搜索782" class="headerlink" title="2.3 搜索782"></a>2.3 搜索782</h5><p>从一堆日志中根本看不出有什么被杀原因的线索，“单纯”被杀了。继续回到<code>com.iflytek.autofly.avatar</code>的日志中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一行日志非常关键，可以看到com.iflytek.autofly.avatar被3186强制停止了！！</span></span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Force stopping com.iflytek.autofly.avatar appid=<span class="number">1000</span> user=<span class="number">0</span>: from pid <span class="number">3186</span></span><br><span class="line"><span class="comment">// 被停止的oom_adj值为200说明内存暂时也还不高，因此暂时排除com.iflytek.autofly.avatar因为内存问题被kill的可能</span></span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Killing <span class="number">2211</span>:com.iflytek.autofly.avatar/<span class="number">1000</span> (adj <span class="number">200</span>): stop com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I am_kill : [<span class="number">0</span>,<span class="number">2211</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]xxxxxxxxxx com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Force stopping com.iflytek.autofly.avatar appid=<span class="number">1000</span> user=<span class="number">0</span>: from pid <span class="number">3186</span></span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Killing <span class="number">2211</span>:com.iflytek.autofly.avatar/<span class="number">1000</span> (adj <span class="number">200</span>): stop com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I am_kill : [<span class="number">0</span>,<span class="number">2211</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]</span><br></pre></td></tr></table></figure>


<h5 id="2-4-搜索”3186”查看这个进程干了什么"><a href="#2-4-搜索”3186”查看这个进程干了什么" class="headerlink" title="2.4 搜索”3186”查看这个进程干了什么"></a>2.4 搜索”3186”查看这个进程干了什么</h5><p>从<code>3186</code>可以看到很多重要信息，如下信息显示这个进程会去做内存检查，当前可用内存：51687837696，已用内存419430400，发起超过400M警告</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: MSG_CHECK_DATA_MEMORY</span><br><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: requestCheckDataAvailableMemorySize</span><br><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: checkDataAvailableMemorySize is <span class="number">51687837696</span> check memorySize is <span class="number">419430400</span></span><br><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: MSG_DATA_MEMORY_MORE_400M</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Force stopping com.iflytek.autofly.avatar appid=<span class="number">1000</span> user=<span class="number">0</span>: from pid <span class="number">3186</span></span><br><span class="line"><span class="number">3186</span>  <span class="number">3218</span> D procmonitor: <span class="meta">@ActivityProcManager</span>@: onProcessDied pid=<span class="number">2211</span> uid=<span class="number">1000</span></span><br><span class="line"><span class="comment">// 从这句话可以看出com.iflytek.autofly.avatar被杀了</span></span><br><span class="line"><span class="number">3186</span>  <span class="number">3246</span> D procmonitor: <span class="meta">@ActivityProcManager</span>@: runLimitLogic kill packagename = com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">3186</span>  <span class="number">3246</span> D procmonitor: <span class="meta">@ConfigManager</span>@: <span class="function">getWhiteLists <span class="title">called</span><span class="params">()</span> isInitFalg</span>=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>真相即将浮现，查看procmonitor是哪个服务输出的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jieou<span class="meta">@gxatek</span>-fw-no:/work/jieou/gxa_code/lagvm_p/LINUX/android/vendor/gxatek/proprietary$ grep -nr <span class="string">&quot;procmonitor&quot;</span></span><br><span class="line">CarProcManager/ProcManagementService/service/src/main/java/com/gxa/car/procmanagement/utils/LogUtils.java:<span class="number">27</span>:    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;procmonitor&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在源码中grep到日志是ProcManagementService发出的，于是开始分析这个服务到底是干了什么。</p>
<h4 id="3-ProcManagementService源码分析"><a href="#3-ProcManagementService源码分析" class="headerlink" title="3.ProcManagementService源码分析"></a>3.ProcManagementService源码分析</h4><h5 id="3-1-服务架构如下"><a href="#3-1-服务架构如下" class="headerlink" title="3.1 服务架构如下"></a>3.1 服务架构如下</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-7c74847778ed3cb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ProcManagerService.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcManagementService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;onCreate()&quot;</span>);</span><br><span class="line">        mProcManagementImpl = <span class="keyword">new</span> ProcManagementImpl(<span class="keyword">this</span>.getApplicationContext());</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正实现在<code>ProcManagementImpl</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProcManagementImpl</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">// 1.一键清理manager</span></span><br><span class="line">    mCleanProcManager = <span class="keyword">new</span> CleanProcManager(mContext);</span><br><span class="line">    <span class="comment">// 2.内存管理monitor</span></span><br><span class="line">    mDeviceStorageMonitor = <span class="keyword">new</span> DeviceStorageMonitor(mContext);</span><br><span class="line">    mDeviceStorageMonitor.init();</span><br><span class="line">    <span class="comment">// 3.界面管理manager</span></span><br><span class="line">    mActivityProcManager = <span class="keyword">new</span> ActivityProcManager(mContext.getApplicationContext());</span><br><span class="line">    mAsyncHandlerThread = <span class="keyword">new</span> HandlerThread(THREAD_NAME);</span><br><span class="line">    mAsyncHandlerThread.start();</span><br><span class="line">    mAsyncHandler = <span class="keyword">new</span> Handler(mAsyncHandlerThread.getLooper()) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        	asyncHandleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4.初始化Handler，解析配置文件</span></span><br><span class="line">    mAsyncHandler.sendEmptyMessageDelayed(ID_INIT, DELAY_TIME_500);</span><br><span class="line">    <span class="comment">// 5.注册清理app内存和清理后台app内存广播</span></span><br><span class="line">    registerDebugReceiver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>从构造方法中可以看出，ProcManagement主要会做五个事情，其中我们主要分析1，2，3，5步。</p>
<h5 id="3-2-CleanProcManager"><a href="#3-2-CleanProcManager" class="headerlink" title="3.2 CleanProcManager"></a>3.2 CleanProcManager</h5><p>CleanProcManager主要是提供接口供设置应用使用，设置可以一键kill非白名单后台应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CleanProcManager.java</span></span><br><span class="line"><span class="comment">// kill非白名单应用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBackgroundProcessByWhiteList</span><span class="params">(List&lt;String&gt; whiteList)</span> </span>&#123;</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;killBackgroundProcessByWhiteList&quot;</span>);</span><br><span class="line">        MemoryInfo beforeInfo = <span class="keyword">new</span> MemoryInfo();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAms.getMemoryInfo(beforeInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;getMemoryInfo exception=&quot;</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;RecentTaskInfo&gt; runningAppList = filterAppInfoByWhiteList(getRecentTask(), whiteList);</span><br><span class="line">        <span class="keyword">if</span> (runningAppList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RecentTaskInfo info : runningAppList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    LogUtils.logd(TAG, <span class="string">&quot;runningAppList:&quot;</span> + info.realActivity.getPackageName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//KillProcess</span></span><br><span class="line">                String packageName = info.realActivity.getPackageName();</span><br><span class="line">                <span class="keyword">if</span> (packageName.contains(<span class="string">&quot;launcher&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;killProcess:&quot;</span> + info.realActivity.getPackageName());</span><br><span class="line">                <span class="comment">// mAm.killBackgroundProcesses(info.realActivity.getPackageName());</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mAms.removeTask(info.persistentId);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                    LogUtils.loge(TAG, <span class="string">&quot;killBackgroundProcessByWhiteList ex=&quot;</span> + ex.toString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemoryInfo afterInfo = <span class="keyword">new</span> MemoryInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAms.getMemoryInfo(afterInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;getMemoryInfo exception=&quot;</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mem = afterInfo.availMem - beforeInfo.availMem;</span><br><span class="line">        String freeMem = Formatter.formatFileSize(mContext, mem);</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;FreeMem=&quot;</span> + freeMem);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CleanProcManager.java</span></span><br><span class="line"><span class="comment">// 清理应用内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteCacheByWhiteList</span><span class="params">(List&lt;String&gt; whiteList)</span> </span>&#123;</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;deleteCacheByWhiteList&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (mAppDataObserver == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAppDataObserver = <span class="keyword">new</span> AppDataObserver();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ApplicationInfo&gt; installApps = getInstallApplications();</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; installApps.size(); i++) &#123;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;getInstallApplications-&gt;&quot;</span> + installApps.get(i).packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ApplicationInfo&gt; runningAppList = filterAppInfoByWhiteList(installApps, whiteList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runningAppList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ApplicationInfo info : runningAppList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    LogUtils.logd(TAG, <span class="string">&quot;runningAppList-&gt;&quot;</span> + info.processName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (info.packageName.contains(<span class="string">&quot;launcher&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;deleteApplicationCacheFiles-&gt;&quot;</span> + info.processName);</span><br><span class="line">                mPm.deleteApplicationCacheFiles(info.processName, mAppDataObserver);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-DeviceStorageMonitor"><a href="#3-3-DeviceStorageMonitor" class="headerlink" title="3.3 DeviceStorageMonitor"></a>3.3 DeviceStorageMonitor</h5><p>在DeviceStorageMonitor主要是判断每个应用在data分区的数据大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        requestCheckDataAvailableMemorySize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkDataAvailableMemorySize(MEMORY_SIZE_FOR_400M)) &#123;</span><br><span class="line">            mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_MORE_400M);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkDataAvailableMemorySize(MEMORY_SIZE_FOR_200M)) &#123;</span><br><span class="line">                mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_MORE_200M);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkDataAvailableMemorySize(MEMORY_SIZE_FOR_100M)) &#123;</span><br><span class="line">                    mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_MORE_100M);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_LESS_100M);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_CHECK_DATA_MEMORY:</span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_CHECK_DATA_MEMORY&quot;</span>);</span><br><span class="line">        checkMemory();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_MORE_400M:</span><br><span class="line">        <span class="comment">// 当还大于400M，不处理</span></span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_MORE_400M&quot;</span>);</span><br><span class="line">        mLowStorageSpace = <span class="keyword">false</span>;</span><br><span class="line">   	 <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_MORE_200M:</span><br><span class="line">        <span class="comment">// 当小于200M，弹出toast</span></span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_MORE_200M&quot;</span>);</span><br><span class="line">        mLowStorageSpace = <span class="keyword">false</span>;</span><br><span class="line">        CarToast.makeText(mContext, R.string.system_basic_recovery_and_remove_app_text,</span><br><span class="line">        TOAST_SHOW_LONG_TIME).show();</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_MORE_100M:</span><br><span class="line">        <span class="comment">// 当小于100M，弹出警告框</span></span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_MORE_100M&quot;</span>);</span><br><span class="line">        mLowStorageSpace = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (has3rdApp()) &#123;</span><br><span class="line">       		showStorageWarningView();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			showMasterCleanDialog();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理log日志</span></span><br><span class="line">        clearLogFiles();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_LESS_100M:</span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_LESS_100M&quot;</span>);</span><br><span class="line">        <span class="comment">// 低内存标志位置位</span></span><br><span class="line">        mLowStorageSpace = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 弹出清理提示框</span></span><br><span class="line">        showMasterCleanDialog();</span><br><span class="line">       	<span class="comment">// 删除temp目录</span></span><br><span class="line">        deletePlaceHolderFile();</span><br><span class="line">        <span class="comment">// 清理log日志</span></span><br><span class="line">        clearLogFiles();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-4-ActivityProcManager"><a href="#3-4-ActivityProcManager" class="headerlink" title="3.4 ActivityProcManager"></a>3.4 ActivityProcManager</h5><p>这里着重介绍ActivityProcManager类，因为出现该问题的原因就是这个manager导致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityProcManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mMonitorHandlerThread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">        mMonitorHandlerThread.start();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(mMonitorHandlerThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 判断是否杀掉进程的逻辑</span></span><br><span class="line">                myHandleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    	<span class="comment">// 进程观察者</span></span><br><span class="line">        mProcessObserver = <span class="keyword">new</span> ProcessObserver();</span><br><span class="line">        mAm = ActivityManager.getService();</span><br><span class="line">        <span class="comment">// monitor activity change.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAm.registerProcessObserver(mProcessObserver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;cannot register activity monitoring&quot;</span> + Log.getStackTraceString(ex));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先来看一下信号输入，进程观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessObserver</span> <span class="keyword">extends</span> <span class="title">IProcessObserver</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onForegroundActivitiesChanged</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid, <span class="keyword">boolean</span> foregroundActivities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            LogUtils.logd(TAG, <span class="string">&quot;onForegroundActivitiesChanged,pid=&quot;</span> + pid + <span class="string">&quot; uid=&quot;</span> + uid</span><br><span class="line">                + <span class="string">&quot; foregroundActivities=&quot;</span> + foregroundActivities);</span><br><span class="line">        &#125;</span><br><span class="line">        String packageName = getPackageNameByPidUid(pid, uid);</span><br><span class="line">        <span class="keyword">if</span> (foregroundActivities) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果是前台activity，做一个标记</span></span><br><span class="line">                mCurrentActivityInfo = <span class="keyword">new</span> LastActivityInfo(pid, uid, packageName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是忽略列表中的应用，直接返回，(应用返回home或者systemui)不做记录</span></span><br><span class="line">        <span class="keyword">if</span> (checkIsIgnorePackage(packageName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果切换界面的进程号是一样的，不做判断</span></span><br><span class="line">        <span class="keyword">if</span> (mLastActivityInfo != <span class="keyword">null</span> &amp;&amp; mLastActivityInfo.mPid == pid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="comment">// 记录上一次界面的进程号和包名</span></span><br><span class="line">            mLastActivityInfo = <span class="keyword">new</span> LastActivityInfo(pid, uid, packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            LogUtils.logd(TAG, <span class="string">&quot;mLastActivityInfo = &quot;</span> + mLastActivityInfo.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知检查activity界面</span></span><br><span class="line">        notifyForegroundActivitiesChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessDied</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyForegroundActivitiesChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;notifyForegroundActivitiesChanged handler is null!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check interval time</span></span><br><span class="line">    	<span class="comment">// 每10秒触发一次界面检查：ID_CHECK_RUN_LIMIT</span></span><br><span class="line">        <span class="keyword">long</span> curTime = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">if</span> ((curTime - mLastRunLimitLogicTime) &gt;= MINIMUM_RUNNING_INTERVAL) &#123;</span><br><span class="line">            mHandler.removeMessages(ID_CHECK_RUN_LIMIT);</span><br><span class="line">            mHandler.sendEmptyMessage(ID_CHECK_RUN_LIMIT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHandler.removeMessages(ID_CHECK_RUN_LIMIT);</span><br><span class="line">            <span class="keyword">long</span> delay = MINIMUM_RUNNING_INTERVAL - (curTime - mLastRunLimitLogicTime);</span><br><span class="line">            mHandler.sendEmptyMessageDelayed(ID_CHECK_RUN_LIMIT, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = msg.what;</span><br><span class="line">        <span class="keyword">if</span> (id == ID_CHECK_RUN_LIMIT) &#123;</span><br><span class="line">            runLimitLogic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runLimitLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFeaturesEnable) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="comment">// 获取当前activity栈</span></span><br><span class="line">        List&lt;RecentTaskInfo&gt; infos = getRecentTask();</span><br><span class="line">        <span class="keyword">if</span> (infos == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RecentTaskInfo info : infos) &#123;</span><br><span class="line">            String packageName = info.realActivity.getPackageName();</span><br><span class="line">            <span class="comment">// 校验当前activity是否是前台activity</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsCurrentActiveTask(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 校验是否是白名单应用</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsWhiteList(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 校验是否是音乐应用在后台播放</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsAudioInBackground(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 校验是否跳过两级界面</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsLastRecord(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果以上都是false，杀掉进程</span></span><br><span class="line">                Method method = Class.forName(ACTIVITY_MANAGER_NAME)</span><br><span class="line">                                .getMethod(FORCE_STOP_PACKAGE, String.class);</span><br><span class="line">                method.invoke((ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE), packageName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;forceStopPackage ex=&quot;</span> + Log.getStackTraceString(ex));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;runLimitLogic kill packagename = &quot;</span> + packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update record time</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            mLastRunLimitLogicTime = SystemClock.elapsedRealtime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ok，我们找到问题了，<code>com.iflytek.autofly.avatar</code>不是白名单应用，界面跳过两级以上，被procmanger杀死了。</p>
<h5 id="3-5-问题解决"><a href="#3-5-问题解决" class="headerlink" title="3.5 问题解决"></a>3.5 问题解决</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在procmanager/proc_management_cfg.xml中加入应用白名单 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">proc_configs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">white_lists</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.app.launcher<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.appservice.procmanagement<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.systemui<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.app.settings<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.android.systemui<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">white_lists</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">black_lists</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>demo.test.package<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">black_lists</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proc_configs</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="4-问题回溯"><a href="#4-问题回溯" class="headerlink" title="4.问题回溯"></a>4.问题回溯</h4><p>车机系统在基于原生AMS的oom_adj内存管理机制的基础上，另外建立了一套进程管理机制来保证车机在有限的资源中，优先级高的应用进程能够获得更多存活机会。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>kill</tag>
      </tags>
  </entry>
  <entry>
    <title>(1)Iptables教程</title>
    <url>/2021/03/23/(1)Iptables%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="0-Iptables介绍"><a href="#0-Iptables介绍" class="headerlink" title="0. Iptables介绍"></a>0. Iptables介绍</h3><p>iptables防火墙可以用于创建过滤(filter)与NAT规则。所有Linux发行版都能使用iptables，因此理解如何配置iptables将会帮助你更有效地管理Linux防火墙。如果你是第一次接触iptables，你会觉得它很复杂，但是一旦你理解iptables的工作原理，你会发现其实它很简单。</p>
<p>首先介绍iptables的结构：iptables -&gt; Tables -&gt; Chains -&gt; Rules. 简单地讲，tables由chains组成，而chains又由rules组成。如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a1a23a58ea0dbfeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-table-chain-rule-structure.png"></p>
<h3 id="1-iptables的表与链"><a href="#1-iptables的表与链" class="headerlink" title="1.  iptables的表与链"></a>1.  iptables的表与链</h3><p>iptables具有Filter, NAT, Mangle, Raw四种内建表：Filter表、NAT表、Mangle表和Raw表</p>
<h4 id="1-1-Filter表"><a href="#1-1-Filter表" class="headerlink" title="1.1 Filter表"></a>1.1 Filter表</h4><p>Filter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：</p>
<ul>
<li>INPUT链 – 处理来自外部的数据。</li>
<li>OUTPUT链 – 处理向外发送的数据。</li>
<li>FORWARD链 – 将数据转发到本机的其他网卡设备上。</li>
</ul>
<h4 id="1-2-NAT表"><a href="#1-2-NAT表" class="headerlink" title="1.2 NAT表"></a>1.2 NAT表</h4><p>NAT表有三种内建链：</p>
<ul>
<li>PREROUTING链 – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。</li>
<li>POSTROUTING链 – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。</li>
<li>OUTPUT链 – 处理本机产生的数据包。</li>
</ul>
<h4 id="3-Mangle表"><a href="#3-Mangle表" class="headerlink" title="3. Mangle表"></a>3. Mangle表</h4><p>Mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链(解释见上)：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
<li>FORWARD</li>
<li>INPUT</li>
<li>POSTROUTING</li>
</ul>
<h3 id="4-Raw表"><a href="#4-Raw表" class="headerlink" title="4. Raw表"></a>4. Raw表</h3><p>Raw表用于处理异常，它具有2个内建链：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
</ul>
<p>以下是Iptables中的三个重要表格</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b9b4675931350c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-filter-nat-mangle-tables.png"></p>
<h3 id="2-IPTABLES-规则-Rules"><a href="#2-IPTABLES-规则-Rules" class="headerlink" title="2.IPTABLES 规则(Rules)"></a>2.IPTABLES 规则(Rules)</h3><p>牢记以下三点式理解iptables规则的关键：</p>
<ul>
<li>Rules包括一个条件和一个<strong>目标值</strong>(target)</li>
<li>如果满足条件，就执行目标(target)中的规则或者特定值。</li>
<li>如果不满足条件，就判断下一条Rules。</li>
</ul>
<p><strong>目标值（Target Values）</strong></p>
<p>下面是你可以在target里指定的特殊值：</p>
<ul>
<li>ACCEPT – 允许防火墙接收数据包</li>
<li>DROP – 防火墙丢弃包</li>
<li>QUEUE – 防火墙将数据包移交到用户空间</li>
<li>RETURN – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。</li>
</ul>
<p>如果你执行<code>iptables --list</code>你将看到防火墙上的可用规则。下例说明当前系统没有定义防火墙，你可以看到，它显示了默认的filter表，以及表内默认的input链, forward链, output链。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -t filter --list</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li>target：目标值     </li>
<li>prot： 协议</li>
<li>opt：选项</li>
<li>source：数据包源地址</li>
<li>destination：数据包目标地址</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-97d2c29e31e90ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter表内容.png"></p>
<p>bw_INPUT、bw_OUTPUT和bw_FORWARD chain用于带宽(Bandwidth)控制；</p>
<p>fw_INPUT、fw_OUTPUT和fw_FORWARD chain用于防火墙(Firewall)控制；</p>
<p>natctrl_FORWARD用于网络地址转换(NAT)控制；</p>
<p>oem_fwd、oem_out用于OEM厂商自定义的控制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看mangle表</span></span><br><span class="line">iptables -t mangle --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看nat表</span></span><br><span class="line">iptables -t nat --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看raw表</span></span><br><span class="line">iptables -t raw --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于默认表是filter表，不加-t选项默认输出filter表</span></span><br><span class="line">iptables -t filter --list</span><br><span class="line">(or)</span><br><span class="line">iptables --list</span><br></pre></td></tr></table></figure>


<h3 id="3-清空所有iptables规则"><a href="#3-清空所有iptables规则" class="headerlink" title="3.清空所有iptables规则"></a>3.清空所有iptables规则</h3><p>在配置iptables之前，你通常需要用<code>iptables --list</code>命令或者<code>iptables-save</code>命令查看有无现存规则，因为有时需要删除现有的iptables规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables --flush</span><br><span class="line">或者</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>
<p>这两条命令是等效的。但是并非执行后就万事大吉了。你仍然需要检查规则是不是真的清空了，因为有的linux发行版上这个命令不会清除NAT表中的规则，此时只能手动清除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t NAT -F</span><br></pre></td></tr></table></figure>


<h3 id="4-永久生效"><a href="#4-永久生效" class="headerlink" title="4.永久生效"></a>4.永久生效</h3><p>当你删除、添加规则后，这些更改并不能永久生效，这些规则很有可能在系统重启后恢复原样。为了让配置永久生效，根据平台的不同，具体操作也不同。下面进行简单介绍：</p>
<h4 id="4-1-Ubuntu"><a href="#4-1-Ubuntu" class="headerlink" title="4.1 Ubuntu"></a>4.1 Ubuntu</h4><p>首先，保存现有的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>然后新建一个bash脚本，并保存到/etc/network/if-pre-up.d/目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">iptables-restore &lt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>这样，每次系统重启后iptables规则都会被自动加载。<br>/!\注意：不要尝试在.bashrc或者.profile中执行以上命令，因为用户通常不是root，而且这只能在登录时加载iptables规则。</p>
<h4 id="4-2-CentOS-RedHat"><a href="#4-2-CentOS-RedHat" class="headerlink" title="4.2 CentOS, RedHat"></a>4.2 CentOS, RedHat</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 保存iptables规则</span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line"># 重启iptables服务</span><br><span class="line">service iptables stop</span><br><span class="line">service iptables start</span><br></pre></td></tr></table></figure>
<p>查看当前规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat  &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure>


<h3 id="5-追加iptables规则"><a href="#5-追加iptables规则" class="headerlink" title="5. 追加iptables规则"></a>5. 追加iptables规则</h3><p>可以使用<code>iptables -A</code>命令追加新规则，其中-A表示Append。因此，新的规则将追加到链尾。<br>一般而言，最后一条规则用于丢弃(DROP)所有数据包。如果你已经有这样的规则了，并且使用-A参数添加新规则，那么就是无用功。</p>
<h4 id="5-1语法"><a href="#5-1语法" class="headerlink" title="5.1语法"></a>5.1语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A chain firewall-rule</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">-A chain – 指定要追加规则的链</span></span><br><span class="line"><span class="meta">#</span><span class="bash">firewall-rule – 具体的规则参数</span></span><br></pre></td></tr></table></figure>


<h4 id="5-2-描述规则的基本参数"><a href="#5-2-描述规则的基本参数" class="headerlink" title="5.2 描述规则的基本参数"></a>5.2 描述规则的基本参数</h4><p>以下这些规则参数用于描述数据包的协议、源地址、目的地址、允许经过的网络接口，以及如何处理这些数据包。这些描述是对规则的基本描述。</p>
<h5 id="p-协议（protocol）"><a href="#p-协议（protocol）" class="headerlink" title="-p 协议（protocol）"></a>-p 协议（protocol）</h5><ul>
<li><p>指定规则的协议，如tcp, udp, icmp等，可以使用all来指定所有协议。</p>
</li>
<li><p>如果不指定-p参数，则默认是all值。这并不明智，请总是明确指定协议名称。</p>
</li>
<li><p>可以使用协议名(如tcp)，或者是协议值（比如6代表tcp）来指定协议。映射关系请查看/etc/protocols</p>
</li>
<li><p>还可以使用–protocol参数代替-p参数</p>
</li>
</ul>
<h5 id="s-源地址（source）"><a href="#s-源地址（source）" class="headerlink" title="-s 源地址（source）"></a>-s 源地址（source）</h5><ul>
<li>指定数据包的源地址</li>
<li>参数可以使IP地址、网络地址、主机名</li>
<li>例如：-s 192.168.1.101指定IP地址</li>
<li>例如：-s 192.168.1.10/24指定网络地址</li>
<li>如果不指定-s参数，就代表所有地址</li>
<li>还可以使用–src或者–source</li>
</ul>
<h5 id="d-目的地址（destination）"><a href="#d-目的地址（destination）" class="headerlink" title="-d 目的地址（destination）"></a>-d 目的地址（destination）</h5><ul>
<li>指定目的地址</li>
<li>参数和-s相同</li>
<li>还可以使用–dst或者–destination</li>
</ul>
<h5 id="j-执行目标（jump-to-target）"><a href="#j-执行目标（jump-to-target）" class="headerlink" title="-j 执行目标（jump to target）"></a>-j 执行目标（jump to target）</h5><ul>
<li>-j代表”jump to target”</li>
<li>-j指定了当与规则(Rule)匹配时如何处理数据包</li>
<li>可能的值是ACCEPT, DROP, QUEUE, RETURN</li>
<li>还可以指定其他链（Chain）作为目标</li>
</ul>
<h5 id="i-输入接口（input-interface）"><a href="#i-输入接口（input-interface）" class="headerlink" title="-i 输入接口（input interface）"></a>-i 输入接口（input interface）</h5><ul>
<li>-i代表输入接口(input interface)</li>
<li>-i指定了要处理来自哪个接口的数据包</li>
<li>这些数据包即将进入INPUT, FORWARD, PREROUTE链</li>
<li>例如：-i eth0指定了要处理经由eth0进入的数据包</li>
<li>如果不指定-i参数，那么将处理进入所有接口的数据包</li>
<li>如果出现! -i eth0，那么将处理所有经由eth0以外的接口进入的数据包</li>
<li>如果出现-i eth+，那么将处理所有经由eth开头的接口进入的数据包</li>
<li>还可以使用–in-interface参数</li>
</ul>
<h5 id="o-输出（out-interface）"><a href="#o-输出（out-interface）" class="headerlink" title="-o 输出（out interface）"></a>-o 输出（out interface）</h5><ul>
<li>-o代表”output interface”</li>
<li>-o指定了数据包由哪个接口输出</li>
<li>这些数据包即将进入FORWARD, OUTPUT, POSTROUTING链</li>
<li>如果不指定-o选项，那么系统上的所有接口都可以作为输出接口</li>
<li>如果出现! -o eth0，那么将从eth0以外的接口输出</li>
<li>如果出现-i eth+，那么将仅从eth开头的接口输出</li>
<li>还可以使用–out-interface参数</li>
</ul>
<h4 id="5-3-描述规则的扩展参数"><a href="#5-3-描述规则的扩展参数" class="headerlink" title="5.3 描述规则的扩展参数"></a>5.3 描述规则的扩展参数</h4><p>对规则有了一个基本描述之后，有时候我们还希望指定端口、TCP标志、ICMP类型等内容。</p>
<h5 id="–sport-源端口（source-port）针对-p-tcp-或者-p-udp"><a href="#–sport-源端口（source-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–sport 源端口（source port）针对 -p tcp 或者 -p udp"></a>–sport 源端口（source port）针对 -p tcp 或者 -p udp</h5><ul>
<li>缺省情况下，将匹配所有端口</li>
<li>可以指定端口号或者端口名称，例如”–sport 22″与”–sport ssh”。</li>
<li>/etc/services文件描述了上述映射关系。</li>
<li>从性能上讲，使用端口号更好</li>
<li>使用冒号可以匹配端口范围，如”–sport 22:100″</li>
<li>还可以使用”–source-port”</li>
</ul>
<h5 id="–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp"><a href="#–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–-dport 目的端口（destination port）针对-p tcp 或者 -p udp"></a>–-dport 目的端口（destination port）针对-p tcp 或者 -p udp</h5><ul>
<li>参数和–sport类似</li>
<li>还可以使用”–destination-port”</li>
</ul>
<h5 id="–tcp-flags-TCP标志-针对-p-tcp"><a href="#–tcp-flags-TCP标志-针对-p-tcp" class="headerlink" title="-–tcp-flags TCP标志 针对-p tcp"></a>-–tcp-flags TCP标志 针对-p tcp</h5><ul>
<li>可以指定由逗号分隔的多个参数</li>
<li>有效值可以是：SYN, ACK, FIN, RST, URG, PSH</li>
<li>可以使用ALL或者NONE</li>
</ul>
<h5 id="–icmp-type-ICMP类型-针对-p-icmp"><a href="#–icmp-type-ICMP类型-针对-p-icmp" class="headerlink" title="-–icmp-type ICMP类型 针对-p icmp"></a>-–icmp-type ICMP类型 针对-p icmp</h5><ul>
<li>–icmp-type 0 表示Echo Reply</li>
<li>–icmp-type 8 表示Echo</li>
</ul>
<h4 id="5-4-追加规则的完整实例：仅允许SSH服务"><a href="#5-4-追加规则的完整实例：仅允许SSH服务" class="headerlink" title="5.4 追加规则的完整实例：仅允许SSH服务"></a>5.4 追加规则的完整实例：仅允许SSH服务</h4><p>本例实现的规则将仅允许SSH数据包通过本地计算机，其他一切连接（包括ping）都将被拒绝。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.清空所有iptables规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.接收目标端口为22的数据包</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.拒绝所有其他数据包</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure>


<h3 id="6-更改默认策略"><a href="#6-更改默认策略" class="headerlink" title="6. 更改默认策略"></a>6. 更改默认策略</h3><p>上例的例子仅对接收的数据包过滤，而对于要发送出去的数据包却没有任何限制。本节主要介绍如何更改链策略，以改变链的行为。</p>
<h4 id="6-1-默认链策略"><a href="#6-1-默认链策略" class="headerlink" title="6.1 默认链策略"></a>6.1 默认链策略</h4><p>/!\警告：请勿在远程连接的服务器、虚拟机上测试！<br>当我们使用-L选项验证当前规则是发现，所有的链旁边都有policy ACCEPT标注，这表明当前链的默认策略为ACCEPT：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh</span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p>这种情况下，如果没有明确添加DROP规则，那么默认情况下将采用ACCEPT策略进行过滤。除非：<br>a)为以上三个链单独添加DROP规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -j DROP</span><br><span class="line">iptables -A OUTPUT -j DROP</span><br><span class="line">iptables -A FORWARD -j DROP</span><br></pre></td></tr></table></figure>
<p>b)更改默认策略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>


<h3 id="7-配置应用程序规则"><a href="#7-配置应用程序规则" class="headerlink" title="7.配置应用程序规则"></a>7.配置应用程序规则</h3><p>尽管5.4节已经介绍了如何初步限制除SSH以外的其他连接，但是那是在链默认策略为ACCEPT的情况下实现的，并且没有对输出数据包进行限制。本节在上一节基础上，以SSH和HTTP所使用的端口为例，教大家如何在默认链策略为DROP的情况下，进行防火墙设置。在这里，我们将引进一种新的参数-m state，并检查数据包的状态字段。</p>
<h4 id="7-1-SSH"><a href="#7-1-SSH" class="headerlink" title="7.1 SSH"></a>7.1 SSH</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的SSH请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.允许发送本地主机的SSH响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">-m state: 启用状态匹配模块（state matching module）</span><br><span class="line">–-state: 状态匹配模块的参数。当SSH客户端第一个数据包到达服务器时，状态字段为NEW；建立连接后数据包的状态字段都是ESTABLISHED</span><br><span class="line">–sport 22: sshd监听22端口，同时也通过该端口和客户端建立连接、传送数据。因此对于SSH服务器而言，源端口就是22</span><br><span class="line">–dport 22: ssh客户端程序可以从本机的随机端口与SSH服务器的22端口建立连接。因此对于SSH客户端而言，目的端口就是22</span><br></pre></td></tr></table></figure>


<h4 id="7-2-HTTP"><a href="#7-2-HTTP" class="headerlink" title="7.2 HTTP"></a>7.2 HTTP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.允许发送本地主机的HTTP响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="7-3-完整的配置"><a href="#7-3-完整的配置" class="headerlink" title="7.3 完整的配置"></a>7.3 完整的配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.删除现有规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.配置默认链策略</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.允许远程主机进行SSH连接</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.允许本地主机进行SSH连接</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.允许HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>



<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.thegeekstuff.com/2011/01/iptables-fundamentals/">1.  Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals</a></p>
<p><a href="https://www.thegeekstuff.com/2011/02/iptables-add-rule/">2. Linux IPTables: How to Add Firewall Rules (With Allow SSH Example)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/03/iptables-inbound-and-outbound-rules/">3. Linux IPTables: Incoming and Outgoing Rule Examples (SSH and HTTP)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/06/iptables-rules-examples/">4. 25 Most Frequently Used Linux IPTables Rules Examples</a></p>
<p><a href="https://www.thegeekstuff.com/category/iptables/">5. iptables相关所有教程</a></p>
<p><a href="https://www.zsythink.net/archives/1199">6.朱双印的一系列Iptables原理讲解教程</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>(5)网络配置管理</title>
    <url>/2021/07/30/5-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-Ip-route"><a href="#1-Ip-route" class="headerlink" title="1. Ip route"></a>1. Ip route</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基础指令</span></span><br><span class="line">ip link list 显示ip链路状态信息</span><br><span class="line">ip address show 除显示所有网络地址</span><br><span class="line">ip route show 显示主路由表信息</span><br><span class="line">ip neigh show 显示邻居表</span><br></pre></td></tr></table></figure>
<p>Linux系统路由表，linux可以自定义从1－252个路由表，linux系统维护了4个路由表：</p>
<ul>
<li>0#表 系统保留表</li>
<li>253#表 defulte table 没特别指定的默认路由都放在改表</li>
<li>254#表 main table 没指明路由表的所有路由放在该表</li>
<li>255#表 locale table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看路由表信息</span></span><br><span class="line">ip route list table table_number</span><br><span class="line">ip route list table table_name</span><br></pre></td></tr></table></figure>


<p>路由表添加完毕即时生效，下面为实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在一号表中添加默认路由为192.168.1.1</span></span><br><span class="line">ip route add default via 192.168.1.1 table 1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在一号表中添加一条到192.168.0.0网段的路由为192.168.1.2</span></span><br><span class="line">ip route add 192.168.0.0/24 via 192.168.1.2 table 1</span><br></pre></td></tr></table></figure>
<p>注:各路由表中应当指明默认路由,尽量不回查路由表.路由添加完毕,即可在路由规则中应用</p>
<h4 id="2-ip-rule"><a href="#2-ip-rule" class="headerlink" title="2. ip rule"></a>2. ip rule</h4><p>进行路由时，根据路由规则来进行匹配，按优先级（pref）从低到高匹配,直到找到合适的规则.所以在应用中配置默认路由是必要的.   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示路由规则</span></span><br><span class="line">ip rule show </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 路由规则的添加,如果pref值不指定，则将在已有规则最小序号前插入</span></span><br><span class="line">ip rule add from 192.168.1.10/32 table 1 pref 100</span><br></pre></td></tr></table></figure>
<p>注：创建完路由规则若需立即生效须执行#ip route flush cache;刷新路由缓冲<br>可参数解析如下： </p>
<blockquote>
<p>From — 源地址<br>To — 目的地址（这里是选择规则时使用，查找路由表时也使用）<br>　　 Tos — IP包头的TOS（type of sevice）域Linux高级路由-<br>　　 Dev — 物理接口<br>　 　Fwmark — iptables标签<br>采取的动作除了指定路由表外，还可以指定下面的动作：<br>Table 指明所使用的表<br>　 Nat 透明网关</p>
<p>　　 Prohibit 丢弃该包，并发送 COMM.ADM.PROHIITED的ICMP信息<br>　　 Reject 单纯丢弃该包<br>　　 Unreachable丢弃该包， 并发送 NET UNREACHABLE的ICMP信息<br>具体格式如下：更强大，使用更灵活，它使网络管理员不仅能<br>Usage: ip rule [ list | add | del ] SELECTOR ACTION<br>SELECTOR := [ from PREFIX ] [ to PREFIX ] [ tos TOS ][ dev STRING ] [ pref NUMBER ]<br>ACTION := [ table TABLE_ID ] [ nat ADDRESS ][ prohibit | reject | unreachable ]<br>[ flowid CLASSID ]<br>TABLE_ID := [ local | main | default | new | NUMBER ]</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip route add 192.168.1.0/24 dev eth0 via 192.168.1.66 realm 4</span></span><br><span class="line">注:发往子网192.168.1.0/24的数据包通过分类4转发配合tc使用</span><br><span class="line"><span class="meta">#</span><span class="bash">ip route add default via 192.168.1.1 table int1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip route add 192.168.1.0/24 via 192.168.1.1 table int2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip route add 172.16.0.2/16 via 172.16.0.1 table int3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip rule sh 显示路由规则</span> </span><br><span class="line">0:      from all lookup local </span><br><span class="line">32766:  from all lookup main </span><br><span class="line">32767:  from all lookup default</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip rule规则添加示例： </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add from 192.168.1.112/32 [tos 0x10] table test2 pref 999 prohibit</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add to 192.168.1.2 pref 1000 table test1</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add from 192.168.1.0/24 pref 1001 table test1</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add [from 0/0] table test1 pref 1003</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add fwmark 1 pref 1002 table test2</span>  </span><br><span class="line">（此句型配合iptables -t mangle应用。如先对数据包作标记:</span><br><span class="line"><span class="meta">#</span><span class="bash">iptables -t mangle -A PREROUTING -p tcp -m multiport --dports 80,8080,20,21 -s 192.168.1.0/24 -j MARK --set-mark 1  ）</span></span><br></pre></td></tr></table></figure>


<h4 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h4><p><a href="https://blog.csdn.net/bytxl/article/details/9850803?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.control">策略路由以及使用 ip route ， ip rule ， iptables 配置策略路由实例</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>RTMP直播客户端部署</title>
    <url>/2021/07/31/RTMP%E7%9B%B4%E6%92%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="1-Rtmp下载与介绍"><a href="#1-Rtmp下载与介绍" class="headerlink" title="1.Rtmp下载与介绍"></a>1.Rtmp下载与介绍</h4><p>[1] <a href="http://rtmpdump.mplayerhq.hu/">http://rtmpdump.mplayerhq.hu/</a> 【rtmp官网】【LibRTMP】</p>
<p>[2] <a href="http://rtmpdump.mplayerhq.hu/download">http://rtmpdump.mplayerhq.hu/download</a> 【rtmp下载中心】 </p>
<p>[3] <a href="https://www.videolan.org/developers/x264.html">https://www.videolan.org/developers/x264.html</a> 【x264官网】</p>
<h4 id="2-RTMP基本调用流程"><a href="#2-RTMP基本调用流程" class="headerlink" title="2.RTMP基本调用流程"></a>2.RTMP基本调用流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-eb4452d80cdebebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RTMP基本调用流程.png"></p>
<p>推流：视频+音频<br>视频：Camera采集    –&gt; 封装(压缩) —&gt; rtmp包    —&gt; 发送服务器<br>音频：AudioRecord –&gt; 封装(压缩) —&gt; rtmp包    —&gt; 发送服务器 </p>
<h4 id="3-RtmpDump集成部署。"><a href="#3-RtmpDump集成部署。" class="headerlink" title="3.RtmpDump集成部署。"></a>3.RtmpDump集成部署。</h4><p>RTMPDump<br>是一个用来处理RTMP流媒体的开源工具包。  它能够单独使用进行RTMP的通信，  也可以集成到 FFmpeg中通过FFmpeg接口来使用RTMPDump。<br>源码下载：<a href="http://rtmpdump.mplayerhq.hu/download">http://rtmpdump.mplayerhq.hu/download</a> </p>
<p>在Android中可以直接借助NDK在JNI层调用RTMPDump来完成RTMP通信。<br>在根目录下提供了一个Makefile与一些.c源文件。这里的源文件将会编译出一系列的可执行文件。 然后我们需要的并不是可执行文件，真正的对RTMP的实现都在librtmp子目录中。在这个子目录 中同样包含了一个Makefile文件。通过阅读Makefile发现，它的源码并不多:OBJS=rtmp.o log.o amf.o hashswf.o parseurl.o。因此我们不进行预编译，即直接放入AS中借助CMakeLists.txt来进 行编译。这么做可以让我们方便的对库本身进行调试或修改(实际上我们确实会稍微修改这个库的 源码)。</p>
<h4 id="4-X264交叉编译与集成部署"><a href="#4-X264交叉编译与集成部署" class="headerlink" title="4. X264交叉编译与集成部署"></a>4. X264交叉编译与集成部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://code.videolan.org/videolan/x264.git</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--disable-cli   # disable cli Android用不了，直接关掉</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">ANDROID_API=17</span><br><span class="line"></span><br><span class="line">PREFIX=./android/armeabi-v7a</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-cli \</span><br><span class="line">--enable-static \</span><br><span class="line">--enable-pic \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/$CPU- \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC -I$RTMP/include&quot; \</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译全包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">NDK=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">configure()</span><br><span class="line">&#123;</span><br><span class="line">    CPU=$1</span><br><span class="line">    PREFIX=$(pwd)/android/$CPU</span><br><span class="line">    HOST=&quot;&quot;</span><br><span class="line">    CROSS_PREFIX=&quot;&quot;</span><br><span class="line">    SYSROOT=&quot;&quot;</span><br><span class="line">    if [ &quot;$CPU&quot; == &quot;armv7-a&quot; ]</span><br><span class="line">    then</span><br><span class="line">        HOST=arm-linux</span><br><span class="line">        SYSROOT=$NDK/platforms/android-21/arch-arm/</span><br><span class="line">        CROSS_PREFIX=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-</span><br><span class="line">    else</span><br><span class="line">        HOST=aarch64-linux</span><br><span class="line">        SYSROOT=$NDK/platforms/android-21/arch-arm64/</span><br><span class="line">        CROSS_PREFIX=$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-</span><br><span class="line">    fi</span><br><span class="line">    ./configure \</span><br><span class="line">    --prefix=$PREFIX \</span><br><span class="line">    --host=$HOST \</span><br><span class="line">    --enable-pic \</span><br><span class="line">    --disable-cli \</span><br><span class="line">    --enable-static \</span><br><span class="line">    --enable-neon \</span><br><span class="line">    --extra-cflags=&quot;-isysroot $NDK/sysroot -isystem $NDK/sysroot/usr/include/aarch64-linux-android -fPIE -pie&quot; \</span><br><span class="line">    --extra-ldflags=&quot;-fPIE -pie&quot; \</span><br><span class="line">    --cross-prefix=$CROSS_PREFIX \</span><br><span class="line">    --sysroot=$SYSROOT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build()</span><br><span class="line">&#123;</span><br><span class="line">    make clean</span><br><span class="line">    cpu=$1</span><br><span class="line">    echo &quot;build $cpu&quot;</span><br><span class="line"></span><br><span class="line">    configure $cpu</span><br><span class="line">    #-j&lt;CPU核心数&gt;</span><br><span class="line">    make -j4</span><br><span class="line">    make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build arm64</span><br><span class="line">build armv7-a</span><br></pre></td></tr></table></figure>


<h4 id="5-faac交叉编译"><a href="#5-faac交叉编译" class="headerlink" title="5.faac交叉编译"></a>5.faac交叉编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载地址</span></span><br><span class="line">wget https://udomain.dl.sourceforge.net/project/faac/faac-src/faac-1.29/faac-1.29.9.2.tar.gz</span><br></pre></td></tr></table></figure>
<p>编译arm-v7a库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个是最终输出成功的路径</span></span><br><span class="line">PREFIX=`pwd`/android/armeabi-v7a</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">FLAGS=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=17 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -std=c++11 -O0 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">export CC=&quot;$CROSS_COMPILE-gcc --sysroot=$NDK_ROOT/platforms/android-17/arch-arm&quot;</span><br><span class="line">export CFLAGS=&quot;$FLAGS&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--with-pic \</span><br><span class="line">--enable-shared=no  </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>编译arm64-v8a库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">NDK=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">API=28</span><br><span class="line"></span><br><span class="line">echo &quot;开始编译中 NDK=$NDK&quot;</span><br><span class="line"></span><br><span class="line">CPU=armv8-a</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/aarch64-linux-android</span><br><span class="line">PREFIX=$(pwd)/android3/$CPU</span><br><span class="line"></span><br><span class="line">FLAGS=&quot;-isysroot $NDK/sysroot -isystem $NDK/sysroot/usr/include/aarch64-linux-android -march=$CPU -O0 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">export CC=&quot;$CROSS_COMPILE-gcc --sysroot=$NDK/platforms/android-$API/arch-arm64&quot;</span><br><span class="line">export CFLAGS=&quot;$FLAGS&quot;</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--host=aarch64-linux \</span><br><span class="line">--with-pic \</span><br><span class="line">--enable-shared=no  </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p><strong>RTMPPacket数据包有两个类型</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>第一字节标注位</th>
<th>第二字节标注位</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>解码信息</td>
<td>0xAF</td>
<td>0x00</td>
<td>解码数据</td>
</tr>
<tr>
<td>音频数据</td>
<td>0xAF</td>
<td>0x01</td>
<td>音频数据</td>
</tr>
</tbody></table>
<h5 id="5-1-Audio-Tag"><a href="#5-1-Audio-Tag" class="headerlink" title="5.1 Audio Tag"></a>5.1 Audio Tag</h5><blockquote>
<p><strong>AF双声道</strong>：<br>十六进制：0xAF ===&gt;  二进制对比下图：1010 1111<br>1010 ==&gt; 十进制等于10 ==&gt; AAC<br>11 ==&gt; 十进制等于3 ===&gt; 3 = 44-kHz(对于AAC来说，该字段总是3)<br>1 ==&gt; 十进制等于1 ===&gt; 1 = snd16Bit(对于压缩过的音频来说，一般都是16bit) 1 ==&gt; 十进制等于1 ===&gt; 1 = sndStereo(对于AAC，总是1)双声道</p>
</blockquote>
<blockquote>
<p><strong>AE单声道</strong>：<br>十六进制：0xAE ===&gt;  二进制对比下图：1010 1110<br>1010 ==&gt; 十进制等于10 ==&gt; AAC<br>11 ==&gt; 十进制等于3 ===&gt; 3 = 44-kHz(对于AAC来说，该字段总是3)<br>1 ==&gt; 十进制等于1 ===&gt; 1 = snd16Bit(对于压缩过的音频来说，一般都是16bit) 0 ==&gt; 十进制等于0 ===&gt; 0 = sndMono单声道</p>
</blockquote>
<table>
<thead>
<tr>
<th>字段</th>
<th>占位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SoundFormat</td>
<td>4</td>
<td>音频数据格式值：<br>0 = Linear PCM, platform endian <br>1 = ADPCM <br>2 = MP3 <br>3 = Linear PCM, little endian <br>4 = Nellymoser 16-kHz mono <br>5 = Nellymoser 8-kHz mono <br>6 = Nellymoser <br>7 = G.711 A-law logarithmic PCM <br>8 = G.711 mu-law logarithmic PCM <br>9 = reserved <br>10 = AAC <br>11 = Speex <br>14 = MP3 8-kHz <br>15 = Device-speciﬁc sound</td>
</tr>
<tr>
<td>SoundRate</td>
<td>2</td>
<td>音频采样率值： <br>0 = 5.5-kHz <br>1 = 11-kHz <br>2 = 22-kHz <br>3 = 44-kHz(对于AAC来说，该字段总是3)</td>
</tr>
<tr>
<td>SoundSize</td>
<td>1</td>
<td>采样长度值： <br>0 = snd9Bit <br>1 = snd16Bit(对于压缩过的音频来说，一般都是16bit</td>
</tr>
<tr>
<td>SoundType</td>
<td>1</td>
<td>音频类型(单声道还是双声道)值：<br> 0 = sndMono 单声道 <br>1 = sndStereo(对于AAC，总是1) 双声道</td>
</tr>
<tr>
<td>SoundData</td>
<td>n</td>
<td>音频数据部分（AAC则需要参考下面AACAUDIODA 分）</td>
</tr>
</tbody></table>
<h5 id="5-2-AACAUDIODATA"><a href="#5-2-AACAUDIODATA" class="headerlink" title="5.2 AACAUDIODATA"></a>5.2 AACAUDIODATA</h5><table>
<thead>
<tr>
<th>字段</th>
<th>字节</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AACPacketType</td>
<td>1</td>
<td>0：AAC 序列头 1：AAC 数据</td>
</tr>
<tr>
<td>Data</td>
<td>n</td>
<td>如果AACPacketType==0参考下面的 AudioSpeciﬁcConﬁg;<br>如果AACPacketType==1， AAC原始音频数据</td>
</tr>
</tbody></table>
<p>AudioSpecificConfig</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>占位符</th>
</tr>
</thead>
<tbody><tr>
<td>audioObjectType</td>
<td>5</td>
</tr>
<tr>
<td>samplingFrequencyIndex</td>
<td>4</td>
</tr>
<tr>
<td>channelConﬁguration</td>
<td>4</td>
</tr>
<tr>
<td>frameLengthFlag</td>
<td>1</td>
</tr>
<tr>
<td>dependsOnCoreCoder</td>
<td>1</td>
</tr>
<tr>
<td>extensionFlag</td>
<td>1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTMP</tag>
      </tags>
  </entry>
  <entry>
    <title>解析dumpsys cpuinfo</title>
    <url>/2021/08/12/%E8%A7%A3%E6%9E%90dumpsys-cpuinfo/</url>
    <content><![CDATA[<h4 id="1-车机原始数据"><a href="#1-车机原始数据" class="headerlink" title="1.车机原始数据"></a>1.车机原始数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Load: <span class="number">14.49</span> / <span class="number">8.82</span> / <span class="number">7.01</span></span><br><span class="line">CPU usage from 9057ms to 1851<span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">39.845</span> to <span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">47.051</span>)</span>:</span></span><br><span class="line"><span class="function">  79% 792/system_server: 44% user + 35% kernel / faults: 1774 minor</span></span><br><span class="line"><span class="function">  46% 485/surfaceflinger: 24% user + 21% kernel / faults: 1815 minor</span></span><br><span class="line"><span class="function">  20% 1513/com.gxa.service.systemui: 19% user + 0.4% kernel / faults: 22 minor</span></span><br><span class="line"><span class="function">  17% 452/android.hardware.graphics.composer@2.2-service: 10% user + 6.6% kernel</span></span><br><span class="line"><span class="function">  14% 446/android.hardware.broadcastradio@2.0-service.g6: 1.6% user + 13% kernel</span></span><br><span class="line"><span class="function">  4.8% 23782/adbd: 0.2% user + 4.5% kernel / faults: 39003 minor</span></span><br><span class="line"><span class="function">  4.7% 293/logd: 1.1% user + 3.6% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  3.8% 1099/com.android.bluetooth: 1.9% user + 1.9% kernel / faults: 141 minor</span></span><br><span class="line"><span class="function">  2.7% 461/android.hardware.usb@1.0-service: 0% user + 2.7% kernel</span></span><br><span class="line"><span class="function">  2.6% 2501/com.iflytek.autofly.avatar: 1.8% user + 0.8% kernel / faults: 16 minor</span></span><br><span class="line"><span class="function">  1.8% 3511/com.gxatek.cockpit.scenesengine: 1.6% user + 0.1% kernel / faults: 15 minor</span></span><br><span class="line"><span class="function">  1.8% 21524/kworker/1:1: 0% user + 1.8% kernel</span></span><br><span class="line"><span class="function">  1.3% 357/vendor.ts.systemlog@1.0-service: 0% user + 1.3% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0.5% 444/android.hardware.bluetooth@1.0-service-qti: 0.5% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.3% 13161/kworker/1:2: 0% user + 0.3% kernel</span></span><br><span class="line"><span class="function">  1.2% 2612/com.iflytek.autofly.dms: 0.2% user + 0.9% kernel / faults: 3 minor</span></span><br><span class="line"><span class="function">  1.1% 24014/logcat: 0.1% user + 0.9% kernel</span></span><br><span class="line"><span class="function">  0.8% 195/spi1: 0% user + 0.8% kernel</span></span><br><span class="line"><span class="function">  0.8% 1347/cds_ol_rx_threa: 0% user + 0.8% kernel</span></span><br><span class="line"><span class="function">  0.8% 32737/kworker/u16:8: 0% user + 0.8% kernel</span></span><br><span class="line"><span class="function">  0.6% 1<span class="comment">//init: 0.1% user + 0.5% kernel / faults: 413 minor</span></span></span><br><span class="line"><span class="function">  0.6% 215/irq/136-8804000: 0% user + 0.6% kernel</span></span><br><span class="line"><span class="function">  0.6% 359/netd: 0.2% user + 0.4% kernel / faults: 14 minor</span></span><br><span class="line"><span class="function">  0.6% 2397/platformservice.Services: 0.4% user + 0.2% kernel / faults: 85 minor</span></span><br><span class="line"><span class="function">  0.6% 32618/com.iflytek.autofly.systemserver: 0.1% user + 0.5% kernel / faults: 274 minor</span></span><br><span class="line"><span class="function">  0.5% 455/android.hardware.memtrack@1.0-service: 0.1% user + 0.4% kernel</span></span><br><span class="line"><span class="function">  0.5% 457/android.hardware.sensors@1.0-service: 0.1% user + 0.4% kernel</span></span><br><span class="line"><span class="function">  0.5% 2594/com.gxa.service.bluetooth: 0.2% user + 0.2% kernel / faults: 90 minor</span></span><br><span class="line"><span class="function">  0.5% 30761/com.android.commands.monkey: 0.2% user + 0.2% kernel / faults: 36 minor</span></span><br><span class="line"><span class="function">  0.5% 30967/kworker/u16:5: 0% user + 0.5% kernel</span></span><br><span class="line"><span class="function">  0.4% 1772/com.android.car: 0.2% user + 0.1% kernel / faults: 48 minor</span></span><br><span class="line"><span class="function">  0.4% 32143/com.gxatek.cockpit.carservice: 0.2% user + 0.1% kernel / faults: 347 minor</span></span><br><span class="line"><span class="function">  0.2% 471/vendor.ts.gnssext@1.0-service: 0.2% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.2% 742/mdnsd: 0.2% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.2% 1225/com.core.system.service: 0.1% user + 0.1% kernel / faults: 91 minor</span></span><br><span class="line"><span class="function">  0.2% 1451/com.gxa.car.power: 0.1% user + 0.1% kernel / faults: 48 minor</span></span><br><span class="line"><span class="function">  0.2% 2782/com.iflytek.autofly.mediax: 0.1% user + 0.1% kernel / faults: 16 minor</span></span><br><span class="line"><span class="function">  0% 8/ksoftirqd/0: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 9/rcu_preempt: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 24/ksoftirqd/2: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 30/ksoftirqd/3: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 305/android.hardware.automotive.vehicle@2.0-service.g6: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 309/com.desaysv.vehiclelan.proxy@1.0-service: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 349/kworker/u17:1: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 353/ais_v4l2_proxy: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 447/android.hardware.camera.provider@2.4-service_64: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0% 451/android.hardware.dsp@1.0-service: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 463/android.hardware.wifi@1.0-service: 0.1% user + 0% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0% 464/vendor.desaysv.hardware.tbox@1.0-service: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 609/cnss-daemon: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 724/wlan_logging_th: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 1243/com.android.systemui: 0.1% user + 0% kernel / faults: 69 minor</span></span><br><span class="line"><span class="function">  0.1% 1381/com.gxa.service.account: 0.1% user + 0% kernel / faults: 44 minor</span></span><br><span class="line"><span class="function">  0.1% 2567/com.gac.cloud.app: 0.1% user + 0% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0.1% 2643/com.gxa.appservice.platformadapter.adaptermainservice: 0.1% user + 0% kernel / faults: 53 minor</span></span><br><span class="line"><span class="function">  0.1% 3104/com.iflytek.autofly.mediax:remote: 0.1% user + 0% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0.1% 3252/android.ext.services: 0.1% user + 0% kernel / faults: 12 minor</span></span><br><span class="line"><span class="function">  0.1% 3267/android.ext.services: 0.1% user + 0% kernel / faults: 14 minor</span></span><br><span class="line"><span class="function">  0.1% 10320/com.iflytek.autofly.accountcenter: 0.1% user + 0% kernel</span></span><br><span class="line"><span class="function">  0% 18185/kworker/3:3: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 20603/kworker/u16:3: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0% 30508/kworker/6:0: 0% user + 0% kernel</span></span><br><span class="line"><span class="function"> +0% 1090/sh: 0% user + 0% kernel</span></span><br><span class="line"><span class="function"> +0% 1103/dumpsys: 0% user + 0% kernel</span></span><br><span class="line"><span class="function"> +0% 1153/qti: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">29% TOTAL: 13% user + 12% kernel + 0% iowait + 2.5% irq + 0.7% softirq</span></span><br><span class="line"><span class="function">------finish dumpsys cpuinfo------</span></span><br></pre></td></tr></table></figure>


<h4 id="2-负载参数解读"><a href="#2-负载参数解读" class="headerlink" title="2.负载参数解读"></a>2.负载参数解读</h4><h5 id="2-1-参数解读"><a href="#2-1-参数解读" class="headerlink" title="2.1 参数解读"></a>2.1 参数解读</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Load: <span class="number">14.49</span> / <span class="number">8.82</span> / <span class="number">7.01</span></span><br></pre></td></tr></table></figure>
<p>此行显示CPU负载的平均值，这三个数字表示逐渐变长的时间段（平均一分钟，五分钟和十五分钟）的平均值，如果数字较小则说明负载在降低，数字越大表示问题或机器过载。由于当前测试车机是八核处理器，我们以单核处理器来说明以上参数。</p>
<p>CPU处理代码相当于车辆过桥一样，单核处理器相当于桥梁，代码相当于车辆。代码在处理器上运行相当于车辆在桥上跑一样。因此，以上数字含义：</p>
<ul>
<li>0.00表示桥上根本没有流量。实际上，介于0.00和1.00之间意味着没有备份，而到达的汽车将直接开启。</li>
<li>1.00表示桥梁正好处于饱和容量状态。一切都还不错，但如果流量变得更重，事情就会变慢。</li>
<li>超过1.00表示有拥堵。那么，2.00意味着总共有两条车道 - 一条车道的价值在桥上，一条车道值得等待。3.00意味着总共有三条车道 - 桥上有一条车道，两条车道值得等待。</li>
</ul>
<p>这基本上就是CPU负载。代码(“汽车”)是使用一段CPU时间片（“过桥”）或排队使用CPU的过程。Unix将此称为<code>运行队列长度</code>：当前运行的进程数加上等待（排队）运行的进程数之和。</p>
<h5 id="2-2-理想负载"><a href="#2-2-理想负载" class="headerlink" title="2.2 理想负载"></a>2.2 理想负载</h5><p>如果单核处理器一直处于1，那么说明当前处理器一直在满负荷运行，没有任何余量。CPU长时间处于满负荷或者超负荷运行将导致CPU大量发热，或者降低CPU寿命。因此需要一个参考值来衡量当前系统CPU是否健康。经验参考值如下(单核)：</p>
<ul>
<li>阈值大于0.7：如果长时间平均阈值大于0.7，需要在事态进一步恶化之前进行调查。</li>
<li>阈值大于1.0：如果长时间平均阈值大于1.0，需要找到问题并立即修复，否者可能将面临半夜起来调查问题的情况</li>
<li>阈值大于5.0：如果长时间平均值大于5.0,系统一定出现严重异常，紧要任务是立即排除严重故障，否则影响cpu寿命等不可预知的问题。当前系统处于长时间没有响应，或者接近死机了。你不应该让系统达到这个值。</li>
</ul>
<h5 id="2-3-多核和多处理器"><a href="#2-3-多核和多处理器" class="headerlink" title="2.3 多核和多处理器"></a>2.3 多核和多处理器</h5><p>经常有听到有多少个处理器，一个处理器有多少核，让我们谈谈多核与多处理器。出于性能目的，具有单个双核处理器的机器基本上等同于具有两个处理器的机器，每个处理器具有一个核心？是的，这里有许多关于缓存数量，处理器之间的进程切换频率等的细微之处。尽管有这些更精细的点，但为了确定CPU负载值的大小，核心的总数是重要的，无论如何这些核心分布在许多物理处理器上。因此无论多少处理器，我们主要考虑<strong>该机器上有多少核！！</strong>因此又出现两个经验法则：</p>
<ul>
<li><em>“核心数=最大负载”经验</em>法则：在多核系统上，您的负载不应超过可用核心数</li>
<li>该<em>“内核是内核”</em>经验法则：不管核心是如何分布在CPU的无所谓，两个四核==四个双核==八个单核。这些都是用于这些目的的八个核心。</li>
</ul>
<h5 id="2-4-如何观察这三个参数"><a href="#2-4-如何观察这三个参数" class="headerlink" title="2.4 如何观察这三个参数"></a>2.4 如何观察这三个参数</h5><p>上面提到以上三个参数代表：一分钟，五分钟，十五分钟平均值。那么我们如何观察并采取行动呢？</p>
<ul>
<li>一分钟：如果监控中显示一分钟cpu负载大于核心数，可以暂时不采取行动，可能是因为开机启动，突然有高cpu进程运行等原因。</li>
<li>五分钟：如果监控中显示五分钟cpu负载大于核心数，需要结合需求调查对高负荷进程进行调查</li>
<li>十五分钟：如果监控中显示十五分钟cpu负荷大于核心数，需要评估高负荷进程CPU消耗原因或者CPU硬件瓶颈</li>
</ul>
<p>获取机器CPU信息指令，每一块信息代表一个核的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>


<h4 id="3-单应用参数解读"><a href="#3-单应用参数解读" class="headerlink" title="3. 单应用参数解读"></a>3. 单应用参数解读</h4><h5 id="3-1-时间戳解析"><a href="#3-1-时间戳解析" class="headerlink" title="3.1 时间戳解析"></a>3.1 时间戳解析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java</span></span><br><span class="line">CPU usage from 9057ms to 1851<span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">39.845</span> to <span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">47.051</span>)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">// 9057ms == mLastSampleTime</span></span></span><br><span class="line"><span class="function"><span class="comment">// 1851ms == mCurrentSampleTime</span></span></span><br><span class="line"><span class="function"><span class="comment">// 后面()是系统时间戳，相减也等于上面两个变量相减的时间，记录这段时间cpu上执行过的代码</span></span></span><br></pre></td></tr></table></figure>


<h5 id="3-2-单应用解析"><a href="#3-2-单应用解析" class="headerlink" title="3.2 单应用解析"></a>3.2 单应用解析</h5><p>Dumpsys cpuinfo计算cpu使用率是基于 SystemClock.uptimeMillis()差值来计算得到的。详细见：<a href="https://blog.csdn.net/oujunli/article/details/51463707">《Android CPU使用率：top和dump cpuinfo的不同》</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">79</span>% <span class="number">792</span>/system_server: <span class="number">44</span>% user + <span class="number">35</span>% kernel / faults: <span class="number">1774</span> minor</span><br><span class="line"><span class="comment">// 79% 代表当前进程CPU使用占比</span></span><br><span class="line"><span class="comment">// 792 进程id，即pid</span></span><br><span class="line"><span class="comment">// system_server 进程名</span></span><br><span class="line"><span class="comment">// 44% 用户空间使用44%</span></span><br><span class="line"><span class="comment">// 35% 内核空间使用35%</span></span><br><span class="line"><span class="comment">// faults: 1774 minor  下面说明</span></span><br></pre></td></tr></table></figure>


<h5 id="3-3-minor解析"><a href="#3-3-minor解析" class="headerlink" title="3.3 minor解析"></a>3.3 minor解析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] PROCESS_STATS_FORMAT = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_PARENS,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 10: minor faults</span></span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 12: major faults</span></span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 14: utime</span></span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 15: stime</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCpuTimeForPid</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSinglePidStatsData) &#123;</span><br><span class="line">            <span class="keyword">final</span> String statFile = <span class="string">&quot;/proc/&quot;</span> + pid + <span class="string">&quot;/stat&quot;</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span>[] statsData = mSinglePidStatsData;</span><br><span class="line">            <span class="keyword">if</span> (Process.readProcFile(statFile, PROCESS_STATS_FORMAT,</span><br><span class="line">                    <span class="keyword">null</span>, statsData, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> time = statsData[PROCESS_STAT_UTIME]</span><br><span class="line">                        + statsData[PROCESS_STAT_STIME];</span><br><span class="line">                <span class="keyword">return</span> time * mJiffyMillis;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出minor代表<strong>小错误</strong>，通过读取/proc/<pid>/stat中第10个数值获取的。至于minor是什么，详见《<a href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">4.Understanding page faults and memory swap-in/outs: when should you worry?</a>》</pid></p>
<h4 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">29</span>% TOTAL: <span class="number">13</span>% user + <span class="number">12</span>% kernel + <span class="number">0</span>% iowait + <span class="number">2.5</span>% irq + <span class="number">0.7</span>% softirq</span><br><span class="line"><span class="comment">// 29% 代表总共cpu消耗占比</span></span><br><span class="line"><span class="comment">// 13% 代表用户空间总消耗</span></span><br><span class="line"><span class="comment">// 12% 代表内核空间总消耗</span></span><br><span class="line"><span class="comment">// 0% 代表CPU在I/O请求中消耗等待时间占比</span></span><br><span class="line"><span class="comment">// 2.5% 代表硬中断执行消耗</span></span><br><span class="line"><span class="comment">// 0.7% 代表中断执行消耗</span></span><br></pre></td></tr></table></figure>


<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.cnblogs.com/muahao/p/6492665.html">1.理解Linux CPU负载和 CPU使用</a></p>
<p><a href="https://scoutapm.com/blog/understanding-load-averages">2.Understanding Linux CPU Load - when should you be worried?</a></p>
<p><a href="https://stackoverflow.com/questions/40186347/dumpsys-cpuinfo-in-android-interpreting-the-results-of-this-command">3.dumpsys cpuinfo in Android: Interpreting the results of this command</a></p>
<p><a href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">4.Understanding page faults and memory swap-in/outs: when should you worry?</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>cpuinfo</tag>
      </tags>
  </entry>
  <entry>
    <title>调查Android P持续打印non-protected broadcast 问题</title>
    <url>/2021/08/04/%E8%B0%83%E6%9F%A5Android-P%E6%8C%81%E7%BB%AD%E6%89%93%E5%8D%B0non-protected-broadcast-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>​    在logcat日志和dropbox日志中持续打印 E/ActivityManager( 803): Sending non-protected broadcast android.intent.action.VIEW from system 3235:com.iflytek.cutefly.speechclient.hmi/1000 pkg com.iflytek.cutefly.speechclient.hmi</p>
<h4 id="2-问题定位"><a href="#2-问题定位" class="headerlink" title="2.问题定位"></a>2.问题定位</h4><p>查看logcat，持续输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E/ActivityManager( <span class="number">803</span>): Sending non-<span class="keyword">protected</span> broadcast android.intent.action.VIEW from system <span class="number">3235</span>:com.iflytek.cutefly.speechclient.hmi/<span class="number">1000</span> pkg com.iflytek.cutefly.speechclient.hmi</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): java.lang.Throwable</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. checkBroadcastFromSystem(ActivityManagerService.java:<span class="number">21241</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. broadcastIntentLocked(ActivityManagerService.java:<span class="number">21845</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. broadcastIntent(ActivityManagerService.java:<span class="number">21987</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at android.app.IActivityManager$Stub. onTransact$broadcastIntent$(IActivityManager.java:<span class="number">10171</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at android.app.IActivityManager$Stub. onTransact(IActivityManager.java:<span class="number">167</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. onTransact(ActivityManagerService.java:<span class="number">3291</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at android.os.Binder.execTransact(Binder.java:<span class="number">731</span>)</span><br><span class="line"><span class="comment">// ActivityManager打印com.iflytek.cutefly.speechclient.hmi发送了未受保护的广播</span></span><br><span class="line">I/am_wtf ( <span class="number">803</span>): [<span class="number">0</span>,<span class="number">803</span>,system_server,-<span class="number">1</span>,ActivityManager,Sending non-<span class="keyword">protected</span> broadcast android.intent.action.VIEW from system <span class="number">3235</span>:com.iflytek.cutefly.speechclient.hmi/<span class="number">1000</span> pkg com.iflytek.cutefly.speechclient.hmi]</span><br></pre></td></tr></table></figure>


<p>撸出源码，grep报错日志，定位到ActivityManagerService中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是系统应用，则判断声明发送的广播都声明成protect-broadcast</span></span><br><span class="line"><span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">	checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">		isProtectedBroadcast, registeredReceivers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkBroadcastFromSystem</span><span class="params">(Intent intent, ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">       String callerPackage, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> isProtectedBroadcast, List receivers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((intent.getFlags() &amp; Intent.FLAG_RECEIVER_FROM_SHELL) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t yell about broadcasts sent via shell</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    	<span class="comment">// 如果是受保护的广播或者下面枚举的广播，直接返回，不处理</span></span><br><span class="line">        <span class="keyword">if</span> (isProtectedBroadcast</span><br><span class="line">            || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)</span><br><span class="line">            || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)</span><br><span class="line">            || Intent.ACTION_MEDIA_BUTTON.equals(action)</span><br><span class="line">            || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)</span><br><span class="line">            || Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)</span><br><span class="line">            || Intent.ACTION_MASTER_CLEAR.equals(action)</span><br><span class="line">            || Intent.ACTION_FACTORY_RESET.equals(action)</span><br><span class="line">            || AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">            || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)</span><br><span class="line">            || LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)</span><br><span class="line">            || TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)</span><br><span class="line">            || SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)</span><br><span class="line">            || AudioEffect.ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION.equals(action)</span><br><span class="line">            || AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// Broadcast is either protected, or it&#x27;s a public action that</span></span><br><span class="line">			<span class="comment">// we&#x27;ve relaxed, so it&#x27;s fine for system internals to send.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This broadcast may be a problem...  but there are often system components that</span></span><br><span class="line">        <span class="comment">// want to send an internal broadcast to themselves, which is annoying to have to</span></span><br><span class="line">        <span class="comment">// explicitly list each action as a protected broadcast, so we will check for that</span></span><br><span class="line">        <span class="comment">// one safe case and allow it: an explicit broadcast, only being received by something</span></span><br><span class="line">        <span class="comment">// that has protected itself.</span></span><br><span class="line">        <span class="keyword">if</span> (intent.getPackage() != <span class="keyword">null</span> || intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (receivers == <span class="keyword">null</span> || receivers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Intent is explicit and there&#x27;s no receivers.</span></span><br><span class="line">                <span class="comment">// This happens, e.g. , when a system component sends a broadcast to</span></span><br><span class="line">                <span class="comment">// its own runtime receiver, and there&#x27;s no manifest receivers for it,</span></span><br><span class="line">                <span class="comment">// because this method is called twice for each broadcast,</span></span><br><span class="line">                <span class="comment">// for runtime receivers and manifest receivers and the later check would find</span></span><br><span class="line">                <span class="comment">// no receivers.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> allProtected = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = receivers.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                Object target = receivers.get(i);</span><br><span class="line">                <span class="keyword">if</span> (target <span class="keyword">instanceof</span> ResolveInfo) &#123;</span><br><span class="line">                    ResolveInfo ri = (ResolveInfo)target;</span><br><span class="line">                    <span class="comment">// 如果activity的exported是true，说明该activity有action过滤器，直接判断广播是否开启了保护模式</span></span><br><span class="line">                    <span class="keyword">if</span> (ri.activityInfo.exported &amp;&amp; ri.activityInfo.permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        allProtected = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    BroadcastFilter bf = (BroadcastFilter)target;</span><br><span class="line">                    <span class="keyword">if</span> (bf.requiredPermission == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        allProtected = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (allProtected) &#123;</span><br><span class="line">                <span class="comment">// All safe!</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The vast majority of broadcasts sent from system internals</span></span><br><span class="line">        <span class="comment">// should be protected to avoid security holes, so yell loudly</span></span><br><span class="line">        <span class="comment">// to ensure we examine these cases.</span></span><br><span class="line">    	<span class="comment">// 为了避免安全漏洞，系统应用的广播需要加受保护权限，打印wtf日志！！！</span></span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Sending non-protected broadcast &quot;</span> + action</span><br><span class="line">                + <span class="string">&quot; from system &quot;</span> + callerApp.toShortString() + <span class="string">&quot; pkg &quot;</span> + callerPackage,</span><br><span class="line">                    <span class="keyword">new</span> Throwable());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Sending non-protected broadcast &quot;</span> + action</span><br><span class="line">                            + <span class="string">&quot; from system uid &quot;</span> + UserHandle.formatUid(callingUid)</span><br><span class="line">                            + <span class="string">&quot; pkg &quot;</span> + callerPackage,</span><br><span class="line">                    <span class="keyword">new</span> Throwable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断系统应用是不是受保护的。这个状态是从PKMS启动扫描各个应用apk的时候存储的</span></span><br><span class="line">isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isProtectedBroadcast</span><span class="params">(String actionName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// allow instant applications</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mProtectedBroadcasts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mProtectedBroadcasts.contains(actionName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> remove these terrible hacks</span></span><br><span class="line">            <span class="keyword">if</span> (actionName.startsWith(<span class="string">&quot;android.net.netmon.lingerExpired&quot;</span>)</span><br><span class="line">            || actionName.startsWith(<span class="string">&quot;com.android.server.sip.SipWakeupTimer&quot;</span>)</span><br><span class="line">            || actionName.startsWith(<span class="string">&quot;com.android.internal.telephony.data-reconnect&quot;</span>)</span><br><span class="line">            || actionName.startsWith(<span class="string">&quot;android.net.netmon.launchCaptivePortalApp&quot;</span>)) &#123;</span><br><span class="line">            	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码可知，实际是PackageManagerService里面维护一个名为mProtectedBroadcasts的系统广播白名单。在PackageManagerService扫描系统App时会将AndroidManifest.xml中的所有protected-broadcast加入到此ArraySet变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitPackageSettings</span><span class="params">(PackageParser.Package pkg,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="meta">@Nullable</span> PackageParser.Package oldPkg, PackageSetting pkgSetting, UserHandle user,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> <span class="meta">@ScanFlags</span> <span class="keyword">int</span> scanFlags, <span class="keyword">boolean</span> chatty)</span> </span>&#123;</span><br><span class="line">					.........</span><br><span class="line">			<span class="keyword">if</span> (pkg.protectedBroadcasts != <span class="keyword">null</span>) &#123;</span><br><span class="line">				N = pkg.protectedBroadcasts.size();</span><br><span class="line">				<span class="keyword">synchronized</span> (mProtectedBroadcasts) &#123;</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">					mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;					</span><br><span class="line">	.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PackageManagerService每次启动时会扫描下面三个目录的App：<br>/system/app<br>/system/priv-app<br>/system/framework/framework-res.apk</p>
<p>所以理论上只要在自己App中的AndroidManifest.xml中将自己新增的广播声明为protected-broadcast即可，不应该会出现Sending non-protected broadcast才对。</p>
<p>但是PKMS中有个广播白名单机制，如果扫描的app不在priv-app目录，就会把protectedBroadcasts 标志位置为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyPolicy</span><span class="params">(PackageParser.Package pkg, <span class="keyword">final</span> <span class="meta">@ParseFlags</span> <span class="keyword">int</span> 	</span></span></span><br><span class="line"><span class="function"><span class="params">	parseFlags, <span class="keyword">final</span> <span class="meta">@ScanFlags</span> <span class="keyword">int</span> scanFlags, PackageParser.Package platformPkg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((scanFlags &amp; SCAN_AS_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 如果不是priv-app，将pkg.protectedBroadcasts置为空</span></span><br><span class="line">	<span class="keyword">if</span> ((scanFlags &amp; SCAN_AS_PRIVILEGED) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// clear protected broadcasts</span></span><br><span class="line">            pkg.protectedBroadcasts = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// ignore export request for single user receivers</span></span><br><span class="line">            <span class="keyword">if</span> (pkg.receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = pkg.receivers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> PackageParser.Activity receiver = pkg.receivers.get(i);</span><br><span class="line">                    <span class="keyword">if</span> ((receiver.info.flags &amp; ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">                        receiver.info.exported = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可知，PackageManagerService在扫描App时，发现如果App不是来自priv-app目录下的App（当然framework-res.apk除外），就会将此App的中声明的protected广播清空，这样这个广播就不会加入到白名单，所以才就一直打印上面的warning log</p>
<p>不过这个仅仅是warning的log而已，广播还是可以正常发送和接收的，该结果和金(磊)老板确认过，只是输出日志，不影响收发，但是对于在做系统稳定性的人来说，眼里容不下这种刺。</p>
<h4 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h4><h5 id="3-1-修改原生代码"><a href="#3-1-修改原生代码" class="headerlink" title="3.1 修改原生代码"></a>3.1 修改原生代码</h5><p>将自定义的广播在frameworks/base/core/res/AndroidManifest.xml中声明为protected-broadcast，例如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Added in O --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protected-broadcast</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.action.APPLICATION_DELEGATION_SCOPES_CHANGED&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protected-broadcast</span> <span class="attr">android:name</span>=<span class="string">&quot;com.android.server.wm.ACTION_REVOKE_SYSTEM_ALERT_WINDOW_PERMISSION&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protected-broadcast</span> <span class="attr">android:name</span>=<span class="string">&quot;android.media.tv.action.PARENTAL_CONTROLS_ENABLED_CHANGED&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方案是不可取的。为了减少耦合，修改问题的原则尽量采用不修改原生的方式完成。</p>
<h5 id="3-2-修改应用的包位置"><a href="#3-2-修改应用的包位置" class="headerlink" title="3.2 修改应用的包位置"></a>3.2 修改应用的包位置</h5><p>如果不希望改Android的源码，可以将自己的App放置到/system/priv-app下，而不是默认的/system/app目录下:<br>可在自己app的Android.mk中指定路径：<br>LOCAL_MODULE_PATH := $(TARGET_OUT_APPS_PRIVILEGED)</p>
<p>但是特别注意的是：如果App放置到priv-app目录，是会一些权限限制的。</p>
<h4 id="4-问题回溯与反思"><a href="#4-问题回溯与反思" class="headerlink" title="4.问题回溯与反思"></a>4.问题回溯与反思</h4><p>针对Android P持续打印non-protected broadcast 问题，google很多地方考虑到安全漏洞：使用了平台签名的系统应用广播应该收到保护。虽然没有采取严厉的措施，只是打印wtf日志，但是我们做系统稳定性也要思考是否所有预装应用都赋予平台权限。赋予了平台权限的应用可以和SystemServer跑在一个进程中，如果应用crash了，极有可能导致系统崩溃。因此，系统稳定性下一步应该考虑的哪些应用可以赋予平台权限，哪些应用不必赋予平台权限。</p>
<p>例如HMI层的apk,几乎不会调用到系统隐藏api等，是否可以取消平台权限，加强系统稳定性。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>non-protected-broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title>Dumpsys命令详细说明</title>
    <url>/2021/08/14/Dumpsys%E5%91%BD%E4%BB%A4%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h4 id="1-指令与说明"><a href="#1-指令与说明" class="headerlink" title="1.指令与说明"></a>1.指令与说明</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印出当前系统所有service信息，在后面可加上具体的服务名</span></span><br><span class="line">adb shell dumpsys [system services]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印显示系统信息</span></span><br><span class="line">adb shell dumpsys display</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取设备电池信息</span></span><br><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取cpu信息</span></span><br><span class="line">adb shell dumpsys cpuinfo	</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取内存信息</span></span><br><span class="line">adb shell dumpsys meminfo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要获取具体应用的内存信息，可加上包名</span></span><br><span class="line">adb shell dumpsys meminfo PACKAGE_NAME</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取Activity信息</span></span><br><span class="line">adb shell dumpsys activity</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上-h可以获取帮助信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取当前界面的UI信息，可以用：</span></span><br><span class="line">adb shell dumpsys activity top</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要获取当前界面的Activity：</span></span><br><span class="line">adb shell dumpsys activity top | findstr ACTIVITY</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取package信息</span></span><br><span class="line">adb shell dumpsys package</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上-h可以获取帮助信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某个包的信息：</span></span><br><span class="line">adb shell dumpsys package PACKAGE_NAME</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取通知信息</span></span><br><span class="line">adb shell dumpsys notification</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取wifi信息</span></span><br><span class="line">adb shell dumpsys wifi</span><br><span class="line"><span class="meta">#</span><span class="bash">　可以获取到当前连接的wifi名、搜索到的wifi列表、wifi强度等</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取电源管理信息</span></span><br><span class="line">adb shell dumpsys power</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以获取到是否处于锁屏状态：mWakefulness=Asleep或者mScreenOn=<span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 亮度值：mScreenBrightness=255</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 屏幕休眠时间：Screen off timeout: 60000 ms</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 屏幕分辨率：mDisplayWidth=1920，mDisplayHeight=1080</span></span><br></pre></td></tr></table></figure>


<h4 id="2-常用的命令行参数"><a href="#2-常用的命令行参数" class="headerlink" title="2.常用的命令行参数"></a>2.常用的命令行参数</h4><blockquote>
<p>不同的服务有不同的选项，一下两个是常见的参数：</p>
<p>-h：对于大多数的服务，可以添加-h看到文本的帮助</p>
<p>-c：对于一些服务，可以添加-c查看数据会更友好</p>
</blockquote>
<h4 id="3-包信息查询"><a href="#3-包信息查询" class="headerlink" title="3.包信息查询"></a>3.包信息查询</h4>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>dumpsys</tag>
      </tags>
  </entry>
</search>
