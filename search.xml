<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(1)Iptables教程</title>
    <url>/2021/03/23/(1)Iptables%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="0-Iptables介绍"><a href="#0-Iptables介绍" class="headerlink" title="0. Iptables介绍"></a>0. Iptables介绍</h3><p>iptables防火墙可以用于创建过滤(filter)与NAT规则。所有Linux发行版都能使用iptables，因此理解如何配置iptables将会帮助你更有效地管理Linux防火墙。如果你是第一次接触iptables，你会觉得它很复杂，但是一旦你理解iptables的工作原理，你会发现其实它很简单。</p>
<p>首先介绍iptables的结构：iptables -&gt; Tables -&gt; Chains -&gt; Rules. 简单地讲，tables由chains组成，而chains又由rules组成。如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a1a23a58ea0dbfeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-table-chain-rule-structure.png"></p>
<h3 id="1-iptables的表与链"><a href="#1-iptables的表与链" class="headerlink" title="1.  iptables的表与链"></a>1.  iptables的表与链</h3><p>iptables具有Filter, NAT, Mangle, Raw四种内建表：Filter表、NAT表、Mangle表和Raw表</p>
<h4 id="1-1-Filter表"><a href="#1-1-Filter表" class="headerlink" title="1.1 Filter表"></a>1.1 Filter表</h4><p>Filter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：</p>
<ul>
<li>INPUT链 – 处理来自外部的数据。</li>
<li>OUTPUT链 – 处理向外发送的数据。</li>
<li>FORWARD链 – 将数据转发到本机的其他网卡设备上。</li>
</ul>
<h4 id="1-2-NAT表"><a href="#1-2-NAT表" class="headerlink" title="1.2 NAT表"></a>1.2 NAT表</h4><p>NAT表有三种内建链：</p>
<ul>
<li>PREROUTING链 – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。</li>
<li>POSTROUTING链 – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。</li>
<li>OUTPUT链 – 处理本机产生的数据包。</li>
</ul>
<h4 id="3-Mangle表"><a href="#3-Mangle表" class="headerlink" title="3. Mangle表"></a>3. Mangle表</h4><p>Mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链(解释见上)：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
<li>FORWARD</li>
<li>INPUT</li>
<li>POSTROUTING</li>
</ul>
<h3 id="4-Raw表"><a href="#4-Raw表" class="headerlink" title="4. Raw表"></a>4. Raw表</h3><p>Raw表用于处理异常，它具有2个内建链：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
</ul>
<p>以下是Iptables中的三个重要表格</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b9b4675931350c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-filter-nat-mangle-tables.png"></p>
<h3 id="2-IPTABLES-规则-Rules"><a href="#2-IPTABLES-规则-Rules" class="headerlink" title="2.IPTABLES 规则(Rules)"></a>2.IPTABLES 规则(Rules)</h3><p>牢记以下三点式理解iptables规则的关键：</p>
<ul>
<li>Rules包括一个条件和一个<strong>目标值</strong>(target)</li>
<li>如果满足条件，就执行目标(target)中的规则或者特定值。</li>
<li>如果不满足条件，就判断下一条Rules。</li>
</ul>
<p><strong>目标值（Target Values）</strong></p>
<p>下面是你可以在target里指定的特殊值：</p>
<ul>
<li>ACCEPT – 允许防火墙接收数据包</li>
<li>DROP – 防火墙丢弃包</li>
<li>QUEUE – 防火墙将数据包移交到用户空间</li>
<li>RETURN – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。</li>
</ul>
<p>如果你执行<code>iptables --list</code>你将看到防火墙上的可用规则。下例说明当前系统没有定义防火墙，你可以看到，它显示了默认的filter表，以及表内默认的input链, forward链, output链。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -t filter --list</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li>target：目标值     </li>
<li>prot： 协议</li>
<li>opt：选项</li>
<li>source：数据包源地址</li>
<li>destination：数据包目标地址</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-97d2c29e31e90ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter表内容.png"></p>
<p>bw_INPUT、bw_OUTPUT和bw_FORWARD chain用于带宽(Bandwidth)控制；</p>
<p>fw_INPUT、fw_OUTPUT和fw_FORWARD chain用于防火墙(Firewall)控制；</p>
<p>natctrl_FORWARD用于网络地址转换(NAT)控制；</p>
<p>oem_fwd、oem_out用于OEM厂商自定义的控制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看mangle表</span></span><br><span class="line">iptables -t mangle --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看nat表</span></span><br><span class="line">iptables -t nat --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看raw表</span></span><br><span class="line">iptables -t raw --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于默认表是filter表，不加-t选项默认输出filter表</span></span><br><span class="line">iptables -t filter --list</span><br><span class="line">(or)</span><br><span class="line">iptables --list</span><br></pre></td></tr></table></figure>


<h3 id="3-清空所有iptables规则"><a href="#3-清空所有iptables规则" class="headerlink" title="3.清空所有iptables规则"></a>3.清空所有iptables规则</h3><p>在配置iptables之前，你通常需要用<code>iptables --list</code>命令或者<code>iptables-save</code>命令查看有无现存规则，因为有时需要删除现有的iptables规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables --flush</span><br><span class="line">或者</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>
<p>这两条命令是等效的。但是并非执行后就万事大吉了。你仍然需要检查规则是不是真的清空了，因为有的linux发行版上这个命令不会清除NAT表中的规则，此时只能手动清除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t NAT -F</span><br></pre></td></tr></table></figure>


<h3 id="4-永久生效"><a href="#4-永久生效" class="headerlink" title="4.永久生效"></a>4.永久生效</h3><p>当你删除、添加规则后，这些更改并不能永久生效，这些规则很有可能在系统重启后恢复原样。为了让配置永久生效，根据平台的不同，具体操作也不同。下面进行简单介绍：</p>
<h4 id="4-1-Ubuntu"><a href="#4-1-Ubuntu" class="headerlink" title="4.1 Ubuntu"></a>4.1 Ubuntu</h4><p>首先，保存现有的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>然后新建一个bash脚本，并保存到/etc/network/if-pre-up.d/目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">iptables-restore &lt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>这样，每次系统重启后iptables规则都会被自动加载。<br>/!\注意：不要尝试在.bashrc或者.profile中执行以上命令，因为用户通常不是root，而且这只能在登录时加载iptables规则。</p>
<h4 id="4-2-CentOS-RedHat"><a href="#4-2-CentOS-RedHat" class="headerlink" title="4.2 CentOS, RedHat"></a>4.2 CentOS, RedHat</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 保存iptables规则</span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line"># 重启iptables服务</span><br><span class="line">service iptables stop</span><br><span class="line">service iptables start</span><br></pre></td></tr></table></figure>
<p>查看当前规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat  &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure>


<h3 id="5-追加iptables规则"><a href="#5-追加iptables规则" class="headerlink" title="5. 追加iptables规则"></a>5. 追加iptables规则</h3><p>可以使用<code>iptables -A</code>命令追加新规则，其中-A表示Append。因此，新的规则将追加到链尾。<br>一般而言，最后一条规则用于丢弃(DROP)所有数据包。如果你已经有这样的规则了，并且使用-A参数添加新规则，那么就是无用功。</p>
<h4 id="5-1语法"><a href="#5-1语法" class="headerlink" title="5.1语法"></a>5.1语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A chain firewall-rule</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">-A chain – 指定要追加规则的链</span></span><br><span class="line"><span class="meta">#</span><span class="bash">firewall-rule – 具体的规则参数</span></span><br></pre></td></tr></table></figure>


<h4 id="5-2-描述规则的基本参数"><a href="#5-2-描述规则的基本参数" class="headerlink" title="5.2 描述规则的基本参数"></a>5.2 描述规则的基本参数</h4><p>以下这些规则参数用于描述数据包的协议、源地址、目的地址、允许经过的网络接口，以及如何处理这些数据包。这些描述是对规则的基本描述。</p>
<h5 id="p-协议（protocol）"><a href="#p-协议（protocol）" class="headerlink" title="-p 协议（protocol）"></a>-p 协议（protocol）</h5><ul>
<li><p>指定规则的协议，如tcp, udp, icmp等，可以使用all来指定所有协议。</p>
</li>
<li><p>如果不指定-p参数，则默认是all值。这并不明智，请总是明确指定协议名称。</p>
</li>
<li><p>可以使用协议名(如tcp)，或者是协议值（比如6代表tcp）来指定协议。映射关系请查看/etc/protocols</p>
</li>
<li><p>还可以使用–protocol参数代替-p参数</p>
</li>
</ul>
<h5 id="s-源地址（source）"><a href="#s-源地址（source）" class="headerlink" title="-s 源地址（source）"></a>-s 源地址（source）</h5><ul>
<li>指定数据包的源地址</li>
<li>参数可以使IP地址、网络地址、主机名</li>
<li>例如：-s 192.168.1.101指定IP地址</li>
<li>例如：-s 192.168.1.10/24指定网络地址</li>
<li>如果不指定-s参数，就代表所有地址</li>
<li>还可以使用–src或者–source</li>
</ul>
<h5 id="d-目的地址（destination）"><a href="#d-目的地址（destination）" class="headerlink" title="-d 目的地址（destination）"></a>-d 目的地址（destination）</h5><ul>
<li>指定目的地址</li>
<li>参数和-s相同</li>
<li>还可以使用–dst或者–destination</li>
</ul>
<h5 id="j-执行目标（jump-to-target）"><a href="#j-执行目标（jump-to-target）" class="headerlink" title="-j 执行目标（jump to target）"></a>-j 执行目标（jump to target）</h5><ul>
<li>-j代表”jump to target”</li>
<li>-j指定了当与规则(Rule)匹配时如何处理数据包</li>
<li>可能的值是ACCEPT, DROP, QUEUE, RETURN</li>
<li>还可以指定其他链（Chain）作为目标</li>
</ul>
<h5 id="i-输入接口（input-interface）"><a href="#i-输入接口（input-interface）" class="headerlink" title="-i 输入接口（input interface）"></a>-i 输入接口（input interface）</h5><ul>
<li>-i代表输入接口(input interface)</li>
<li>-i指定了要处理来自哪个接口的数据包</li>
<li>这些数据包即将进入INPUT, FORWARD, PREROUTE链</li>
<li>例如：-i eth0指定了要处理经由eth0进入的数据包</li>
<li>如果不指定-i参数，那么将处理进入所有接口的数据包</li>
<li>如果出现! -i eth0，那么将处理所有经由eth0以外的接口进入的数据包</li>
<li>如果出现-i eth+，那么将处理所有经由eth开头的接口进入的数据包</li>
<li>还可以使用–in-interface参数</li>
</ul>
<h5 id="o-输出（out-interface）"><a href="#o-输出（out-interface）" class="headerlink" title="-o 输出（out interface）"></a>-o 输出（out interface）</h5><ul>
<li>-o代表”output interface”</li>
<li>-o指定了数据包由哪个接口输出</li>
<li>这些数据包即将进入FORWARD, OUTPUT, POSTROUTING链</li>
<li>如果不指定-o选项，那么系统上的所有接口都可以作为输出接口</li>
<li>如果出现! -o eth0，那么将从eth0以外的接口输出</li>
<li>如果出现-i eth+，那么将仅从eth开头的接口输出</li>
<li>还可以使用–out-interface参数</li>
</ul>
<h4 id="5-3-描述规则的扩展参数"><a href="#5-3-描述规则的扩展参数" class="headerlink" title="5.3 描述规则的扩展参数"></a>5.3 描述规则的扩展参数</h4><p>对规则有了一个基本描述之后，有时候我们还希望指定端口、TCP标志、ICMP类型等内容。</p>
<h5 id="–sport-源端口（source-port）针对-p-tcp-或者-p-udp"><a href="#–sport-源端口（source-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–sport 源端口（source port）针对 -p tcp 或者 -p udp"></a>–sport 源端口（source port）针对 -p tcp 或者 -p udp</h5><ul>
<li>缺省情况下，将匹配所有端口</li>
<li>可以指定端口号或者端口名称，例如”–sport 22″与”–sport ssh”。</li>
<li>/etc/services文件描述了上述映射关系。</li>
<li>从性能上讲，使用端口号更好</li>
<li>使用冒号可以匹配端口范围，如”–sport 22:100″</li>
<li>还可以使用”–source-port”</li>
</ul>
<h5 id="–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp"><a href="#–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–-dport 目的端口（destination port）针对-p tcp 或者 -p udp"></a>–-dport 目的端口（destination port）针对-p tcp 或者 -p udp</h5><ul>
<li>参数和–sport类似</li>
<li>还可以使用”–destination-port”</li>
</ul>
<h5 id="–tcp-flags-TCP标志-针对-p-tcp"><a href="#–tcp-flags-TCP标志-针对-p-tcp" class="headerlink" title="-–tcp-flags TCP标志 针对-p tcp"></a>-–tcp-flags TCP标志 针对-p tcp</h5><ul>
<li>可以指定由逗号分隔的多个参数</li>
<li>有效值可以是：SYN, ACK, FIN, RST, URG, PSH</li>
<li>可以使用ALL或者NONE</li>
</ul>
<h5 id="–icmp-type-ICMP类型-针对-p-icmp"><a href="#–icmp-type-ICMP类型-针对-p-icmp" class="headerlink" title="-–icmp-type ICMP类型 针对-p icmp"></a>-–icmp-type ICMP类型 针对-p icmp</h5><ul>
<li>–icmp-type 0 表示Echo Reply</li>
<li>–icmp-type 8 表示Echo</li>
</ul>
<h4 id="5-4-追加规则的完整实例：仅允许SSH服务"><a href="#5-4-追加规则的完整实例：仅允许SSH服务" class="headerlink" title="5.4 追加规则的完整实例：仅允许SSH服务"></a>5.4 追加规则的完整实例：仅允许SSH服务</h4><p>本例实现的规则将仅允许SSH数据包通过本地计算机，其他一切连接（包括ping）都将被拒绝。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.清空所有iptables规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.接收目标端口为22的数据包</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.拒绝所有其他数据包</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure>


<h3 id="6-更改默认策略"><a href="#6-更改默认策略" class="headerlink" title="6. 更改默认策略"></a>6. 更改默认策略</h3><p>上例的例子仅对接收的数据包过滤，而对于要发送出去的数据包却没有任何限制。本节主要介绍如何更改链策略，以改变链的行为。</p>
<h4 id="6-1-默认链策略"><a href="#6-1-默认链策略" class="headerlink" title="6.1 默认链策略"></a>6.1 默认链策略</h4><p>/!\警告：请勿在远程连接的服务器、虚拟机上测试！<br>当我们使用-L选项验证当前规则是发现，所有的链旁边都有policy ACCEPT标注，这表明当前链的默认策略为ACCEPT：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh</span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p>这种情况下，如果没有明确添加DROP规则，那么默认情况下将采用ACCEPT策略进行过滤。除非：<br>a)为以上三个链单独添加DROP规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -j DROP</span><br><span class="line">iptables -A OUTPUT -j DROP</span><br><span class="line">iptables -A FORWARD -j DROP</span><br></pre></td></tr></table></figure>
<p>b)更改默认策略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>


<h3 id="7-配置应用程序规则"><a href="#7-配置应用程序规则" class="headerlink" title="7.配置应用程序规则"></a>7.配置应用程序规则</h3><p>尽管5.4节已经介绍了如何初步限制除SSH以外的其他连接，但是那是在链默认策略为ACCEPT的情况下实现的，并且没有对输出数据包进行限制。本节在上一节基础上，以SSH和HTTP所使用的端口为例，教大家如何在默认链策略为DROP的情况下，进行防火墙设置。在这里，我们将引进一种新的参数-m state，并检查数据包的状态字段。</p>
<h4 id="7-1-SSH"><a href="#7-1-SSH" class="headerlink" title="7.1 SSH"></a>7.1 SSH</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的SSH请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.允许发送本地主机的SSH响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">-m state: 启用状态匹配模块（state matching module）</span><br><span class="line">–-state: 状态匹配模块的参数。当SSH客户端第一个数据包到达服务器时，状态字段为NEW；建立连接后数据包的状态字段都是ESTABLISHED</span><br><span class="line">–sport 22: sshd监听22端口，同时也通过该端口和客户端建立连接、传送数据。因此对于SSH服务器而言，源端口就是22</span><br><span class="line">–dport 22: ssh客户端程序可以从本机的随机端口与SSH服务器的22端口建立连接。因此对于SSH客户端而言，目的端口就是22</span><br></pre></td></tr></table></figure>


<h4 id="7-2-HTTP"><a href="#7-2-HTTP" class="headerlink" title="7.2 HTTP"></a>7.2 HTTP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.允许发送本地主机的HTTP响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="7-3-完整的配置"><a href="#7-3-完整的配置" class="headerlink" title="7.3 完整的配置"></a>7.3 完整的配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.删除现有规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.配置默认链策略</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.允许远程主机进行SSH连接</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.允许本地主机进行SSH连接</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.允许HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>



<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.thegeekstuff.com/2011/01/iptables-fundamentals/">1.  Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals</a></p>
<p><a href="https://www.thegeekstuff.com/2011/02/iptables-add-rule/">2. Linux IPTables: How to Add Firewall Rules (With Allow SSH Example)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/03/iptables-inbound-and-outbound-rules/">3. Linux IPTables: Incoming and Outgoing Rule Examples (SSH and HTTP)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/06/iptables-rules-examples/">4. 25 Most Frequently Used Linux IPTables Rules Examples</a></p>
<p><a href="https://www.thegeekstuff.com/category/iptables/">5. iptables相关所有教程</a></p>
<p><a href="https://www.zsythink.net/archives/1199">6.朱双印的一系列Iptables原理讲解教程</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>(1)C++面向对象</title>
    <url>/2021/05/19/1-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="1-amp-引用"><a href="#1-amp-引用" class="headerlink" title="1. &amp;引用"></a>1. &amp;引用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递，内存地址不一样</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = n1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;n1 &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; &amp;n2 &lt;&lt; <span class="built_in">endl</span>;*/ <span class="comment">// 0xffffcbb4---0xffffcbb0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &amp;引用，对被引用地址操作</span></span><br><span class="line"><span class="keyword">int</span> n1 = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; n2 = n1;</span><br><span class="line"><span class="keyword">int</span> &amp; n9 = n1;</span><br><span class="line">n2 = <span class="number">777</span>;</span><br><span class="line">n9 = <span class="number">9527</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;n1 &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; &amp;n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;值：&quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//结果: 0x28ff0c---0x28ff0c</span></span><br><span class="line"><span class="comment">// 9527---9527</span></span><br></pre></td></tr></table></figure>


<h4 id="2-常量引用"><a href="#2-常量引用" class="headerlink" title="2.常量引用"></a>2.常量引用</h4><p>C++的常量是真的常量，C是伪常量，C的常量可以通过指针修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法内部可以修改student,因此会报问题，需要使用到常量引用，在方法体内部不能修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法。</span></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(<span class="keyword">const</span> Student &amp;student)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//方法内对student为只读，不可修改</span></span><br><span class="line">    <span class="comment">// student是旧地址</span></span><br><span class="line">    <span class="comment">// this是新地址</span></span><br><span class="line">    <span class="comment">// student2就是新地址了</span></span><br><span class="line">    student2 = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-深浅拷贝"><a href="#3-深浅拷贝" class="headerlink" title="3.深浅拷贝"></a>3.深浅拷贝</h4><p>浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">// strcpy运行会报错，支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line">	Student2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;空参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">	Student2(<span class="keyword">char</span> * name) :Student2(name, <span class="number">99</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一个参数构造函数 this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Student2(<span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二个参数构造函数 this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)* <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Student2() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数执行 &amp;this-&gt;name:&quot;</span> &lt;&lt; &amp;<span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认有一个拷贝构造函数 隐士的 我们看不见</span></span><br><span class="line">	<span class="comment">// 一旦复写了拷贝构造函数，默认的还在吗？ Java的构造函数一个思路</span></span><br><span class="line">	Student2(<span class="keyword">const</span> Student2 &amp; stu) &#123;</span><br><span class="line">		<span class="comment">// stu 旧地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// this 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// s2 = 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数 &amp;stu:&quot;</span> &lt;&lt; &amp;stu &lt;&lt; <span class="string">&quot; this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 新地址name = 旧地址 （浅拷贝）</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = stu.name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 深拷贝 后面见  原理全部打通的时候讲</span></span><br><span class="line">	&#125; <span class="comment">// 此拷贝构造函数执行完 旧会出现一个 this==新地址  给 main函数的 stu</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Student2 <span class="title">getStudent</span><span class="params">(<span class="keyword">char</span> * name)</span> </span>&#123;</span><br><span class="line">	<span class="function">Student2 <span class="title">stu</span><span class="params">(name)</span></span>; <span class="comment">// 旧地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;getStudent函数:&quot;</span> &lt;&lt; &amp;stu &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 旧地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stu; <span class="comment">// stu 旧地址</span></span><br><span class="line">&#125; <span class="comment">// 弹栈 释放 栈成员 stu</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainT3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// = 会执行拷贝构造函数</span></span><br><span class="line">	<span class="comment">// stu 新地址</span></span><br><span class="line">	Student2 stu = getStudent(<span class="string">&quot;截拳道&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数:&quot;</span> &lt;&lt; &amp;stu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印：</span></span><br><span class="line">	<span class="comment">// 两个参数构造函数</span></span><br><span class="line">	<span class="comment">// 一个参数构造函数</span></span><br><span class="line">	<span class="comment">// getStudent函数: 1000H地址</span></span><br><span class="line">	<span class="comment">// 拷贝构造函数 构建新地址 把新地址 给 main函数的 stu == 新地址</span></span><br><span class="line">	<span class="comment">// 析构函数</span></span><br><span class="line">	<span class="comment">// main函数: </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// getchar(); // 不要一闪而过，让程序停留   需要在拷贝构造函数中使用深拷贝，然后在析构函数中释放this的内存</span></span><br><span class="line">&#125; <span class="comment">// main函数弹栈 stu 新地址 析构函数执行</span></span><br></pre></td></tr></table></figure>


<p>深拷贝：</p>
<p>如果类成员变量中有堆成员，就需要重写拷贝构造函数，实现深拷贝。默认的拷贝构造函数是<strong>浅拷贝</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">// strcpy运行会报错，支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line">	Student() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;空参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">	Student(<span class="keyword">char</span> * name) :Student(name, <span class="number">99</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一个参数构造函数 this:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Student(<span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;二个参数构造函数 this:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)* <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Student() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数执行 &amp;this-&gt;name:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认有一个拷贝构造函数 隐士的 我们看不见</span></span><br><span class="line">	<span class="comment">// 一旦复写了拷贝构造函数，默认的还在吗？ Java的构造函数一个思路</span></span><br><span class="line">	<span class="comment">// 自定义拷贝构造函数 如果有堆成员，必须采用深拷贝</span></span><br><span class="line">	Student(<span class="keyword">const</span> Student &amp; stu) &#123;</span><br><span class="line">		<span class="comment">// stu 旧地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// this 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// s2 = 新地址</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数 &amp;stu:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;stu &lt;&lt; <span class="string">&quot; this:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)<span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 【浅拷贝】：新地址name  旧地址name 指向同一个空间，会造成，重复free的问题，引发奔溃</span></span><br><span class="line">		<span class="comment">// 新地址name = 旧地址 （浅拷贝）</span></span><br><span class="line">		<span class="comment">// this-&gt;name = stu.name;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 【深拷贝】</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span> *)* <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = stu.age;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数2 this-&gt;name:&quot;</span> &lt;&lt; ((<span class="keyword">int</span>) <span class="keyword">this</span>-&gt;name) &lt;&lt; <span class="string">&quot;  stu.name:&quot;</span> &lt;&lt; (<span class="keyword">int</span>)stu.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 深拷贝 后面见  原理全部打通的时候讲</span></span><br><span class="line">	&#125; <span class="comment">// 此拷贝构造函数执行完 旧会出现一个 this==新地址  给 main函数的 stu</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认的拷贝构造函数 是浅拷贝</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//stu是新地址，拷贝构造函数构建新地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStudent</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;showStudent函数：&quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;stu &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; stu.age&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;刘奋&quot;</span>, <span class="number">31</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	showStudent(stu); <span class="comment">// 弹栈后 新地址name释放一遍</span></span><br><span class="line">	<span class="comment">// showStudent(stu); // 弹栈后 新地址name释放一遍</span></span><br><span class="line">	<span class="comment">// 两次释放新地址name 会奔溃</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放一次新地址name  再释放一次旧name也报错</span></span><br><span class="line"></span><br><span class="line">	showStudent(stu);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">&#125; <span class="comment">// main函数弹栈 stu 旧地址</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>(2)iptables规则管理</title>
    <url>/2021/05/20/2-iptables%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-查看表中规则"><a href="#1-查看表中规则" class="headerlink" title="1.查看表中规则"></a>1.查看表中规则</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看filter表中所有规则</span></span><br><span class="line">iptables -t filter -L</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询filter表中INPUT链规则</span></span><br><span class="line">iptables -t filter -L INPUT</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6a5054ba3a6a8777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询表.png"></p>
<h4 id="2-查看规则详情"><a href="#2-查看规则详情" class="headerlink" title="2.查看规则详情"></a>2.查看规则详情</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加入-v参数，查看详情</span></span><br><span class="line">iptables -t filter -L -v</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-fddf11792689aa45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看规则详情.png"></p>
<p>规则字段含义：</p>
<ul>
<li><strong>pkts</strong>:对应规则匹配到的报文的个数。</li>
<li><strong>bytes</strong>:对应匹配到的报文包的大小总和。</li>
<li><strong>target</strong>:规则对应的target，往往表示规则对应的”动作”，即规则匹配成功后需要采取的措施。</li>
<li><strong>prot</strong>:表示规则对应的协议，是否只针对某些协议应用此规则。</li>
<li><strong>opt</strong>:表示规则对应的选项。</li>
<li><strong>in</strong>:表示数据包由哪个接口(网卡)流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li><strong>out</strong>:表示数据包由哪个接口(网卡)流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li><strong>source</strong>:表示规则对应的源头地址，可以是一个IP，也可以是一个网段。</li>
<li><strong>destination</strong>:表示规则对应的目标地址。可以是一个IP，也可以是一个网段。</li>
</ul>
<p>上图中的源地址与目标地址都为anywhere，iptables默认为我们进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低，我们可以使用 <code>-n</code> 选项，表示不对IP地址进行名称反解，直接显示IP地址</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-52e385dc6a00782e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看某链上细化规则.PNG"></p>
<p>链括号中的参数含义：</p>
<p>Chain INPUT (policy ACCEPT 4883 packets, 342K bytes)</p>
<ul>
<li><strong>policy</strong>表示当前链的默认策略，policy ACCEPT表示上图中INPUT的链的默认动作为ACCEPT，换句话说就是，默认接受通过INPUT关卡的所有请求，所以我们在配置INPUT链的具体规则时，应该将需要拒绝的请求配置到规则中，说白了就是”黑名单”机制，默认所有人都能通过，只有指定的人不能通过。</li>
<li><strong>packets</strong>表示当前链（上例为INPUT链）默认策略匹配到的包的数量，0 packets表示默认策略匹配到0。</li>
<li><strong>bytes</strong>表示当前链默认策略匹配到的所有包的大小总和。</li>
</ul>
<h4 id="3-显示规则行号"><a href="#3-显示规则行号" class="headerlink" title="3.显示规则行号"></a>3.显示规则行号</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables --line-number -nvL INPUT</span><br><span class="line"></span><br><span class="line">// 查看精细的字节数可以加-x参数</span><br><span class="line">iptables -nvxL INPUT</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-984020d39d5d27fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看精确字节数.png"></p>
<h4 id="4-添加规则"><a href="#4-添加规则" class="headerlink" title="4.添加规则"></a>4.添加规则</h4><p>使用  <code>-I</code> 或者 <code>-A</code> 来添加规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 14.215.177.39 为百度的一个ip</span></span><br><span class="line">iptables -t filter -I INPUT -s 14.215.177.39 -j DROP</span><br><span class="line">iptables -t filter -A INPUT -s 14.215.177.39 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在INPUT链的第一行添加规则</span></span><br><span class="line">iptables -t filter -A INPUT 1 -s 14.215.177.39 -j ACCEPT</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用-I选项，指明将”规则”插入至哪个链中，-I表示insert，即插入的意思，所以-I INPUT表示将规则插入于INPUT链中，即添加规则之意。</p>
</li>
<li><p>使用-s选项，指明”匹配条件”中的”源地址”，即如果报文的源地址属于-s对应的地址，那么报文则满足匹配条件，-s为source之意，表示源地址。</p>
</li>
<li><p>使用-j选项，指明当”匹配条件”被满足时，所对应的动作，上例中指定的动作为DROP，在上例中，当报文的源地址为14.215.177.39时，报文则被DROP（丢弃）。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bd5416095ad6a169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加规则.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d6fc8d76fc3a0ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证新加规则.png"></p>
<h4 id="5-删除规则"><a href="#5-删除规则" class="headerlink" title="5.删除规则"></a>5.删除规则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除多少行,删除第一行规则</span><br><span class="line">iptables -t filter -D INPUT 1</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cc35faed601dc5f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除规则.png"></p>
<h4 id="6-修改规则"><a href="#6-修改规则" class="headerlink" title="6.修改规则"></a>6.修改规则</h4><p>使用 <code>-R</code> 来更改指定行数规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将INPUT链第一行规则改为接受14.215.177.39的报文,此处一定要加上-s，否者将默认0.0.0.0/0，接受全部。</span></span><br><span class="line">iptables -t filter -R INPUT 1 -s 14.215.177.39 -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="7-设置链默认规则"><a href="#7-设置链默认规则" class="headerlink" title="7.设置链默认规则"></a>7.设置链默认规则</h4><p>使用 <code>-P</code>参数设置链默认规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置filter表FORWARD链默认规则为DROP</span></span><br><span class="line">iptables -t filter -P FORWARD DROP</span><br></pre></td></tr></table></figure>


<h4 id="8-保存-恢复配置信息"><a href="#8-保存-恢复配置信息" class="headerlink" title="8.保存/恢复配置信息"></a>8.保存/恢复配置信息</h4><p>使用<code>iptables-save</code> 指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /data/iptables-rules</span><br><span class="line">iptables-restore &lt; /data/iptables-rules</span><br></pre></td></tr></table></figure>


<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.zsythink.net/archives/1517">iptables规则管理</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>(4)Firewall实战</title>
    <url>/2021/05/24/4-Firewall%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h4 id="1-防火墙黑白名单定义"><a href="#1-防火墙黑白名单定义" class="headerlink" title="1. 防火墙黑白名单定义"></a>1. 防火墙黑白名单定义</h4><p>当链的默认策略为ACCEPT时，链中的规则对应的动作应该为DROP或者REJECT，表示只有匹配到规则的报文才会被拒绝，没有被规则匹配到的报文都会被默认接受，这就是”黑名单”机制。</p>
<p>同理，当链的默认策略为DROP时，链中的规则对应的动作应该为ACCEPT，表示只有匹配到规则的报文才会被放行，没有被规则匹配到的报文都会被默认拒绝，这就是”白名单”机制。</p>
<h4 id="2-有问题的白名单机制"><a href="#2-有问题的白名单机制" class="headerlink" title="2.有问题的白名单机制"></a>2.有问题的白名单机制</h4><p>运行ssh远程连接和web服务连接，其他全部拒绝</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -P INPUT DROP</span><br></pre></td></tr></table></figure>
<p>但是这样配置会有问题，如果使用<code>iptables -F</code>清空了所有规则，这样就会导致所有请求都会被DROP，只能通过刷机才能连上车机了。</p>
<h4 id="3-正确的白名单机制"><a href="#3-正确的白名单机制" class="headerlink" title="3.正确的白名单机制"></a>3.正确的白名单机制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -j REJECT</span><br></pre></td></tr></table></figure>
<p>既将INPUT链的默认策略设置为了ACCEPT，同时又使用了白名单机制，因为如果报文符合放行条件，则会被前面的放行规则匹配到，如果报文不符合放行条件，则会被最后一条拒绝规则匹配到，此刻，即使我们误操作，执行了”iptables -F”操作，也能保证管理员能够远程到主机上进行维护，因为默认策略仍然是ACCEPT。</p>
<h4 id="4-自定义链"><a href="#4-自定义链" class="headerlink" title="4.自定义链"></a>4.自定义链</h4><p><code>-N vendor_fw_INPUT</code>表示创建一个自定义链，自定义链的名称为”vendor_fw_INPUT”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建链</span></span><br><span class="line">iptables -t filter -N vendor_fw_INPUT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建规则：http请求走自定义链</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -j vendor_fw_INPUT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下具体配置vendor_fw_INPUT上的规则即可。</span></span><br></pre></td></tr></table></figure>
<p>此时 <code>vendor_fw_INPUT</code> 就会在INPUT链上有一次引用。</p>
<p>如果我们不喜欢vendor_fw_INPUT这个链的名字，需要改成gxatek_fw_INPUT。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -E vendor_fw_INPUT gxatek_fw_INPUT</span><br></pre></td></tr></table></figure>


<h4 id="5-删除自定义链"><a href="#5-删除自定义链" class="headerlink" title="5.删除自定义链"></a>5.删除自定义链</h4><p>使用”-X”选项可以删除自定义链，但是删除自定义链时，需要满足两个条件：</p>
<ul>
<li><p>1、自定义链没有被任何默认链引用，即自定义链的引用计数为0。</p>
</li>
<li><p>2、自定义链中没有任何规则，即自定义链为空。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除gxatek_fw_INPUT链</span></span><br><span class="line">iptables -X gxatek_fw_INPUT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果链上有引用，先删除链上的引用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除input链上第一条，引用gxatek_fw_INPUT的那行</span></span><br><span class="line">iptables -D INPUT 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空链上规则</span></span><br><span class="line">iptables -t filter -F gxatek_fw_INPUT</span><br></pre></td></tr></table></figure>


<h4 id="6-设置不同协议走不同网卡"><a href="#6-设置不同协议走不同网卡" class="headerlink" title="6. 设置不同协议走不同网卡"></a>6. 设置不同协议走不同网卡</h4><p>udp协议走udp_0网口，icmp协议走icmp_0网口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mangle表set-mark</span><br><span class="line"></span><br><span class="line">iptables -t mangle -A PREROUTING -p udp -j MARK --set-mark 10</span><br><span class="line">iptables -t mangle -A PREROUTING -p icmp -j MARK --set-mark 11</span><br><span class="line"></span><br><span class="line">建表</span><br><span class="line"></span><br><span class="line">ip rule add from all fwmark 10 table 10</span><br><span class="line">ip rule add from all fwmark 11 table 11</span><br><span class="line"></span><br><span class="line">route</span><br><span class="line">ip route add default dev udp_0 table 10</span><br><span class="line">ip route add default dev icmp_0 table 11</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f77be08d92565160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络数据流向.png"></p>
<h4 id="7-防火墙架构"><a href="#7-防火墙架构" class="headerlink" title="7.防火墙架构"></a>7.防火墙架构</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-765096dbea7f51e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="防火墙架构.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>(5)网络配置管理</title>
    <url>/2021/07/30/5-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-Ip-route"><a href="#1-Ip-route" class="headerlink" title="1. Ip route"></a>1. Ip route</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 基础指令</span></span><br><span class="line">ip link list 显示ip链路状态信息</span><br><span class="line">ip address show 除显示所有网络地址</span><br><span class="line">ip route show 显示主路由表信息</span><br><span class="line">ip neigh show 显示邻居表</span><br></pre></td></tr></table></figure>
<p>Linux系统路由表，linux可以自定义从1－252个路由表，linux系统维护了4个路由表：</p>
<ul>
<li>0#表 系统保留表</li>
<li>253#表 defulte table 没特别指定的默认路由都放在改表</li>
<li>254#表 main table 没指明路由表的所有路由放在该表</li>
<li>255#表 locale table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看路由表信息</span></span><br><span class="line">ip route list table table_number</span><br><span class="line">ip route list table table_name</span><br></pre></td></tr></table></figure>


<p>路由表添加完毕即时生效，下面为实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在一号表中添加默认路由为192.168.1.1</span></span><br><span class="line">ip route add default via 192.168.1.1 table 1 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在一号表中添加一条到192.168.0.0网段的路由为192.168.1.2</span></span><br><span class="line">ip route add 192.168.0.0/24 via 192.168.1.2 table 1</span><br></pre></td></tr></table></figure>
<p>注:各路由表中应当指明默认路由,尽量不回查路由表.路由添加完毕,即可在路由规则中应用</p>
<h4 id="2-ip-rule"><a href="#2-ip-rule" class="headerlink" title="2. ip rule"></a>2. ip rule</h4><p>进行路由时，根据路由规则来进行匹配，按优先级（pref）从低到高匹配,直到找到合适的规则.所以在应用中配置默认路由是必要的.   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示路由规则</span></span><br><span class="line">ip rule show </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 路由规则的添加,如果pref值不指定，则将在已有规则最小序号前插入</span></span><br><span class="line">ip rule add from 192.168.1.10/32 table 1 pref 100</span><br></pre></td></tr></table></figure>
<p>注：创建完路由规则若需立即生效须执行#ip route flush cache;刷新路由缓冲<br>可参数解析如下： </p>
<blockquote>
<p>From — 源地址<br>To — 目的地址（这里是选择规则时使用，查找路由表时也使用）<br>　　 Tos — IP包头的TOS（type of sevice）域Linux高级路由-<br>　　 Dev — 物理接口<br>　 　Fwmark — iptables标签<br>采取的动作除了指定路由表外，还可以指定下面的动作：<br>Table 指明所使用的表<br>　 Nat 透明网关</p>
<p>　　 Prohibit 丢弃该包，并发送 COMM.ADM.PROHIITED的ICMP信息<br>　　 Reject 单纯丢弃该包<br>　　 Unreachable丢弃该包， 并发送 NET UNREACHABLE的ICMP信息<br>具体格式如下：更强大，使用更灵活，它使网络管理员不仅能<br>Usage: ip rule [ list | add | del ] SELECTOR ACTION<br>SELECTOR := [ from PREFIX ] [ to PREFIX ] [ tos TOS ][ dev STRING ] [ pref NUMBER ]<br>ACTION := [ table TABLE_ID ] [ nat ADDRESS ][ prohibit | reject | unreachable ]<br>[ flowid CLASSID ]<br>TABLE_ID := [ local | main | default | new | NUMBER ]</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip route add 192.168.1.0/24 dev eth0 via 192.168.1.66 realm 4</span></span><br><span class="line">注:发往子网192.168.1.0/24的数据包通过分类4转发配合tc使用</span><br><span class="line"><span class="meta">#</span><span class="bash">ip route add default via 192.168.1.1 table int1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip route add 192.168.1.0/24 via 192.168.1.1 table int2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ip route add 172.16.0.2/16 via 172.16.0.1 table int3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ip rule sh 显示路由规则</span> </span><br><span class="line">0:      from all lookup local </span><br><span class="line">32766:  from all lookup main </span><br><span class="line">32767:  from all lookup default</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip rule规则添加示例： </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add from 192.168.1.112/32 [tos 0x10] table test2 pref 999 prohibit</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add to 192.168.1.2 pref 1000 table test1</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add from 192.168.1.0/24 pref 1001 table test1</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add [from 0/0] table test1 pref 1003</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">ip rule add fwmark 1 pref 1002 table test2</span>  </span><br><span class="line">（此句型配合iptables -t mangle应用。如先对数据包作标记:</span><br><span class="line"><span class="meta">#</span><span class="bash">iptables -t mangle -A PREROUTING -p tcp -m multiport --dports 80,8080,20,21 -s 192.168.1.0/24 -j MARK --set-mark 1  ）</span></span><br></pre></td></tr></table></figure>


<h4 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h4><p><a href="https://blog.csdn.net/bytxl/article/details/9850803?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-15.control">策略路由以及使用 ip route ， ip rule ， iptables 配置策略路由实例</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>Android IPC机制</title>
    <url>/2021/01/28/Android-IPC%E6%9C%BA%E5%88%B6%E5%9F%BA%E7%A1%80(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="1-Android-IPC简介"><a href="#1-Android-IPC简介" class="headerlink" title="1. Android IPC简介"></a>1. Android IPC简介</h3><p>​    IPC是Inter-Process Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程间进行数据交换的过程。关于进程和线程的区别，在我之前发过的<a href="https://www.jianshu.com/p/683d50374775">多线程并发总结录(一) – 线程进程基础</a>中有详细叙述到。在Android程序中有一个主线程叫UI线程，只有在UI线程里面才能操作界面元素。很多时候，如果在UI线程执行很多耗时操作，严重影响了用户的体验，系统就会报出ANR异常（Application Not Responding）即应用无响应。</p>
<p>​    IPC机制不是Android独有的，任何操作系统都有响应的IPC机制，比如Windows的剪切板，管道都是进程间通信机制；Linux上可以通过命名管道，共享内存，信号量等进行进程间通信。</p>
<p>​    在Android中常用的进程间通信方式有：<strong>Bundle、文件共享、AIDL、Messager、ContentProvider和Socket。</strong></p>
<h3 id="2-IPC基础概念"><a href="#2-IPC基础概念" class="headerlink" title="2. IPC基础概念"></a>2. IPC基础概念</h3><p>IPC的基础概念包含三部分内容：Serializable接口，Parcelable接口和Binder。</p>
<p>Serializable和Parcelable接口可以完成对象的序列化过程，然后通过Intent和Binder进行传输。下面我们分别来介绍一下这三者的使用。</p>
<h4 id="2-1-Serializable序列化对象"><a href="#2-1-Serializable序列化对象" class="headerlink" title="2.1 Serializable序列化对象"></a>2.1 Serializable序列化对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Serializable实现序列化，只需要实现Serializable接口，并且定义一个serialVersionUID即可。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">123456789L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    ......  <span class="comment">//get set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化 Student对象</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">&quot;JackOu&quot;</span>, <span class="keyword">true</span>, <span class="number">18</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">out.writeObject(student);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化 Student对象</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">Student student1 = (Student) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>


<p><strong>注意：</strong>serialVersionUID为任意值都可以，但是序列化前的对象和反序列化对象的serialVersionUID必须一致，否则会报异常。因为序列化的时候，系统会把serialVersionUID写入到文件中，在反序列化的时候，会对比这个值，如果不一样，就说明这个对象被修改过，不是同一版本的，所以会报异常。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常如下，说serialVersionUID不一致了</span></span><br><span class="line">java.io.InvalidClassException: com.gacrnd.gcs.ipc.Student; local class incompatible: stream classdesc serialVersionUID = 123456789, local class serialVersionUID = 123789</span><br></pre></td></tr></table></figure>


<h4 id="2-2-Parcelable序列化对象"><a href="#2-2-Parcelable序列化对象" class="headerlink" title="2.2 Parcelable序列化对象"></a>2.2 Parcelable序列化对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义好对象的属性，实现writeToParcel、describeContents和创建Creator&lt;Person&gt;即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Person</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-Serializable和Parcelable区别"><a href="#2-3-Serializable和Parcelable区别" class="headerlink" title="2.3 Serializable和Parcelable区别"></a>2.3 Serializable和Parcelable区别</h4><p>Serializable和Parcelable都可以实现序列化，那么他们有什么区别呢。</p>
<ul>
<li><p>Serializable是Java中序列化接口，使用起来简单，但是开销比较大，序列化和反序列化过程需要大量I/O操作。</p>
</li>
<li><p>Parcelable是Android的序列化方式，主要用在内存序列化，因此效率比较高一些，但是使用比较麻烦。</p>
</li>
</ul>
<p>如果使用基于Binder实现的通信方式，一般选择Parcelable效率比较高；如果将序列化对象存储在设备中或者通过网络进行传输，选择Serializable比较方便。</p>
<h4 id="2-4-Binder通信"><a href="#2-4-Binder通信" class="headerlink" title="2.4 Binder通信"></a>2.4 Binder通信</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.gacrnd.gcs.ipc;</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.gacrnd.gcs.ipc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gacrnd.gcs.ipc.Book; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>服务端实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在service端内部创建一个IBookManager.Stub对象，在onBind()方法中返回。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IBookManager.Stub mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBookList) &#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBookList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mBookList.contains(book)) &#123;</span><br><span class="line">                mBookList.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>客户端实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IBookManager mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">		<span class="comment">// 绑定服务端</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">        bindService(intent,sconn, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection sconn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 拿到服务端代理之后就可以调用服务端的方法了</span></span><br><span class="line">            mService = IBookManager.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            mService = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Binder最简单的使用就是上面的代码，后面分析framework的时候会详细分析Binder的具体实现。</p>
<p>另外当客户端和服务端断开的希望接收到通知，我们可以实现一个DeathRecipient对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个死亡通知</span></span><br><span class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mService.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">        mService = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在连上服务端的时候，绑定死亡通知</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    mService = IBookManager.Stub.asInterface(service);</span><br><span class="line">    service.linkToDeath(mDeathRecipient,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>参考文档：</strong></p>
<p>《Android开发艺术探索》</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC机制</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android P源码编译, 第三方jar包报DateTimeException</title>
    <url>/2021/04/27/Android-P%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91-%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%E6%8A%A5DateTimeException/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>Android P源码环境下AOSP源码以及编译完成，但是引入第三方jar包之后，编译报“ Invalid value for MonthOfYear (valid values 1 - 12): 0 ” 错误。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-77ce144031aab4bb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常信息.jpg"></p>
<h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>第三方提供的jar包编译环境与系统不一致。详见<a href="https://stackoverflow.com/questions/46508081/jarsigner-error-java-time-datetimeexception-invalid-value-for-monthofyear-val">1.统一编译环境</a></p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>确认如下环境是否一致：</p>
<ul>
<li>java环境：java -version</li>
<li>javac环境：javac -version</li>
</ul>
<p>环境配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载对应版本</span></span><br><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line">	</span><br><span class="line"><span class="meta">#</span><span class="bash"> 版本之间切换</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line">sudo update-alternatives --config javac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确定ubuntu版本信息</span></span><br><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>


<p>如果环境一致了还是不好使，那么<strong>必须将模块代码放入源码编译!!!!</strong></p>
<p>开始项目代码是用Android Studio开发的，打jar包也是用AS来构建的，随便怎么配置，随便怎么对环境，打出来的jar包在Android Q源码里都会报”DateTimeException”。其他版本的源码不报这个异常。</p>
<p>所以真正解决这个问题的办法只有将代码移入到Android Q源码中，写一个Android.mk脚本来编译就可以了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d7652f367013e859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功.png"></p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://stackoverflow.com/questions/46508081/jarsigner-error-java-time-datetimeexception-invalid-value-for-monthofyear-val">1.统一编译环境</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>编译第三方jar包</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio编译引用系统@hide api</title>
    <url>/2021/06/01/Android-Studio%E7%BC%96%E8%AF%91%E5%BC%95%E7%94%A8%E7%B3%BB%E7%BB%9F-hide-api/</url>
    <content><![CDATA[<h4 id="1-问题叙述"><a href="#1-问题叙述" class="headerlink" title="1.问题叙述"></a>1.问题叙述</h4><p>在APP开发中，Android Studio工程无法引用framework.jar带有@hide的api，但是在framework开发中需要引用到系统的@hide接口，为了在AS中开发，需要做如下配置。</p>
<h4 id="2-配置步骤"><a href="#2-配置步骤" class="headerlink" title="2.配置步骤"></a>2.配置步骤</h4><ul>
<li>从android源码的如下目录中获取class.jar （这里的class.jar包含了系统中被标注了@hide的api）</li>
</ul>
<p>out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar</p>
<ul>
<li><p>将framework.jar拷贝到APP的工程目录的libs目录下.</p>
</li>
<li><p>配置build.gradle</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 一定要注释掉，否者会报3小节中的错误</span></span><br><span class="line">    <span class="comment">//implementation fileTree(include: [&#x27;*.jar&#x27;], dir: &#x27;libs&#x27;)</span></span><br><span class="line">    ......</span><br><span class="line">    compileOnly files(<span class="string">&#x27;libs/framework.jar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在根目录build.gradle中加入,<code>-Xbootclasspath/p:</code>后面加入framework.jar的路径</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line"></span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">        tasks.withType(JavaCompile) &#123;</span><br><span class="line">            options.compilerArgs &lt;&lt; <span class="string">&#x27;-Xbootclasspath/p:app/libs/framework.jar&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后编译工程。系统hide API在AS中一样是红色的，但是可以正常编译通过运行。</li>
</ul>
<h4 id="3-编译报错"><a href="#3-编译报错" class="headerlink" title="3.编译报错"></a>3.编译报错</h4><p>引入的framework.jar只能用compileOnly，不能用implement，否则会报如下错误，注释掉implementation也是这个原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.ArrayIndexOutOfBoundsException: 65535</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>Android权限管理</title>
    <url>/2021/05/31/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-定义配置文件字段意义"><a href="#1-定义配置文件字段意义" class="headerlink" title="1.定义配置文件字段意义"></a>1.定义配置文件字段意义</h4><ul>
<li><code>presetPaths</code>：预置应用路径</li>
<li><code>presetShops</code>：预置应用商城包名，可以配置能够安装应用的应用，例如应用商城或者浏览器等。</li>
<li><code>rules</code>：规则集合</li>
<li><code>majorType</code>： 应用主规则名单<ul>
<li>1：白名单应用</li>
<li>2：签名应用</li>
<li>3：预置应用</li>
<li>4：应用商城应用</li>
<li>5：其他应用</li>
</ul>
</li>
<li><code>priority</code> ：优先级</li>
<li><code>enable</code> ：规则生效使能键</li>
<li><code>apps</code>：主规则名单中应用的授权类型</li>
<li><code>packageNames</code>：主规则名单中应用包名</li>
<li><code>authorizationType</code>: 授权类型<ul>
<li>1：全部权限授权</li>
<li>2：部分权限授权</li>
<li>3：全部权限拒绝</li>
<li>4：错误值</li>
</ul>
</li>
<li><code>name</code> ：权限名</li>
<li><code>status</code>：权限状态<ul>
<li>1：默认授权</li>
<li>2：默认拒绝</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;presetPaths&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;/vendor/app/&quot;</span>,</span><br><span class="line">      <span class="string">&quot;/system/app/&quot;</span>,</span><br><span class="line">      <span class="string">&quot;/system/priv-app/&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;presetShops&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;cn.gaei.appstore&quot;</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">&quot;rules&quot;</span>: [&#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">1</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;apps&quot;</span>: [&#123;</span><br><span class="line">               <span class="string">&quot;packageNames&quot;</span>: [</span><br><span class="line">                   <span class="string">&quot;cn.gaei.appstore&quot;</span></span><br><span class="line">               ],</span><br><span class="line">               <span class="string">&quot;authorizationType&quot;</span>: <span class="number">1</span></span><br><span class="line">           &#125;]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">3</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">900</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;authorizationType&quot;</span>: <span class="number">1</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">4</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">800</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;authorizationType&quot;</span>: <span class="number">1</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="string">&quot;majorType&quot;</span>: <span class="number">5</span>,</span><br><span class="line">           <span class="string">&quot;priority&quot;</span>: <span class="number">600</span>,</span><br><span class="line">           <span class="string">&quot;enable&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line">           <span class="string">&quot;authorizationType&quot;</span>: <span class="number">2</span>,</span><br><span class="line">           <span class="string">&quot;permissions&quot;</span>: [&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>: <span class="string">&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;</span>,</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="number">2</span></span><br><span class="line">           &#125;]</span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础回顾--字符串操作</title>
    <url>/2021/05/09/C%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="1-字符串定义"><a href="#1-字符串定义" class="headerlink" title="1.字符串定义"></a>1.字符串定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义字符串</span></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;JACKOU&quot;</span>;</span><br><span class="line"><span class="comment">// 注意这样定义字符串最后一定需要加&#x27;\0&#x27;，否者系统会默认加入系统字符。</span></span><br><span class="line"><span class="comment">// 不加&#x27;\0&#x27;如下字符串长度为9，加了为6</span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = &#123;<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-计算字符串长度"><a href="#2-计算字符串长度" class="headerlink" title="2.计算字符串长度"></a>2.计算字符串长度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这种写法相当于: *string != &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (*<span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="built_in">string</span>++;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二不能用作参数传递</span></span><br><span class="line"><span class="keyword">int</span> intArr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(intArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明，第二种方式不是完美的，有毛病，C/C++编译器，数组作为参数传递的时候，会把数组优化成指针</span></span><br><span class="line"><span class="comment">// 此时的len结果为：1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLen</span><span class="params">(<span class="keyword">int</span> intArr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(intArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三 #include&lt;string.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>


<h4 id="3-字符串转换"><a href="#3-字符串转换" class="headerlink" title="3.字符串转换"></a>3.字符串转换</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串转int</span></span><br><span class="line">atoi(num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转double</span></span><br><span class="line">atof();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转long</span></span><br><span class="line">atol();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转long long</span></span><br><span class="line">atoll();</span><br></pre></td></tr></table></figure>


<h4 id="4-字符串比较"><a href="#4-字符串比较" class="headerlink" title="4.字符串比较"></a>4.字符串比较</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;jackou1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="string">&quot;jackou&quot;</span>;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">strcmp</span>(str1, str2);</span><br><span class="line"><span class="comment">// strcmp相等返回0   strcmp区分大小写</span></span><br><span class="line"><span class="comment">// strcmpi 不区分大小写</span></span><br></pre></td></tr></table></figure>


<h4 id="5-字符串查找"><a href="#5-字符串查找" class="headerlink" title="5. 字符串查找"></a>5. 字符串查找</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;jackou1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="string">&quot;k&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">strstr</span>(str1,str2);</span><br><span class="line"><span class="comment">// 返回结果:kou1</span></span><br><span class="line"><span class="comment">// str是源字符串，str2是目标字符串，返回从目标字符串开支的以后字符串</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subString</span><span class="params">(<span class="keyword">char</span> *result, <span class="keyword">char</span> *str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        *(result++) = *(str + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6.结构体"></a>6.结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Study</span> <span class="title">study</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Wan</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *content;</span><br><span class="line">    &#125; wan;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">dog</span>;</span></span><br><span class="line">    <span class="comment">// 不赋值为系统值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dog: name=%s, age=%d, sex=%d \n&quot;</span>, dog.name, dog.age, dog.sex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-结构体指针"><a href="#7-结构体指针" class="headerlink" title="7.结构体指针"></a>7.结构体指针</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Cat &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct Cat cat &#x3D; &#123;&quot;cat&quot;, 5&#125;;</span><br><span class="line">    struct Cat *catP &#x3D; &amp;cat;</span><br><span class="line">    printf(&quot;name&#x3D;%s,age&#x3D;%d \n&quot;, catP-&gt;name, catP-&gt;age);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-正确的方法结果接收写法"><a href="#8-正确的方法结果接收写法" class="headerlink" title="8.正确的方法结果接收写法"></a>8.正确的方法结果接收写法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *result = <span class="string">&quot;abc&quot;</span>; <span class="comment">//赋过值的指针不能用于接收结果，因为result已经指向静态常量区的“abc”了</span></span><br><span class="line">    <span class="keyword">char</span> *result1 = <span class="literal">NULL</span>; <span class="comment">//原因同上，已经指向NULL了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *result2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    action(result2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> result3[<span class="number">100</span>] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 不会报错因为数组元素是在栈区分配空间</span></span><br><span class="line">    action(result3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="9-typedef"><a href="#9-typedef" class="headerlink" title="9. typedef"></a>9. typedef</h4><p>为了兼容方法内部的内容不做改变，使用typedef来定义结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Person;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C基础</tag>
        <tag>字符串操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础回顾--指针相关知识点</title>
    <url>/2021/05/09/C%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E6%8C%87%E9%92%88%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="1-lt-gt-和“”引用区别"><a href="#1-lt-gt-和“”引用区别" class="headerlink" title="1. &lt;&gt;和“”引用区别"></a>1. &lt;&gt;和“”引用区别</h4><ul>
<li>#include &lt;&gt; 主要用于对标准库的引用</li>
<li>#include “”  主要用于对自定义本地库的引用</li>
</ul>
<h4 id="2-指针函数"><a href="#2-指针函数" class="headerlink" title="2. 指针函数"></a>2. 指针函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result : %d \n&quot;</span>, i + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>(*p)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    p(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// p被明确声明为函数指针，可以省略*</span></span><br><span class="line">    (p)(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// p被明确声明为函数指针，可以省略*</span></span><br><span class="line">    (*p)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(add);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-文档查看"><a href="#3-文档查看" class="headerlink" title="3.文档查看"></a>3.文档查看</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看文档方法中有 &amp;xxxx 可以尝试传NULL试试</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span>) time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;rand num: %d \n&quot;</span>, + rand() / <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-静态内存和动态内存"><a href="#4-静态内存和动态内存" class="headerlink" title="4. 静态内存和动态内存"></a>4. 静态内存和动态内存</h4><blockquote>
<p>静态内存(栈内开辟内存)和动态内存开僻(使用malloc开辟内存)。</p>
</blockquote>
<h5 id="4-1-栈上分配内存"><a href="#4-1-栈上分配内存" class="headerlink" title="4.1 栈上分配内存"></a>4.1 栈上分配内存</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用执行会入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">staticMem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>]; <span class="comment">//在栈空间分配20字节内存</span></span><br><span class="line">&#125; <span class="comment">// 执行完毕会出栈</span></span><br><span class="line"><span class="comment">// 每次开辟/释放20字节</span></span><br></pre></td></tr></table></figure>


<h5 id="4-2-堆上分配内存"><a href="#4-2-堆上分配内存" class="headerlink" title="4.2 堆上分配内存"></a>4.2 堆上分配内存</h5><ul>
<li>野指针：没有指向的指针。指针不使用了需要指向NULL。</li>
<li>悬空指针：当堆内存释放之后，指针指向的地址还在，这就形成了悬空指针。当堆内存空间被释放之后，需要将指针指向NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicMem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int *p; // 野指针</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">// 规范写法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>);   <span class="comment">// 1M</span></span><br><span class="line">    <span class="comment">// &amp;arr取栈上地址, arr堆上的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack addr: %p , deap addr: %p \n&quot;</span>, &amp;arr, arr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr); <span class="comment">//如果不释放，内存地址会一直添加</span></span><br><span class="line">    arr = <span class="literal">NULL</span>;  <span class="comment">// 如果不指向NULL，会出现 “悬空指针”</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack addr: %p , deap addr: %p \n&quot;</span>, &amp;arr, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        dynamicMem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-堆上空间分配使用场景"><a href="#5-堆上空间分配使用场景" class="headerlink" title="5.堆上空间分配使用场景"></a>5.堆上空间分配使用场景</h4><h5 id="5-1-开辟可变空间-malloc"><a href="#5-1-开辟可变空间-malloc" class="headerlink" title="5.1 开辟可变空间(malloc)"></a>5.1 开辟可变空间(malloc)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please insert the count of the number: \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> insert_num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please insert No.%d :&quot;</span>, (i + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;insert_num);</span><br><span class="line">        arr[i] = insert_num;</span><br><span class="line">        <span class="comment">// *(arr + i) == arr[i]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;your number is: %d , the addr: %p\n&quot;</span>, *(arr + i), arr + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr) &#123;</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-2-在原来分配的基础上继续再分配"><a href="#5-2-在原来分配的基础上继续再分配" class="headerlink" title="5.2 在原来分配的基础上继续再分配"></a>5.2 在原来分配的基础上继续再分配</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please insert the count of the number: \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> insert_num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please insert No.%d :&quot;</span>, (i + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;insert_num);</span><br><span class="line">        arr[i] = insert_num;</span><br><span class="line">        <span class="comment">// *(arr + i) == arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;your number is: %d , the addr: %p\n&quot;</span>, *(arr + i), arr + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在原基础上新增加空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please insert the count of the new memory: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> newMem;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;newMem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// realloc第一个参数传入指针是为了防止分配内存不够时，系统会重新开辟一个连续的空间，然后把以前地址(arr)的数据拷贝过来。</span></span><br><span class="line">    <span class="keyword">int</span> *newArr = (<span class="keyword">int</span> *) <span class="built_in">realloc</span>(arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (num + newMem));</span><br><span class="line">    <span class="keyword">if</span> (newArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &lt; num + newMem; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> insert_num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;please insert No.%d :&quot;</span>, (i + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;insert_num);</span><br><span class="line">            newArr[i] = insert_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num + newMem; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;your number is: %d , the addr: %p\n&quot;</span>, *(newArr + i), newArr + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newArr) &#123;</span><br><span class="line">        <span class="comment">// 开辟成功了释放新内存空间，包含了旧地址空间</span></span><br><span class="line">        <span class="built_in">free</span>(newArr);</span><br><span class="line">        newArr = <span class="literal">NULL</span>;</span><br><span class="line">        arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没成功释放旧内存即可</span></span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C基础</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Dumpsys命令详细说明</title>
    <url>/2021/08/14/Dumpsys%E5%91%BD%E4%BB%A4%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h4 id="1-指令与说明"><a href="#1-指令与说明" class="headerlink" title="1.指令与说明"></a>1.指令与说明</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印出当前系统所有service信息，在后面可加上具体的服务名</span></span><br><span class="line">adb shell dumpsys [system services]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印显示系统信息</span></span><br><span class="line">adb shell dumpsys display</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取设备电池信息</span></span><br><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取cpu信息</span></span><br><span class="line">adb shell dumpsys cpuinfo	</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取内存信息</span></span><br><span class="line">adb shell dumpsys meminfo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要获取具体应用的内存信息，可加上包名</span></span><br><span class="line">adb shell dumpsys meminfo PACKAGE_NAME</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取Activity信息</span></span><br><span class="line">adb shell dumpsys activity</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上-h可以获取帮助信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取当前界面的UI信息，可以用：</span></span><br><span class="line">adb shell dumpsys activity top</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要获取当前界面的Activity：</span></span><br><span class="line">adb shell dumpsys activity top | findstr ACTIVITY</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取package信息</span></span><br><span class="line">adb shell dumpsys package</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上-h可以获取帮助信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某个包的信息：</span></span><br><span class="line">adb shell dumpsys package PACKAGE_NAME</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取通知信息</span></span><br><span class="line">adb shell dumpsys notification</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取wifi信息</span></span><br><span class="line">adb shell dumpsys wifi</span><br><span class="line"><span class="meta">#</span><span class="bash">　可以获取到当前连接的wifi名、搜索到的wifi列表、wifi强度等</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取电源管理信息</span></span><br><span class="line">adb shell dumpsys power</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以获取到是否处于锁屏状态：mWakefulness=Asleep或者mScreenOn=<span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 亮度值：mScreenBrightness=255</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 屏幕休眠时间：Screen off timeout: 60000 ms</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 屏幕分辨率：mDisplayWidth=1920，mDisplayHeight=1080</span></span><br></pre></td></tr></table></figure>


<h4 id="2-常用的命令行参数"><a href="#2-常用的命令行参数" class="headerlink" title="2.常用的命令行参数"></a>2.常用的命令行参数</h4><blockquote>
<p>不同的服务有不同的选项，一下两个是常见的参数：</p>
<p>-h：对于大多数的服务，可以添加-h看到文本的帮助</p>
<p>-c：对于一些服务，可以添加-c查看数据会更友好</p>
</blockquote>
<h4 id="3-包信息查询"><a href="#3-包信息查询" class="headerlink" title="3.包信息查询"></a>3.包信息查询</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys package [-h] [-f] [--checkin] [cmd]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-h</td>
<td>打印帮助信息</td>
</tr>
<tr>
<td>-f</td>
<td>打印intent filter的信息</td>
</tr>
<tr>
<td>–checkin</td>
<td>打印出已经登记的库、系统功能、安装包</td>
</tr>
<tr>
<td>cmd</td>
<td>子命令（可以在-h帮助文档中查看有哪些子命令）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>cmd子命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>prov[iders]</td>
<td>获取content providers</td>
</tr>
<tr>
<td>p[ackages]</td>
<td>获取安装包基本信息</td>
</tr>
<tr>
<td>s[hared-user]</td>
<td>获取共享用户ID的应用</td>
</tr>
<tr>
<td>m[essages]</td>
<td>打印运行时收集的信息</td>
</tr>
<tr>
<td>v[erifiers]</td>
<td>打印包校验信息</td>
</tr>
<tr>
<td>version</td>
<td>打印数据库版本信息</td>
</tr>
<tr>
<td>write</td>
<td>写当前位置</td>
</tr>
<tr>
<td>&lt;package.name&gt;</td>
<td>输出给定包的信息</td>
</tr>
<tr>
<td>installs</td>
<td>安装会话的详细信息</td>
</tr>
<tr>
<td>l[ibraries]</td>
<td>列出已知的共享库</td>
</tr>
<tr>
<td>f[ibraries]</td>
<td>列出手机的功能</td>
</tr>
<tr>
<td>k[eysets]</td>
<td>列出各个包的Signing KeySets</td>
</tr>
<tr>
<td>r[esolvers]</td>
<td>获取intent filter</td>
</tr>
<tr>
<td>perm[issions]</td>
<td>获取权限</td>
</tr>
<tr>
<td>pref[erred]</td>
<td>打印包首选项</td>
</tr>
<tr>
<td>preferred-xml [—full]</td>
<td>打印包首选项，xml格式打印</td>
</tr>
</tbody></table>
<h4 id="4-Activity信息查询"><a href="#4-Activity信息查询" class="headerlink" title="4.Activity信息查询"></a>4.Activity信息查询</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity [-a] [-c]…</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>包括所有可用的服务器状态</td>
</tr>
<tr>
<td>-c</td>
<td>包括客户端状态</td>
</tr>
<tr>
<td>-p</td>
<td>限制输出为给定的包，例如： adb shell dumpsys activity -p com.android.browser</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助信息</td>
</tr>
<tr>
<td>cmd</td>
<td>子命令</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>cmd子命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a[ctivities]</td>
<td>activity堆栈状态</td>
</tr>
<tr>
<td>r[recents]</td>
<td>最近activity的状态</td>
</tr>
<tr>
<td>b[rodacasts] [package_name] [histpry [-s]]</td>
<td>广播状态</td>
</tr>
<tr>
<td>i[ntents] [package_name]</td>
<td>挂起的intent状态</td>
</tr>
<tr>
<td>p[rocesses] [package_name]</td>
<td>进程状态</td>
</tr>
<tr>
<td>o[om]</td>
<td>oom管理</td>
</tr>
<tr>
<td>perm[issions]</td>
<td>url权限授权状态</td>
</tr>
<tr>
<td>prov[iders] [comp_spec…]</td>
<td>content provider状态</td>
</tr>
<tr>
<td>provider [comp_spec]</td>
<td>provider客户端状态</td>
</tr>
<tr>
<td>s[ervices] [comp_spec…]</td>
<td>服务状态</td>
</tr>
<tr>
<td>as[sociations]</td>
<td>跟踪应用程序的关联</td>
</tr>
<tr>
<td>service [comp_spec]</td>
<td>服务客户端状态</td>
</tr>
<tr>
<td>package [package_name]</td>
<td>给的包的所有状态</td>
</tr>
<tr>
<td>all</td>
<td>转储所有的activityes</td>
</tr>
<tr>
<td>top</td>
<td>转储栈顶的activity</td>
</tr>
<tr>
<td>write</td>
<td>写入所有挂起状态存储</td>
</tr>
<tr>
<td>track-associations</td>
<td>允许会话跟踪</td>
</tr>
<tr>
<td>untrack-associations</td>
<td>禁用和明确会话跟踪，命令参数可能也是一个comp_spec 转储的activity</td>
</tr>
</tbody></table>
<h4 id="5-网络信息查询"><a href="#5-网络信息查询" class="headerlink" title="5.网络信息查询"></a>5.网络信息查询</h4><table>
<thead>
<tr>
<th>子命令</th>
<th>说明</th>
<th>命令格式</th>
</tr>
</thead>
<tbody><tr>
<td>connectivity</td>
<td>网络连接</td>
<td>adb shell dumpsys connectivity</td>
</tr>
<tr>
<td>netpolicy</td>
<td>网络策略</td>
<td>adb shell dumpsys netpolicy</td>
</tr>
<tr>
<td>netstats</td>
<td>网络状态</td>
<td>adb shell dumpsys netstats</td>
</tr>
<tr>
<td>network_management</td>
<td>网络管理</td>
<td>adb shell dumpsys network_management</td>
</tr>
</tbody></table>
<h4 id="6-其他服务信息查询"><a href="#6-其他服务信息查询" class="headerlink" title="6.其他服务信息查询"></a>6.其他服务信息查询</h4><table>
<thead>
<tr>
<th>子命令</th>
<th>说明</th>
<th>命令格式</th>
</tr>
</thead>
<tbody><tr>
<td>meminfo</td>
<td>内存</td>
<td>adn shell dumpsys meminfo</td>
</tr>
<tr>
<td>cpuinfo</td>
<td>CPU</td>
<td>adn shell dumpsys cpuinfo</td>
</tr>
<tr>
<td>gfxinfo</td>
<td>帧率</td>
<td>adn shell dumpsys gfxinfo</td>
</tr>
<tr>
<td>display</td>
<td>显示</td>
<td>adn shell dumpsys display</td>
</tr>
<tr>
<td>power</td>
<td>电源</td>
<td>adn shell dumpsys power</td>
</tr>
<tr>
<td>batterystats</td>
<td>电池状态</td>
<td>adn shell dumpsys batterystats</td>
</tr>
<tr>
<td>battery</td>
<td>电池</td>
<td>adn shell dumpsys battery</td>
</tr>
<tr>
<td>alarm</td>
<td>闹钟</td>
<td>adn shell dumpsys alarm</td>
</tr>
<tr>
<td>location</td>
<td>位置</td>
<td>adn shell dumpsys location</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>dumpsys</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide内存管理</title>
    <url>/2021/05/14/Glide%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>Glide框架的核心内容主要包含生命周期自动管理和内存管理，生命周期管理在《<a href="https://www.jianshu.com/p/f42a2c00c9d1">Glide源码分析-生命周期管理</a>》有详细叙述到，本篇主要叙述Glide框架的内存管理。</p>
<h3 id="2-内存管理总体框架"><a href="#2-内存管理总体框架" class="headerlink" title="2.内存管理总体框架"></a>2.内存管理总体框架</h3><p>Glide内存管理分为如下图中五种情况，下面我们一一来分析这五种情况资源是如何在内存中移动的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4b8adbac673e1e55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide内存管理.png"></p>
<h4 id="2-1-资源在活动内存中"><a href="#2-1-资源在活动内存中" class="headerlink" title="2.1 资源在活动内存中"></a>2.1 资源在活动内存中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveResources</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isActiveResourceRetentionAllowed;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor monitorClearedResourcesExecutor;</span><br><span class="line">  <span class="comment">// 保存正在显示资源的弱已用</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span> <span class="keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一种情况是资源仅在活动内存中。</strong>Map&lt;Key, ResourceWeakReference&gt;就是我们所讲的活动内存，此内存保存界面正在加载的资源，当资源仅存在活动内存的时候，Glide会直接加载资源到控件中。</p>
<h4 id="2-2-资源在内存缓存中"><a href="#2-2-资源在内存缓存中" class="headerlink" title="2.2 资源在内存缓存中"></a>2.2 资源在内存缓存中</h4><p><strong>第二种情况是资源不在活动内存中，在内存缓存中。</strong>从图中可以看出，这种情况资源会从内存缓存中删除(<strong>删除后如虚线圈所示</strong>)，然后被挪到活动缓存中，Glide从活动缓存中加载资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">// 从内存缓存中获取资源</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cached.acquire();</span><br><span class="line">      <span class="comment">// 保存到活动缓存中</span></span><br><span class="line">      activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//取资源</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">    <span class="comment">// cache是内存缓存，首先从内存缓存中取出元素，并且删除内存缓存中元素</span></span><br><span class="line">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">      <span class="comment">// Save an object allocation if we&#x27;ve cached an EngineResource (the typical case).</span></span><br><span class="line">      result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result =</span><br><span class="line">          <span class="keyword">new</span> EngineResource&lt;&gt;(</span><br><span class="line">              cached, <span class="comment">/*isMemoryCacheable=*/</span> <span class="keyword">true</span>, <span class="comment">/*isRecyclable=*/</span> <span class="keyword">true</span>, key, <span class="comment">/*listener=*/</span> <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存资源</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    ResourceWeakReference toPut =</span><br><span class="line">        <span class="keyword">new</span> ResourceWeakReference(</span><br><span class="line">            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存资源到活动缓存中</span></span><br><span class="line">    ResourceWeakReference removed = activeEngineResources.put(key, toPut);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-资源在用户申明的Glide磁盘中"><a href="#2-3-资源在用户申明的Glide磁盘中" class="headerlink" title="2.3 资源在用户申明的Glide磁盘中"></a>2.3 资源在用户申明的Glide磁盘中</h4><p><strong>第三种情况是活动缓存和内存缓存都没有资源，资源保存在用户申明的磁盘缓存中。</strong>这种情况Glide会尝试从本地磁盘缓存中获取，如果获取到了<strong>复制</strong>资源(**实线圈)**到活动缓存中显示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 获取key</span></span><br><span class="line">    EngineKey key =</span><br><span class="line">        keyFactory.buildKey(</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            transformations,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            options);</span><br><span class="line"></span><br><span class="line">    EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line">	  </span><br><span class="line">      <span class="comment">// 内存缓存中没有资源</span></span><br><span class="line">      <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            options,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            cb,</span><br><span class="line">            callbackExecutor,</span><br><span class="line">            key,</span><br><span class="line">            startTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Avoid calling back while holding the engine lock, doing so makes it easier for callers to</span></span><br><span class="line">    <span class="comment">// deadlock.</span></span><br><span class="line">    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>具体如何从磁盘缓存中获取资源流程可以参考《<a href="https://www.jianshu.com/p/cfcca86587e4">Glide源码分析</a>—4.2 从不同缓存中搜寻资源》 </p>
<h4 id="2-4-资源在云端"><a href="#2-4-资源在云端" class="headerlink" title="2.4 资源在云端"></a>2.4 资源在云端</h4><p><strong>第四种情况本地没有资源，资源在云端。</strong>这种情况Glide会首先搜寻活动缓存，然后搜寻内存缓存，再搜寻本地磁盘缓存。如果以上三者都搜不到，那就启动httpurlconnection从网络上加载资源。当资源下载好之后将资源保存在磁盘缓存中，并且将资源复制到活动缓存中，供界面显示。</p>
<h4 id="2-5-资源回收"><a href="#2-5-资源回收" class="headerlink" title="2.5 资源回收"></a>2.5 资源回收</h4><p>当空白Fragment感知到界面被销毁，onDestory()方法被调用之后，Glide最终会调用活动缓存中的onResourceReleased方法，此方法中资源会从活动缓存中回收，然后被保存到内存缓存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从活动缓存中删除</span></span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      <span class="comment">// 保存到内存缓存中</span></span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deactivate</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    ResourceWeakReference removed = activeEngineResources.remove(key);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="keyword">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-在运行时缓存中为什么会做成两级缓存，意义何在"><a href="#3-在运行时缓存中为什么会做成两级缓存，意义何在" class="headerlink" title="3.在运行时缓存中为什么会做成两级缓存，意义何在"></a>3.在运行时缓存中为什么会做成两级缓存，意义何在</h3><h4 id="3-1-只有LRU内存缓存，没有活动缓存"><a href="#3-1-只有LRU内存缓存，没有活动缓存" class="headerlink" title="3.1 只有LRU内存缓存，没有活动缓存"></a>3.1 只有LRU内存缓存，没有活动缓存</h4><p>LRU内存缓存有个特性，就是当LRU缓存装满的时候，如果还有资源需要存储，缓存会将最近最少使用的资源删除，然后保存新添加的资源。</p>
<p>如果只有LRU内存缓存的话，会出现一个BUG，接入我设置LRU内存缓存大小为5，如果RecycleView需要加载的资源为5张图片了，缓慢滚动屏幕，有一张图片出现，需要新加入到LRU中，那最先放入LRU中的那种图片就会被销毁，然而那种图片还有一部分正在显示。这样就会引起崩溃。</p>
<p>所以鉴于此BUG，活动内存就应运而生，活动内存是一个map集合，随便存多少，因此为了清晰管理内存。活动内存专门存放当前界面显示的资源，LRU缓存负责缓存暂时不在显示的资源。</p>
<h4 id="3-2-只有活动缓存，没有LRU内存缓存"><a href="#3-2-只有活动缓存，没有LRU内存缓存" class="headerlink" title="3.2 只有活动缓存，没有LRU内存缓存"></a>3.2 只有活动缓存，没有LRU内存缓存</h4><p>只有活动缓存(Map)不是不行，只是如果存储和删除都在一个map集合中，管理起来比较混乱，而且在操作map的时候一定要采用同步，扩大了同步操作范围，降低效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReleased</span><span class="params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同步释放资源</span></span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      <span class="comment">// 此处没有同步了，如果用一个集合的话，需要将此map也放在同步块中操作。</span></span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, <span class="comment">/*forceNextFrame=*/</span> <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>-Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>HIDL demo实现详细步骤</title>
    <url>/2021/03/19/HIDL-demo%E5%AE%9E%E7%8E%B0%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h3><p>首先将AOSP的源码编译一下，<a href="https://www.jianshu.com/p/eff1e738befe">编译步骤详见传送门</a></p>
<p>编译完成之后，查看：源码根目录/out/host/linux-x86/bin中是否有<strong>hidl-gen</strong>工具。</p>
<ul>
<li><p>如果有就可以直接配置环境变量</p>
</li>
<li><p>如果没有使用(在根目录)：make hidl-gen 生成hidl-gen工具</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-05b5ac1e03508121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成hidl-gen工具.png"></p>
<p>配置环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jackou@ubuntu:~$ vim .bashrc </span><br></pre></td></tr></table></figure>
<p>在末尾添加</p>
<blockquote>
<p>export PATH=$PATH:/home/jackou/work_directory/out/host/linux-x86/bin/</p>
</blockquote>
<h3 id="2-新建HIDL模块"><a href="#2-新建HIDL模块" class="headerlink" title="2.新建HIDL模块"></a>2.新建HIDL模块</h3><h4 id="2-1-新建hal接口文件"><a href="#2-1-新建hal接口文件" class="headerlink" title="2.1 新建hal接口文件"></a>2.1 新建hal接口文件</h4><p>在hardware/interfaces目录新建存放接口的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p hidltest/1.0</span><br></pre></td></tr></table></figure>
<p>创建hal文件，名为IHidlTest.hal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.hardware.hidltest@<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IHidlTest</span> </span>&#123;</span><br><span class="line">    helloWorld(string name) generates (string result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-生成-h和-cpp文件"><a href="#2-2-生成-h和-cpp文件" class="headerlink" title="2.2 生成.h和.cpp文件"></a>2.2 生成.h和.cpp文件</h4><p>在根目录下利用hidl-gen生成对应的服务端代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PACKAGE=android.hardware.hidltest@1.0</span><br><span class="line">LOC=hardware/interfaces/hidltest/1.0/default/</span><br><span class="line">hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE</span><br><span class="line">hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE</span><br></pre></td></tr></table></figure>
<img src="/2021/03/19/HIDL-demo%E5%AE%9E%E7%8E%B0%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/blog\source\_posts\HIDL-demo实现详细步骤\生成bp文件.png" alt="生成bp文件" style="zoom:75%;">



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动生成的HidlTest.h头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_HARDWARE_HIDLTEST_V1_0_HIDLTEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_HARDWARE_HIDLTEST_V1_0_HIDLTEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/hidltest/1.0/IHidlTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/MQDescriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/Status.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> hardware &#123;</span><br><span class="line"><span class="keyword">namespace</span> hidltest &#123;</span><br><span class="line"><span class="keyword">namespace</span> V1_0 &#123;</span><br><span class="line"><span class="keyword">namespace</span> implementation &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_array;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_memory;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_string;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_vec;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Return;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Void;</span><br><span class="line"><span class="keyword">using</span> ::android::sp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HidlTest</span> :</span> <span class="keyword">public</span> IHidlTest &#123;</span><br><span class="line">    <span class="comment">// Methods from ::android::hardware::hidltest::V1_0::IHidlTest follow.</span></span><br><span class="line">    <span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> most likely delete, this is only for passthrough implementations</span></span><br><span class="line"><span class="comment">// 如果使用直通模式，一定把下面语句注释删掉</span></span><br><span class="line"><span class="comment">// 此软件包经过 dlopen 处理，且实现使用 HIDL_FETCH_IHidlTest 进行了实例化。</span></span><br><span class="line"><span class="comment">// 参考说明：https://source.android.com/devices/architecture/hidl</span></span><br><span class="line"> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">IHidlTest* <span class="title">HIDL_FETCH_IHidlTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace implementation</span></span><br><span class="line">&#125;  <span class="comment">// namespace V1_0</span></span><br><span class="line">&#125;  <span class="comment">// namespace hidltest</span></span><br><span class="line">&#125;  <span class="comment">// namespace hardware</span></span><br><span class="line">&#125;  <span class="comment">// namespace android</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// ANDROID_HARDWARE_HIDLTEST_V1_0_HIDLTEST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动生成的c++实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HidlTest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> hardware &#123;</span><br><span class="line"><span class="keyword">namespace</span> hidltest &#123;</span><br><span class="line"><span class="keyword">namespace</span> V1_0 &#123;</span><br><span class="line"><span class="keyword">namespace</span> implementation &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::android::hardware::hidltest::V1_0::IHidlTest follow.</span></span><br><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">HidlTest::helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO implement</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ::<span class="built_in">snprintf</span>(buf,<span class="number">100</span>,<span class="string">&quot;hello world, %s&quot;</span>,name.c_str());</span><br><span class="line">    <span class="function">hidl_string <span class="title">result</span><span class="params">(buf)</span></span>;</span><br><span class="line">    _hidl_cb(result);</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span></span><br><span class="line"><span class="function">IHidlTest* <span class="title">HIDL_FETCH_IHidlTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HidlTest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;  <span class="comment">// namespace implementation</span></span><br><span class="line">&#125;  <span class="comment">// namespace V1_0</span></span><br><span class="line">&#125;  <span class="comment">// namespace hidltest</span></span><br><span class="line">&#125;  <span class="comment">// namespace hardware</span></span><br><span class="line">&#125;  <span class="comment">// namespace android</span></span><br></pre></td></tr></table></figure>


<h4 id="2-3-更新bp文件"><a href="#2-3-更新bp文件" class="headerlink" title="2.3 更新bp文件"></a>2.3 更新bp文件</h4><p>使用一下脚本更新bp文件，不知道为什么，我使用的Android P代码，lunch 10产品，使用一下脚本始终不能像博友生成Android.mk文件，只生成了Andorid.bp文件。不过没关系，不影响编译，bp文件也是可以编译的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;hardware&#x2F;interfaces&#x2F;update-makefiles.sh</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6f2f45a84eb8d14f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="更新makefile文件.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d4f20b0291860191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用脚本更新bp文件.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// Android.bp文件</span><br><span class="line">// This file is autogenerated by hidl-gen -Landroidbp.</span><br><span class="line"></span><br><span class="line">hidl_interface &#123;</span><br><span class="line">    name: &quot;android.hardware.hidltest@1.0&quot;,</span><br><span class="line">    root: &quot;android.hardware&quot;,</span><br><span class="line">    vndk: &#123;</span><br><span class="line">        enabled: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;IHidlTest.hal&quot;,</span><br><span class="line">    ],</span><br><span class="line">    interfaces: [</span><br><span class="line">        &quot;android.hidl.base@1.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">    gen_java: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标签说明：</strong></p>
<ul>
<li>name 需要与package name 相同，编译的时候会根据需要生成对应的so 或jar</li>
<li>root 即为与hidl 对应的root name</li>
<li>interfaces 为编译过程中依赖的接口名称，如c 中的shared library</li>
<li>types 为模块中所需要的自定义类型</li>
<li>如果有需要的java 代码可以将 gen_java  设为 true，如果没有（例如passthrough 模式）需要将这里设为false。不过一般通过update_makefiles.sh 就可以自动生成。详细看<a href="https://blog.csdn.net/shift_wwx/article/details/86525079">Android HIDL 中 hidl-gen使用</a></li>
</ul>
<p>配置完成之后，编译会在**~/work_directory/out/soong/.intermediates/hardware/interfaces/hidltest/1.0**生成如下文件：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f71fb8d6f8e195fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根目录Android.bp生成文件说明.png"></p>
<ul>
<li><p><a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#100;&#x2e;&#104;&#x61;&#114;&#x64;&#119;&#x61;&#114;&#x65;&#x2e;&#104;&#105;&#100;&#x6c;&#x74;&#101;&#x73;&#x74;&#64;&#49;&#46;&#x30;">&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#100;&#x2e;&#104;&#x61;&#114;&#x64;&#119;&#x61;&#114;&#x65;&#x2e;&#104;&#105;&#100;&#x6c;&#x74;&#101;&#x73;&#x74;&#64;&#49;&#46;&#x30;</a> 就是模块对应的库文件；</p>
</li>
<li><p><a href="mailto:&#97;&#x6e;&#x64;&#x72;&#x6f;&#105;&#x64;&#x2e;&#x68;&#97;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#104;&#105;&#x64;&#108;&#116;&#x65;&#115;&#x74;&#64;&#49;&#46;&#x30;&#95;&#x67;&#101;&#x6e;&#99;">&#97;&#x6e;&#x64;&#x72;&#x6f;&#105;&#x64;&#x2e;&#x68;&#97;&#114;&#100;&#119;&#x61;&#114;&#101;&#x2e;&#104;&#105;&#x64;&#108;&#116;&#x65;&#115;&#x74;&#64;&#49;&#46;&#x30;&#95;&#x67;&#101;&#x6e;&#99;</a>++ 为生成对应的C++临时文件，在使用的时候都是链接到这里；</p>
</li>
<li><p><a href="mailto:&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#x77;&#97;&#x72;&#101;&#46;&#x68;&#x69;&#x64;&#x6c;&#x74;&#101;&#x73;&#116;&#64;&#x31;&#46;&#x30;&#x5f;&#103;&#x65;&#110;&#99;">&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#x77;&#97;&#x72;&#101;&#46;&#x68;&#x69;&#x64;&#x6c;&#x74;&#101;&#x73;&#116;&#64;&#x31;&#46;&#x30;&#x5f;&#103;&#x65;&#110;&#99;</a>++_headers 为生成的C++ 所需的头文件；</p>
</li>
<li><p>android.hardware.hidltest-V1.0-java 为java 代码所使用的java 库文件；</p>
</li>
<li><p>android.hardware.hidltest-V1.0-java_gen_java 为java 代码所使用的java 文件</p>
</li>
</ul>
<h4 id="2-4-采取直通模式"><a href="#2-4-采取直通模式" class="headerlink" title="2.4 采取直通模式"></a>2.4 采取直通模式</h4><p>将HidlTest.h中的以下注释解开，代码如2.2小节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extern &quot;C&quot; IHidlTest* HIDL_FETCH_IHidlTest(const char* name);</span></span><br></pre></td></tr></table></figure>
<p>将HidlTest.cpp中的以下代码注解解开，代码如2.2小节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">IHidlTest* <span class="title">HIDL_FETCH_IHidlTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HidlTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-5-实现功能"><a href="#2-5-实现功能" class="headerlink" title="2.5 实现功能"></a>2.5 实现功能</h4><p>在HidlTest.cpp中实现接口的功能，代码见代码如2.2小节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">HidlTest::helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO implement</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ::<span class="built_in">snprintf</span>(buf,<span class="number">100</span>,<span class="string">&quot;hello world, %s&quot;</span>,name.c_str());</span><br><span class="line">    <span class="function">hidl_string <span class="title">result</span><span class="params">(buf)</span></span>;</span><br><span class="line">    _hidl_cb(result);</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，现在大功告成； 准备开始编译。</p>
<h4 id="2-6-编译模块"><a href="#2-6-编译模块" class="headerlink" title="2.6 编译模块"></a>2.6 编译模块</h4><p>在根目录使用以下命令编译模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmm hardware/interfaces/hidltest/1.0/default/</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f1551c396f339e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功.png"></p>
<p>具有实现的so库有了，我们开始构建binder通信服务。</p>
<h4 id="2-7-编写-97-x6e-x64-x72-111-x69-100-x2e-x68-97-114-x64-x77-97-114-101-x2e-x68-x69-100-108-x74-x65-x73-116-x40-49-46-x30-x2d-115-101-114-x76-105-x63-x65-46-x72-x63-文件"><a href="#2-7-编写-97-x6e-x64-x72-111-x69-100-x2e-x68-97-114-x64-x77-97-114-101-x2e-x68-x69-100-108-x74-x65-x73-116-x40-49-46-x30-x2d-115-101-114-x76-105-x63-x65-46-x72-x63-文件" class="headerlink" title="2.7  编写&#97;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#x68;&#x69;&#100;&#108;&#x74;&#x65;&#x73;&#116;&#x40;&#49;&#46;&#x30;&#x2d;&#115;&#101;&#114;&#x76;&#105;&#x63;&#x65;&#46;&#x72;&#x63;文件"></a>2.7  编写<a href="mailto:&#97;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#x68;&#x69;&#100;&#108;&#x74;&#x65;&#x73;&#116;&#x40;&#49;&#46;&#x30;&#x2d;&#115;&#101;&#114;&#x76;&#105;&#x63;&#x65;&#46;&#x72;&#x63;">&#97;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#114;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#x68;&#x69;&#100;&#108;&#x74;&#x65;&#x73;&#116;&#x40;&#49;&#46;&#x30;&#x2d;&#115;&#101;&#114;&#x76;&#105;&#x63;&#x65;&#46;&#x72;&#x63;</a>文件</h4><p>在default目录创建<a href="mailto:&#x61;&#x6e;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#97;&#x72;&#x65;&#x2e;&#x68;&#x69;&#x64;&#108;&#116;&#x65;&#x73;&#116;&#x40;&#x31;&#x2e;&#x30;&#45;&#x73;&#101;&#x72;&#118;&#105;&#99;&#x65;&#46;&#114;&#x63;">&#x61;&#x6e;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#x68;&#97;&#114;&#x64;&#119;&#97;&#x72;&#x65;&#x2e;&#x68;&#x69;&#x64;&#108;&#116;&#x65;&#x73;&#116;&#x40;&#x31;&#x2e;&#x30;&#45;&#x73;&#101;&#x72;&#118;&#105;&#99;&#x65;&#46;&#114;&#x63;</a>文件，作为启动文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service hidltest_hal_service /vendor/bin/hw/android.hardware.hidltest@1.0-service</span><br><span class="line">	class hal</span><br><span class="line">	user system</span><br><span class="line">	group system</span><br></pre></td></tr></table></figure>
<p>配置服务的名字为hidltest_hal_service。</p>
<h4 id="2-8-编写service文件"><a href="#2-8-编写service文件" class="headerlink" title="2.8 编写service文件"></a>2.8 编写service文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default目录下建立service.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">&quot;android.hardware.hidltest@1.0-service&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/hidltest/1.0/IHidlTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/LegacySupport.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> android::hardware::hidltest::V1_0::IHidlTest;</span><br><span class="line"><span class="keyword">using</span> android::hardware::defaultPassthroughServiceImplementation;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;start hidltest service&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;IHidlTest&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="2-9-在Android-bp中添加对服务器的编译："><a href="#2-9-在Android-bp中添加对服务器的编译：" class="headerlink" title="2.9 在Android.bp中添加对服务器的编译："></a>2.9 在Android.bp中添加对服务器的编译：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim hardware/interfaces/hidltest/1.0/default/Android.bp</span><br></pre></td></tr></table></figure>
<p>在Android.bp中添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;android.hardware.hidltest@1.0-service&quot;,</span><br><span class="line">    relative_install_path: &quot;hw&quot;,</span><br><span class="line">    proprietary: true,</span><br><span class="line">    init_rc: [&quot;android.hardware.hidltest@1.0-service.rc&quot;],</span><br><span class="line">    srcs: [&quot;service.cpp&quot;],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libcutils&quot;,</span><br><span class="line">        &quot;libdl&quot;,</span><br><span class="line">        &quot;libbase&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">        &quot;libhardware&quot;,</span><br><span class="line">        &quot;libhidlbase&quot;,</span><br><span class="line">        &quot;libhidltransport&quot;,</span><br><span class="line">        &quot;android.hardware.hidltest@1.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-10-编写manifest-xml文件"><a href="#2-10-编写manifest-xml文件" class="headerlink" title="2.10 编写manifest.xml文件"></a>2.10 编写manifest.xml文件</h4><p>为了使客户端能够调用服务端的代码需要在manifest.xml中添加服务：在device/qcom/msm8996/manifest.xml文件最后添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hal</span> <span class="attr">format</span>=<span class="string">&quot;hidl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hardware.hidltest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--由于之前采用的是直通式，所以这里也要用直通式，否则会找不到服务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transport</span>&gt;</span>passthrough<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>IHidlTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者在车机 /vendor/etc/vintf/manifest.xml中</p>
<h4 id="2-11-再次编译模块"><a href="#2-11-再次编译模块" class="headerlink" title="2.11 再次编译模块"></a>2.11 再次编译模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmm hardware/interfaces/hidltest/1.0/default/</span><br></pre></td></tr></table></figure>
<p>最后生成的文件</p>
<blockquote>
<p>out/target/product/generic_x86_64/vendor/lib64/hw/<a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#x72;&#x64;&#119;&#97;&#x72;&#101;&#46;&#104;&#105;&#x64;&#x6c;&#116;&#x65;&#x73;&#x74;&#x40;&#49;&#46;&#x30;&#45;&#x69;&#x6d;&#112;&#x6c;&#46;&#115;&#111;">&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#x72;&#x64;&#119;&#97;&#x72;&#101;&#46;&#104;&#105;&#x64;&#x6c;&#116;&#x65;&#x73;&#x74;&#x40;&#49;&#46;&#x30;&#45;&#x69;&#x6d;&#112;&#x6c;&#46;&#115;&#111;</a></p>
<p>out/target/product/generic_x86_64/vendor/bin/hw/<a href="mailto:&#97;&#110;&#100;&#x72;&#x6f;&#105;&#100;&#x2e;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#x68;&#105;&#x64;&#x6c;&#116;&#101;&#x73;&#x74;&#x40;&#49;&#46;&#x30;&#x2d;&#x73;&#101;&#x72;&#118;&#x69;&#x63;&#101;">&#97;&#110;&#100;&#x72;&#x6f;&#105;&#100;&#x2e;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#x68;&#105;&#x64;&#x6c;&#116;&#101;&#x73;&#x74;&#x40;&#49;&#46;&#x30;&#x2d;&#x73;&#101;&#x72;&#118;&#x69;&#x63;&#101;</a></p>
<p>out/target/product/generic_x86_64/system/lib64/vndk-28/<a href="mailto:&#97;&#110;&#x64;&#x72;&#111;&#x69;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#x2e;&#104;&#x69;&#100;&#108;&#x74;&#101;&#115;&#x74;&#x40;&#49;&#x2e;&#x30;&#46;&#115;&#111;">&#97;&#110;&#x64;&#x72;&#111;&#x69;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#x2e;&#104;&#x69;&#100;&#108;&#x74;&#101;&#115;&#x74;&#x40;&#49;&#x2e;&#x30;&#46;&#115;&#111;</a></p>
</blockquote>
<h4 id="2-12-编写C-客户端"><a href="#2-12-编写C-客户端" class="headerlink" title="2.12 编写C++客户端"></a>2.12 编写C++客户端</h4><p>在hardware/interfaces/hidltest/1.0/建立test目录，用于存储c++客户端代码。</p>
<p>创建HidlTestClient.cpp文件，并且编写客户端代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/hardware/hidltest/1.0/IHidlTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/Status.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/LegacySupport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/misc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/HidlSupport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_string;</span><br><span class="line"><span class="keyword">using</span> ::android::sp;</span><br><span class="line"><span class="keyword">using</span> android::hardware::hidltest::V1_0::IHidlTest;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    android::sp&lt;IHidlTest&gt; service = IHIdlTest::getService();</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to get service\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    service-&gt;helloWorld(<span class="string">&quot;HidlTest&quot;</span>, [&amp;](hidl_string result)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, result.c_str());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2-13-编写客户端编译脚本"><a href="#2-13-编写客户端编译脚本" class="headerlink" title="2.13 编写客户端编译脚本"></a>2.13 编写客户端编译脚本</h4><p>在hardware/interfaces/hidltest/1.0/test目录下，创建Android.bp</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    relative_install_path: &quot;hw&quot;,</span><br><span class="line">    defaults: [&quot;hidl_defaults&quot;],</span><br><span class="line">    name: &quot;hidltest_client&quot;,</span><br><span class="line">    proprietary: true,</span><br><span class="line">    srcs: [&quot;HidlTestClient.cpp&quot;],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libhardware&quot;,</span><br><span class="line">        &quot;libhidlbase&quot;,</span><br><span class="line">        &quot;libhidltransport&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">        &quot;android.hardware.hidltest@1.0&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1ade4363c462ffc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端代码.png"></p>
<h4 id="2-14-编译模块"><a href="#2-14-编译模块" class="headerlink" title="2.14 编译模块"></a>2.14 编译模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmm hardware/interfaces/hidltest/1.0/</span><br></pre></td></tr></table></figure>
<ul>
<li>out/target/product/generic_x86_64/system/framework/oat/x86_64/目录下生成android.hardware.hidltest-V1.0-java.odex可执行文件</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5d7770432e7d3810.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hidl客户端编译成功.png"></p>
<h4 id="2-15-编写Android-app端代码"><a href="#2-15-编写Android-app端代码" class="headerlink" title="2.15 编写Android app端代码"></a>2.15 编写Android app端代码</h4><h5 id="2-15-1-取的jar包"><a href="#2-15-1-取的jar包" class="headerlink" title="2.15.1 取的jar包"></a>2.15.1 取的jar包</h5><p>从2.3中~/work_directory/out/soong/.intermediates/hardware/interfaces/hidltest/1.0/android.hardware.hidltest-V1.0-java/android_common/combined目录拿到Android端使用的jar包。</p>
<h5 id="2-15-2-建立AS工程"><a href="#2-15-2-建立AS工程" class="headerlink" title="2.15.2 建立AS工程"></a>2.15.2 建立AS工程</h5><p>由于HIDL调用需要java 8，所以在build.gradle中加入以下配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ......</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-15-3-编写代码"><a href="#2-15-3-编写代码" class="headerlink" title="2.15.3 编写代码"></a>2.15.3 编写代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MainActivity.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> Button mShow;</span><br><span class="line">    <span class="keyword">private</span> TextView mTextShow;</span><br><span class="line">    IHidlTest mService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextShow = findViewById(R.id.textView);</span><br><span class="line">        mShow = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        String content;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得服务</span></span><br><span class="line">            mService = IHidlTest.getService();</span><br><span class="line">            <span class="keyword">if</span> (mService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;service is null&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            content = mService.helloWorld(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">            mTextShow.setText(content);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mShow.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String content = mService.helloWorld(<span class="string">&quot;hello world!&quot;</span> + System.currentTimeMillis());</span><br><span class="line">                    mTextShow.setText(content);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上面demo工程，生成apk文件，准备在目标板子上运行。</p>
<p><strong>至此，所有准备工作已经做完了。</strong></p>
<h4 id="2-16-将目标文件烧写到车机"><a href="#2-16-将目标文件烧写到车机" class="headerlink" title="2.16 将目标文件烧写到车机"></a>2.16 将目标文件烧写到车机</h4><p>需要准备的文件</p>
<blockquote>
<p>base path: ~/work_directory/out/target/product/generic_x86_64</p>
<p>abstract path:</p>
<ul>
<li>/vendor/lib64/hw/<a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#x68;&#x61;&#x72;&#x64;&#x77;&#x61;&#114;&#101;&#46;&#104;&#105;&#x64;&#108;&#116;&#x65;&#x73;&#116;&#64;&#49;&#x2e;&#x30;&#45;&#105;&#109;&#112;&#108;&#x2e;&#x73;&#x6f;">&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#46;&#x68;&#x61;&#x72;&#x64;&#x77;&#x61;&#114;&#101;&#46;&#104;&#105;&#x64;&#108;&#116;&#x65;&#x73;&#116;&#64;&#49;&#x2e;&#x30;&#45;&#105;&#109;&#112;&#108;&#x2e;&#x73;&#x6f;</a></li>
<li>/system/lib64/<a href="mailto:&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#x64;&#x2e;&#104;&#x61;&#x72;&#x64;&#x77;&#97;&#x72;&#101;&#46;&#104;&#105;&#x64;&#x6c;&#116;&#x65;&#x73;&#x74;&#64;&#x31;&#46;&#48;&#x2e;&#x73;&#111;">&#x61;&#x6e;&#100;&#x72;&#x6f;&#105;&#x64;&#x2e;&#104;&#x61;&#x72;&#x64;&#x77;&#97;&#x72;&#101;&#46;&#104;&#105;&#x64;&#x6c;&#116;&#x65;&#x73;&#x74;&#64;&#x31;&#46;&#48;&#x2e;&#x73;&#111;</a></li>
<li>/vendor/bin/hw/hidltest_client</li>
<li>/vendor/bin/hw/<a href="mailto:&#97;&#x6e;&#100;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#97;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#46;&#x68;&#105;&#x64;&#108;&#116;&#x65;&#115;&#116;&#x40;&#49;&#46;&#48;&#45;&#115;&#101;&#114;&#x76;&#x69;&#99;&#x65;">&#97;&#x6e;&#100;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#97;&#114;&#x64;&#119;&#x61;&#x72;&#101;&#46;&#x68;&#105;&#x64;&#108;&#116;&#x65;&#115;&#116;&#x40;&#49;&#46;&#48;&#45;&#115;&#101;&#114;&#x76;&#x69;&#99;&#x65;</a></li>
</ul>
</blockquote>
<blockquote>
<p>车机中的manifest.xml修改之后push到原来的目录</p>
</blockquote>
<h5 id="2-16-1-push路径说明"><a href="#2-16-1-push路径说明" class="headerlink" title="2.16.1 push路径说明"></a>2.16.1 push路径说明</h5><blockquote>
<p><a href="mailto:&#x61;&#x6e;&#x64;&#x72;&#x6f;&#105;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#x77;&#97;&#114;&#x65;&#46;&#104;&#105;&#x64;&#108;&#116;&#x65;&#115;&#x74;&#64;&#x31;&#x2e;&#x30;&#45;&#105;&#x6d;&#x70;&#108;&#46;&#x73;&#111;">&#x61;&#x6e;&#x64;&#x72;&#x6f;&#105;&#x64;&#x2e;&#x68;&#x61;&#114;&#x64;&#x77;&#97;&#114;&#x65;&#46;&#104;&#105;&#x64;&#108;&#116;&#x65;&#115;&#x74;&#64;&#x31;&#x2e;&#x30;&#45;&#105;&#x6d;&#x70;&#108;&#46;&#x73;&#111;</a>  –&gt;      /vendor/lib64/hw</p>
<p><a href="mailto:&#x61;&#110;&#x64;&#x72;&#111;&#105;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#97;&#x72;&#101;&#46;&#104;&#105;&#x64;&#108;&#116;&#101;&#x73;&#x74;&#64;&#49;&#46;&#48;&#46;&#115;&#x6f;">&#x61;&#110;&#x64;&#x72;&#111;&#105;&#x64;&#46;&#x68;&#x61;&#114;&#100;&#x77;&#97;&#x72;&#101;&#46;&#104;&#105;&#x64;&#108;&#116;&#101;&#x73;&#x74;&#64;&#49;&#46;&#48;&#46;&#115;&#x6f;</a>           –&gt;     /system/lib64</p>
<p>hidltest_client                                               –&gt;    /vendor/bin/hw</p>
<p><a href="mailto:&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#x72;&#x64;&#119;&#x61;&#x72;&#x65;&#46;&#x68;&#105;&#100;&#x6c;&#116;&#101;&#115;&#x74;&#x40;&#49;&#x2e;&#x30;&#x2d;&#115;&#101;&#114;&#x76;&#x69;&#x63;&#101;">&#97;&#110;&#x64;&#114;&#111;&#x69;&#100;&#x2e;&#x68;&#97;&#x72;&#x64;&#119;&#x61;&#x72;&#x65;&#46;&#x68;&#105;&#100;&#x6c;&#116;&#101;&#115;&#x74;&#x40;&#49;&#x2e;&#x30;&#x2d;&#115;&#101;&#114;&#x76;&#x69;&#x63;&#101;</a>  –&gt;    /vendor/bin/hw</p>
<p>manifest.xml                                               –&gt;    /vendor/etc/vintf</p>
</blockquote>
<p>2.16.2 安装apk</p>
<blockquote>
<p>adb install -r  /本地路径/app-debug.apk</p>
</blockquote>
<h4 id="2-17-启动服务，测试功能"><a href="#2-17-启动服务，测试功能" class="headerlink" title="2.17 启动服务，测试功能"></a>2.17 启动服务，测试功能</h4><blockquote>
<p>1.启动Hidl模块服务<br>./vendor/bin/hw/<a href="mailto:&#97;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#114;&#100;&#119;&#97;&#114;&#101;&#x2e;&#x68;&#x69;&#100;&#108;&#116;&#x65;&#115;&#x74;&#x40;&#49;&#x2e;&#48;&#x2d;&#115;&#x65;&#114;&#x76;&#x69;&#99;&#101;">&#97;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#114;&#100;&#119;&#97;&#114;&#101;&#x2e;&#x68;&#x69;&#100;&#108;&#116;&#x65;&#115;&#x74;&#x40;&#49;&#x2e;&#48;&#x2d;&#115;&#x65;&#114;&#x76;&#x69;&#99;&#101;</a></p>
<p>2.启动客户端<br>./vendor/bin/hw/hidltest_client  </p>
<p>3.运行apk看界面现象</p>
</blockquote>
<p><strong>Notice</strong>：HAL回调实现下一小节叙述，或者见参考文献3</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.csdn.net/shift_wwx/article/details/86530600">1. Android HIDL 实例</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1619361">2. HIDL实战笔记</a></p>
<p><a href="https://www.jianshu.com/p/b80865c61d8e">3. Android HIDL学习（3） —- 注册回调</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>HIDL</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC机制(三) -- ContentProvider、Socket和Binder池</title>
    <url>/2021/01/29/IPC%E6%9C%BA%E5%88%B6-%E4%B8%89-ContentProvider%E3%80%81Socket%E5%92%8CBinder%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="1-ContentProvider"><a href="#1-ContentProvider" class="headerlink" title="1.ContentProvider"></a>1.ContentProvider</h3><p>ContentProvider的底层实现是基于Binder，系统为我们做了深度的封装，让我们使用起来非常容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line"><span class="comment">// 实现一个内容提供者，每个CURD方法中实现对数据的提供，可以是大多是从数据库加载数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">&quot;com.gacrnd.gcs.ipc.BookProvider&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOK_CONTENT_URI = Uri.parse(<span class="string">&quot;content://&quot;</span> + AUTHORITY + <span class="string">&quot;/book&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_CONTENT_URI = Uri.parse(<span class="string">&quot;content://&quot;</span> + AUTHORITY + <span class="string">&quot;/user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_URI_CODE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_URI_CODE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sUriMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sUriMatcher.addURI(AUTHORITY,<span class="string">&quot;book&quot;</span>,BOOK_URI_CODE);</span><br><span class="line">        sUriMatcher.addURI(AUTHORITY,<span class="string">&quot;user&quot;</span>,USER_URI_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过uri获取表名</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.BOOK_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> USER_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">//以下应该在子线程中加载数据库</span></span><br><span class="line">        initDatabase();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDatabase = <span class="keyword">new</span> DbOpenHelper(mContext).getWritableDatabase();</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;DELETE FROM &quot;</span> + DbOpenHelper.BOOK_TABLE_NAME);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;DELETE FROM &quot;</span> + DbOpenHelper.USER_TABLE_NAME);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO book VALUES(1,&#x27;ANDROID 1&#x27;);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO book VALUES(2,&#x27;ANDROID 2&#x27;);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO book VALUES(3,&#x27;ANDROID 3&#x27;);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO user VALUES(1,&#x27;JackOu&#x27;,0);&quot;</span>);</span><br><span class="line">        mDatabase.execSQL(<span class="string">&quot;INSERT INTO user VALUES(2,&#x27;DY&#x27;,1);&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;JackOu&quot;</span>,<span class="string">&quot;query:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        String tableName = getTableName(uri);</span><br><span class="line">        <span class="keyword">if</span> (tableName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;uri illegal！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDatabase.query(tableName,projection,selection,selectionArgs,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//需要基于数据库实现对应的CURD操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二步 在manifest中声明该Provider</span></span><br><span class="line">&lt;provider</span><br><span class="line">    android:authorities=<span class="string">&quot;com.gacrnd.gcs.ipc.BookProvider&quot;</span></span><br><span class="line">    android:name=<span class="string">&quot;.BookProvider&quot;</span></span><br><span class="line">    android:permission=<span class="string">&quot;com.gacrnd.gcs.PROVIDER&quot;</span></span><br><span class="line">    android:process=<span class="string">&quot;:provider&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">&quot;book_provider.db&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">&quot;book&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + BOOK_TABLE_NAME</span><br><span class="line">            + <span class="string">&quot;(_id INTEGER PRIMARY KEY, name TEXT)&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + USER_TABLE_NAME</span><br><span class="line">            + <span class="string">&quot;(_id INTEGER PRIMARY KEY, name TEXT, sex INT)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">        db.execSQL(CREATE_USER_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 忽略数据库版本升级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第四步在需要使用的地方获取数据即可</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.gacrnd.gcs.ipc.BookProvider&quot;</span>);</span><br><span class="line">getContentResolver().query(uri,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>); <span class="comment">// 写两个主要是想打印工作线程信息</span></span><br><span class="line">getContentResolver().query(uri,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>


<h3 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2. Socket"></a>2. Socket</h3><p>Socket称为“套接字”，是网络通信中的概念，分为流式套接字和用户数据报套接字两种，分别对应网络传输控制层的TCP和UDP协议。TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性。而UDP是无连接的，提供不稳定的单向/双向通信功能，在性能上，UDP协议不需要握手和挥手，效率会更高</p>
<h4 id="2-1-Socket服务端"><a href="#2-1-Socket服务端" class="headerlink" title="2.1 Socket服务端"></a>2.1 Socket服务端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDestory = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 正常应该用一个线程池来处理客户端来的请求的，但是作为demo，就暴力的新开一个线程处理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TcpServer()).start();</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 死循环处理客户端的请求</span></span><br><span class="line">            <span class="keyword">while</span> (!mDestory) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 接收客户端</span></span><br><span class="line">                    <span class="keyword">final</span> Socket client = serverSocket.accept();</span><br><span class="line">                    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//处理客户端发来的内容并且回复客户端</span></span><br><span class="line">                                responseClient(client);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseClient</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//接收客户端的消息</span></span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">        <span class="comment">//发送数据到客户端</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream())));</span><br><span class="line">        <span class="keyword">while</span> (!mDestory) &#123;</span><br><span class="line">            String fromClient = in.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;msg from client:&quot;</span> + fromClient);</span><br><span class="line">            <span class="keyword">if</span> (fromClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//客户端断开，直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">&quot;收到你的消息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交流完毕</span></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDestory = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-Socket客户端"><a href="#2-2-Socket客户端" class="headerlink" title="2.2 Socket客户端"></a>2.2 Socket客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//很粗暴的连接服务端，接收并且发送，主要是演示socket通信过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectServerSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrintWriter pw = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader br= <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!mDestory) &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">            pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())),<span class="keyword">true</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;client send msg&quot;</span>);</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            System.out.println(<span class="string">&quot;receive from server:&quot;</span> + br.readLine());</span><br><span class="line">         &#125;</span><br><span class="line">        pw.close();</span><br><span class="line">        br.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-Binder池"><a href="#3-Binder池" class="headerlink" title="3. Binder池"></a>3. Binder池</h4><p>由于项目业务逻辑越来越服务，需要和多个AIDL交互，如果一个一个绑定，调用，这样显得比较麻烦，所以就有了Binder池的概念出来。所有要请求服务端都放在Binder池中，客户端通过Binder池拿到自己需要服务的客户端。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a060c429afef494a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder池.png"></p>
<h4 id="3-1-binder池服务端"><a href="#3-1-binder池服务端" class="headerlink" title="3.1 binder池服务端"></a>3.1 binder池服务端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder mBinderPool = <span class="keyword">new</span> BinderPoolImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinderPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolImpl</span> <span class="keyword">extends</span> <span class="title">IBinderPool</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECURITY_SERVICE_PROXY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPUTE_SERVICE_PROXY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderPoolImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (binderCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> SECURITY_SERVICE_PROXY:</span><br><span class="line">                <span class="comment">// 此处用伪代码实现，返回SecurityCenterImpl，他继承ISecurityCenter.Stub()，实现了对应接口</span></span><br><span class="line">                <span class="comment">//binder = new SecurityCenterImpl();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COMPUTE_SERVICE_PROXY:</span><br><span class="line">                <span class="comment">//binder = new ComputerImpl();</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-2-Binder池客户端"><a href="#3-2-Binder池客户端" class="headerlink" title="3.2 Binder池客户端"></a>3.2 Binder池客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> BinderPool sInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> IBinderPool mBinderPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 用于等待连接BinderPool，如果没有连接就一直阻塞等待</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch mCountDownLatch;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> BinderPoolServiceConnection();</span><br><span class="line">    <span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> BinderPoolDeathRecipient();</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderPool</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context.getApplicationContext();</span><br><span class="line">        connectBinderPoolService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinderPool <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BinderPool.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> BinderPool(context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connectBinderPoolService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCountDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(mContext, BinderPoolService.class);</span><br><span class="line">        mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCountDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询binder接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> </span>&#123;</span><br><span class="line">        IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBinderPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从Binder服务端查询需要的接口</span></span><br><span class="line">                binder = mBinderPool.queryBinder(binderCode);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolServiceConnection</span> <span class="keyword">implements</span> <span class="title">ServiceConnection</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mBinderPool = IBinderPool.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mBinderPool.asBinder().linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//绑定成功，释放线程继续执行</span></span><br><span class="line">            mCountDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mBinderPool.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">            mBinderPool = <span class="keyword">null</span>;</span><br><span class="line">            connectBinderPoolService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC机制</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC机制(二) -- Bundle,文件共享,Messager</title>
    <url>/2021/01/28/IPC%E6%9C%BA%E5%88%B6-%E4%BA%8C-Bundle-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB-Messager/</url>
    <content><![CDATA[<h3 id="1-Bundle"><a href="#1-Bundle" class="headerlink" title="1.Bundle"></a>1.Bundle</h3><p>我们知道，Acitivity、Service和Receiver都是通过Bundle进行通信的，所有的Intent.putExtra()方法最终都会分装到Bundle中，而Bundle实现了Parcelable接口，所以可以很方便的在进程间进行通信。</p>
<p>所以我们可以通过Intent启动进程B的一个Service组件(例如IntentService，JobService，JobIntentService)，执行后台计算，计算完成之后，由于这个Service在进程B中，所以进程B可以直接处理计算结果。</p>
<h4 id="1-1-JobIntentService用法"><a href="#1-1-JobIntentService用法" class="headerlink" title="1.1 JobIntentService用法"></a>1.1 JobIntentService用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IntentService被废弃了，就不举例了</span></span><br><span class="line"><span class="comment">// 进程内使用Bundle传输数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">JobIntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyIntentService.class.getSimpleName();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> JOB_ID = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴露给Activity发送需要执行的耗时任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enqueueWork</span><span class="params">(Context context, Intent work)</span> </span>&#123;</span><br><span class="line">        enqueueWork(context, MyIntentService.class, JOB_ID, work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理耗时任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleWork</span><span class="params">(<span class="meta">@NonNull</span> Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Executing work: &quot;</span> + intent);</span><br><span class="line">        String label = intent.getStringExtra(<span class="string">&quot;label&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (label == <span class="keyword">null</span>) &#123;</span><br><span class="line">            label = intent.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        toast(<span class="string">&quot;Executing: &quot;</span> + label);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Running service &quot;</span> + (i + <span class="number">1</span>)</span><br><span class="line">                    + <span class="string">&quot;/5 @ &quot;</span> + SystemClock.elapsedRealtime());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Completed service @ &quot;</span> + SystemClock.elapsedRealtime());</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;label: &quot;</span> + label +<span class="string">&quot;, current thread :&quot;</span> + Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(MyIntentService.<span class="keyword">this</span>, (String)msg.obj, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toast</span><span class="params">(<span class="keyword">final</span> CharSequence text)</span> </span>&#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage();</span><br><span class="line">        msg.obj = text.toString();</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程发送任务</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">&quot;label&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">MyIntentService.enqueueWork(<span class="keyword">this</span>,intent);</span><br></pre></td></tr></table></figure>
<h4 id="1-2-JobService用法"><a href="#1-2-JobService用法" class="headerlink" title="1.2 JobService用法"></a>1.2 JobService用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jobService服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJobService</span> <span class="keyword">extends</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyJobService.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mActivityMessenger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        mActivityMessenger = intent.getParcelableExtra(MESSENGER_INTENT_KEY);</span><br><span class="line">        <span class="keyword">return</span> START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(<span class="keyword">final</span> JobParameters params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        <span class="comment">// 如果还有任务没有执行完就返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">        sendMessage(MSG_COLOR_STOP, params.getJobId());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> messageID, <span class="meta">@Nullable</span> Object params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把消息回送到发送者</span></span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.what = messageID;</span><br><span class="line">        m.obj = params;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mActivityMessenger.send(m);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Error passing service object back to activity.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">mServiceComponent = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, MyJobService.class);</span><br><span class="line">JobInfo.Builder builder = <span class="keyword">new</span> JobInfo.Builder(mJobId++, mServiceComponent);</span><br><span class="line"><span class="comment">// 设置策略</span></span><br><span class="line">.....</span><br><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line">PersistableBundle extras = <span class="keyword">new</span> PersistableBundle();</span><br><span class="line">String workDuration = mDurationTimeEditText.getText().toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安排执行任务</span></span><br><span class="line">JobScheduler tm = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">tm.schedule(builder.build());</span><br></pre></td></tr></table></figure>


<h3 id="2-文件共享"><a href="#2-文件共享" class="headerlink" title="2. 文件共享"></a>2. 文件共享</h3><p>文件共享的方式实现进程间通信，主要实现就是进程A通过把序列化的对象写入到文件中，在进程B通过ObjectInputStream来将对象读取出来。具体实现demo将上一讲的序列化和反序列化的测试代码。<a href="https://www.jianshu.com/p/f2ea2793090c">2.1 Serializable序列化对象</a></p>
<h3 id="3-Messager"><a href="#3-Messager" class="headerlink" title="3. Messager"></a>3. Messager</h3><p>Messager是一种轻量级的IPC方案，其底层实现也是基于AIDL。从如下代码可以证明Messager是基于AIDL实现的，通过传入的IBinder对象拿到服务端代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端初始化用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端初始化用</span></span><br><span class="line"><span class="comment">//Handler实现了Messager的服务端IMessenger.Stub</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_FROM_CLIENT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_TO_CLIENT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger messager = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessagerHandler());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessagerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_FROM_CLIENT:</span><br><span class="line">                    Log.i(<span class="string">&quot;JackOu&quot;</span>,msg.getData().getString(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">                    <span class="comment">// 如果要回复，拿到客户端的Messager代理在发送回去</span></span><br><span class="line">                    Messenger messenger = msg.replyTo;</span><br><span class="line">                    Message message = Message.obtain(<span class="keyword">null</span>, MESSAGE_TO_CLIENT);</span><br><span class="line">                    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                    bundle.putString(<span class="string">&quot;reply&quot;</span>, <span class="string">&quot;hello client&quot;</span>);</span><br><span class="line">                    message.setData(bundle);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        messenger.send(message);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messager.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>客户端实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection messengerSconn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">        Message msg = Message.obtain(<span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        msg.setData(bundle);</span><br><span class="line">        msg.replyTo = clientMessenger; <span class="comment">// 如果需要服务端回复需要把自己的处理器发过去</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMessenger.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定服务端</span></span><br><span class="line">Intent intentMessenger = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</span><br><span class="line">bindService(intentMessenger, messengerSconn, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IPC机制</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>(1)Iptables教程</title>
    <url>/2021/03/23/Iptables%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="0-Iptables介绍"><a href="#0-Iptables介绍" class="headerlink" title="0. Iptables介绍"></a>0. Iptables介绍</h3><p>iptables防火墙可以用于创建过滤(filter)与NAT规则。所有Linux发行版都能使用iptables，因此理解如何配置iptables将会帮助你更有效地管理Linux防火墙。如果你是第一次接触iptables，你会觉得它很复杂，但是一旦你理解iptables的工作原理，你会发现其实它很简单。</p>
<p>首先介绍iptables的结构：iptables -&gt; Tables -&gt; Chains -&gt; Rules. 简单地讲，tables由chains组成，而chains又由rules组成。如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a1a23a58ea0dbfeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-table-chain-rule-structure.png"></p>
<h3 id="1-iptables的表与链"><a href="#1-iptables的表与链" class="headerlink" title="1.  iptables的表与链"></a>1.  iptables的表与链</h3><p>iptables具有Filter, NAT, Mangle, Raw四种内建表：Filter表、NAT表、Mangle表和Raw表</p>
<h4 id="1-1-Filter表"><a href="#1-1-Filter表" class="headerlink" title="1.1 Filter表"></a>1.1 Filter表</h4><p>Filter表示iptables的默认表，因此如果你没有自定义表，那么就默认使用filter表，它具有以下三种内建链：</p>
<ul>
<li>INPUT链 – 处理来自外部的数据。</li>
<li>OUTPUT链 – 处理向外发送的数据。</li>
<li>FORWARD链 – 将数据转发到本机的其他网卡设备上。</li>
</ul>
<h4 id="1-2-NAT表"><a href="#1-2-NAT表" class="headerlink" title="1.2 NAT表"></a>1.2 NAT表</h4><p>NAT表有三种内建链：</p>
<ul>
<li>PREROUTING链 – 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址（destination ip address），通常用于DNAT(destination NAT)。</li>
<li>POSTROUTING链 – 处理即将离开本机的数据包。它会转换数据包中的源IP地址（source ip address），通常用于SNAT（source NAT）。</li>
<li>OUTPUT链 – 处理本机产生的数据包。</li>
</ul>
<h4 id="3-Mangle表"><a href="#3-Mangle表" class="headerlink" title="3. Mangle表"></a>3. Mangle表</h4><p>Mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。Mangle表具有5个内建链(解释见上)：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
<li>FORWARD</li>
<li>INPUT</li>
<li>POSTROUTING</li>
</ul>
<h3 id="4-Raw表"><a href="#4-Raw表" class="headerlink" title="4. Raw表"></a>4. Raw表</h3><p>Raw表用于处理异常，它具有2个内建链：</p>
<ul>
<li>PREROUTING</li>
<li>OUTPUT</li>
</ul>
<p>以下是Iptables中的三个重要表格</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b9b4675931350c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iptables-filter-nat-mangle-tables.png"></p>
<h3 id="2-IPTABLES-规则-Rules"><a href="#2-IPTABLES-规则-Rules" class="headerlink" title="2.IPTABLES 规则(Rules)"></a>2.IPTABLES 规则(Rules)</h3><p>牢记以下三点式理解iptables规则的关键：</p>
<ul>
<li>Rules包括一个条件和一个<strong>目标值</strong>(target)</li>
<li>如果满足条件，就执行目标(target)中的规则或者特定值。</li>
<li>如果不满足条件，就判断下一条Rules。</li>
</ul>
<p><strong>目标值（Target Values）</strong></p>
<p>下面是你可以在target里指定的特殊值：</p>
<ul>
<li>ACCEPT – 允许防火墙接收数据包</li>
<li>DROP – 防火墙丢弃包</li>
<li>QUEUE – 防火墙将数据包移交到用户空间</li>
<li>RETURN – 防火墙停止执行当前链中的后续Rules，并返回到调用链(the calling chain)中。</li>
</ul>
<p>如果你执行<code>iptables --list</code>你将看到防火墙上的可用规则。下例说明当前系统没有定义防火墙，你可以看到，它显示了默认的filter表，以及表内默认的input链, forward链, output链。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -t filter --list</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li>target：目标值     </li>
<li>prot： 协议</li>
<li>opt：选项</li>
<li>source：数据包源地址</li>
<li>destination：数据包目标地址</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-97d2c29e31e90ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter表内容.png"></p>
<p>bw_INPUT、bw_OUTPUT和bw_FORWARD chain用于带宽(Bandwidth)控制；</p>
<p>fw_INPUT、fw_OUTPUT和fw_FORWARD chain用于防火墙(Firewall)控制；</p>
<p>natctrl_FORWARD用于网络地址转换(NAT)控制；</p>
<p>oem_fwd、oem_out用于OEM厂商自定义的控制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看mangle表</span></span><br><span class="line">iptables -t mangle --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看nat表</span></span><br><span class="line">iptables -t nat --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令查看raw表</span></span><br><span class="line">iptables -t raw --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于默认表是filter表，不加-t选项默认输出filter表</span></span><br><span class="line">iptables -t filter --list</span><br><span class="line">(or)</span><br><span class="line">iptables --list</span><br></pre></td></tr></table></figure>


<h3 id="3-清空所有iptables规则"><a href="#3-清空所有iptables规则" class="headerlink" title="3.清空所有iptables规则"></a>3.清空所有iptables规则</h3><p>在配置iptables之前，你通常需要用<code>iptables --list</code>命令或者<code>iptables-save</code>命令查看有无现存规则，因为有时需要删除现有的iptables规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables --flush</span><br><span class="line">或者</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>
<p>这两条命令是等效的。但是并非执行后就万事大吉了。你仍然需要检查规则是不是真的清空了，因为有的linux发行版上这个命令不会清除NAT表中的规则，此时只能手动清除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t NAT -F</span><br></pre></td></tr></table></figure>


<h3 id="4-永久生效"><a href="#4-永久生效" class="headerlink" title="4.永久生效"></a>4.永久生效</h3><p>当你删除、添加规则后，这些更改并不能永久生效，这些规则很有可能在系统重启后恢复原样。为了让配置永久生效，根据平台的不同，具体操作也不同。下面进行简单介绍：</p>
<h4 id="4-1-Ubuntu"><a href="#4-1-Ubuntu" class="headerlink" title="4.1 Ubuntu"></a>4.1 Ubuntu</h4><p>首先，保存现有的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>然后新建一个bash脚本，并保存到/etc/network/if-pre-up.d/目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">iptables-restore &lt; &#x2F;etc&#x2F;iptables.rules</span><br></pre></td></tr></table></figure>
<p>这样，每次系统重启后iptables规则都会被自动加载。<br>/!\注意：不要尝试在.bashrc或者.profile中执行以上命令，因为用户通常不是root，而且这只能在登录时加载iptables规则。</p>
<h4 id="4-2-CentOS-RedHat"><a href="#4-2-CentOS-RedHat" class="headerlink" title="4.2 CentOS, RedHat"></a>4.2 CentOS, RedHat</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 保存iptables规则</span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line"># 重启iptables服务</span><br><span class="line">service iptables stop</span><br><span class="line">service iptables start</span><br></pre></td></tr></table></figure>
<p>查看当前规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat  &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br></pre></td></tr></table></figure>


<h3 id="5-追加iptables规则"><a href="#5-追加iptables规则" class="headerlink" title="5. 追加iptables规则"></a>5. 追加iptables规则</h3><p>可以使用<code>iptables -A</code>命令追加新规则，其中-A表示Append。因此，新的规则将追加到链尾。<br>一般而言，最后一条规则用于丢弃(DROP)所有数据包。如果你已经有这样的规则了，并且使用-A参数添加新规则，那么就是无用功。</p>
<h4 id="5-1语法"><a href="#5-1语法" class="headerlink" title="5.1语法"></a>5.1语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A chain firewall-rule</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">-A chain – 指定要追加规则的链</span></span><br><span class="line"><span class="meta">#</span><span class="bash">firewall-rule – 具体的规则参数</span></span><br></pre></td></tr></table></figure>


<h4 id="5-2-描述规则的基本参数"><a href="#5-2-描述规则的基本参数" class="headerlink" title="5.2 描述规则的基本参数"></a>5.2 描述规则的基本参数</h4><p>以下这些规则参数用于描述数据包的协议、源地址、目的地址、允许经过的网络接口，以及如何处理这些数据包。这些描述是对规则的基本描述。</p>
<h5 id="p-协议（protocol）"><a href="#p-协议（protocol）" class="headerlink" title="-p 协议（protocol）"></a>-p 协议（protocol）</h5><ul>
<li><p>指定规则的协议，如tcp, udp, icmp等，可以使用all来指定所有协议。</p>
</li>
<li><p>如果不指定-p参数，则默认是all值。这并不明智，请总是明确指定协议名称。</p>
</li>
<li><p>可以使用协议名(如tcp)，或者是协议值（比如6代表tcp）来指定协议。映射关系请查看/etc/protocols</p>
</li>
<li><p>还可以使用–protocol参数代替-p参数</p>
</li>
</ul>
<h5 id="s-源地址（source）"><a href="#s-源地址（source）" class="headerlink" title="-s 源地址（source）"></a>-s 源地址（source）</h5><ul>
<li>指定数据包的源地址</li>
<li>参数可以使IP地址、网络地址、主机名</li>
<li>例如：-s 192.168.1.101指定IP地址</li>
<li>例如：-s 192.168.1.10/24指定网络地址</li>
<li>如果不指定-s参数，就代表所有地址</li>
<li>还可以使用–src或者–source</li>
</ul>
<h5 id="d-目的地址（destination）"><a href="#d-目的地址（destination）" class="headerlink" title="-d 目的地址（destination）"></a>-d 目的地址（destination）</h5><ul>
<li>指定目的地址</li>
<li>参数和-s相同</li>
<li>还可以使用–dst或者–destination</li>
</ul>
<h5 id="j-执行目标（jump-to-target）"><a href="#j-执行目标（jump-to-target）" class="headerlink" title="-j 执行目标（jump to target）"></a>-j 执行目标（jump to target）</h5><ul>
<li>-j代表”jump to target”</li>
<li>-j指定了当与规则(Rule)匹配时如何处理数据包</li>
<li>可能的值是ACCEPT, DROP, QUEUE, RETURN</li>
<li>还可以指定其他链（Chain）作为目标</li>
</ul>
<h5 id="i-输入接口（input-interface）"><a href="#i-输入接口（input-interface）" class="headerlink" title="-i 输入接口（input interface）"></a>-i 输入接口（input interface）</h5><ul>
<li>-i代表输入接口(input interface)</li>
<li>-i指定了要处理来自哪个接口的数据包</li>
<li>这些数据包即将进入INPUT, FORWARD, PREROUTE链</li>
<li>例如：-i eth0指定了要处理经由eth0进入的数据包</li>
<li>如果不指定-i参数，那么将处理进入所有接口的数据包</li>
<li>如果出现! -i eth0，那么将处理所有经由eth0以外的接口进入的数据包</li>
<li>如果出现-i eth+，那么将处理所有经由eth开头的接口进入的数据包</li>
<li>还可以使用–in-interface参数</li>
</ul>
<h5 id="o-输出（out-interface）"><a href="#o-输出（out-interface）" class="headerlink" title="-o 输出（out interface）"></a>-o 输出（out interface）</h5><ul>
<li>-o代表”output interface”</li>
<li>-o指定了数据包由哪个接口输出</li>
<li>这些数据包即将进入FORWARD, OUTPUT, POSTROUTING链</li>
<li>如果不指定-o选项，那么系统上的所有接口都可以作为输出接口</li>
<li>如果出现! -o eth0，那么将从eth0以外的接口输出</li>
<li>如果出现-i eth+，那么将仅从eth开头的接口输出</li>
<li>还可以使用–out-interface参数</li>
</ul>
<h4 id="5-3-描述规则的扩展参数"><a href="#5-3-描述规则的扩展参数" class="headerlink" title="5.3 描述规则的扩展参数"></a>5.3 描述规则的扩展参数</h4><p>对规则有了一个基本描述之后，有时候我们还希望指定端口、TCP标志、ICMP类型等内容。</p>
<h5 id="–sport-源端口（source-port）针对-p-tcp-或者-p-udp"><a href="#–sport-源端口（source-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–sport 源端口（source port）针对 -p tcp 或者 -p udp"></a>–sport 源端口（source port）针对 -p tcp 或者 -p udp</h5><ul>
<li>缺省情况下，将匹配所有端口</li>
<li>可以指定端口号或者端口名称，例如”–sport 22″与”–sport ssh”。</li>
<li>/etc/services文件描述了上述映射关系。</li>
<li>从性能上讲，使用端口号更好</li>
<li>使用冒号可以匹配端口范围，如”–sport 22:100″</li>
<li>还可以使用”–source-port”</li>
</ul>
<h5 id="–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp"><a href="#–-dport-目的端口（destination-port）针对-p-tcp-或者-p-udp" class="headerlink" title="–-dport 目的端口（destination port）针对-p tcp 或者 -p udp"></a>–-dport 目的端口（destination port）针对-p tcp 或者 -p udp</h5><ul>
<li>参数和–sport类似</li>
<li>还可以使用”–destination-port”</li>
</ul>
<h5 id="–tcp-flags-TCP标志-针对-p-tcp"><a href="#–tcp-flags-TCP标志-针对-p-tcp" class="headerlink" title="-–tcp-flags TCP标志 针对-p tcp"></a>-–tcp-flags TCP标志 针对-p tcp</h5><ul>
<li>可以指定由逗号分隔的多个参数</li>
<li>有效值可以是：SYN, ACK, FIN, RST, URG, PSH</li>
<li>可以使用ALL或者NONE</li>
</ul>
<h5 id="–icmp-type-ICMP类型-针对-p-icmp"><a href="#–icmp-type-ICMP类型-针对-p-icmp" class="headerlink" title="-–icmp-type ICMP类型 针对-p icmp"></a>-–icmp-type ICMP类型 针对-p icmp</h5><ul>
<li>–icmp-type 0 表示Echo Reply</li>
<li>–icmp-type 8 表示Echo</li>
</ul>
<h4 id="5-4-追加规则的完整实例：仅允许SSH服务"><a href="#5-4-追加规则的完整实例：仅允许SSH服务" class="headerlink" title="5.4 追加规则的完整实例：仅允许SSH服务"></a>5.4 追加规则的完整实例：仅允许SSH服务</h4><p>本例实现的规则将仅允许SSH数据包通过本地计算机，其他一切连接（包括ping）都将被拒绝。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.清空所有iptables规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.接收目标端口为22的数据包</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.拒绝所有其他数据包</span></span><br><span class="line">iptables -A INPUT -j DROP</span><br></pre></td></tr></table></figure>


<h3 id="6-更改默认策略"><a href="#6-更改默认策略" class="headerlink" title="6. 更改默认策略"></a>6. 更改默认策略</h3><p>上例的例子仅对接收的数据包过滤，而对于要发送出去的数据包却没有任何限制。本节主要介绍如何更改链策略，以改变链的行为。</p>
<h4 id="6-1-默认链策略"><a href="#6-1-默认链策略" class="headerlink" title="6.1 默认链策略"></a>6.1 默认链策略</h4><p>/!\警告：请勿在远程连接的服务器、虚拟机上测试！<br>当我们使用-L选项验证当前规则是发现，所有的链旁边都有policy ACCEPT标注，这表明当前链的默认策略为ACCEPT：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> iptables -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            tcp dpt:ssh</span><br><span class="line">DROP       all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p>这种情况下，如果没有明确添加DROP规则，那么默认情况下将采用ACCEPT策略进行过滤。除非：<br>a)为以上三个链单独添加DROP规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -j DROP</span><br><span class="line">iptables -A OUTPUT -j DROP</span><br><span class="line">iptables -A FORWARD -j DROP</span><br></pre></td></tr></table></figure>
<p>b)更改默认策略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br></pre></td></tr></table></figure>


<h3 id="7-配置应用程序规则"><a href="#7-配置应用程序规则" class="headerlink" title="7.配置应用程序规则"></a>7.配置应用程序规则</h3><p>尽管5.4节已经介绍了如何初步限制除SSH以外的其他连接，但是那是在链默认策略为ACCEPT的情况下实现的，并且没有对输出数据包进行限制。本节在上一节基础上，以SSH和HTTP所使用的端口为例，教大家如何在默认链策略为DROP的情况下，进行防火墙设置。在这里，我们将引进一种新的参数-m state，并检查数据包的状态字段。</p>
<h4 id="7-1-SSH"><a href="#7-1-SSH" class="headerlink" title="7.1 SSH"></a>7.1 SSH</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的SSH请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.允许发送本地主机的SSH响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">-m state: 启用状态匹配模块（state matching module）</span><br><span class="line">–-state: 状态匹配模块的参数。当SSH客户端第一个数据包到达服务器时，状态字段为NEW；建立连接后数据包的状态字段都是ESTABLISHED</span><br><span class="line">–sport 22: sshd监听22端口，同时也通过该端口和客户端建立连接、传送数据。因此对于SSH服务器而言，源端口就是22</span><br><span class="line">–dport 22: ssh客户端程序可以从本机的随机端口与SSH服务器的22端口建立连接。因此对于SSH客户端而言，目的端口就是22</span><br></pre></td></tr></table></figure>


<h4 id="7-2-HTTP"><a href="#7-2-HTTP" class="headerlink" title="7.2 HTTP"></a>7.2 HTTP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.允许接收远程主机的HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.允许发送本地主机的HTTP响应</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="7-3-完整的配置"><a href="#7-3-完整的配置" class="headerlink" title="7.3 完整的配置"></a>7.3 完整的配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.删除现有规则</span></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.配置默认链策略</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.允许远程主机进行SSH连接</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.允许本地主机进行SSH连接</span></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.允许HTTP请求</span></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>



<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.thegeekstuff.com/2011/01/iptables-fundamentals/">1.  Linux Firewall Tutorial: IPTables Tables, Chains, Rules Fundamentals</a></p>
<p><a href="https://www.thegeekstuff.com/2011/02/iptables-add-rule/">2. Linux IPTables: How to Add Firewall Rules (With Allow SSH Example)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/03/iptables-inbound-and-outbound-rules/">3. Linux IPTables: Incoming and Outgoing Rule Examples (SSH and HTTP)</a></p>
<p><a href="https://www.thegeekstuff.com/2011/06/iptables-rules-examples/">4. 25 Most Frequently Used Linux IPTables Rules Examples</a></p>
<p><a href="https://www.thegeekstuff.com/category/iptables/">5. iptables相关所有教程</a></p>
<p><a href="https://www.zsythink.net/archives/1199">6.朱双印的一系列Iptables原理讲解教程</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI动态注册与线程理解</title>
    <url>/2021/06/29/JNI%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="1-静态注册与动态注册函数"><a href="#1-静态注册与动态注册函数" class="headerlink" title="1. 静态注册与动态注册函数"></a>1. 静态注册与动态注册函数</h4><h5 id="1-1-静态注册函数"><a href="#1-1-静态注册函数" class="headerlink" title="1.1 静态注册函数"></a>1.1 静态注册函数</h5><p>在开发默认情况下，就是静态注册，静态注册是最简单的方式，NDK开发过程中，基本上使用静态注册，但是Android 系统的C++源码：基本上都是动态注册。</p>
<blockquote>
<p>静态注册： 优点：开发简单<br>缺点<br>1.JNI函数名非常长<br>2.捆绑 上层 包名 + 类名<br>3.运行期 才会去 匹配JNI函数，性能上 低于 动态注册</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日志输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">&quot;JNISTUDY&quot;</span></span></span><br><span class="line"><span class="comment">// __VA_ARGS__ 代表 ...的可变参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG,  __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG,  __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // 在AS上 pthread不需要额外配置，默认就有</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;默认就是静态注册哦&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_staticRegister(JNIEnv *env, jobject thiz) &#123;&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-2-动态注册函数"><a href="#1-2-动态注册函数" class="headerlink" title="1.2 动态注册函数"></a>1.2 动态注册函数</h5><blockquote>
<p> JavaVM、JNIEnv、jobject 域的结论：</p>
<ol>
<li><p>JavaVM全局，绑定当前进程， 只有一个地</p>
</li>
<li><p>JNIEnv线程绑定， 绑定主线程，绑定子线程</p>
</li>
<li><p>jobject 谁调用JNI函数，谁的实例会给jobject</p>
</li>
<li><p>JNIEnv *env 不能跨越线程，否则奔溃，  他可以跨越函数<br>【解决方式：使用全局的JavaVM附加当前异步线程 得到权限env操作】</p>
</li>
<li><p>jobject thiz 不能跨越线程，否则奔溃，不能跨越函数，否则奔溃<br>【解决方式：默认是局部引用，提升全局引用，可解决此问题】</p>
</li>
<li><p>JavaVM 能够跨越线程，能够跨越函数</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">JavaVM *jVm = <span class="literal">nullptr</span>; <span class="comment">// 0x003545 系统乱值，C++11后，取代NULL，作用是可以初始化指针赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mainActivityClassName = <span class="string">&quot;com/jack/as_jni_project/MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native 真正的执行函数</span></span><br><span class="line"><span class="comment">// void dynamicMethod01(JNIEnv *env, jobject thiz) &#123; // OK的</span></span><br><span class="line"><span class="comment">// 如果你用不到  JNIEnv jobject ，可以不用写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicMethod01</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    LOGD(<span class="string">&quot;我是动态注册的函数 dynamicMethod01...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dynamicMethod02</span><span class="params">(JNIEnv *env, jobject thiz, jstring valueStr)</span> </span>&#123; <span class="comment">// 也OK</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *text = env-&gt;GetStringUTFChars(valueStr, <span class="literal">nullptr</span>);</span><br><span class="line">    LOGD(<span class="string">&quot;我是动态注册的函数 dynamicMethod02... %s&quot;</span>, text);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(valueStr, text);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     typedef struct &#123;</span></span><br><span class="line"><span class="comment">        const char* name;       // 函数名</span></span><br><span class="line"><span class="comment">        const char* signature; // 函数的签名</span></span><br><span class="line"><span class="comment">        void*       fnPtr;     // 函数指针</span></span><br><span class="line"><span class="comment">     &#125; JNINativeMethod;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod jniNativeMethod[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;dynamicJavaMethod01&quot;</span>, <span class="string">&quot;()V&quot;</span>,                   (<span class="keyword">void</span> *) (dynamicMethod01)&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;dynamicJavaMethod02&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)I&quot;</span>, (<span class="keyword">int</span> *) (dynamicMethod02)&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java：像 Java的构造函数，如果你不写构造函数，默认就有构造函数，如果你写构造函数 覆写默认的构造函数</span></span><br><span class="line"><span class="comment">// JNI JNI_OnLoad函数，如果你不写JNI_OnLoad，默认就有JNI_OnLoad，如果你写JNI_OnLoad函数 覆写默认的JNI_OnLoad函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *javaVm, <span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this.javaVm = javaVm;</span></span><br><span class="line">    <span class="comment">// javaVm全局唯一</span></span><br><span class="line">    ::jVm = javaVm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做动态注册 全部做完</span></span><br><span class="line">	<span class="comment">// JNIEnv线程唯一</span></span><br><span class="line">    JNIEnv *jniEnv = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> result = javaVm-&gt;GetEnv(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(&amp;jniEnv), JNI_VERSION_1_6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// result 等于0  就是成功</span></span><br><span class="line">    <span class="keyword">if</span> (result != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 会奔溃，故意奔溃</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;System.loadLibrary ---》 JNI Load init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jclass mainActivityClass = jniEnv-&gt;FindClass(mainActivityClassName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jint RegisterNatives(Class, 我们的数组==jniNativeMethod， 注册的数量 = 2)</span></span><br><span class="line">    jniEnv-&gt;RegisterNatives(mainActivityClass,</span><br><span class="line">                            jniNativeMethod,</span><br><span class="line">                            <span class="keyword">sizeof</span>(jniNativeMethod) / <span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;动态 注册没有毛病&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6; <span class="comment">//  // AS的JDK在JNI默认最高1.6      存Java的JDKJNI 1.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-JNI子线程中，对JniEnv的理解"><a href="#2-JNI子线程中，对JniEnv的理解" class="headerlink" title="2.  JNI子线程中，对JniEnv的理解"></a>2.  JNI子线程中，对JniEnv的理解</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContext</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    JNIEnv *jniEnv = <span class="literal">nullptr</span>;  <span class="comment">// 不能跨线程 ，会奔溃</span></span><br><span class="line">    jobject instance = <span class="literal">nullptr</span>; <span class="comment">// 不能跨线程 ，会奔溃</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子线程中跨线程对JniEnv的使用</span></span><br><span class="line"><span class="comment">// 方法1，在子线程中使用AttachCurrentThread来获取jnienv</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myThreadTaskAction</span><span class="params">(<span class="keyword">void</span> *pVoid)</span> </span>&#123; <span class="comment">// 当前是异步线程</span></span><br><span class="line">    LOGE(<span class="string">&quot;myThreadTaskAction run&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求：有这样的场景，</span></span><br><span class="line">    <span class="comment">// 例如：下载完成 ，下载失败，等等，必须告诉Activity UI端，所以需要在子线程调用UI端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个是必须要的</span></span><br><span class="line">    <span class="comment">// JNIEnv *env</span></span><br><span class="line">    <span class="comment">// jobject thiz   OK</span></span><br><span class="line"></span><br><span class="line">    MyContext * myContext = <span class="keyword">static_cast</span>&lt;MyContext *&gt;(pVoid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jclass mainActivityClass = myContext-&gt;jniEnv-&gt;FindClass(mainActivityClassName); // 不能跨线程 ，会奔溃</span></span><br><span class="line">    <span class="comment">// mainActivityClass = myContext-&gt;jniEnv-&gt;GetObjectClass(myContext-&gt;instance); // 不能跨线程 ，会奔溃</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 解决方式 （安卓进程只有一个 JavaVM，是全局的，是可以跨越线程的）</span></span><br><span class="line">    JNIEnv * jniEnv = <span class="literal">nullptr</span>; <span class="comment">// 全新的JNIEnv  异步线程里面操作</span></span><br><span class="line">    jint attachResult = ::jVm-&gt;AttachCurrentThread(&amp;jniEnv, <span class="literal">nullptr</span>); <span class="comment">// 附加当前异步线程后，会得到一个全新的 env，此env相当于是子线程专用env</span></span><br><span class="line">    <span class="keyword">if</span> (attachResult != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 附加失败，返回了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.拿到class</span></span><br><span class="line">    jclass mainActivityClass = jniEnv-&gt;GetObjectClass(myContext-&gt;instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.拿到方法</span></span><br><span class="line">    jmethodID updateActivityUI = jniEnv-&gt;GetMethodID(mainActivityClass, <span class="string">&quot;updateActivityUI&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.调用</span></span><br><span class="line">    jniEnv-&gt;CallVoidMethod(myContext-&gt;instance, updateActivityUI);</span><br><span class="line"></span><br><span class="line">    ::jVm-&gt;DetachCurrentThread(); <span class="comment">// 必须解除附加，否则报错</span></span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;C++ 异步线程OK&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过创建MyContext并且把</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_naitveThread(JNIEnv *env, jobject job) &#123; <span class="comment">// 当前是主线程</span></span><br><span class="line">    <span class="comment">/*pthread_t pid;</span></span><br><span class="line"><span class="comment">    pthread_create(&amp;pid, nullptr, myThreadTaskAction, nullptr);</span></span><br><span class="line"><span class="comment">    pthread_join(pid, nullptr);*/</span></span><br><span class="line"></span><br><span class="line">    MyContext * myContext = <span class="keyword">new</span> MyContext;</span><br><span class="line">    myContext-&gt;jniEnv = env;</span><br><span class="line">    <span class="comment">// myContext-&gt;instance = job; // 默认是局部引用，会奔溃</span></span><br><span class="line">    myContext-&gt;instance = env-&gt;NewGlobalRef(job); <span class="comment">// 提升全局引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">nullptr</span>, myThreadTaskAction, myContext);</span><br><span class="line">    pthread_join(pid, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_closeThread(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    <span class="comment">// 做释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三部分 纠结纠结细节 区域 ==================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_nativeFun1(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数job地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun1 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数job地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, job, ::jVm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_nativeFun2(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数job地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun2 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数job地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, job, ::jVm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">run</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123; <span class="comment">// native的子线程 env地址  和  Java的子线程env地址，一样吗  不一样的</span></span><br><span class="line">    JNIEnv * newEnv = <span class="literal">nullptr</span>;</span><br><span class="line">    ::jVm-&gt;AttachCurrentThread(&amp;newEnv, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;run jvm地址:%p,  当前run函数的newEnv地址:%p \n&quot;</span>, ::jVm, newEnv);</span><br><span class="line"></span><br><span class="line">    ::jVm-&gt;DetachCurrentThread();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_staticFun3(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun3 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数clazz地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, clazz, ::jVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用run</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">nullptr</span>, run, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java子线程调用的</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_staticFun4(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun4 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数clazz地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, clazz, ::jVm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_nativeFun5(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    JavaVM * javaVm = <span class="literal">nullptr</span>;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;javaVm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印：当前函数env地址， 当前函数jvm地址， 当前函数clazz地址,  JNI_OnLoad的jvm地址</span></span><br><span class="line">    LOGE(<span class="string">&quot;nativeFun5 当前函数env地址%p,  当前函数jvm地址:%p,  当前函数job地址:%p, JNI_OnLoad的jvm地址:%p\n&quot;</span>, env, javaVm, job, ::jVm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI对象共享内存与Parcel实现分析</title>
    <url>/2021/07/01/JNI%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8EParcel%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="1-nativePtr作用"><a href="#1-nativePtr作用" class="headerlink" title="1. nativePtr作用"></a>1. nativePtr作用</h4><ul>
<li>Java层：nativePtr long类型的 保存 C++ 对象指针的地址</li>
<li>C++层：nativePtr —&gt; C++ 对象</li>
</ul>
<h5 id="1-1-理解源码中nativePtr"><a href="#1-1-理解源码中nativePtr" class="headerlink" title="1.1 理解源码中nativePtr"></a>1.1 理解源码中nativePtr</h5><p>在openCV中有个<a href="https://github.com/opencv/opencv/blob/master/modules/core/misc/java/src/java/core%2BMat.java">Mat.java</a>，<a href="https://github.com/opencv/opencv/blob/fc1a15626226609babd128e043cf7c4e32f567ca/modules/java/generator/src/cpp/Mat.cpp">Mat.cpp(Java_org_opencv_core_Mat_n_1Mat__DDI)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> nativeObj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mat</span><span class="params">(<span class="keyword">long</span> addr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Native object address is NULL&quot;</span>);</span><br><span class="line">        nativeObj = addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// javadoc: Mat::Mat()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nativeObj = n_Mat();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// C++: Mat::Mat()</span></span><br><span class="line">    <span class="comment">// 调入到native初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">n_Mat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++: Mat::Mat(int rows, int cols, int type)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">n_Mat</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的声明</span></span><br><span class="line">JNIEXPORT jlong JNICALL Java_org_opencv_core_Mat_n_1Mat__DDI</span><br><span class="line">  (JNIEnv* env, jclass, jdouble size_width, jdouble size_height, jint type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line">JNIEXPORT jlong JNICALL Java_org_opencv_core_Mat_n_1Mat__DDI</span><br><span class="line">  (JNIEnv* env, jclass, jdouble size_width, jdouble size_height, jint type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> method_name[] = <span class="string">&quot;Mat::n_1Mat__DDI()&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LOGD(<span class="string">&quot;%s&quot;</span>, method_name);</span><br><span class="line">        <span class="function">Size <span class="title">size</span><span class="params">((<span class="keyword">int</span>)size_width, (<span class="keyword">int</span>)size_height)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// new Mat.cpp 实例 强行 转换</span></span><br><span class="line">        <span class="comment">//【重点这一句，new Mat(); C++对象，把此对象的首地址返回给Java==nativeObj】</span></span><br><span class="line">        <span class="keyword">return</span> (jlong) <span class="keyword">new</span> Mat( size, type ); </span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e) &#123;</span><br><span class="line">        throwJavaException(env, &amp;e, method_name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        throwJavaException(env, <span class="number">0</span>, method_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>结论：</strong>Java层拿到nativeObj就是 Native层C++对象的指针，也就是对象的首地址，下次想去使用Native层的功能时，就可以使用首地址寻找C++对象，并让他干活即可。</p>
<h4 id="2-Parcel源码分析"><a href="#2-Parcel源码分析" class="headerlink" title="2. Parcel源码分析"></a>2. Parcel源码分析</h4><h5 id="2-1-Parcel初始化流程"><a href="#2-1-Parcel初始化流程" class="headerlink" title="2.1 Parcel初始化流程"></a>2.1 Parcel初始化流程</h5><p><strong>java端初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于初始化 Parcel对象的函数</span></span><br><span class="line"><span class="comment">     * Retrieve a new Parcel object from the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Parcel <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Parcel[] pool = sOwnedPool;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">            Parcel p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">                p = pool[i];</span><br><span class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pool[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">                        p.mStack = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    p.mReadWriteHelper = ReadWriteHelper.DEFAULT;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意：这里的 new Parcel(0); 操作，会进入下面代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Parcel(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Parcel</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">		mStack = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Log.i(TAG, &quot;Initializing obj=0x&quot; + Integer.toHexString(obj), mStack</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意：这里的 init函数，会继续你下面代码</span></span><br><span class="line">	init(nativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> nativePtr)</span> </span>&#123; <span class="comment">// mNativePtr == Parcel.cpp 对象指针地址</span></span><br><span class="line">	<span class="keyword">if</span> (nativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">		mNativePtr = nativePtr;</span><br><span class="line">		mOwnsNativeParcelObject = <span class="keyword">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mNativePtr = nativeCreate(); <span class="comment">// 注意：这里的nativeCreate();会返回C++的头指针内存地址</span></span><br><span class="line">		mOwnsNativeParcelObject = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeCreate</span><span class="params">()</span></span>; <span class="comment">// 注意：从这里进入Native层代码</span></span><br></pre></td></tr></table></figure>


<p><strong>native代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gParcelMethods[] = &#123;</span><br><span class="line">    <span class="comment">//动态注册各种方法</span></span><br><span class="line">    ......</span><br><span class="line">    &#123;<span class="string">&quot;openFileDescriptor&quot;</span>,        <span class="string">&quot;(Ljava/lang/String;I)Ljava/io/FileDescriptor;&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_openFileDescriptor&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dupFileDescriptor&quot;</span>,         <span class="string">&quot;(Ljava/io/FileDescriptor;)Ljava/io/FileDescriptor;&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_dupFileDescriptor&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;closeFileDescriptor&quot;</span>,       <span class="string">&quot;(Ljava/io/FileDescriptor;)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_closeFileDescriptor&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里就找到了，【nativeCreate】</span></span><br><span class="line">    &#123;<span class="string">&quot;nativeCreate&quot;</span>,              <span class="string">&quot;()J&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_create&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeFreeBuffer&quot;</span>,          <span class="string">&quot;(J)J&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_freeBuffer&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;nativeDestroy&quot;</span>,             <span class="string">&quot;(J)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_destroy&#125;,</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正在的实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化C++ 对象，此对象 就是一个 内存地址指针</span></span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> Parcel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回：内存地址指针，并且用reinterpret_cast 转换jlong类型，这代码一看就知道比OpenCV写得好</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-2-写数据"><a href="#2-2-写数据" class="headerlink" title="2.2 写数据"></a>2.2 写数据</h5><p><strong>Parcel.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Write an integer value into the parcel at the current dataPosition(),</span></span><br><span class="line"><span class="comment">    * growing dataCapacity() if needed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 注意：这里会调用native层，下面就会分析这个代码</span></span><br><span class="line">       nativeWriteInt(mNativePtr, val);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FastNative</span> <span class="comment">// 思考：行参一的作用是可以通过此内存地址去寻找native层的C++对象</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteInt</span><span class="params">(<span class="keyword">long</span> nativePtr, <span class="keyword">int</span> val)</span></span>; <span class="comment">// 下面进入native</span></span><br></pre></td></tr></table></figure>


<p><strong>android_os_Parcel.cpp 的 nativeWriteInt:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;nativeWriteByteArray&quot;</span>,      <span class="string">&quot;(J[BII)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeByteArray&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteBlob&quot;</span>,           <span class="string">&quot;(J[BII)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeBlob&#125;,</span><br><span class="line">  <span class="comment">// @FastNative</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 还是采用动态注册的方式，搜索函数实现 android_os_Parcel_writeInt 即可</span></span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteInt&quot;</span>,            <span class="string">&quot;(JI)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeInt&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @FastNative</span></span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteLong&quot;</span>,           <span class="string">&quot;(JJ)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeLong&#125;,</span><br><span class="line">  <span class="comment">// @FastNative</span></span><br><span class="line">  &#123;<span class="string">&quot;nativeWriteFloat&quot;</span>,          <span class="string">&quot;(JF)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Parcel_writeFloat&#125;,</span><br></pre></td></tr></table></figure>


<p><strong>实现函数android_os_Parcel_writeInt</strong> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeInt</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jint val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过在Java层保存的，C++对象首地址，来查找到C++对象 Parcel* parcel</span></span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 把内容写入进去，这里是调用到哪里去？ 看下面代码...</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">status_t</span> err = parcel-&gt;writeInt32(val); </span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="comment">// 抛出异常</span></span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Parcel.cpp 的 writeInt32:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::writeInt32</span><span class="params">(<span class="keyword">int32_t</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writeAligned(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="comment">// 相当于Java的泛型</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::writeAligned</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mDataPos：内存首地址的当前挪动位置</span></span><br><span class="line">    <span class="comment">// mDataCapacity：共享内存的总大小</span></span><br><span class="line">    <span class="comment">// mData：共享内存的首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就相当于，指针++ 挪动好位置 然后存放刚刚挪动的位置</span></span><br><span class="line">        <span class="comment">// * mData共享内存的首地址 = val赋值给左边;</span></span><br><span class="line">        restart_write: *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面分析 finsihWrite函数</span></span><br><span class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = growData(<span class="keyword">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>finsihWrite函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::finishWrite</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; INT32_MAX) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t accept size_t values which may have come from an</span></span><br><span class="line">        <span class="comment">// inadvertent conversion from a negative int.</span></span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;Finish write of %d\n&quot;, len);</span></span><br><span class="line">    mDataPos += len; <span class="comment">// 【上面函数存值后，把指针位置进行挪动一次，方便后续的值 存放】</span></span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;finishWrite Setting data pos of %p to %zu&quot;</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    <span class="keyword">if</span> (mDataPos &gt; mDataSize) &#123;</span><br><span class="line">        mDataSize = mDataPos;</span><br><span class="line">        ALOGV(<span class="string">&quot;finishWrite Setting data size of %p to %zu&quot;</span>, <span class="keyword">this</span>, mDataSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;New pos=%d, size=%d\n&quot;, mDataPos, mDataSize);</span></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>读的流程是一样的，按照顺序一个类型一个类型读出来。最核心的思想就是共享内存写数据和读数据。</p>
<h5 id="2-3-CMakeList配置导入全部-cpp"><a href="#2-3-CMakeList配置导入全部-cpp" class="headerlink" title="2.3 CMakeList配置导入全部.cpp"></a>2.3 CMakeList配置导入全部.cpp</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">file(GLOB allSource *.c *.cpp)</span><br><span class="line">add_library(</span><br><span class="line">	native-lib</span><br><span class="line">	SHARED</span><br><span class="line">	$&#123;allSource&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h4 id="3-自定义Parcelable"><a href="#3-自定义Parcelable" class="headerlink" title="3. 自定义Parcelable"></a>3. 自定义Parcelable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Student</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        in.readInt(); <span class="comment">// 顺序不能乱</span></span><br><span class="line">        in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(<span class="number">10</span>); <span class="comment">// 顺序不能乱</span></span><br><span class="line">        dest.writeString(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Student&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Student <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Student[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// =========================  源码分析</span></span><br><span class="line">        Parcel parcel = Parcel.obtain();</span><br><span class="line"></span><br><span class="line">        parcel.writeInt(<span class="number">50</span>);</span><br><span class="line">        parcel.writeInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mDataPos = 8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么要修改成0,将内存地址还原</span></span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r = parcel.readInt();</span><br><span class="line">        Log.d(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;onCreate: 系统的：&quot;</span> + r);</span><br><span class="line">        r = parcel.readInt();</span><br><span class="line">        Log.d(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;onCreate: 系统的：&quot;</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-Parcelable为什么比Serializable高效"><a href="#4-Parcelable为什么比Serializable高效" class="headerlink" title="4.Parcelable为什么比Serializable高效"></a>4.Parcelable为什么比Serializable高效</h4><p>Serializable IO流完成的(存储到磁盘)，   Parcelable C++ 对象指针 共享内存 指针挪动报错数据。</p>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存管理(一)</title>
    <url>/2021/01/27/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="JVM与操作系统的关系"><a href="#JVM与操作系统的关系" class="headerlink" title="JVM与操作系统的关系"></a>JVM与操作系统的关系</h3><h4 id="1-JVM-基础"><a href="#1-JVM-基础" class="headerlink" title="1.JVM 基础"></a>1.JVM 基础</h4><h5 id="1-1-Java-Virtual-Machine是什么"><a href="#1-1-Java-Virtual-Machine是什么" class="headerlink" title="1.1 Java Virtual Machine是什么"></a>1.1 Java Virtual Machine是什么</h5><p>​    JVM 全称 Java Virtual Machine，也就是我们耳熟能详的 Java 虚拟机。它能识别 .class后缀的文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作。</p>
<h5 id="1-2-JVM的作用是什么"><a href="#1-2-JVM的作用是什么" class="headerlink" title="1.2 JVM的作用是什么"></a>1.2 JVM的作用是什么</h5><p>​    JVM是一个抽象层，有了JVM，java代码就可以跨平台运行。JVM的作用主要是将字节码”翻译”成操作系统可以执行的指令代码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ee64fa579a5df769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM的作用.png"></p>
<h5 id="1-3-JVM、JRE、JDK的关系"><a href="#1-3-JVM、JRE、JDK的关系" class="headerlink" title="1.3 JVM、JRE、JDK的关系"></a>1.3 JVM、JRE、JDK的关系</h5><p>​    <strong>JVM</strong>只是一个翻译，把Class翻译成机器识别的代码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到JRE。</p>
<p>​    <strong>JRE</strong>是Java 运行环境(Java Runtime Environment)，它除了包含JVM之外，提供了很多的类库（就是我们说的jar包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用I/O等等之类的）这些东西就是JRE提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境。</p>
<p>​    但对于程序员来说，JRE还不够。我写完要编译代码，还需要调试代码，还需要打包代码、有时候还需要反编译代码。所以我们会使用JDK，因为JDK还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译&lt;反汇编&gt;）等。这个就是<strong>JDK</strong>。</p>
<h4 id="2-JVM的结构"><a href="#2-JVM的结构" class="headerlink" title="2. JVM的结构"></a>2. JVM的结构</h4><h5 id="2-1-整体结构"><a href="#2-1-整体结构" class="headerlink" title="2.1 整体结构"></a>2.1 整体结构</h5><p>​    一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到方法区，执行引擎将会执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的翻译存在，输入字节码，调用操作系统函数。</p>
<p>​    代码被处理的过程如下：<strong>Java 文件-&gt;编译器-&gt;字节码-&gt;JVM-&gt;机器码。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-36f3d8a67016dd32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序执行过程.png"></p>
<h5 id="2-2-JVM运行时数据区域"><a href="#2-2-JVM运行时数据区域" class="headerlink" title="2.2  JVM运行时数据区域"></a>2.2  JVM运行时数据区域</h5><p>​    Java 引以为豪的就是它的自动内存管理机制。相比于 C++的手动内存管理、复杂难以理解的指针等，Java 程序写起来就方便的多。</p>
<p>​    在 Java 中，JVM 内存主要分为<strong>堆、程序计数器、方法区、虚拟机栈和本地方法栈</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f1662d8307302609.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时数据区组成.png"></p>
<h5 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h5><p>​    较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。</p>
<p>​    程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如：分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>
<p>​    由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p>
<p>​    程序计数器也是JVM中唯一不会OOM(OutOfMemory)的内存区域</p>
<h5 id="2-2-2-虚拟机栈"><a href="#2-2-2-虚拟机栈" class="headerlink" title="2.2.2 虚拟机栈"></a>2.2.2 虚拟机栈</h5><p>​    虚拟机栈在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址<strong>。</strong></p>
<p>​    Java 虚拟机栈是基于线程的。哪怕只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。</p>
<p>​    栈里的每条数据，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。</p>
<p>​    每个栈帧，都包含四个区域：(<strong>局部变量表、操作数栈、动态链接、返回地址</strong>)</p>
<ul>
<li><strong>局部变量表:<strong>用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个</strong>引用地址</strong>即可，实体对象在堆中存放。</li>
<li><strong>操作数据栈</strong>：存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法就是JVM一直运行入栈/出栈的操作。</li>
<li><strong>动态链接:</strong> Java语言特性多态（需要类运行时才能确定具体的方法）。</li>
<li><strong>返回地址:</strong> 正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定）</li>
</ul>
<p>​    栈的大小调节：缺省为1M，可用参数 <strong>–Xss调整大小，例如-Xss256k</strong></p>
<p>​    </p>
<h5 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3 本地方法栈"></a>2.2.3 本地方法栈</h5><p>​    本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p>
<p>​    本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。你甚至可以认为虚拟机栈和本地方法栈是同一个区域。</p>
<p>​    虚拟机规范无强制规定，各版本虚拟机自由实现 ，HotSpot直接把本地方法栈和虚拟机栈合二为一 。</p>
<h5 id="2-2-4-方法区-永久代-线程共享区"><a href="#2-2-4-方法区-永久代-线程共享区" class="headerlink" title="2.2.4 方法区(永久代) (线程共享区)"></a>2.2.4 方法区(永久代) (线程共享区)</h5><p>​    方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、静态变量、常量、运行时常量池、字符串常量池。</p>
<p>​    JVM 在执行某个类的时候，必须先加载。在加载类（加载、验证、准备、解析、初始化）的时候，JVM 会先加载 class 文件，而在 class 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用。</p>
<p>​    字面量包括字符串（String a=“b”）、基本类型的常量（final 修饰的变量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。</p>
<p>​    而当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时的常量池中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。</p>
<p>​    <strong>元空间大小参数：</strong> </p>
<ul>
<li>jdk1.7及以前（初始和最大值）：-XX:PermSize；-XX:MaxPermSize；</li>
<li>jdk1.8以后（初始和最大值）：-XX:MetaspaceSize； -XX:MaxMetaspaceSize</li>
<li>jdk1.8以后大小就只受本机总内存的限制（如果不设置参数的话）</li>
</ul>
<p>​    <strong>Java8 为什么使用元空间替代永久代，这样做有什么好处呢？</strong></p>
<p>​    移除永久代是为了融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，所以不需要配置永久代。</p>
<p>​    永久代内存经常不够用或发生内存溢出，抛出异常 java.lang.OutOfMemoryError: PermGen。这是因为在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于 PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有，为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。</p>
<h5 id="2-2-5-堆区-线程共享区"><a href="#2-2-5-堆区-线程共享区" class="headerlink" title="2.2.5 堆区(线程共享区)"></a>2.2.5 堆区(线程共享区)</h5><p>​    堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。<br>​    堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。<br>​    随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。<br>​    那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。<br>​    Java 的对象可以分为基本数据类型和普通对象。<br>​    对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。<br>​    对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配</p>
<p><strong>堆大小参数：</strong> </p>
<ul>
<li><p>-Xms：堆的最小值；</p>
</li>
<li><p>-Xmx：堆的最大值；</p>
</li>
<li><p>-Xmn：新生代的大小；</p>
</li>
<li><p>-XX:NewSize；新生代最小值；</p>
</li>
<li><p>-XX:MaxNewSize：新生代最大值；</p>
<p>例如- Xmx256m</p>
</li>
</ul>
<h5 id="2-3-直接内存"><a href="#2-3-直接内存" class="headerlink" title="2.3 直接内存"></a>2.3 直接内存</h5><p>​    不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；</p>
<p>​    这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。</p>
<h4 id="3-深入理解运行时数据区"><a href="#3-深入理解运行时数据区" class="headerlink" title="3.深入理解运行时数据区"></a>3.深入理解运行时数据区</h4><h5 id="3-1-测试代码"><a href="#3-1-测试代码" class="headerlink" title="3.1 测试代码"></a>3.1 测试代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> k = (i + j) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.calculate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    使用javac工具编译Test.java类生成Test.class，并且使用javap工具反编译Test.class字节码可以看到calculate()方法字节码如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-746ab13e44623df7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="calculate字节码.png"></p>
<p>​    从图中可以看到calculate()方法被反编结果包含两个部分: 一个是“行号”，用于程序计数器指引下一行机器需要执行的指令；另一个是字节码指令，用于虚拟机翻译成机器码执行的指令代码。</p>
<p>​    因此，java代码执行是基于字节码指令；而C代码执行是基于寄存器。虽然基于寄存器的代码执行效率会高一点，但是可移植性会很差，不同平台不容易移植；而基于字节码指令的java代码，基于不同平台，只要虚拟机支持，java代码可以无缝移植。</p>
<h5 id="3-2-运行时数据区执行过程"><a href="#3-2-运行时数据区执行过程" class="headerlink" title="3.2 运行时数据区执行过程"></a>3.2 运行时数据区执行过程</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-c847ec8dfa478c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时数据区.png"></p>
<p><strong>对应的执行过程说明如下</strong>：</p>
<p>0: iconst_1  -&gt; 将int型 1 入操作数栈<br>1: istore_1  -&gt; 将操作数栈栈顶int型值存入局部变量表(下标为1的位置)<br>2: iconst_2 -&gt; 将int型 2 入操作数栈<br>3: istore_2 -&gt; 将操作数栈栈顶int型值存入局部变量表(下标为2的位置)<br>4: iload_1 -&gt; 将局部变量表中下标为1位置的值压入操作数栈<br>5: iload_2 -&gt; 将局部变量表中下标为2位置的值压入操作数栈<br>6: iadd      -&gt; (1)将栈顶两个元素出栈 (2)执行相加 (3)将结果压入操作数栈<br>7: bipush  10 -&gt; 将int型 10压入操作数栈<br>9: imul       -&gt; (1)将栈顶两个元素出栈 (2)执行相乘 (3)将结果压入操作数栈<br>10: istore_3   -&gt; 将操作数栈顶int型数值压入局部变量表(下标为3的位置)<br>11: iload_3   -&gt; 将局部变量表中下标为3位置的值压入操作数栈<br>12: ireturn   -&gt;  返回调用calculate方法的下一行地址继续执行</p>
<p><strong>参考资料</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">JVM参数参考说明</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用指令集</title>
    <url>/2021/07/02/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<h4 id="1-指令集"><a href="#1-指令集" class="headerlink" title="1.指令集"></a>1.指令集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 光标移到命令行最前端</span></span><br><span class="line">ctrl + A </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 光标移到命令行最后面</span></span><br><span class="line">ctrl + E</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前命令行指令</span></span><br><span class="line">ctrl + U</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有详情</span></span><br><span class="line">ls -all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看文件大小</span></span><br><span class="line">ls -lh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归查看文件夹内容</span></span><br><span class="line">ls -R</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看磁盘大小</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件属性介绍</span></span><br><span class="line">-rw-r--r--    1     root     root     0      Apr 25 20:33</span><br><span class="line">文件权限    软连接数  当前用户  用户组   文件大小    日期</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件权限</span></span><br><span class="line">- 【普通文件】 </span><br><span class="line">d 【目录】 </span><br><span class="line">l 【软链接（Win快捷方式】 </span><br><span class="line">c 【字符设备文件】 </span><br><span class="line">b 【块设备文件】 </span><br><span class="line">p 【管道】 </span><br><span class="line">s 【套接字】</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> root用户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> 普通用户</span></span><br><span class="line"></span><br><span class="line">chmod u+rwx 111.txt  第一组可读可写可执行【u当前用户 g当前组 o其他组 a代表所有组】</span><br><span class="line"></span><br><span class="line">adduser jack   添加名为jack这个组</span><br><span class="line">chown aaa 1.txt  把1.txt修改aaa当前用户组</span><br><span class="line">chgrp aaa 1.txt  将1.txt的组权限改成aaa同组</span><br><span class="line"></span><br><span class="line">tac倒序查看</span><br><span class="line">more 1.txt 分页查看</span><br><span class="line">head -2 1.txt 查看前两行</span><br><span class="line">tail -3 1.txt 查看后三行</span><br><span class="line"></span><br><span class="line">shift+zz  命令行模式退出</span><br><span class="line">u撤销</span><br><span class="line"></span><br><span class="line">i当前光标字符输入</span><br><span class="line">I当前光标所在行头</span><br><span class="line">a当前光标后一个字符输入</span><br><span class="line">A当前光标所在行尾输入</span><br><span class="line"></span><br><span class="line">h:左  j:下  k:右  l:上</span><br><span class="line">gg跳到第一行</span><br><span class="line">G调到最后一行</span><br><span class="line">：set number 查看行号</span><br><span class="line"><span class="meta">$</span><span class="bash">回到行尾部</span></span><br><span class="line">0回到行首</span><br><span class="line">dw删除单词</span><br><span class="line">dd删除本行</span><br><span class="line">yy复制光标所在行</span><br><span class="line">p粘贴到当前行</span><br><span class="line">P粘贴到下一行</span><br><span class="line"></span><br><span class="line">r+字符，替换光标当前字符</span><br><span class="line">：s  /123/456   当前所在行的123替换成456</span><br><span class="line">：1.6s /123/456/g 1—6行中123换成456</span><br><span class="line">：%s /123/456/g 全文123替换成456</span><br><span class="line"></span><br><span class="line">分屏：</span><br><span class="line">：vsp 左右分屏</span><br><span class="line">： sp上下分屏</span><br><span class="line">ctrl+ww 切换分屏</span><br><span class="line"></span><br><span class="line">echo $?  监测上一个命令是否执行成功，0为成功，其他为失败</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换字符串</span></span><br><span class="line">sed -i &quot;s/com.gxa.sdk/com.gxa.service/g&quot; `grep -rl &quot;com.gxa.sdk&quot; ./`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有进程</span></span><br><span class="line">PS -A</span><br></pre></td></tr></table></figure>


<h4 id="2-SHELL脚本"><a href="#2-SHELL脚本" class="headerlink" title="2. SHELL脚本"></a>2. SHELL脚本</h4><h5 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义变量(符号之间不能有空格)</span></span><br><span class="line">A=10</span><br><span class="line"></span><br><span class="line">echo A==$A</span><br></pre></td></tr></table></figure>


<h5 id="2-2-参数"><a href="#2-2-参数" class="headerlink" title="2.2 参数"></a>2.2 参数</h5><table>
<thead>
<tr>
<th>$0</th>
<th>当前脚本的文件名</th>
</tr>
</thead>
<tbody><tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td>$$</td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody></table>
<p>$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。</p>
<p>但是当它们被双引号(“ “)包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；”$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。<br>对于（””）双引号中带$符号的非参数前面必须加’ \ ‘</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打印当前路径,注意是大写</span></span><br><span class="line">echo PWD: $PWD</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取参数</span></span><br><span class="line">echo 当前shell脚本名称是: $0</span><br><span class="line">echo 参数一: $1</span><br><span class="line">echo 参数二: $2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看执行状态</span></span><br><span class="line"><span class="meta">if(($</span><span class="bash">?));<span class="keyword">then</span></span></span><br><span class="line">	echo 执行失败</span><br><span class="line">else</span><br><span class="line">	echo 执行成功</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看外界传入的参数</span></span><br><span class="line">echo 外界传入参数内容: $*</span><br><span class="line">echo 外界传入参数个数: $#</span><br></pre></td></tr></table></figure>


<h5 id="2-3-循环"><a href="#2-3-循环" class="headerlink" title="2.3 循环"></a>2.3 循环</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> seq 1 20是循环遍历1到20</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行命令使用``</span></span><br><span class="line">for i in `seq 1 20`</span><br><span class="line">do</span><br><span class="line">	echo &quot;the number:$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<h5 id="2-4-计算器工具"><a href="#2-4-计算器工具" class="headerlink" title="2.4 计算器工具"></a>2.4 计算器工具</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line">for f in `seq 1 100`</span><br><span class="line">do</span><br><span class="line">	a=`expr $f + $a`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;total: $a&quot;</span><br></pre></td></tr></table></figure>


<h5 id="2-5-查找文件并打包"><a href="#2-5-查找文件并打包" class="headerlink" title="2.5 查找文件并打包"></a>2.5 查找文件并打包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -czf output.tgz *.txt</span><br></pre></td></tr></table></figure>


<h5 id="2-6-读文件"><a href="#2-6-读文件" class="headerlink" title="2.6 读文件"></a>2.6 读文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"></span><br><span class="line">while read readline</span><br><span class="line">do</span><br><span class="line">	echo $readline</span><br><span class="line">done&lt;`pwd`/1.txt</span><br></pre></td></tr></table></figure>


<h5 id="2-7-shell函数"><a href="#2-7-shell函数" class="headerlink" title="2.7 shell函数"></a>2.7 shell函数</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function test01() &#123; </span><br><span class="line">	echo &quot;我是一个函数&quot; </span><br><span class="line">&#125; </span><br><span class="line">test01 # 调用此函数</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数里面是可以定义变量的，不要去考虑，堆，栈，弹栈，他就是脚本</span> </span><br><span class="line">function test02() &#123; </span><br><span class="line">    var1=&quot;Kevin&quot; </span><br><span class="line">    var2=&quot;Derry&quot; </span><br><span class="line">    echo $var1 </span><br><span class="line">    echo $var2 </span><br><span class="line">    echo &quot;我是一个函数&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数传递参数</span></span><br><span class="line">function test03() &#123; </span><br><span class="line">	echo &quot;我是一个函数，参数是:`expr $1`&quot; </span><br><span class="line">&#125; </span><br><span class="line">test03 99999 # 内置传递参数</span><br><span class="line"></span><br><span class="line">function test04() &#123; </span><br><span class="line">	echo &quot;我是一个函数，参数是:`expr $1`&quot; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">test04 $1 # 脚本配合    内置传递参数</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>指令集</tag>
      </tags>
  </entry>
  <entry>
    <title>RTMP与FFmpeg编译问题集</title>
    <url>/2021/07/29/RTMP%E4%B8%8EFFmpeg%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<h3 id="1-error-undefined-reference-to-‘av-version-info-’"><a href="#1-error-undefined-reference-to-‘av-version-info-’" class="headerlink" title="1.error: undefined reference to ‘av_version_info()’"></a>1.error: undefined reference to ‘av_version_info()’</h3><blockquote>
<p>出错原因：  ffmpeg是纯C的库，头文件没有做好C++调用的准备  用extern “C”{}套住ffmpeg头文件，用C 语言的编译规则来编译ffmpeg代码，就可以了</p>
<p>解决办法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/avutil.h&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-libavutil-log-c-186-error-undefined-reference-to-‘stderr’"><a href="#2-libavutil-log-c-186-error-undefined-reference-to-‘stderr’" class="headerlink" title="2.libavutil/log.c:186: error: undefined reference to ‘stderr’"></a>2.libavutil/log.c:186: error: undefined reference to ‘stderr’</h4><blockquote>
<p>出错原因：<br>代码中使用了大量的标准IO设备：stderr 等，这些在NDK15以后，这些都不被支持了，代码本身 没问题，只是编译器链接时找不到对应的静态库定义了； </p>
<p>解决方案：<br>在编译选项中添加语句-DANDROID_API=[你的android API版本号]即可；  比如我的测试手机为 android 5.1.1 对应 API = 22，编译选项中应该添加：-DANDROID_API=22<br>adb shell 获取 android 系统版本：   adb shell getprop ro.build.version.release adb shell 获取 android 系统 API 版本：   adb shell getprop ro.build.version.sdk</p>
</blockquote>
<h4 id="3-libavformat-utils-c-513-error-undefined-reference-to-‘av-parser-close’"><a href="#3-libavformat-utils-c-513-error-undefined-reference-to-‘av-parser-close’" class="headerlink" title="3.libavformat/utils.c:513: error: undefined reference to ‘av_parser_close’"></a>3.libavformat/utils.c:513: error: undefined reference to ‘av_parser_close’</h4><blockquote>
<p>出错原因：  链接静态库先后顺序不正确，引起的符号定义找不到。<br>解决方案： </p>
<ol>
<li><p>修改静态库的链接顺序。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">	native-lib </span><br><span class="line">	avfilter avformat avcodec avutil swresample swscale log</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>忽略静态库的链接顺序。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">    native-lib </span><br><span class="line">    -Wl,--start-group </span><br><span class="line">    avcodec avfilter avformat avutil swresample swscale -Wl,--end-group </span><br><span class="line">    log</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h4 id="4-libavformat-http-c-1649-error-undefined-reference-to-‘inflateEnd’"><a href="#4-libavformat-http-c-1649-error-undefined-reference-to-‘inflateEnd’" class="headerlink" title="4.libavformat/http.c:1649: error: undefined reference to ‘inflateEnd’"></a>4.libavformat/http.c:1649: error: undefined reference to ‘inflateEnd’</h4><blockquote>
<p>出错原因：  找不到的z库中的函数的实现。因为 ffmpeg 依赖了z库。编译ffmpeg的时候如果仔细看编译 时输出的日志，就可以看到   External libraries: zlib<br>解决方案：添加z库的依赖。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">    native-lib </span><br><span class="line">    -Wl,--start-group </span><br><span class="line">    avcodec avfilter avformat avutil swresample swscale -Wl,--end-group </span><br><span class="line">    log </span><br><span class="line">    z </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-libavformat-hls-c-845-error-undefined-reference-to-‘atof’"><a href="#5-libavformat-hls-c-845-error-undefined-reference-to-‘atof’" class="headerlink" title="5.libavformat/hls.c:845: error: undefined reference to ‘atof’"></a>5.libavformat/hls.c:845: error: undefined reference to ‘atof’</h3><blockquote>
<p>出错原因：<br>Google have moved some of the C standard library functions like atof() from being inline functions in header files to normal functions. The latest NDKs will default to building a .so that is only compatible with the latest Android devices that have the atof() function in the device’s standard C library (libc.so). This means if you run a library on an older device that has an older version of the C library, you will get an error loading the dll as the expected atof() function will not exist.<br>解决方案：  修改ffmpeg编译脚本，指定Android API版本为17，重新编译。 </p>
<p>这里又有一个问题：<br>libavcodec/v4l2_buffers.c:434:44: error: call to ‘mmap’ declared with attribute error: mmap is not available &gt; with _FILE_OFFSET_BITS=64 when using GCC until android-21. Either raise your minSdkVersion, disable &gt; _FILE_OFFSET_BITS=64, or switch to Clang.</p>
<p>所以21版本以下，需要取消 _FILE_OFFSET_BITS宏定义。添加编译参数：   -U_FILE_OFFSET_BITS</p>
</blockquote>
<h4 id="6-混合编译FFmpeg和Rtmp"><a href="#6-混合编译FFmpeg和Rtmp" class="headerlink" title="6.混合编译FFmpeg和Rtmp"></a>6.混合编译FFmpeg和Rtmp</h4><h5 id="6-1-下载最新库"><a href="#6-1-下载最新库" class="headerlink" title="6.1 下载最新库"></a>6.1 下载最新库</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载rtmp</span></span><br><span class="line">wget https:<span class="comment">//codeload.github.com/yixia/librtmp/zip/refs/heads/master</span></span><br><span class="line">unzip master</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 下载最新ffmpeg</span></span><br><span class="line">wget https:<span class="comment">//ffmpeg.org/releases/ffmpeg-4.2.2.tar.bz2</span></span><br><span class="line">tar -xvf ffmpeg-<span class="number">4.2</span><span class="number">.2</span>.tar.bz2</span><br></pre></td></tr></table></figure>


<h5 id="6-2-单编rtmp脚本"><a href="#6-2-单编rtmp脚本" class="headerlink" title="6.2 单编rtmp脚本"></a>6.2 单编rtmp脚本</h5><p>编译androideabi架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">export XCFLAGS=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=17&quot;</span><br><span class="line">export XLDFLAGS=&quot;--sysroot=$&#123;NDK_ROOT&#125;/platforms/android-17/arch-arm &quot;</span><br><span class="line">export CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi-</span><br><span class="line"></span><br><span class="line">make install SYS=android prefix=`pwd`/result CRYPTO= SHARED=  XDEF=-DNO_SSL </span><br></pre></td></tr></table></figure>


<p>编译arm64-v8a架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=aarch64-linux-android</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">export XCFLAGS=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=17&quot;</span><br><span class="line">export XLDFLAGS=&quot;--sysroot=$&#123;NDK_ROOT&#125;/platforms/android-17/arch-arm &quot;</span><br><span class="line">export CROSS_COMPILE=$TOOLCHAIN/bin/aarch64-linux-android-</span><br><span class="line"></span><br><span class="line">make install SYS=android prefix=`pwd`/result CRYPTO= SHARED=  XDEF=-DNO_SSL</span><br></pre></td></tr></table></figure>


<h5 id="6-2混编FFmpeg和rtmp"><a href="#6-2混编FFmpeg和rtmp" class="headerlink" title="6.2混编FFmpeg和rtmp"></a>6.2混编FFmpeg和rtmp</h5><p>6.2.1 修改configure文件</p>
<p>6.2.1.1 最新版本的ffmpeg默认使用clang编译，可以修改configure文件来关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">注释4210-4213行，关闭掉： </span><br><span class="line">4209 </span><br><span class="line">4210 #set_default target_os </span><br><span class="line">4211 #if test &quot;$target_os&quot; = android; then 4212 #   cc_default=&quot;clang&quot; </span><br><span class="line">4213 #fi </span><br><span class="line">4214</span><br></pre></td></tr></table></figure>
<p>6.2.1.2 由于ffmpeg 默认开启librtmp需要pkgconfig，这里我们手动关闭，修改ffmpeg的configure文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#注解掉6256行</span></span></span><br><span class="line">6254 enabled libpulse          &amp;&amp; require_pkg_config libpulse libpulse pulse/pulseaudio.h pa_context_new</span><br><span class="line">6255 enabled librsvg           &amp;&amp; require_pkg_config librsvg librsvg-2.0 librsvg-2.0/librsvg/rsvg.h rsvg_handle_render_cairo</span><br><span class="line">6256 # enabled librtmp           &amp;&amp; require_pkg_config librtmp librtmp librtmp/rtmp.h RTMP_Socket</span><br><span class="line">6257 enabled librubberband     &amp;&amp; require_pkg_config librubberband &quot;rubberband &gt;= 1.8.1&quot; rubberband/rubberband-c.h rubberband_new -lstdc++ &amp;&amp; append librubberband_extralibs &quot;-lstdc++&quot;</span><br><span class="line">6258 enabled libshine          &amp;&amp; require_pkg_config libshine shine shine/layer3.h shine_encode_buffer</span><br></pre></td></tr></table></figure>


<p>6.2.2 编译androideabi架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">ANDROID_API=17</span><br><span class="line"></span><br><span class="line">PREFIX=./android/armeabi-v7a/ffmpeg_rtmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rtmp路径</span></span><br><span class="line">RTMP=/root/KevinStudyNDK/MyFFmpeg3/librtmp/result</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-librtmp \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/$CPU- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC -I$RTMP/include&quot; \</span><br><span class="line">--extra-ldflags=&quot;-L$RTMP/lib&quot; \</span><br><span class="line">--extra-libs=&quot;-lrtmp&quot; \</span><br><span class="line">--arch=arm \</span><br><span class="line">--target-os=android </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>编译arm64-v8a架构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=aarch64-linux-android</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">ANDROID_API=21</span><br><span class="line"></span><br><span class="line">PREFIX=./android/arm64-v8a/ffmpeg_rtmp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">rtmp路径</span></span><br><span class="line">RTMP=/home/jackou/ndk/ffmpeg/librtmp-master/result</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-librtmp \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/$CPU- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm64 \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=arm64-v8a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC -I$RTMP/include&quot; \</span><br><span class="line">--extra-ldflags=&quot;-L$RTMP/lib&quot; \</span><br><span class="line">--extra-libs=&quot;-lrtmp&quot; \</span><br><span class="line">--arch=aarch64 \</span><br><span class="line">--target-os=android </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>6.2.3 集成到AS中CMakelist脚本</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入FFmpeg的头文件 </span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/ffmpeg/<span class="keyword">include</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入FFmpeg的库文件 </span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; - </span></span><br><span class="line"><span class="string">L$&#123;CMAKE_SOURCE_DIR&#125;/ffmpeg/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>) <span class="comment"># 导入Rtmp的库文件 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS  <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; - </span></span><br><span class="line"><span class="string">L$&#123;CMAKE_SOURCE_DIR&#125;/rtmp/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( </span><br><span class="line">    my-player </span><br><span class="line">    <span class="variable">$&#123;log-lib&#125;</span> </span><br><span class="line">    -Wl,</span><br><span class="line">    --start-group </span><br><span class="line">    avcodec avfilter avformat avutil swresample swscale -Wl,</span><br><span class="line">    --end-group </span><br><span class="line">    z </span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h4 id="7-搭建rtmp服务器"><a href="#7-搭建rtmp服务器" class="headerlink" title="7.搭建rtmp服务器"></a>7.搭建rtmp服务器</h4><h5 id="7-1-下载Nginx和rtmp-module"><a href="#7-1-下载Nginx和rtmp-module" class="headerlink" title="7.1 下载Nginx和rtmp-module"></a>7.1 下载Nginx和rtmp-module</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载Nginx</span></span><br><span class="line">wget http://nginx.org/download/nginx-1.15.3.tar.gz tar xvf nginx-1.15.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下载rtmp-module</span></span><br><span class="line">wget https://codeload.github.com/arut/nginx-rtmp-module/tar.gz/v1.2.1</span><br></pre></td></tr></table></figure>


<h5 id="7-2-执行配置和安装"><a href="#7-2-执行配置和安装" class="headerlink" title="7.2 执行配置和安装"></a>7.2 执行配置和安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成makefile</span></span><br><span class="line">./configure --prefix=./bin --add-module=../nginx-rtmp-module-1.2.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成结果在bin</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>成功之后，会在/bin下生成conf  html  logs  sbin几个文件。</p>
<h5 id="7-3-配置Nginx"><a href="#7-3-配置Nginx" class="headerlink" title="7.3 配置Nginx"></a>7.3 配置Nginx</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入到成果目录，并且配置nginx</span></span><br><span class="line">cd /bin/conf</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">启动nginx服务器就会报错，权限被拒绝</span></span><br><span class="line">user root;</span><br><span class="line"></span><br><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果启动错误，这个就是错误日志详情</span></span><br><span class="line">error_log logs/error.log debug;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">	worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;</span><br><span class="line">	server &#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">注意端口占用  流媒体服务器的端口</span></span><br><span class="line">		listen 1935;</span><br><span class="line">		</span><br><span class="line"><span class="meta">		#</span><span class="bash">如果不加，可能会失败</span></span><br><span class="line">		application myapp &#123;</span><br><span class="line">			live on;</span><br><span class="line"><span class="meta">			#</span><span class="bash">丢弃闲置5s的连接</span></span><br><span class="line">			drop_idle_publisher 5s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下面就是为了测试 http://139.224.136.101:8080/<span class="built_in">stat</span> 控制面板的意思</span></span><br><span class="line">http &#123;</span><br><span class="line">	server &#123;</span><br><span class="line"><span class="meta">		#</span><span class="bash">注意端口占用</span></span><br><span class="line">		listen 8080;</span><br><span class="line">		location /stat &#123;</span><br><span class="line">			rtmp_stat all;</span><br><span class="line">			rtmp_stat_stylesheet stat.xsl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /stat.xsl</span><br><span class="line">		&#123; </span><br><span class="line">			root /home/jackou/ndk/Nginx_RTMP/nginx-rtmp-module-1.2.1/;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /control</span><br><span class="line">		&#123; </span><br><span class="line">			rtmp_control all;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location /rtmp-publisher</span><br><span class="line">		&#123; </span><br><span class="line">			root /home/jackou/ndk/Nginx_RTMP/nginx-rtmp-module-1.2.1/test;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location / &#123;</span><br><span class="line">			root /home/jackou/ndk/Nginx_RTMP/nginx-rtmp-module-1.2.1/test/www;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-4-启动服务"><a href="#7-4-启动服务" class="headerlink" title="7.4 启动服务"></a>7.4 启动服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jackou@ubuntu:~/ndk/Nginx_RTMP/nginx-1.15.3$ sudo bin/sbin/nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:1935 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:8080 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] still could not bind()</span><br><span class="line"><span class="meta">#</span><span class="bash">端口被占用需要停止服务</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line">sudo bin/sbin/nginx -s stop</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启后输入如下域名查看是否启动成功</span></span><br><span class="line">http://139.224.136.101:8080/stat</span><br></pre></td></tr></table></figure>
<p>启动成功之后，就会出现这种情况，139.224.136.101是一个共有云服务器，需要自己买。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-19b73c7af1ac4eef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ngnix启动成功.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>RTMP</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>RTMP直播客户端部署</title>
    <url>/2021/07/31/RTMP%E7%9B%B4%E6%92%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="1-Rtmp下载与介绍"><a href="#1-Rtmp下载与介绍" class="headerlink" title="1.Rtmp下载与介绍"></a>1.Rtmp下载与介绍</h4><p>[1] <a href="http://rtmpdump.mplayerhq.hu/">http://rtmpdump.mplayerhq.hu/</a> 【rtmp官网】【LibRTMP】</p>
<p>[2] <a href="http://rtmpdump.mplayerhq.hu/download">http://rtmpdump.mplayerhq.hu/download</a> 【rtmp下载中心】 </p>
<p>[3] <a href="https://www.videolan.org/developers/x264.html">https://www.videolan.org/developers/x264.html</a> 【x264官网】</p>
<h4 id="2-RTMP基本调用流程"><a href="#2-RTMP基本调用流程" class="headerlink" title="2.RTMP基本调用流程"></a>2.RTMP基本调用流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-eb4452d80cdebebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RTMP基本调用流程.png"></p>
<p>推流：视频+音频<br>视频：Camera采集    –&gt; 封装(压缩) —&gt; rtmp包    —&gt; 发送服务器<br>音频：AudioRecord –&gt; 封装(压缩) —&gt; rtmp包    —&gt; 发送服务器 </p>
<h4 id="3-RtmpDump集成部署。"><a href="#3-RtmpDump集成部署。" class="headerlink" title="3.RtmpDump集成部署。"></a>3.RtmpDump集成部署。</h4><p>RTMPDump<br>是一个用来处理RTMP流媒体的开源工具包。  它能够单独使用进行RTMP的通信，  也可以集成到 FFmpeg中通过FFmpeg接口来使用RTMPDump。<br>源码下载：<a href="http://rtmpdump.mplayerhq.hu/download">http://rtmpdump.mplayerhq.hu/download</a> </p>
<p>在Android中可以直接借助NDK在JNI层调用RTMPDump来完成RTMP通信。<br>在根目录下提供了一个Makefile与一些.c源文件。这里的源文件将会编译出一系列的可执行文件。 然后我们需要的并不是可执行文件，真正的对RTMP的实现都在librtmp子目录中。在这个子目录 中同样包含了一个Makefile文件。通过阅读Makefile发现，它的源码并不多:OBJS=rtmp.o log.o amf.o hashswf.o parseurl.o。因此我们不进行预编译，即直接放入AS中借助CMakeLists.txt来进 行编译。这么做可以让我们方便的对库本身进行调试或修改(实际上我们确实会稍微修改这个库的 源码)。</p>
<h4 id="4-X264交叉编译与集成部署"><a href="#4-X264交叉编译与集成部署" class="headerlink" title="4. X264交叉编译与集成部署"></a>4. X264交叉编译与集成部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://code.videolan.org/videolan/x264.git</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--disable-cli   # disable cli Android用不了，直接关掉</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">CPU=arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/$CPU-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">ANDROID_API=17</span><br><span class="line"></span><br><span class="line">PREFIX=./android/armeabi-v7a</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-cli \</span><br><span class="line">--enable-static \</span><br><span class="line">--enable-pic \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/$CPU- \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-$ANDROID_API/arch-arm \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=$ANDROID_API -U_FILE_OFFSET_BITS -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC -I$RTMP/include&quot; \</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译全包</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">NDK=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">configure()</span><br><span class="line">&#123;</span><br><span class="line">    CPU=$1</span><br><span class="line">    PREFIX=$(pwd)/android/$CPU</span><br><span class="line">    HOST=&quot;&quot;</span><br><span class="line">    CROSS_PREFIX=&quot;&quot;</span><br><span class="line">    SYSROOT=&quot;&quot;</span><br><span class="line">    if [ &quot;$CPU&quot; == &quot;armv7-a&quot; ]</span><br><span class="line">    then</span><br><span class="line">        HOST=arm-linux</span><br><span class="line">        SYSROOT=$NDK/platforms/android-21/arch-arm/</span><br><span class="line">        CROSS_PREFIX=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-</span><br><span class="line">    else</span><br><span class="line">        HOST=aarch64-linux</span><br><span class="line">        SYSROOT=$NDK/platforms/android-21/arch-arm64/</span><br><span class="line">        CROSS_PREFIX=$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-</span><br><span class="line">    fi</span><br><span class="line">    ./configure \</span><br><span class="line">    --prefix=$PREFIX \</span><br><span class="line">    --host=$HOST \</span><br><span class="line">    --enable-pic \</span><br><span class="line">    --disable-cli \</span><br><span class="line">    --enable-static \</span><br><span class="line">    --enable-neon \</span><br><span class="line">    --extra-cflags=&quot;-isysroot $NDK/sysroot -isystem $NDK/sysroot/usr/include/aarch64-linux-android -fPIE -pie&quot; \</span><br><span class="line">    --extra-ldflags=&quot;-fPIE -pie&quot; \</span><br><span class="line">    --cross-prefix=$CROSS_PREFIX \</span><br><span class="line">    --sysroot=$SYSROOT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build()</span><br><span class="line">&#123;</span><br><span class="line">    make clean</span><br><span class="line">    cpu=$1</span><br><span class="line">    echo &quot;build $cpu&quot;</span><br><span class="line"></span><br><span class="line">    configure $cpu</span><br><span class="line">    #-j&lt;CPU核心数&gt;</span><br><span class="line">    make -j4</span><br><span class="line">    make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build arm64</span><br><span class="line">build armv7-a</span><br></pre></td></tr></table></figure>


<h4 id="5-faac交叉编译"><a href="#5-faac交叉编译" class="headerlink" title="5.faac交叉编译"></a>5.faac交叉编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载地址</span></span><br><span class="line">wget https://udomain.dl.sourceforge.net/project/faac/faac-src/faac-1.29/faac-1.29.9.2.tar.gz</span><br></pre></td></tr></table></figure>
<p>编译arm-v7a库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个是最终输出成功的路径</span></span><br><span class="line">PREFIX=`pwd`/android/armeabi-v7a</span><br><span class="line"></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi</span><br><span class="line"></span><br><span class="line">FLAGS=&quot;-isysroot $NDK_ROOT/sysroot -isystem $NDK_ROOT/sysroot/usr/include/arm-linux-androideabi -D__ANDROID_API__=17 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -std=c++11 -O0 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">export CC=&quot;$CROSS_COMPILE-gcc --sysroot=$NDK_ROOT/platforms/android-17/arch-arm&quot;</span><br><span class="line">export CFLAGS=&quot;$FLAGS&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--with-pic \</span><br><span class="line">--enable-shared=no  </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>编译arm64-v8a库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">NDK=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line">API=28</span><br><span class="line"></span><br><span class="line">echo &quot;开始编译中 NDK=$NDK&quot;</span><br><span class="line"></span><br><span class="line">CPU=armv8-a</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64</span><br><span class="line">CROSS_COMPILE=$TOOLCHAIN/bin/aarch64-linux-android</span><br><span class="line">PREFIX=$(pwd)/android3/$CPU</span><br><span class="line"></span><br><span class="line">FLAGS=&quot;-isysroot $NDK/sysroot -isystem $NDK/sysroot/usr/include/aarch64-linux-android -march=$CPU -O0 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">export CC=&quot;$CROSS_COMPILE-gcc --sysroot=$NDK/platforms/android-$API/arch-arm64&quot;</span><br><span class="line">export CFLAGS=&quot;$FLAGS&quot;</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--host=aarch64-linux \</span><br><span class="line">--with-pic \</span><br><span class="line">--enable-shared=no  </span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p><strong>RTMPPacket数据包有两个类型</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>第一字节标注位</th>
<th>第二字节标注位</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>解码信息</td>
<td>0xAF</td>
<td>0x00</td>
<td>解码数据</td>
</tr>
<tr>
<td>音频数据</td>
<td>0xAF</td>
<td>0x01</td>
<td>音频数据</td>
</tr>
</tbody></table>
<h5 id="5-1-Audio-Tag"><a href="#5-1-Audio-Tag" class="headerlink" title="5.1 Audio Tag"></a>5.1 Audio Tag</h5><blockquote>
<p><strong>AF双声道</strong>：<br>十六进制：0xAF ===&gt;  二进制对比下图：1010 1111<br>1010 ==&gt; 十进制等于10 ==&gt; AAC<br>11 ==&gt; 十进制等于3 ===&gt; 3 = 44-kHz(对于AAC来说，该字段总是3)<br>1 ==&gt; 十进制等于1 ===&gt; 1 = snd16Bit(对于压缩过的音频来说，一般都是16bit) 1 ==&gt; 十进制等于1 ===&gt; 1 = sndStereo(对于AAC，总是1)双声道</p>
</blockquote>
<blockquote>
<p><strong>AE单声道</strong>：<br>十六进制：0xAE ===&gt;  二进制对比下图：1010 1110<br>1010 ==&gt; 十进制等于10 ==&gt; AAC<br>11 ==&gt; 十进制等于3 ===&gt; 3 = 44-kHz(对于AAC来说，该字段总是3)<br>1 ==&gt; 十进制等于1 ===&gt; 1 = snd16Bit(对于压缩过的音频来说，一般都是16bit) 0 ==&gt; 十进制等于0 ===&gt; 0 = sndMono单声道</p>
</blockquote>
<table>
<thead>
<tr>
<th>字段</th>
<th>占位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SoundFormat</td>
<td>4</td>
<td>音频数据格式值：<br>0 = Linear PCM, platform endian <br>1 = ADPCM <br>2 = MP3 <br>3 = Linear PCM, little endian <br>4 = Nellymoser 16-kHz mono <br>5 = Nellymoser 8-kHz mono <br>6 = Nellymoser <br>7 = G.711 A-law logarithmic PCM <br>8 = G.711 mu-law logarithmic PCM <br>9 = reserved <br>10 = AAC <br>11 = Speex <br>14 = MP3 8-kHz <br>15 = Device-speciﬁc sound</td>
</tr>
<tr>
<td>SoundRate</td>
<td>2</td>
<td>音频采样率值： <br>0 = 5.5-kHz <br>1 = 11-kHz <br>2 = 22-kHz <br>3 = 44-kHz(对于AAC来说，该字段总是3)</td>
</tr>
<tr>
<td>SoundSize</td>
<td>1</td>
<td>采样长度值： <br>0 = snd9Bit <br>1 = snd16Bit(对于压缩过的音频来说，一般都是16bit</td>
</tr>
<tr>
<td>SoundType</td>
<td>1</td>
<td>音频类型(单声道还是双声道)值：<br> 0 = sndMono 单声道 <br>1 = sndStereo(对于AAC，总是1) 双声道</td>
</tr>
<tr>
<td>SoundData</td>
<td>n</td>
<td>音频数据部分（AAC则需要参考下面AACAUDIODA 分）</td>
</tr>
</tbody></table>
<h5 id="5-2-AACAUDIODATA"><a href="#5-2-AACAUDIODATA" class="headerlink" title="5.2 AACAUDIODATA"></a>5.2 AACAUDIODATA</h5><table>
<thead>
<tr>
<th>字段</th>
<th>字节</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AACPacketType</td>
<td>1</td>
<td>0：AAC 序列头 1：AAC 数据</td>
</tr>
<tr>
<td>Data</td>
<td>n</td>
<td>如果AACPacketType==0参考下面的 AudioSpeciﬁcConﬁg;<br>如果AACPacketType==1， AAC原始音频数据</td>
</tr>
</tbody></table>
<p>AudioSpecificConfig</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>占位符</th>
</tr>
</thead>
<tbody><tr>
<td>audioObjectType</td>
<td>5</td>
</tr>
<tr>
<td>samplingFrequencyIndex</td>
<td>4</td>
</tr>
<tr>
<td>channelConﬁguration</td>
<td>4</td>
</tr>
<tr>
<td>frameLengthFlag</td>
<td>1</td>
</tr>
<tr>
<td>dependsOnCoreCoder</td>
<td>1</td>
</tr>
<tr>
<td>extensionFlag</td>
<td>1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava原理(一) -- 响应式编程核心思想的实现</title>
    <url>/2021/01/27/Rxjava%E5%8E%9F%E7%90%86-%E4%B8%80-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="1-Rxjava的使用"><a href="#1-Rxjava的使用" class="headerlink" title="1.Rxjava的使用"></a>1.Rxjava的使用</h4><p>​    关于Rxjava的使用，网上有太多太多，我这里把所有操作符汇总出来，大家有需要了解的自行查找用法，当然我也写了一点点使用方法，在文后的github链接中，这篇文章主要是想写写自己在学习Rxjava中做的笔记，希望能理解得更深刻。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ff7af6f6bb4f9d6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rxjava操作符汇总.png"></p>
<p>详细的使用方法文档传送门：<a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#109;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#109;</a>:oujie123/UnderstandingOfRxJava.git</p>
<h4 id="2-Rxjava思想"><a href="#2-Rxjava思想" class="headerlink" title="2.Rxjava思想"></a>2.Rxjava思想</h4><p>​    任何需求只有一个起点和一个终点，起点开始流向一个”事件”，”事件”经过处理之后最终流向终点，期间事件的处理可以分为很多步骤，处理的过程和终点只关心上一个过程的结果。在订阅之前的流程称之为<strong>上游</strong>，在订阅之后的流程称之为<strong>下游</strong>。</p>
<h4 id="3-Rxjava的hook点"><a href="#3-Rxjava的hook点" class="headerlink" title="3.Rxjava的hook点"></a>3.Rxjava的hook点</h4><p>​    在看源码之前，多看几个api，细心的朋友都会看到在<strong>每个API返回</strong>的之后都会有RxJavaPlugins.onAssembly()方法。他的作用是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//io.reactivex.plugins.RxJavaPlugins类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(<span class="meta">@NonNull</span> Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下onObservableAssembly为null，导致if语句不起作用。那么Rxjava设计这个有什么用呢？他的主要用途就是用于hook每一次调用。注意，这个方法会在<strong>每一个API</strong>最后中调用，意味着每一个Rxjava的方法都会经历这个方法。所以就可以通过这个方法来hook开发者的每一次调用。那么使用方法是怎样的呢？、</p>
<p>可以通过一下方法设置一个处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setOnObservableAssembly</span><span class="params">(<span class="meta">@Nullable</span> Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; onObservableAssembly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockdown) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Plugins can&#x27;t be changed anymore&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RxJavaPlugins.onObservableAssembly = onObservableAssembly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply中可以加入自己想实现的代码</span></span><br><span class="line">RxJavaPlugins.setOnObservableAssembly(<span class="keyword">new</span> Function&lt;io.reactivex.Observable, io.reactivex.Observable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> io.reactivex.<span class="function">Observable <span class="title">apply</span><span class="params">(io.reactivex.Observable observable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.i(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;api of rxjava is invoked ！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> observable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>


<h4 id="4-Rxjava核心实现"><a href="#4-Rxjava核心实现" class="headerlink" title="4.Rxjava核心实现"></a>4.Rxjava核心实现</h4><p>首先列出基本代码，其他的操作符都是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回Observable&lt;String&gt;  真实的是ObservaleCreate&lt;String&gt;()</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ObservaleCreate.map</span></span><br><span class="line">.map(<span class="keyword">new</span> Function&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Bitmap <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ObservableMap.subscribe()</span></span><br><span class="line"> .subscribe(<span class="keyword">new</span> Observer&lt;Bitmap&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>分析分为3步：</strong></p>
<ul>
<li>创建Observer，就是new一个接口 自定义观察者 </li>
<li>创建Observable</li>
<li>subscribe订阅过程</li>
</ul>
<h5 id="4-1-创建观察者"><a href="#4-1-创建观察者" class="headerlink" title="4.1 创建观察者"></a>4.1 创建观察者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当订阅成功后回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(<span class="meta">@NonNull</span> Disposable d)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发者调用onNext回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="meta">@NonNull</span> T t)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通知观察者发生异常时回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理结束回调</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察者的创建就是创建一个回调实现，用于接收上游传下来的事件结果。</p>
<h5 id="4-2-创建Observable"><a href="#4-2-创建Observable" class="headerlink" title="4.2 创建Observable"></a>4.2 创建Observable</h5><p>调用流程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e4471d4f36c96294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建Observable.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步调用create方法，传入自定义source</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;novel1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//创建ObservableCreate封装自定义source</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">&quot;source is null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="comment">//最终用ObservableCreate包裹了自定义source（ObservableOnSubscribe接口）</span></span><br></pre></td></tr></table></figure>


<h5 id="4-3-subscribe订阅过程"><a href="#4-3-subscribe订阅过程" class="headerlink" title="4.3 subscribe订阅过程"></a>4.3 subscribe订阅过程</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-d181dee45f600e7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="订阅过程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.当subscribe()一被调用，Observable的subscribe()方法会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">		<span class="comment">// 调入子类</span></span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.调用子类ObservaleCreate的subscribeActual方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 创建发射器包裹自定义的观察者</span></span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">    	<span class="comment">// 调用观察者的onSubscribe订阅回调</span></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 上述创建的自定义source，即ObservableOnSubscribe</span></span><br><span class="line">            <span class="comment">// 调用ObservableOnSubscribe的subscribe传入自定义观察者</span></span><br><span class="line">            <span class="comment">// 开发者调用发射器的onNext()就会调到自定义观察者的onNext()中</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-4-原理图"><a href="#4-4-原理图" class="headerlink" title="4.4 原理图"></a>4.4 原理图</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-1800bb5ccf2c82e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rxjava原理图.png"></p>
<h4 id="5-标准观察者模式和Rxjava的变异观察者模式有哪些区别"><a href="#5-标准观察者模式和Rxjava的变异观察者模式有哪些区别" class="headerlink" title="5.标准观察者模式和Rxjava的变异观察者模式有哪些区别"></a>5.标准观察者模式和Rxjava的变异观察者模式有哪些区别</h4><p>​    <strong>在标准的观察者模式</strong>，是一个“被观察者”，多个“观察者”，当被观察者有事件通知的时候，所有观察者都会收到；在标准的观察者设计模式中：当发出通知改变时，会遍历Observable里面的容器，此容器里面有10个Observer，就会通知10个Observer<br>​    <strong>rxjava的观察者模式</strong>是多个“被观察者”，一个“观察者”，需要起点和终点订阅一次之后，但发出改变通知，观察者才能看到。在RxJava观察者设计模式中：分发事件时，会拿到发射器，通过发射器关联到我们自定义的Observer，发射器调用到我们自定义的Observer</p>
<h4 id="6-在创建类操作符中create和just的区别"><a href="#6-在创建类操作符中create和just的区别" class="headerlink" title="6.在创建类操作符中create和just的区别"></a>6.在创建类操作符中create和just的区别</h4><p>​    just内部封装了一个run方法，自动执行了，observer.onNext()</p>
<p>​    create需要程序员去调用createEmitter.onNext（）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava原理(二) -- 线程调度</title>
    <url>/2021/01/27/Rxjava%E5%8E%9F%E7%90%86-%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="1-创建线程池和线程管理策略分析"><a href="#1-创建线程池和线程管理策略分析" class="headerlink" title="1. 创建线程池和线程管理策略分析"></a>1. 创建线程池和线程管理策略分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在开发中使用Rxjava来完成线程切换会调用到以下方法(还有几个就不一一列举了，原理一样的)，那么就从这里开始分析</span></span><br><span class="line">Schedulers.io()</span><br><span class="line">Schedulers.computation()</span><br><span class="line">Schedulers.newThread()</span><br><span class="line">AndroidSchedulers.mainThread()</span><br></pre></td></tr></table></figure>
<p>当我们调用以上方法中的任意一个，都会调到Schedulers类中，Schedulers使用策略模式封装了所有线程切换策略(因此后面以io()分析)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Schedulers类中，静态创建IOTask(),当调用Schedulers.io()的时候，就是返回这个Callable.</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    SINGLE = RxJavaPlugins.initSingleScheduler(<span class="keyword">new</span> SingleTask());</span><br><span class="line"></span><br><span class="line">    COMPUTATION = RxJavaPlugins.initComputationScheduler(<span class="keyword">new</span> ComputationTask());</span><br><span class="line"></span><br><span class="line">    IO = RxJavaPlugins.initIoScheduler(<span class="keyword">new</span> IOTask());</span><br><span class="line"></span><br><span class="line">    TRAMPOLINE = TrampolineScheduler.instance();</span><br><span class="line"></span><br><span class="line">    NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(<span class="keyword">new</span> NewThreadTask());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建IoScheduler</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Scheduler</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Scheduler <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> IoHolder.DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IoHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> IoScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IoScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.pool = <span class="keyword">new</span> AtomicReference&lt;CachedWorkerPool&gt;(NONE);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// CachedWorkerPool任务池，里面持有任务队列和线程池</span></span><br><span class="line">        CachedWorkerPool update = <span class="keyword">new</span> CachedWorkerPool(KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT, threadFactory);</span><br><span class="line">        <span class="keyword">if</span> (!pool.compareAndSet(NONE, update)) &#123;</span><br><span class="line">            update.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. CachedWorkerPool构造方法中创建线程池，并且暴露get()提供需要执行的任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedWorkerPool</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;ThreadWorker&gt; expiringWorkerQueue;</span><br><span class="line">        <span class="keyword">final</span> CompositeDisposable allWorkers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService evictorService;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;?&gt; evictorTask;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">       CachedWorkerPool(<span class="keyword">long</span> keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (unit != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建线程池</span></span><br><span class="line">                evictor = Executors.newScheduledThreadPool(<span class="number">1</span>, EVICTOR_THREAD_FACTORY);</span><br><span class="line">                task = evictor.scheduleWithFixedDelay(<span class="keyword">this</span>, <span class="keyword">this</span>.keepAliveTime, <span class="keyword">this</span>.keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="function">ThreadWorker <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            .....</span><br><span class="line">            <span class="keyword">while</span> (!expiringWorkerQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 任务队列不为空，从队列中取一个并返回</span></span><br><span class="line">                ThreadWorker threadWorker = expiringWorkerQueue.poll();</span><br><span class="line">                <span class="keyword">if</span> (threadWorker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> threadWorker;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果任务队列是空的，就创建一个并返回</span></span><br><span class="line">            ThreadWorker w = <span class="keyword">new</span> ThreadWorker(threadFactory);</span><br><span class="line">            allWorkers.add(w);</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>用一张图可能说明得比较清楚一些。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2ef68b88cc6ebe82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Schedulers调度过程.png"></p>
<h4 id="2-Rxjava上游任务在子线程中执行分析"><a href="#2-Rxjava上游任务在子线程中执行分析" class="headerlink" title="2. Rxjava上游任务在子线程中执行分析"></a>2. Rxjava上游任务在子线程中执行分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上游线程切换使用过程</span></span><br><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  <span class="comment">// ObservableCreate.subscribeOn</span></span><br><span class="line">  .subscribeOn(Schedulers.io())</span><br><span class="line">  <span class="comment">// ObservableSubscribeOn.subscribe</span></span><br><span class="line">  .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">		......</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>从上面使用过程的代码看下面的图，分析Rxjava封装任务和抛任务到线程池的过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-02cfb7c0fb8d2e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上游任务在线程池执行流程图.png"></p>
<p>当我们一订阅(调用subscribe(Observer)方法)的时候，Rxjava将会把上游需要执行的任务和下游的观察者经过层层包裹，包裹好之后，就会得到一个<strong>Scheduler.Worker任务对象</strong>。当调用发射器的onNext的方式的时候，结合第一小节的图片，ObservableSubscribeOn就会将任务抛到线程池执行，在子线程中执行任务并且返回，从而完成线程切换功能。</p>
<h4 id="3-Rxjava下游任务在主线程中执行分析"><a href="#3-Rxjava下游任务在主线程中执行分析" class="headerlink" title="3. Rxjava下游任务在主线程中执行分析"></a>3. Rxjava下游任务在主线程中执行分析</h4><h5 id="3-1-创建AndroidSchedulers-mainThread的过程"><a href="#3-1-创建AndroidSchedulers-mainThread的过程" class="headerlink" title="3.1 创建AndroidSchedulers.mainThread的过程"></a>3.1 创建AndroidSchedulers.mainThread的过程</h5><p>如第一节Schedulers的创建流程一样，当调用AndroidSchedulers.mainThread()之后，最终会创建HandlerScheduler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建HandlerScheduler，并且传入MainLooper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建HandlerScheduler</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(</span><br><span class="line">            <span class="keyword">new</span> Callable&lt;Scheduler&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Scheduler <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> MainHolder.DEFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">mainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.当创建任务的时候，创建HandlerWorker</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    HandlerScheduler(Handler handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HandlerWorker(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.当执行任务的时候</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line">    </span><br><span class="line">        HandlerWorker(Handler handler) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">			<span class="comment">// 包装任务</span></span><br><span class="line">            run = RxJavaPlugins.onSchedule(run);</span><br><span class="line">            ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 创建Message包装任务</span></span><br><span class="line">            Message message = Message.obtain(handler, scheduled);</span><br><span class="line">            message.obj = <span class="keyword">this</span>; </span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 发送任务到MainLooper中，该任务就在主线程中执行了</span></span><br><span class="line">            handler.sendMessageDelayed(message, Math.max(<span class="number">0L</span>, unit.toMillis(delay)));</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> scheduled;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实真正将任务放在主线程中执行就是上面三个步骤，但是Rxjava增加了很多其他功能，例如解除订阅(将任务包装在Disposable中)，增加hook功能(在任务外面在包装了ScheduledRunnable)等等，其最内层的本质就是我们需要执行的任务。细化的包裹情况如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7cbfa0616acdf0ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主线程执行任务.png"></p>
<h4 id="4-多个线程切换，以哪个为准"><a href="#4-多个线程切换，以哪个为准" class="headerlink" title="4.多个线程切换，以哪个为准"></a>4.多个线程切换，以哪个为准</h4><p>如下面代码，我们作死得切换线程，那么哪些线程会最终执行我们的任务呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        e.onNext(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .subscribeOn(Schedulers.io())    <span class="comment">// 上游切换，靠近上游的生效</span></span><br><span class="line">  .subscribeOn(Schedulers.newThread())</span><br><span class="line">  .subscribeOn(Schedulers.computation())</span><br><span class="line">  </span><br><span class="line">  .observeOn(Schedulers.io())</span><br><span class="line">  .observeOn(Schedulers.computation())</span><br><span class="line">  .observeOn(AndroidSchedulers.mainThread())  <span class="comment">// 下游切换，靠近下游的生效</span></span><br><span class="line">  .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">	  ......</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以从第二节和第三节看出，当我们<strong>每调用一次subscribeOn方法</strong>，<strong>上游</strong>就会多包装一层Scheduler，在订阅之后，解包裹的时候越靠近“待执行任务”的subscribeOn越后解包，所以最靠近任务的subscribeOn调用会是最终被执行，也就是最终被执行的线程。</p>
<p>因此我们可以总结得到：</p>
<p><strong>总结一： 在多次调用线程切换的时候，第一次调用subscribeOn的线程切换会是最后执行任务的线程；最后调用observeOn切换的线程会是最后执行的线程。</strong></p>
<p><strong>总结二：从调用关系来看，越靠近上游的线程切换，将是最终执行任务的线程；越靠近下游的线程切换，将是最终执行任务的线程。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装工具篇</title>
    <url>/2021/02/09/Ubuntu%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%E7%AF%87/</url>
    <content><![CDATA[<h3 id="1-安装VMware-Tools"><a href="#1-安装VMware-Tools" class="headerlink" title="1.安装VMware Tools"></a>1.安装VMware Tools</h3><p>1.1 选择安装/重新安装VMware tools</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-aee2d7937bb7cc4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装或者重新安装VMtools.png"></p>
<p><strong>1.2 VMware会自动下载最新的安装包</strong>(默认会在以下目录：/media/&lt;你的用户名&gt;/VMware Tools)</p>
<p><strong>1.3 进入安装包目录</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-97f9b808e074b119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装包目录.png"></p>
<p><strong>1.4 解压安装包</strong>(指令：tar -zxvf VMwareTools-10.2.5-8068393.tar.gz)</p>
<p>如果报以下错误：<strong>chmod: changing permissions of ‘VMwareTools-10.2.5-8068393.tar.gz’: Read-only file system</strong></p>
<p>使用以下指令，将压缩包解压到可写目录即可：tar -zxvf VMwareTools-10.2.5-8068393.tar.gz -C  /home/jackou/Desktop</p>
<p><strong>1.5 进入vmware-tools-distrib然后运行./vmware-install.pl 按默认安装一直回车到底即可。</strong>、</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-9efd8917947dda3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装.png"></p>
<p><strong>1.6 安装成功</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b96be5c744b247a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装成功.png"></p>
<h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git </span><br><span class="line">git config -–global user.email “test<span class="meta">@test</span>.com” </span><br><span class="line">git config -–global user.name “test”</span><br></pre></td></tr></table></figure>


<h3 id="3-安装CURL"><a href="#3-安装CURL" class="headerlink" title="3.安装CURL"></a>3.安装CURL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>


<h3 id="4-安装repo"><a href="#4-安装repo" class="headerlink" title="4.安装repo"></a>4.安装repo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br><span class="line">curl https:<span class="comment">//storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span></span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>


<h3 id="5-安装python3-6"><a href="#5-安装python3-6" class="headerlink" title="5.安装python3.6"></a>5.安装python3.6</h3><p>如果使用下面的被拒绝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:jonathonf/python-<span class="number">3.6</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python3<span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>请使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python3<span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>不关需要安装python3.6，还需要安装pip和python3.6-dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装pip</span><br><span class="line">wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py  --no-check-certificate</span><br><span class="line">python3 get-pip.py</span><br><span class="line">     </span><br><span class="line">#安装python3.6-dev</span><br><span class="line">apt-get install python3.6-dev</span><br></pre></td></tr></table></figure>


<h3 id="6-安装open-jdk"><a href="#6-安装open-jdk" class="headerlink" title="6.安装open-jdk"></a>6.安装open-jdk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubunt下NDK编译手顺</title>
    <url>/2021/07/10/Ubunt%E4%B8%8BNDK%E7%BC%96%E8%AF%91%E6%89%8B%E9%A1%BA/</url>
    <content><![CDATA[<h4 id="1-安装sz和rz"><a href="#1-安装sz和rz" class="headerlink" title="1.安装sz和rz"></a>1.安装sz和rz</h4><blockquote>
<p>root 账号登陆后，依次执行以下命令：<br>wget <a href="http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz">http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</a><br>tar zxvf lrzsz-0.12.20.tar.gz<br>cd lrzsz-0.12.20<br>./configure &amp;&amp; make &amp;&amp; make install</p>
</blockquote>
<blockquote>
<p>上面安装过程默认把lsz和lrz安装到了/usr/local/bin/目录下，现在我们并不能直接使用， 下面创建软链接，并命名为rz/sz：<br>cd /usr/local/bin 【安装到这里来】<br>ln -s /usr/local/bin/lrz rz 【设置快捷方式    相当于win】<br>ln -s /usr/local/bin/lsz sz 【设置快捷方式    相当于win】</p>
</blockquote>
<h4 id="2-下载NDK"><a href="#2-下载NDK" class="headerlink" title="2.下载NDK"></a>2.下载NDK</h4><blockquote>
<p>//下载<br>wget <a href="https://dl.google.com/android/repository/android-ndk-r17c-linux-x86_64.zip">https://dl.google.com/android/repository/android-ndk-r17c-linux-x86_64.zip</a>? hl=zh_cn</p>
<p>//改名字<br>mv android-ndk-r17c-linux-x86_64.zip?hl=zh_cn  android-ndk-r17c-linux- x86_64.zip</p>
<p>// 解压<br>unzip android-ndk-r17c-linux- x86_64.zip</p>
</blockquote>
<h4 id="3-交叉编译"><a href="#3-交叉编译" class="headerlink" title="3.交叉编译"></a>3.交叉编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc</span></span><br><span class="line">export NDK_GCC=&quot;/home/jackou/tools/android-ndk-r17c/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-gcc&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --sysroot=路径（自动寻找    头文件，库文件.h/.a/.so）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -isystem 路径（自动寻找    头文件）</span></span><br><span class="line">export GCC_PATH=&quot;--sysroot=/home/jackou/tools/android-ndk-r17c/platforms/android-21/arch-arm64 -isystem /home/jackou/tools/android-ndk-r17c/sysroot/usr/include -isystem /home/jackou/tools/android-ndk-r17c/sysroot/usr/include/aarch64-linux-android&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_GCC -pie <span class="variable">$GCC_PATH</span> main.c -o mainexe</span></span><br></pre></td></tr></table></figure>


<h4 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4.配置环境变量"></a>4.配置环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">vim /etc/profile</span></span><br><span class="line"></span><br><span class="line">export NDK=&quot;/home/jackou/tools/android-ndk-r17c&quot;</span><br><span class="line"></span><br><span class="line">export PATH=$NDK:$PATH</span><br><span class="line"></span><br><span class="line">export NDK_GCC_arm_64=&quot;$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android-gcc&quot;</span><br><span class="line"></span><br><span class="line">export NCK_CFIG_arm_64=&quot;--sysroot=$NDK/platforms/android-21/arch-arm64 -isystem $NDK/sysroot/usr/include -isystem $NDK/sysroot/usr/include/aarch64-linux-android&quot;</span><br></pre></td></tr></table></figure>


<h4 id="5-编译动态库"><a href="#5-编译动态库" class="headerlink" title="5.编译动态库"></a>5.编译动态库</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get.h 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;studio.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;get.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">666</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_GCC_arm_64 <span class="variable">$NCK_CFIG_arm_64</span> -fPIC -shared get.c -o libgetndk.so</span></span><br></pre></td></tr></table></figure>


<h4 id="6-编译静态库"><a href="#6-编译静态库" class="headerlink" title="6.编译静态库"></a>6.编译静态库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置环境</span></span><br><span class="line">export NDK_AR_arm_64=&quot;$NDK/toolchains/aarch64-linux-android-4.9/prebuilt/linux- x86_64/bin/aarch64-linux-android-ar&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成目标文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_GCC_arm_64 <span class="variable">$NCK_CFIG_arm_64</span> -fPIC -c get.c -o getndk.o</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成静态库</span></span><br><span class="line"><span class="meta">$</span><span class="bash">NDK_AR_arm_64 rcs -o libgetndk.a getndk.o</span> </span><br></pre></td></tr></table></figure>


<h4 id="7-AS引入库"><a href="#7-AS引入库" class="headerlink" title="7.AS引入库"></a>7.AS引入库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量导入</span> </span><br><span class="line">file(GLOB allCPP *.cpp) </span><br><span class="line">add_library( </span><br><span class="line">    native-lib </span><br><span class="line">    SHARED </span><br><span class="line">    $&#123;allCPP&#125;</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">find_library( </span><br><span class="line">    log-lib </span><br><span class="line">    log</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入静态库</span></span><br><span class="line">add_library(getndk STATIC IMPORTED) </span><br><span class="line"><span class="meta">#</span><span class="bash"> 真正导入    静态库</span> </span><br><span class="line">set_target_properties(getndk PROPERTIES IMPORTED_LOCATION </span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;CMAKE_SOURCE_DIR&#125;/libgetndk.a)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入动态库</span></span><br><span class="line">add_library(getndk SHARED IMPORTED) </span><br><span class="line">set_target_properties(getndk PROPERTIES IMPORTED_LOCATION </span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libgetndk.so)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>(CMAKE_CXX_FLAGS )</span> </span><br><span class="line"></span><br><span class="line">target_link_libraries( </span><br><span class="line">    native-lib </span><br><span class="line">    $&#123;log-lib&#125; </span><br><span class="line">    getndk # 链接此静态库到总库    libnative-lib.so</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title>WARNING: API &#39;variant.getPackageApplication()&#39; is obsolete and has been replaced with &#39;variant.ge...</title>
    <url>/2021/01/27/WARNING-API-variant-getPackageApplication-is-obsolete-and-has-been-replaced-with-variant-ge/</url>
    <content><![CDATA[<p>相信大家在使用gradle定制自己打包出来的apk名字时，都遇到过这个问题吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WARNING: API <span class="string">&#x27;variant.getPackageApplication()&#x27;</span> is obsolete and has been replaced with <span class="string">&#x27;variant.getPackageApplicationProvider()&#x27;</span>.</span><br><span class="line">It will be removed at the end of <span class="number">2019.</span></span><br><span class="line"></span><br><span class="line">For more information, see https:<span class="comment">//d.android.com/r/tools/task-configuration-avoidance.</span></span><br><span class="line"></span><br><span class="line">To determine what is calling variant.getPackageApplication(), use -Pandroid.debug.obsoleteApi=<span class="keyword">true</span> on the command line to display more information.</span><br><span class="line"></span><br><span class="line">Affected Modules: app</span><br></pre></td></tr></table></figure>


<p><strong>原因就是：</strong></p>
<p>在app模块下的build.gradle中，我们在android{}闭包中写了:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line"></span><br><span class="line">    variant.outputs.all &#123; output -&gt;</span><br><span class="line">        <span class="comment">//自定义目录，我这里把apk包输出路径定义到：/工程根目录/output/项目代号</span></span><br><span class="line">        variant.getPackageApplication().outputDirectory =<span class="keyword">new</span> File(project.rootDir.absolutePath +<span class="string">&quot;/output/$&#123;projectId&#125;/&quot;</span>)</span><br><span class="line">        <span class="comment">//apk名字定义为：自己想取的名字_版本名.apk</span></span><br><span class="line">        outputFileName =<span class="string">&quot;自己想取的名字_$&#123;variant.versionName&#125;.apk&quot;</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在使用了这段代码修改路径和apk名字的时候，AndroidStudio就会报以上警告，其实原因很简单，就是api过时了，需要修改一下api，修改如下即可</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.all &#123; output -&gt;</span><br><span class="line">        	<span class="comment">//把getPackageApplication()改成getPackageApplicationProvider().get()即可</span></span><br><span class="line">            variant.getPackageApplicationProvider().get().outputDirectory = <span class="keyword">new</span> File(project.rootDir.absolutePath + <span class="string">&quot;/output/$&#123;projectId&#125;/&quot;</span>)</span><br><span class="line">            outputFileName = <span class="string">&quot;自己想取的名字_$&#123;variant.versionName&#125;.apk&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>API过时</tag>
      </tags>
  </entry>
  <entry>
    <title>dex2jar 报错 com.googlecode.d2j.DexException: not support version</title>
    <url>/2021/01/27/dex2jar-%E6%8A%A5%E9%94%99-com-googlecode-d2j-DexException-not-support-version/</url>
    <content><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p>​    在日常开发中，有时候想做一点羞羞的事情(ps: 学习一下别人的代码)，但是一用dex2jar工具反编就报com.googlecode.d2j.DexException: not support version异常，在我高涨的学习热情上直接浇了一盆冷水。(后面有工具下载地址)</p>
<h4 id="2-反编手顺："><a href="#2-反编手顺：" class="headerlink" title="2. 反编手顺："></a>2. 反编手顺：</h4><p>​    反编其实很简单，先简单叙述一下：</p>
<ul>
<li><p>Step 1：将apk用任意解压工具直接解压(我用的zip)得到classes.dex，你可能会得到很多dex，不要紧，一个一个反编就行。</p>
</li>
<li><p>Step 2 : 使用dex2jar工具将每一个dex文件反编成jar包</p>
<ul>
<li>将dex2jar工具解压到任意目录(我暂时解压到桌面)</li>
<li>进入解压目录并且按(shift+右键，选择在此处打开命令行窗口)进入cmd命令行</li>
<li>将classes.dex拷贝到dex2jar工具目录，使用指令:d2j-dex2jar.bat classes.dex   即可得到反编后的jar包</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5ffef9ea3d119c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dex2jar正常结果.png"></p>
<ul>
<li>Step 3 : 使用JD-GUI工具尽情学习就行了。</li>
</ul>
<h4 id="3-问题发现："><a href="#3-问题发现：" class="headerlink" title="3. 问题发现："></a>3. 问题发现：</h4><p>​    使用dex2jar工具反编的时候，一输入指令，结果报com.googlecode.d2j.DexException: not support version错误(如下图)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ae9293474acef122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常情况.png"></p>
<h4 id="4-1-调查原因："><a href="#4-1-调查原因：" class="headerlink" title="4.1 调查原因："></a>4.1 调查原因：</h4><blockquote>
<p><a href="https://source.android.com/devices/tech/dalvik/dex-format#dex-file-magic">谷歌对dex文件的介绍</a>：常量数组/字符串 <code>DEX_FILE_MAGIC</code> 是字节列表，这类字节必须出现在 <code>.dex</code> 文件的开头，以便系统将其原样识别。该值会特意包含一个换行符（<code>&quot;\n&quot;</code> 或 <code>0x0a</code>）和空字节（<code>&quot;\0&quot;</code> 或 <code>0x00</code>），以便协助检测某些形式的损坏问题。该值还可以将格式版本号编码为 3 个十进制数字；随着格式的演变，预计该值会单调递增。</p>
<p><strong>注意</strong>：Android 9.0 版本中新增了对 <code>039</code> 版格式的支持，其中引入了两个新字节码 <code>const-method-handle</code> 和 <code>const-method-type</code>。（<a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions">字节码集合的总结</a>表中介绍了这些字节码。）在 Android 10 中，版本 <code>039</code> 扩展了 DEX 文件格式，以包含仅适用于启动类路径上的 DEX 文件的隐藏 API 信息。</p>
<p><strong>注意</strong>：Android 8.0 版本中新增了对 <code>038</code> 版格式的支持。<code>038</code> 版本中添加了新字节码（<code>invoke-polymorphic</code> 和 <code>invoke-custom</code>）和用于方法句柄的数据。</p>
<p><strong>注意</strong>：Android 7.0 版本中新增了对 <code>037</code> 版格式的支持。在 <code>037</code> 版本之前，大多数 Android 版本都使用过 <code>035</code> 版格式。<code>035</code> 版与 <code>037</code> 版之间的唯一区别是，是否添加默认方法以及是否调整 <code>invoke</code>。</p>
</blockquote>
<p><strong>简单地说：</strong>就是Android Studio中配置的minSdkVersion参数对应的系统版本是多少，dex文件头就会是多少</p>
<p><strong>例如：minSdkVersion配置成24(对应7.0的系统)，编译出来的dex头为037版本</strong>（使用notepad++打开dex文件就可以看到）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   	......</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ......</span><br><span class="line">        minSdkVersion <span class="number">24</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-488655bee26a00b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译出来的dex文件.png"></p>
<h4 id="4-2-根本原因调查："><a href="#4-2-根本原因调查：" class="headerlink" title="4.2 根本原因调查："></a>4.2 根本原因调查：</h4><p>​    其实看了<strong>调查4.1</strong>就已经有方案了，就是修改dex文件中的版本信息就可以。但是不知道根本原因心里不甘心，继续调查。</p>
<p>​    根据报错信息看：com.googlecode.d2j.reader.DexFileReader.<init>(DexFileReader.java:151) </init></p>
<p>​    猜测是<code>reader.DexFileReader</code>的构造方法中报出来的错误，打开dex2jar-2.0\lib目录，将**<code>dex-reader-2.0.jar</code>或者<code>dex-reader-api-2.0.jar</code>**丢进jd-gui工具中看看源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法中找到报错点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexFileReader</span><span class="params">(ByteBuffer in)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> version = in.getInt() &amp; <span class="number">0xFFFFFF</span>;</span><br><span class="line">        <span class="keyword">if</span> ((version != <span class="number">3486512</span>) &amp;&amp; (version != <span class="number">3552048</span>)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">&quot;not support version.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        skip(in, <span class="number">32</span>);</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持的版本定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_035 = <span class="number">3486512</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_036 = <span class="number">3552048</span>;</span><br></pre></td></tr></table></figure>
<p> <strong>意味着dex2jar-2.0工具只支持035和036版本协议！！！</strong></p>
<h4 id="5-解决问题"><a href="#5-解决问题" class="headerlink" title="5.解决问题"></a>5.解决问题</h4><p>​    使用notepad++文件浏览工具(任何能打开文件的工具都可以，例如记事本…)打开dex文件，<strong>修改版本信息037为036或者035</strong>，然后保存文件即可，再使用反编指令：d2j-dex2jar.bat classes.dex  反编即可成功。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-059b4ebc8e57c790.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改dex版本信息后.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-eec242e2e84b7c6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正常获得jar包.png"></p>
<h4 id="6-参考文档："><a href="#6-参考文档：" class="headerlink" title="6.参考文档："></a>6.参考文档：</h4><p><a href="https://source.android.com/devices/tech/dalvik/dex-format#dex-file-magic">谷歌对dex文件的介绍</a></p>
<p><a href="git@github.com:oujie123/Tools.git">反编译工具下载传送门</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>dex2jar</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>fmod变声测试demo</title>
    <url>/2021/06/19/fmod%E5%8F%98%E5%A3%B0%E6%B5%8B%E8%AF%95demo/</url>
    <content><![CDATA[<h4 id="1-查看手机架构"><a href="#1-查看手机架构" class="headerlink" title="1. 查看手机架构"></a>1. 查看手机架构</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure>


<h4 id="2-解析CMakeList"><a href="#2-解析CMakeList" class="headerlink" title="2. 解析CMakeList"></a>2. 解析CMakeList</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)  #最低支持的Cmake版本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TODO 引入头文件,该头文件是相对CMakeList.txt的</span></span><br><span class="line">include_directories(&quot;inc&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量导入所有源文件</span></span><br><span class="line">file(GLOB allCpp *.c *.h *.cpp)</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">        native-lib</span><br><span class="line"></span><br><span class="line">        # Sets the library as a shared library.</span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        # Provides a relative path to your source file(s).</span><br><span class="line">        $&#123;allCpp&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入库文件,设置环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 引入的库一定放在jniLibs目录中</span></span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找库，防止多次寻找库</span></span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">        log-lib</span><br><span class="line"></span><br><span class="line">        # Specifies the name of the NDK library that</span><br><span class="line">        # you want CMake to locate.</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">        #总库名字</span><br><span class="line">        native-lib</span><br><span class="line"></span><br><span class="line">        # Links the target library to the log library</span><br><span class="line">        # included in the NDK.</span><br><span class="line">        $&#123;log-lib&#125;</span><br><span class="line">        fmod</span><br><span class="line">        fmodL #链接到总so库中</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>


<h4 id="3-调用fmod库"><a href="#3-调用fmod库" class="headerlink" title="3. 调用fmod库"></a>3. 调用fmod库</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> FMOD;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">&quot;Jack_Ou&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_example_practicemethod_MainActivity_changeVoiceNative</span><br><span class="line">        (JNIEnv *env, jobject thiz, jint mode, jstring path) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *content_ = <span class="string">&quot;播放完毕&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取C能识别的path</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path_ = env-&gt;GetStringUTFChars(path, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 音效引擎系统</span></span><br><span class="line">    System *system = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声音</span></span><br><span class="line">    Sound *sound = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声道，音轨</span></span><br><span class="line">    Channel *channel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DSP</span></span><br><span class="line">    DSP *dsp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建系统</span></span><br><span class="line">    System_Create(&amp;system);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统初始化</span></span><br><span class="line">    <span class="comment">// 参数1：最大声道数；</span></span><br><span class="line">    <span class="comment">// 参数2：初始化标记</span></span><br><span class="line">    system-&gt;init(<span class="number">32</span>, FMOD_INIT_NORMAL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建声音</span></span><br><span class="line">    <span class="comment">// 参数1：音频文件路基</span></span><br><span class="line">    <span class="comment">// 参数2：初始化音频标记</span></span><br><span class="line">    <span class="comment">// 参数3：额外参数</span></span><br><span class="line">    <span class="comment">// 参数4：声音</span></span><br><span class="line">    system-&gt;createSound(path_, FMOD_DEFAULT, <span class="number">0</span>, &amp;sound);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放</span></span><br><span class="line">    <span class="comment">// 参数1：声音</span></span><br><span class="line">    <span class="comment">// 参数2：通道分组</span></span><br><span class="line">    <span class="comment">// 参数3：是否暂停</span></span><br><span class="line">    <span class="comment">// 参数4：声道</span></span><br><span class="line">    system-&gt;playSound(sound, <span class="number">0</span>, <span class="literal">false</span>, &amp;channel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换音效</span></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_NORMAL:</span><br><span class="line">            content_ = <span class="string">&quot;原生 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_GIRL:</span><br><span class="line">            <span class="comment">// 音调调高</span></span><br><span class="line">            <span class="comment">// 创建DPS</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);</span><br><span class="line">            <span class="comment">// 设置pitch</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, <span class="number">2.0f</span>);</span><br><span class="line">            <span class="comment">// 添加dsp</span></span><br><span class="line">            <span class="comment">// 参数1：通道编号</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;女声 播放完毕&quot;</span>;</span><br><span class="line">            LOGE(<span class="string">&quot;%s&quot;</span>, content_);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_UNCLE:</span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, <span class="number">0.7f</span>);</span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;大叔 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_HORROR:</span><br><span class="line">            <span class="comment">// 音量调低</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_PITCHSHIFT, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_PITCHSHIFT_PITCH, <span class="number">0.7f</span>);</span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp); <span class="comment">// 配置第一个音轨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加回声</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, <span class="number">200</span>); <span class="comment">// 回音延时</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, <span class="number">10</span>);  <span class="comment">// 回音衰减度</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">1</span>, dsp);  <span class="comment">// 配置第二个音轨</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加颤抖</span></span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_TREMOLO, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_FREQUENCY, <span class="number">20</span>);  <span class="comment">// 颤抖</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_TREMOLO_SKEW, <span class="number">0.8f</span>);  <span class="comment">// 颤抖停顿</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">2</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;惊悚 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_FUN:</span><br><span class="line">            <span class="keyword">float</span> freq;</span><br><span class="line">            channel-&gt;getFrequency(&amp;freq);</span><br><span class="line"></span><br><span class="line">            channel-&gt;setFrequency(freq * <span class="number">1.5f</span>);</span><br><span class="line">            content_ = <span class="string">&quot;搞怪 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> com_example_practicemethod_MainActivity_MODE_ETHEREAL:</span><br><span class="line">            system-&gt;createDSPByType(FMOD_DSP_TYPE_ECHO, &amp;dsp);</span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_DELAY, <span class="number">200</span>); <span class="comment">// 回音延时</span></span><br><span class="line">            dsp-&gt;setParameterFloat(FMOD_DSP_ECHO_FEEDBACK, <span class="number">0</span>);  <span class="comment">// 回音衰减度</span></span><br><span class="line">            channel-&gt;addDSP(<span class="number">0</span>, dsp);</span><br><span class="line">            content_ = <span class="string">&quot;空灵 播放完毕&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待播放完毕</span></span><br><span class="line">    <span class="keyword">bool</span> isPlay = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (isPlay) &#123;</span><br><span class="line">        channel-&gt;isPlaying(&amp;isPlay);  <span class="comment">// 声道知道是否播放完毕</span></span><br><span class="line">        LOGE(<span class="string">&quot;%s&quot;</span>, content_);</span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调结果</span></span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(thiz);</span><br><span class="line">    jmethodID endMethod = env-&gt;GetMethodID(clazz, <span class="string">&quot;playEnd&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jstring value = env-&gt;NewStringUTF(content_);</span><br><span class="line">    env-&gt;CallVoidMethod(thiz, endMethod, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收资源</span></span><br><span class="line">    sound-&gt;release();</span><br><span class="line">    system-&gt;close();</span><br><span class="line">    system-&gt;release();</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(path, path_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>this原理与友元函数</title>
    <url>/2021/06/06/this%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1-可变参数"><a href="#1-可变参数" class="headerlink" title="1.可变参数"></a>1.可变参数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java的可变参数: int ...</span></span><br><span class="line"><span class="comment">// C++的可变参数写法：...</span></span><br><span class="line"><span class="comment">// count的第一个用处：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息</span></span><br><span class="line"><span class="comment">// count主要还是用于记录可变参数个数，方便内部存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    va_list vp; <span class="comment">// 可变参数的动作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数一：可变参数开始的动作vp</span></span><br><span class="line">    <span class="comment">// 参数二：内部需要一个 存储地址用的参考值，如果没有第二个参数，内部他无法处理存放参数信息</span></span><br><span class="line">    va_start(vp, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里后：vp就已经有丰富的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值</span></span><br><span class="line">    <span class="keyword">int</span> number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值</span></span><br><span class="line">    number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值</span></span><br><span class="line">    number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 越界 系统值 乱码</span></span><br><span class="line">    <span class="comment">// 取出可变参数的一个值 【娶不到后，会取系统值 乱码】</span></span><br><span class="line">    number  = va_arg(vp, <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭阶段</span></span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sum(<span class="number">3</span>, <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2.static关键字"></a>2.static关键字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态的总结：</span></span><br><span class="line"><span class="comment"> * 1.可以直接通过类名::静态成员（字段/函数）</span></span><br><span class="line"><span class="comment"> * 2.静态的属性必须要初始化，然后再实现（规则）</span></span><br><span class="line"><span class="comment"> * 3.静态的函数只能取操作静态的属性和方法（Java）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * info;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 报错:静态函数不能调用非静态函数（Java）</span></span><br><span class="line">        <span class="comment">// update2();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再实现</span></span><br><span class="line"><span class="keyword">int</span> Dog::id = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    dog.update2(); <span class="comment">// 普通函数</span></span><br><span class="line">    Dog::update(); <span class="comment">// 静态函数</span></span><br><span class="line">    dog.update(); <span class="comment">// 对象名.静态函数（一般都是使用::调用静态成员，这种方式可以 知道就行）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Dog::id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-友元函数"><a href="#3-友元函数" class="headerlink" title="3.友元函数"></a>3.友元函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有的age，外界不能访问</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义友元函数 (声明，没有实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person * person, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的实现，可以访问所以私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(Person* person, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认情况下：不能修改 私有的age</span></span><br><span class="line">    <span class="comment">// 通过友元函数可以修改私有成员，java反射是这样实现的么？</span></span><br><span class="line">    person-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person = Person(<span class="number">9</span>);</span><br><span class="line">    updateAge(&amp;person, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-友元类"><a href="#4-友元类" class="headerlink" title="4.友元类"></a>4.友元类</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageView</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> viewSize;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>;</span> <span class="comment">// 友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java每个类，都会有一个Class，此Class可以操作 ImageView私有成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ImageView imageView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeViewSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        imageView.viewSize = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getViewSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imageView.viewSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class mImageViewClass;</span><br><span class="line"></span><br><span class="line">    mImageViewClass.changeViewSize(<span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mImageViewClass.getViewSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-各种定义和方法的区别"><a href="#5-各种定义和方法的区别" class="headerlink" title="5.各种定义和方法的区别"></a>5.各种定义和方法的区别</h4><p>静态函数，友元函数，普通函数，构造函数，析构函数，拷贝构造函数，有什么区别。</p>
<p>头文件定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PIG_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIG_H <span class="comment">// 定义这个宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员声明</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数的声明系列</span></span><br><span class="line">    Pig();</span><br><span class="line">    Pig(<span class="keyword">char</span> *);</span><br><span class="line">    Pig(<span class="keyword">char</span> *,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Pig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Pig(<span class="keyword">const</span> Pig &amp; pig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通函数 set get</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPigInfo</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 常量指针常量 只读</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态函数的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeTag</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要这样干</span></span><br><span class="line">    <span class="comment">// void changeTag(int age);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">changeAge</span><span class="params">(Pig * pig, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 关闭/结尾</span></span></span><br></pre></td></tr></table></figure>


<p>实现类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Pig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO  ======================  下面是 普普通通 常规操作 对象::</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现构造函数</span></span><br><span class="line">Pig::Pig() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pig::Pig(<span class="keyword">char</span> * name) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1个参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pig::Pig(<span class="keyword">char</span> * name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2个参数构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现析构函数</span></span><br><span class="line">Pig::~Pig() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 拷贝构造函数</span></span><br><span class="line">Pig::Pig(<span class="keyword">const</span> Pig &amp;pig) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pig::getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Pig::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::setName</span><span class="params">(<span class="keyword">char</span> * name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::showPigInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 常量指针常量 只读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =====  静态 和 友元   ==============</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 静态属性【不需要增加 static关键字】</span></span><br><span class="line"><span class="keyword">int</span> Pig::id = <span class="number">878</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现静态函数，【不需要增加 static关键字】</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::changeTag</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元的实现</span></span><br><span class="line"><span class="comment">// 友元特殊：不需要关键字，也不需要 对象:: ,只需要保证 函数名（参数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeAge</span><span class="params">(Pig * pig, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-this关键字存在的意义"><a href="#6-this关键字存在的意义" class="headerlink" title="6.this关键字存在的意义"></a>6.this关键字存在的意义</h4><p>this关键字可以表示该对象的暴露地址，让执行器知道调用那个对象的某个属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id; <span class="comment">// 先声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认的构造函数 栈区开辟空间 暴露 地址 == this指针 (和Java一致的思路)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再实现</span></span><br><span class="line"><span class="keyword">int</span> Student::id = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ======= 常规使用下而已</span></span><br><span class="line">    Student student;</span><br><span class="line">    student.setAge(<span class="number">99</span>);</span><br><span class="line">    student.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; student.getName() &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; student.getAge()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==========  this 的意义</span></span><br><span class="line">    Student student1;</span><br><span class="line">    <span class="comment">// 设置值的时候，它知道是给student1的age赋值</span></span><br><span class="line">    student1.setAge(<span class="number">88</span>);</span><br><span class="line">    student1.id = <span class="number">880</span>;</span><br><span class="line"></span><br><span class="line">    Student student2;</span><br><span class="line">    <span class="comment">// 设置值的时候，它知道是给student2的age赋值</span></span><br><span class="line">    student2.setAge(<span class="number">99</span>);</span><br><span class="line">    student2.id = <span class="number">990</span>;</span><br><span class="line"></span><br><span class="line">    Student::id = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this关键字能够知道获取student1的age</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; student1.getAge:&quot;</span> &lt;&lt; student1.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它怎么知道是获取student2的age</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; student2.getAge:&quot;</span> &lt;&lt; student2.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;student1.id:&quot;</span> &lt;&lt; student1.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;student2.id:&quot;</span> &lt;&lt; student2.id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student:::&quot;</span> &lt;&lt; Student::id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// main函数弹栈会 隐士代码：（栈区：delete student ...， 堆区需要自己手动delete）</span></span><br></pre></td></tr></table></figure>


<h4 id="7-const修饰函数"><a href="#7-const修饰函数" class="headerlink" title="7.const修饰函数"></a>7.const修饰函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="literal">NULL</span>; <span class="comment">// C++中不像Java，Java有默认值， 如果你不给默认值，那么就是系统值 -64664</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int * const  指针常量 指针常量【地址对应的值能改，地址不可以修改】</span></span><br><span class="line">    <span class="comment">// const int *  常量指针 常量指针【地址可以修改，地址对应的值不能改】</span></span><br><span class="line">    <span class="comment">// const 离谁近，谁就不能改！！！！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纠结：原理：为什么可以修改age</span></span><br><span class="line">    <span class="comment">// 默认持有隐士的this【类型 * const this】</span></span><br><span class="line">    <span class="comment">// 类型 * const 指针常量：代表指针地址不能被修改，但是指针地址的值是可以修改的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代表指针地址不能被修改</span></span><br><span class="line">        <span class="comment">// this = 0x6546;  // 编译不通过，地址不能被修改，因为是指针常量</span></span><br><span class="line">        <span class="comment">// 地址不可以修改</span></span><br><span class="line">        <span class="comment">// this = 0x43563;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 隐士的this</span></span><br><span class="line">        <span class="comment">// 但是指针地址的值是可以修改的</span></span><br><span class="line">        <span class="comment">// 地址对应的值能改</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="string">&quot;JJJ&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认现在：this 等价于 const Student * const  常量指针常量（地址不能改，地址对应的值不能改）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeAction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 地址不能改</span></span><br><span class="line">        <span class="comment">// this = 0x43563;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 地址对应的值不能改</span></span><br><span class="line">        <span class="comment">// this-&gt;age = 100;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原理：修改隐士代码  const 类型 * const 常量指针常量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;name = &quot;&quot;;</span></span><br><span class="line">        <span class="comment">// this-&gt;age = 88;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只读的</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 16.04磁盘扩容</title>
    <url>/2021/02/22/ubuntu-16-04%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>在编译Android O系统源码的时候，看着都快成功了，但是突然VMware虚拟机报磁盘不够了，导致编译失败，删除各种应用也不够，因为要编译Android源码太费磁盘了！！！我之前分配了100G，源码就占了83G左右，所以必须扩容，我先暂时扩展为215G试试吧(要编译aosp_car_x86_64-userdebug至少需要预留300G以上，我这篇文档先暂时演示扩容过程)，下面就开始搞事~~</p>
<h3 id="2-扩展目标"><a href="#2-扩展目标" class="headerlink" title="2.扩展目标"></a>2.扩展目标</h3><p>从目前的208G扩展到218G吧(主要演示过程，其实208G是我自己测试扩展后的容量，我再扩展10G吧)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-350f703829a489b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化内存.png"></p>
<h3 id="3-主要流程"><a href="#3-主要流程" class="headerlink" title="3.主要流程"></a>3.主要流程</h3><ul>
<li>在VMware设置期望扩展后的最大内存大小</li>
<li>将新加的内存分配到主分区</li>
<li>更新UUID</li>
</ul>
<h4 id="4-详细流程"><a href="#4-详细流程" class="headerlink" title="4.详细流程"></a>4.详细流程</h4><h4 id="Step1：关闭虚拟机，点击“编辑虚拟机设置”"><a href="#Step1：关闭虚拟机，点击“编辑虚拟机设置”" class="headerlink" title="Step1：关闭虚拟机，点击“编辑虚拟机设置”"></a>Step1：关闭虚拟机，点击“编辑虚拟机设置”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-30e9f2eb0a4dae1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编辑VMWARE虚拟机设置.png"></p>
<h4 id="Step2：点击“硬盘-SCSI-”-gt-“扩展”"><a href="#Step2：点击“硬盘-SCSI-”-gt-“扩展”" class="headerlink" title="Step2：点击“硬盘(SCSI)” -&gt; “扩展”"></a>Step2：点击“硬盘(SCSI)” -&gt; “扩展”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-7217457ea0853c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改扩展的最大内存.png"></p>
<h4 id="Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”"><a href="#Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”" class="headerlink" title="Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”"></a>Step3：设置最大可扩展的内存，并点击“扩展”，点击“确定”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-10834daf4db3d7db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置最大可占内存.png"></p>
<h4 id="Step4：开机安装“gparted”工具"><a href="#Step4：开机安装“gparted”工具" class="headerlink" title="Step4：开机安装“gparted”工具"></a>Step4：开机安装“gparted”工具</h4><blockquote>
<p>在终端输入：sudo apt-get install gparted</p>
<p>然后输入Y确定即可</p>
</blockquote>
<h4 id="Step5：启动“gparted”，输入管理员密码进入工具"><a href="#Step5：启动“gparted”，输入管理员密码进入工具" class="headerlink" title="Step5：启动“gparted”，输入管理员密码进入工具"></a>Step5：启动“gparted”，输入管理员密码进入工具</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-1c184f2ecaf8e06f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择Gparted工具启动.png"></p>
<h4 id="Step6：可以看到刚刚分配的10G-从最大215G修改成225G"><a href="#Step6：可以看到刚刚分配的10G-从最大215G修改成225G" class="headerlink" title="Step6：可以看到刚刚分配的10G(从最大215G修改成225G)"></a>Step6：可以看到刚刚分配的10G(从最大215G修改成225G)</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-96f1eb133d2f994f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刚分配的10G.png"></p>
<p>1./dev/sda1是主分区</p>
<p>2./dev/sda2是扩展分区</p>
<p>3./dev/sda5是逻辑分区</p>
<p>由于我们需要将为分配分区添加到主分支中，而未分配分区和主分区中间不能有其他分区，所有我们需要先禁止交换空间，并且删除扩展分区和交换空间。</p>
<h4 id="Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）"><a href="#Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）" class="headerlink" title="Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）"></a>Step7：禁止交换空间，鼠标移入linux-swap，右键选择“SwapOff”（禁用交换空间）</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-ec1252839e4d6567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关闭交换空间.png"></p>
<h4 id="Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”"><a href="#Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”" class="headerlink" title="Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”"></a>Step8：删除交换空间和扩展空间，鼠标移入对应的空间，右键选择“delete”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-a5b0c1c6c3a658ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除对应分区.png"></p>
<p>删除交换空间和扩展空间后：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-044c15348d87ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除扩展和交换分区后.png"></p>
<h4 id="Step9：扩展主分区，鼠标移入-dev-sda1，右键选择“Resize-move”-更改大小-移动"><a href="#Step9：扩展主分区，鼠标移入-dev-sda1，右键选择“Resize-move”-更改大小-移动" class="headerlink" title="Step9：扩展主分区，鼠标移入/dev/sda1，右键选择“Resize/move”(更改大小/移动)"></a>Step9：扩展主分区，鼠标移入/dev/sda1，右键选择“Resize/move”(更改大小/移动)</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-e2663a0fc8558bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改主分区大小.png"></p>
<h4 id="Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3-4G左右-填了new-size大小，这个会自动减去-，然后点击“resize”"><a href="#Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3-4G左右-填了new-size大小，这个会自动减去-，然后点击“resize”" class="headerlink" title="Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3.4G左右(填了new size大小，这个会自动减去)，然后点击“resize”"></a>Step10：分配主分区，我这里给主分区大小分配227G，给交换空间分配3.4G左右(填了new size大小，这个会自动减去)，然后点击“resize”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-c16db94d3bd4cdf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配主分区.png"></p>
<p>主分区分配后结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4ce0c57e17ed8b28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主分区分配后结果.png"></p>
<h4 id="Step11：创建扩展分区，鼠标移入“unallocated”-选择“new”"><a href="#Step11：创建扩展分区，鼠标移入“unallocated”-选择“new”" class="headerlink" title="Step11：创建扩展分区，鼠标移入“unallocated”,选择“new”"></a>Step11：创建扩展分区，鼠标移入“unallocated”,选择“new”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-2081d24ff65569d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建扩展分区.png"></p>
<h4 id="Step12：创建为“扩展分区”，选择“Extended-Partition”-并点击“add”"><a href="#Step12：创建为“扩展分区”，选择“Extended-Partition”-并点击“add”" class="headerlink" title="Step12：创建为“扩展分区”，选择“Extended Partition”,并点击“add”"></a>Step12：创建为“扩展分区”，选择“Extended Partition”,并点击“add”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-89853801dc0c26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择扩展分区.png"></p>
<h4 id="Step13：创建交换空间，鼠标移入“unallocated”-选择“new”-进入之后点击“file-system”-选择“linux-swap”-最后点击“add”添加交换分区"><a href="#Step13：创建交换空间，鼠标移入“unallocated”-选择“new”-进入之后点击“file-system”-选择“linux-swap”-最后点击“add”添加交换分区" class="headerlink" title="Step13：创建交换空间，鼠标移入“unallocated”,选择“new”,进入之后点击“file system”,选择“linux-swap”,最后点击“add”添加交换分区"></a>Step13：创建交换空间，鼠标移入“unallocated”,选择“new”,进入之后点击“file system”,选择“linux-swap”,最后点击“add”添加交换分区</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-b41d6635abd7a681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置交换空间.png"></p>
<p>添加完成扩展分区和交换分区的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-680fe218fd31ca9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加扩展分区和交换分区结果.png"></p>
<h4 id="Step14：应用以上的配置，点击“√”，并且点击“apply”"><a href="#Step14：应用以上的配置，点击“√”，并且点击“apply”" class="headerlink" title="Step14：应用以上的配置，点击“√”，并且点击“apply”"></a>Step14：应用以上的配置，点击“√”，并且点击“apply”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-f54e629d635419ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击确认.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2a3e33a5ca6df29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击apply.png"></p>
<h4 id="Step15：分配完成，点击“close”"><a href="#Step15：分配完成，点击“close”" class="headerlink" title="Step15：分配完成，点击“close”"></a>Step15：分配完成，点击“close”</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-83b24558095cb0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配成功.png"></p>
<h4 id="Step16：查看并记住交换空间的UUID"><a href="#Step16：查看并记住交换空间的UUID" class="headerlink" title="Step16：查看并记住交换空间的UUID"></a>Step16：查看并记住交换空间的UUID</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-150c15ee7aa94e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="记录UUID.png"></p>
<h4 id="Step17：修改-etc-fstab中的UUID值"><a href="#Step17：修改-etc-fstab中的UUID值" class="headerlink" title="Step17：修改/etc/fstab中的UUID值"></a>Step17：修改/etc/fstab中的UUID值</h4><blockquote>
<p>sudo vim /etc/fstab</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a653f745a19104ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改UUID.png"></p>
<h4 id="Step18：查看是否扩展成功了"><a href="#Step18：查看是否扩展成功了" class="headerlink" title="Step18：查看是否扩展成功了"></a>Step18：查看是否扩展成功了</h4><blockquote>
<p>输入：df -h</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-311dcc324b229072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扩展成功.png"></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>磁盘扩容</tag>
        <tag>源码编译</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>关于viewmodel创建</title>
    <url>/2021/01/27/%E5%85%B3%E4%BA%8Eviewmodel%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="1-ViewModelProviders-of-被弃用了"><a href="#1-ViewModelProviders-of-被弃用了" class="headerlink" title="1.ViewModelProviders.of()被弃用了"></a><strong>1.ViewModelProviders.of()被弃用了</strong></h4><p>从Android官网可以看到创建ViewModel的方法ViewModelProviders.of()已经被弃用了，我们需要创建ViewModel，只用使用new ViewModelProvider的方式。那么我们应该如何使用呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-beb51a7b1131762e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h4 id="2-使用new-ViewModelProvider方法创建ViewModel"><a href="#2-使用new-ViewModelProvider方法创建ViewModel" class="headerlink" title="2.使用new ViewModelProvider方法创建ViewModel"></a><strong>2.使用new ViewModelProvider方法创建ViewModel</strong></h4><p>从官方给的文档来看，ViewModelProvider有两个构造方法，如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5dc186e405e56f5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>这两个构造方法区别在于: </p>
<p>(1) 第一个构造方法的第一个参数ViewModelStoreOwner是<strong>viewmodel的持有者</strong>，在activity中传入this即可，如果在fragment中，传入requireActivity()即可</p>
<p>(2) 第二个构造方法的第一个参数ViewModelStore是viewmodel的保存容器，工厂创建viewmodel之后，将放入这个容器。</p>
<p>两个构造方法的第二个参数是Factory参数，用于创建viewmodel对象。如果我们需要创建的是<strong>viewmodel</strong>则使用new ViewModelProvider.NewInstanceFactory()即可；如果需要创建的是AndroidViewModel则使用new ViewModelProvider.AndroidViewModelFactory(this.getApplication())。</p>
<blockquote>
<p><strong>//1. WordViewModel继承AndroidViewModel</strong></p>
<p>public class WordViewModel extends AndroidViewModel{</p>
<p>   public WordViewModel(@NonNull Application application) {</p>
<p>​     super(application);</p>
<p>​    }</p>
<p>}</p>
<p><strong>//ViewModel创建方法</strong></p>
<p>WordsViewModel wordsViewModel = new ViewModelProvider(this, new ViewModelProvider.AndroidViewModelFactory(this.getApplication())).get(WordViewModel.class);</p>
<p><strong>//2.WordViewModel继承ViewModel</strong></p>
<p>public class WordViewModel extends ViewModel {}</p>
<p><strong>//ViewModel创建方法</strong></p>
<p>WordsViewModel wordsViewModel = new ViewModelProvider(this, new ViewModelProvider.NewInstanceFactory()).get(WordViewModel.class);</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>viewmodel</tag>
        <tag>jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title>反编译经验总结</title>
    <url>/2021/03/10/%E5%8F%8D%E7%BC%96%E8%AF%91%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1. 内部类"></a>1. 内部类</h3><p>内部类反编出来会出现如下结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2c24402723b9cf7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内部类反编结果.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点开任意一个可以看出是实现的Runnable方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> -$$<span class="title">Lambda</span>$<span class="title">ExtNetworkTracker</span>$<span class="title">InterfaceObserver</span>$6<span class="title">h5H0nN5nrJkfCZwlwJqwAaVTc0</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用的外部类的方法</span></span><br><span class="line">        InterfaceObserver.lambda$interfaceRemoved$<span class="number">1</span>(<span class="keyword">this</span>.f$<span class="number">0</span>, <span class="keyword">this</span>.f$<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-给外部类参数赋值"><a href="#2-给外部类参数赋值" class="headerlink" title="2. 给外部类参数赋值"></a>2. 给外部类参数赋值</h3><p>如果在反编译文件中出现access$xxx等标识，基本都是对外部类变量赋值，找到外部类对应变量进行复制即可即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-72522781ae636664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="给外部类参数赋值.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上两句话，相当于下面两句话，mLinkStateIfaceName，mNetworkLinkState是外部类的两个变量</span></span><br><span class="line">mLinkStateIfaceName = ifaceName;</span><br><span class="line">mNetworkLinkState = state;</span><br></pre></td></tr></table></figure>


<h3 id="3-Log日志"><a href="#3-Log日志" class="headerlink" title="3. Log日志"></a>3. Log日志</h3><p>日常中打的log，在反编译之后，会使用StringBuilder来包装一句log日志。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-03304d8ed8468733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="log日志.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上语音相当于一下语句</span></span><br><span class="line">Log.d(TAG, <span class="string">&quot;interfaceLinkStateChanged:&quot;</span> + ifaceName + <span class="string">&quot; up: &quot;</span> + state);</span><br></pre></td></tr></table></figure>


<h4 id="4-for循环的解析"><a href="#4-for循环的解析" class="headerlink" title="4.for循环的解析"></a>4.for循环的解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果遇到for (;;)，其实就while循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    bool1 = bool2;</span><br><span class="line">    <span class="comment">//重试三次计数</span></span><br><span class="line">    <span class="keyword">if</span> ((i &gt;= <span class="number">3</span>) || (paramBoolean)) &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//实际逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception localException)&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.printStackTrace();</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析代码</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实际逻辑</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-同步代码块"><a href="#5-同步代码块" class="headerlink" title="5.同步代码块"></a>5.同步代码块</h3><h4 id="5-1-类锁"><a href="#5-1-类锁" class="headerlink" title="5.1 类锁"></a>5.1 类锁</h4><p>如果遇到try-finally组合，且finally是空的，考虑是synchronized代码同步块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInterface</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//实际逻辑代码</span></span><br><span class="line">        Object localObject = TAG;</span><br><span class="line">        StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;updateInterface(iface:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramString);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;, status:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramBoolean);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        Log.d((String)localObject, localStringBuilder.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInterface</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//实际逻辑代码</span></span><br><span class="line">        Object localObject = TAG;</span><br><span class="line">        StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;updateInterface(iface:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramString);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;, status:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramBoolean);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        Log.d((String)localObject, localStringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-2-对象锁"><a href="#5-2-对象锁" class="headerlink" title="5.2 对象锁"></a>5.2 对象锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个还是很容易看出是对象锁的，我之前有一处很难发现的代码没找到了，下次找到更新在这里，此处预留</span></span><br><span class="line"><span class="keyword">synchronized</span> (CarlibTimeoutUtil.<span class="keyword">this</span>.mLock)&#123;</span><br><span class="line">	<span class="comment">//真实逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-编译器对象擦除机制"><a href="#6-编译器对象擦除机制" class="headerlink" title="6.编译器对象擦除机制"></a>6.编译器对象擦除机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随意丢一个方法过来，分析java编译中对象擦除机制。为了方便好看，下面实例代码中使用“方法”来代替实际的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateInterface</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object localObject = TAG;</span><br><span class="line">        StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;updateInterface(iface:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramString);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;, status:&quot;</span>);</span><br><span class="line">        localStringBuilder.append(paramBoolean);</span><br><span class="line">        localStringBuilder.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        Log.d((String) localObject, localStringBuilder.toString());</span><br><span class="line">        localObject = (ExtNetworkSet) <span class="keyword">this</span>.mExtNetworkSets.方法;</span><br><span class="line">        <span class="keyword">if</span> (localObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            localObject = TAG;</span><br><span class="line">            localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            localStringBuilder.append(<span class="string">&quot;ExtNetworkSet of &quot;</span>);</span><br><span class="line">            localStringBuilder.append(paramString);</span><br><span class="line">            localStringBuilder.append(<span class="string">&quot; not found&quot;</span>);</span><br><span class="line">            Log.e((String) localObject, localStringBuilder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ((ExtNetworkSet) localObject).mNetworkFactory.方法;</span><br><span class="line">        (((ExtNetworkSet) localObject).mIpConfig.方法;</span><br><span class="line">        ((ExtNetworkSet) localObject).mNetworkFactory.方法;</span><br><span class="line">        ((ExtNetworkSet) localObject).mNetworkFactory.方法;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到localObject这个对象从方法进入到方法结束都一直使用的这个变量。这就是java在编译之后进行对象擦拭机制。进入方法之后，<strong>编译器会把所有对象擦拭成Object对象，然后在适合的位置强转成真实的对象。</strong></p>
<p>例如：在方法进入，编译器先创建了一个Object对象，接收TAG参数，在Log.d方法中将它转化成String对象；<br>然后接收从mExtNetworkSets集合中获得的ExtNetworkSet对象，在方法最后强转成ExtNetworkSet对象来使用它。</p>
<h3 id="7-关于资源文件的解析"><a href="#7-关于资源文件的解析" class="headerlink" title="7.关于资源文件的解析"></a>7.关于资源文件的解析</h3><p>在代码中有关于资源文件的应用如下<br><img src="https://upload-images.jianshu.io/upload_images/13838098-b85f9b90af8d7ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源文件解析.png"></p>
<p><strong>解析方法：</strong></p>
<ul>
<li>首先将十进制“2130837504”转化成十六进制为“0x7f020000”</li>
<li>将apk文件直接拖入Android Studio，找到resources.arsc索引文件，然后根据要查看的内容类型找到具体的内容。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f80225779b402afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应资源内容.png"></p>
<h3 id="8-超高难度解析–内部类调用外部类方法"><a href="#8-超高难度解析–内部类调用外部类方法" class="headerlink" title="8.超高难度解析–内部类调用外部类方法"></a>8.超高难度解析–内部类调用外部类方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-39939aedd0fb6c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内部类超高难度理解.png"></p>
<p>该文件是内部类中的一个实现，实现了Runnable接口。</p>
<p>然后看InterfaceObserver.lambda$interfaceRemoved$1(this.f$0, this.f$1);  这个是interfaceRemoved接口方法中会调用$1(this.f$0, this.f$1)方法。</p>
<p>以上方法的破解有两个方案：</p>
<ul>
<li>一般是内部的实现方法，根据接口的名字interfaceRemoved猜测外部类private的哪个方法比较靠近这个实现，然后用这个方法去试逻辑是否吻合</li>
<li>用排除法，先将其他方法都处理完成之后，看那几个方法没有被调用过，然后结合传入参数，实现内容就可以初步断定调用哪个方法。最后在编译出来上机验证是否符合猜测。</li>
</ul>
<h3 id="9-超高难度解析–解析协议"><a href="#9-超高难度解析–解析协议" class="headerlink" title="9.超高难度解析–解析协议"></a>9.超高难度解析–解析协议</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-692eb6a358d72a0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协议解析.png"></p>
<p>如果遇到以上这种情况，反编译代码中会有奇形怪状的数字(hash值)，这个情况一般是编译器为了找到运行时的对象，算了一个hash值，所以我们不必关心这个hash值，我们就看判断的内容即可。</p>
<p>根据截图以上的代码上下文，可以判断localObject2是协议的key值，localObject3是协议的value值，然后判断key值是否与对应的key值相等，然后处理对应的value值。</p>
<p>根据上面分析，解析结果可以判断为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String key = pair[<span class="number">0</span>];</span><br><span class="line">String value = pair[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ip&quot;</span>:</span><br><span class="line">        ipConfig.ipAddress = <span class="keyword">new</span> LinkAddress(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;domains&quot;</span>:</span><br><span class="line">        ipConfig.domains = value;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;gateway&quot;</span>:</span><br><span class="line">        ipConfig.gateway = InetAddress.parseNumericAddress(value);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;dns&quot;</span>: &#123;</span><br><span class="line">        ArrayList&lt;InetAddress&gt; dnsAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String address : value.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            dnsAddresses.add(InetAddress.parseNumericAddress(address));</span><br><span class="line">        &#125;</span><br><span class="line">        ipConfig.dnsServers.addAll(dnsAddresses);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected key: &quot;</span> + key</span><br><span class="line">                + <span class="string">&quot; in &quot;</span> + configs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化JVM理解运行时数据区(二)</title>
    <url>/2021/01/27/%E5%8F%AF%E8%A7%86%E5%8C%96JVM%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="1-工具以及配置"><a href="#1-工具以及配置" class="headerlink" title="1. 工具以及配置"></a>1. 工具以及配置</h4><p>​    要可视化代码在内存中的位置，以及虚拟机是如何划分运行时数据区的，我们需要使用到<strong>HSDB工具</strong>，该工具位于JDK\lib目录下。</p>
<p>​    我们需要的工具如下：</p>
<ul>
<li>JDK\lib目录下的sa-jdi.jar</li>
<li>JDK\jre\bin目录下的sawindbg.dll动态库 （<strong>注意！！需要把这个动态库copy到JDK\lib</strong>）</li>
</ul>
<p>​    </p>
<p>​    工具准备好了，那就行动吧。</p>
<ul>
<li><p>Step1： 进入到JDK\lib，我的目录是：F:\Java\JDK\lib</p>
</li>
<li><p>Step2：打开命令行控制台</p>
</li>
<li><p>Step3：运行指令: java -cp .\sa-jdi.jar sun.jvm.hotspot.HSDB</p>
<p> 如果出现以下界面说明配置完成了。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-534277fcff41ea0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HSDB启动界面.png"></p>
<h4 id="2-测试代码以及开始分析"><a href="#2-测试代码以及开始分析" class="headerlink" title="2.测试代码以及开始分析"></a>2.测试代码以及开始分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInJvm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String MAN_TYPE = <span class="string">&quot;man&quot;</span>;	<span class="comment">//常量  存方法区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String WOMAN_TYPE = <span class="string">&quot;woman&quot;</span>;	<span class="comment">//静态变量  存方法区</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student T1 = <span class="keyword">new</span> Student();	<span class="comment">// Student对象  存堆区   T1放在栈帧的局部变量表中</span></span><br><span class="line">        T1.setName(<span class="string">&quot;DY&quot;</span>);</span><br><span class="line">        T1.setSexType(WOMAN_TYPE);</span><br><span class="line">        T1.setAge(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            System.gc();	<span class="comment">// 经历15次GC，进入老年代</span></span><br><span class="line">        &#125;</span><br><span class="line">        Student T2 = <span class="keyword">new</span> Student();	<span class="comment">// Student对象  存堆区   T2放在栈帧的局部变量表中</span></span><br><span class="line">        T2.setName(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">        T2.setSexType(MAN_TYPE);</span><br><span class="line">        T2.setAge(<span class="number">29</span>);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE); <span class="comment">//本地方法栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    String sexType;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//get,set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-1-介绍工具"><a href="#2-1-介绍工具" class="headerlink" title="2.1 介绍工具"></a>2.1 介绍工具</h5><ul>
<li>使用javac和java工具将代码编译后运行起来如下：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c588b7d801a98b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行demo.png"></p>
<ul>
<li>使用指令：jps   查看进程号，我们demo进程号是：12328</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b115e69f472b9b31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo运行进程号查看.png"></p>
<ul>
<li>打开HSDB，点击file-&gt; attach to hotspot process-&gt; 输入进程号，即可看到demo的线程信息如图</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2737761b39e4db04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo进程的线程信息.png"></p>
<ul>
<li>选中main线程，点击第三个按钮（show java stack trace）,显示main线程栈帧信息如下</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-41ba6cb87cb79593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="main线程栈帧信息.png"></p>
<ul>
<li>选中main线程，点击第二个按钮（show the stack memory）,显示当前线程栈区的内存地址如下，下一小节会基于此图分析程序</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e4f239c4ce87b2f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈区内存.png"></p>
<h4 id="3-程序运行时内存变化分析"><a href="#3-程序运行时内存变化分析" class="headerlink" title="3. 程序运行时内存变化分析"></a>3. 程序运行时内存变化分析</h4><h5 id="3-1-JVM运行java代码处理过程"><a href="#3-1-JVM运行java代码处理过程" class="headerlink" title="3.1 JVM运行java代码处理过程"></a>3.1 JVM运行java代码处理过程</h5><ul>
<li><p>JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间。</p>
</li>
<li><p>JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p>
</li>
<li><p>完成上一个步骤后， JVM 首先会执行构造器，编译器会在.java 文件被编译成.class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，静态变量和常量放入方法区。</p>
</li>
<li><p>执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 Student对象，对象引用 student 就存放在栈中。执行过程参照上一篇文章《JVM内存管理》中的“运行时数据区执行过程”小节。</p>
</li>
</ul>
<h5 id="3-2-运行时数据区分析"><a href="#3-2-运行时数据区分析" class="headerlink" title="3.2 运行时数据区分析"></a>3.2 运行时数据区分析</h5><ul>
<li>从第二节中运行代码可以在HSDB中看到栈区的内存分布，如下图是每块内存的介绍：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e4cc6abbc8e5ad37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈区内存地址分析.png"></p>
<p>​    </p>
<ul>
<li>在HSDB中选择Heap Parameters可以看到运行时数据区堆区的分配情况</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-28addc06d3987d15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆区地址分配.png"></p>
<h3 id="注意：准备放大招了，前方大招预警"><a href="#注意：准备放大招了，前方大招预警" class="headerlink" title="注意：准备放大招了，前方大招预警!!!!"></a>注意：准备放大招了，前方大招预警!!!!</h3><p>​    因此我们把以上从HSDB中看到的内存地址和各个区放在同一张图中，就可以很清晰得看清楚代码在运行时，对象在各个区中的运动轨迹。如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4fa414b7c814f179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时数据区结合HSDB分析.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始认真分析！！！</span></span><br><span class="line"><span class="comment">//=============第1步=================</span></span><br><span class="line"><span class="comment">//new Student()在堆区创建一个对象，并且在栈区的局部变量表中引用这个新对象的地址</span></span><br><span class="line">Student T1 = <span class="keyword">new</span> Student();   </span><br><span class="line"><span class="comment">// 在堆区内存空间中找到对应位置并赋值</span></span><br><span class="line">T1.setName(<span class="string">&quot;DY&quot;</span>);  </span><br><span class="line">T1.setSexType(WOMAN_TYPE);</span><br><span class="line">T1.setAge(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//=============第2步=================</span></span><br><span class="line"><span class="comment">// 因为T1是强引用，系统无法回收T1所指的对象，因此T1被挪到了老年代，从地址也可以看到</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=============第3步=================</span></span><br><span class="line"><span class="comment">//new Student()在堆区创建一个对象，并且在栈区的局部变量表中引用这个新对象的地址</span></span><br><span class="line"><span class="comment">//由于是才创建的，从地址可以看到T2所指向的对象被分配在Eden区</span></span><br><span class="line">Student T2 = <span class="keyword">new</span> Student();</span><br><span class="line">T2.setName(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line">T2.setSexType(MAN_TYPE);</span><br><span class="line">T2.setAge(<span class="number">29</span>);</span><br></pre></td></tr></table></figure>


<h4 id="4-总结对JVM堆和栈的认识"><a href="#4-总结对JVM堆和栈的认识" class="headerlink" title="4. 总结对JVM堆和栈的认识"></a>4. 总结对JVM堆和栈的认识</h4><ul>
<li><p><strong>功能角度</strong></p>
<p>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；</p>
<p>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；</p>
</li>
<li><p><strong>线程独享还是共享</strong></p>
<p>  栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。</p>
<p>  堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</p>
</li>
<li><p><strong>空间大小</strong></p>
<p>栈的内存要远远小于堆内存</p>
</li>
</ul>
<p>​    谈到内存空间大小，在开发中经常遇到OOM，要么是内存泄漏导致堆溢出，要么是递归调用没有选好结束条件导致栈溢出等等，那么下面我们再来看看OOM包括些什么。</p>
<h5 id="4-1-堆溢出"><a href="#4-1-堆溢出" class="headerlink" title="4.1 堆溢出"></a>4.1 堆溢出</h5><p>堆内存溢出：创建对象时申请内存空间,超出最大堆内存空间。</p>
<p><strong>解决方案：</strong>如果不是内存泄漏，就是说内存中的对象却是都是必须存活的，那么久应该检查JVM的堆参数设置，与机器的内存对比，看是否还有可以调整的空间，再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行时的内存消耗。Android开发中常见的是因为内存泄漏和Bitmap管理不当造成堆溢出。</p>
<h5 id="4-2-栈溢出"><a href="#4-2-栈溢出" class="headerlink" title="4.2 栈溢出"></a>4.2 栈溢出</h5><p>栈溢出：因为每个方法的执行都需要打包成栈帧，一般的方法调用是很难出现的，如果出现了可能会是无限递归。另一种可能是大量创建线程，JVM不断申请栈内存，导致机器没有足够的内存报OOM，因此一般在开发中，最好用线程池来管理线程。</p>
<h5 id="4-3-方法区溢出"><a href="#4-3-方法区溢出" class="headerlink" title="4.3 方法区溢出"></a>4.3 方法区溢出</h5><ul>
<li>运行时常量池溢出</li>
<li>方法区中保存的Class对象没有被及时回收掉或者Class信息占用的内存超过了我们配置。</li>
</ul>
<h4 id="5-虚拟机优化技术"><a href="#5-虚拟机优化技术" class="headerlink" title="5. 虚拟机优化技术"></a>5. 虚拟机优化技术</h4><h5 id="5-1-对内存的优化"><a href="#5-1-对内存的优化" class="headerlink" title="5.1 对内存的优化"></a>5.1 对内存的优化</h5><p>​    在一般的模型中，两个不同的栈帧的内存区域是独立的，但是大部分的JVM在实现中会进行一些优化，使得两个栈帧出现一部分重叠。（主要体现在方法中有参数传递的情况），让下面栈帧的操作数栈和上面栈帧的部分局部变量重叠在一起，这样做不但节约了一部分空间，更加重要的是在进行方法调用时就可以直接公用一部分数据，无需进行额外的参数复制传递了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-168cea95a7c79716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM栈空间优化.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmStackOpt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> z =(x+<span class="number">5</span>)*<span class="number">10</span>;</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">return</span>  z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JvmStackOpt jvmStack = <span class="keyword">new</span> JvmStackOpt();</span><br><span class="line">        jvmStack.work(<span class="number">10</span>);  <span class="comment">// 变量10的内存空间被共享了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a962becc0817ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JVM栈空间优化取证.png"></p>
<h5 id="5-2-编译优化技术——方法内联"><a href="#5-2-编译优化技术——方法内联" class="headerlink" title="5.2 编译优化技术——方法内联"></a>5.2 编译优化技术——方法内联</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// boolean i1 = max(1,2);</span></span><br><span class="line">    <span class="comment">//调用max方法：  虚拟机栈 --入栈（max 栈帧）</span></span><br><span class="line">    <span class="keyword">boolean</span> i1 = <span class="number">1</span>&gt;<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//方法的执行入栈帧。</span></span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>回不去的过去，前进吧，战士</title>
    <url>/2021/01/30/%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E8%BF%87%E5%8E%BB%EF%BC%8C%E5%89%8D%E8%BF%9B%E5%90%A7%EF%BC%8C%E6%88%98%E5%A3%AB/</url>
    <content><![CDATA[<h3 id="1-回不去的学生时代"><a href="#1-回不去的学生时代" class="headerlink" title="1.回不去的学生时代"></a>1.回不去的学生时代</h3><p>回忆总想哭，但是有了过去战斗后的伤痕累累，才能给当前的自己更加不畏未来勇气！</p>
<blockquote>
<p>2011年9月 - 2015年7月               重庆邮电大学                          电气工程及其自动化</p>
<p>2015年9月 - 2018年7月               重庆大学(保研)                                 车辆工程</p>
</blockquote>
<h3 id="2-皮实的大学时光"><a href="#2-皮实的大学时光" class="headerlink" title="2.皮实的大学时光"></a>2.皮实的大学时光</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-6a0bed97c6ec2df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崎岖之路.png"></p>
<p>为什么是皮实的大学时光？请看上面这张图片，这是我大学走过的最崎岖的一条路，而我的大学生活也似乎像这条路一样曲折，但当到达山顶的那一刻，没人能体会到其中的兴奋。因为我是一个闲不下来，喜欢到处走走；停不下来，喜欢到处做做，喜欢到处折腾的人。在大学4年，有太多的失败，又有不少的成功。正是这些一件件“瞎折腾”构成了我皮实的大学时光。下面我以相册中的<strong>”照片残骸“</strong>来慢慢回忆吧。</p>
<h4 id="2-1-接管科技创新协会"><a href="#2-1-接管科技创新协会" class="headerlink" title="2.1 接管科技创新协会"></a>2.1 接管科技创新协会</h4><p>时间回到2012年下半年。当时我接管了科技创新协会(学校的一个社团)。<br>在大一上的时候，我和室友在准备一节课的上台表演时，偶然搜到了乔布斯的一些故事，越看越崇拜他，当时还做了一个简陋的面具，如下照片。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-07c9df645b8f965d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jobs.jpg"></p>
<p>在那时之后，对于一些高科技东西特别好奇，由于专业原因，我和室友开始学习<strong>《郭天祥的51单片机》</strong>，边学边动手搭建自己的最小系统板子，最后在2012年，暑假两个月的时间，我和室友一起成功的自己焊接电路板，自己写程序完成了一个<strong>“带有自动感光功能计算器”</strong>，虽然这个特别简单，但是对于自己亲手做成的东西，特别有成就感。在开学之后，以社团的名义，参加了重庆市组织的《高校联盟电子设计大赛》,并且获得了不错成绩。最后在12月份的时候，我们社团因此被评为<strong>”十佳社团“</strong>(全校91个社团)。下图是获奖照片和社团内的比赛分享。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4120b6d219fe8102.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="科技创新协会.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-368fe056cca5260e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单片机比赛分享.jpg"></p>
<h4 id="2-2-创业经历"><a href="#2-2-创业经历" class="headerlink" title="2.2 创业经历"></a>2.2 创业经历</h4><h5 id="2-2-1-被扼杀的外卖"><a href="#2-2-1-被扼杀的外卖" class="headerlink" title="2.2.1 被扼杀的外卖"></a>2.2.1 被扼杀的外卖</h5><p>大二大三，闲不下来的我发现同学们经常上完课就回寝室，可能是因为食堂饭菜吃腻了，中午也不愿意食堂吃饭。于是，我拉了几个朋友，一起创办了<strong>“零点外卖”</strong>，主要负责部分同学们的午餐和晚餐。当时为了宣传，创建了各种共享群（代取包裹群，拼车群，练车群…….）。我们平均一天可以有300单左右的量。但是正当我们想放大规模的时候，美团和饿了么开始“打架”。推出“8元吃饱，10元吃好”的口号，一下子就把我们外卖创业史扼杀在摇篮中。</p>
<h5 id="2-2-2-过于旺盛的驾校"><a href="#2-2-2-过于旺盛的驾校" class="headerlink" title="2.2.2 过于旺盛的驾校"></a>2.2.2 过于旺盛的驾校</h5><p>我们原班人马都还在感叹资本的强大和叹息我们第一份创业经历就这样失败的不舍时，我们发现学校的驾校每天都有好多人在排队学车，一个人只能练习一两趟，而要等待一上午。由于做外卖有了一点点积累，于是我们几个都没什么商量，凑足了十几万块，买了两辆长安逸动，加盟了凤凰驾校，在我们重邮开启了凤凰驾校-重邮分部。当时由于学校十分提倡大学生创业创新，辅导员也帮我们做了很多宣传，我们每天也做到学车接送服务，在开学两三个月的时间，我们就招了180多名学员，严重超了我们两辆车的培训负荷，导致很多同学学了车，不能去考试(交管所限制了一辆车一个月的考试人数)，最后我们不得不把学习结束的同学安排到总校去参加考试。</p>
<p>此时时间也到了大三下，该做人生抉择的时候，由于我当时成绩每年都在年级前10(总共206人)，顺利申请到了保研名额，在经过各种考试，面试之后，我顺利保送到了重庆大学。</p>
<h5 id="2-2-3-总算盛开的洗碗机"><a href="#2-2-3-总算盛开的洗碗机" class="headerlink" title="2.2.3 总算盛开的洗碗机"></a>2.2.3 总算盛开的洗碗机</h5><p>由于保研了，有一段空闲的时间，不甘心前面失败的我们又搞起了事情，由于之前做过外卖，我们也发现学校周边餐馆生意异常火爆，每天中午和晚上饭后都堆了很大一摊子等待清晰的碗筷，如果餐馆自己洗，必定每个餐馆要请一个人专门干这个事情。于是乎团队的一个小伙伴说，一起搞洗碗机，把周边的所有碗筷收集起来，我们洗完了送回去。就出于这个简单的想法，大家都一拍即合的开始干起来，开始很多餐馆不愿意把碗筷交给我们洗，不是因为收费，是因为怕自己的碗筷到了别人家的餐馆，自己亏了，后来我们想到直接我们出统一的碗筷，直接给餐馆使用，用完了，我们收回来直接一起洗了…..<br>很庆幸的是，这个项目最后得到了我们院某位老师的支持，最后在有一定运营规模的时候，我们和老师一起做了一个洗碗流水线，大大加快了洗碗效率。<br>由于后面去重大读研了，我也很不舍的离开了我们的团队。<br>不过很庆幸的是，居然我们的事情，还有一名记者报道出来了。<a href="https://www.163.com/dy/article/DM9H7G7Q0511D84J.html">小辣椒消毒服务公司</a></p>
<h3 id="3-战斗的研究生生活"><a href="#3-战斗的研究生生活" class="headerlink" title="3.战斗的研究生生活"></a>3.战斗的研究生生活</h3><p>刚到了新的学校，我时常反思自己到底想干什么。虽然本科在创业上花了不少时间，但是我对技术的喜爱一点没有降，研究生的生活再次燃起了我对技术的热爱。</p>
<p>研一的时候，在一次听前言讲座的机会中，偶然接触到了讯飞发布语音交互产品，当时觉得特别好玩，特别牛X，一回来我就到处找资料。由于当时讯飞主要是To B的业务，几乎没有预留给个人开发者的接口。但是天无绝人之路，我发现当时百度对个人开发者提供了很多开发接口，于是就开启了我的开发之路。</p>
<h5 id="3-1-用“助理小荣”备战“上汽杯”软件挑战赛"><a href="#3-1-用“助理小荣”备战“上汽杯”软件挑战赛" class="headerlink" title="3.1 用“助理小荣”备战“上汽杯”软件挑战赛"></a>3.1 用“助理小荣”备战“上汽杯”软件挑战赛</h5><p>当真正接入到百度语音交互方式之后，结合我本科自己对单片机的学习经历，我花了研二一年的时间，基于STM32开发板，自己搭模块、调驱动和应用程序；基于百度语音，百度地图等API，开发出自己的V1，V2和V3版“助理小荣”。V1版实现了硬件各模块调通能运行需要的五类功能，V2版实现了基于百度各开放API开发的语音交互系统，V3版是结合软硬件一起合成的“助理小荣”，这个版本的助理小荣已经具备语音交互，语音控制等复杂一些的功能了。我开发板安装在长安逸动上，实现了一整条链路的控制。<strong>最后通过这个项目拿到了广汽研究院、泛亚技术中心和上汽乘用车实习Offer。</strong></p>
<p><a href="https://www.iqiyi.com/w_19rtqsmjl1.html">V3版助理小荣–实现五大类语音交互控制</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-8d893e0ff15484e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上汽实习通知.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7557d298036e93a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广汽实习通知.png"></p>
<h5 id="3-2-DuerOS开发者"><a href="#3-2-DuerOS开发者" class="headerlink" title="3.2 DuerOS开发者"></a>3.2 DuerOS开发者</h5><p>在广汽研究院实习期间，我也没有闲着，我继续基于百度语音和生态API开发应用，最后在百度第一次发布DuerOS之后，经过和其他开发者PK基于百度开发的应用，成功成为了<strong>DuerOS第一批开发者</strong>，最后结合百度的核心板加一个普通音箱，实现了<strong>AI音箱</strong>的功能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-050a0ddc879fc5d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方推广.jpg"></p>
<h5 id="3-3-ACM图灵中国大会"><a href="#3-3-ACM图灵中国大会" class="headerlink" title="3.3 ACM图灵中国大会"></a>3.3 ACM图灵中国大会</h5><p>当实习结束回到重庆之后，我拉着师弟们一起继续战斗，报名参加了<strong>ACM图灵中国联合清华大学举办的“全国高校物联网应用创新大赛”</strong>。我和师弟们通宵达旦破解长安逸动DBC协议，最后使用我之前已经搭建完成的语音交互app和控制板，完成了五大类语音交互功能和在黑盒情况下语音控制整车一部分的作品(实现整车启停，所有灯光，座椅，空调，雨刮，车窗)。最后用此项目，获得了<strong>西南片区第一名，全国第三名</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-0f10262e12ea4857.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西南赛区一等奖领奖.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-84be8d1b7242b628.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ACM领奖.jpg"></p>
<h3 id="4-完美收官毕业"><a href="#4-完美收官毕业" class="headerlink" title="4.完美收官毕业"></a>4.完美收官毕业</h3><p>在研究生期间，我还有一个研究方向是基于DSRC专用短程通信技术的车辆防碰撞系统，主要是基于DSRC通信技术，结合超声波雷达传感器，解析报文协议，做了前向制动提示功能，当前车踩刹车制动的时候，判断两车距离和速度，如果找警戒阈值内就发出警报提示。(演示视频在答辩PPT中)</p>
<p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201901&filename=1018853533.nh&v=%25mmd2BEvx5EgDftSeuKY9NRchOx9%25mmd2FT%25mmd2FYIUMvrnTD3QIVrgcFqltS9pzJzIOQC54h7lnkb">基于DSRC技术的车辆防碰撞语音提示与辅助控制系统的研发</a></p>
<h3 id="5-学生时代所有自己开发的项目视频"><a href="#5-学生时代所有自己开发的项目视频" class="headerlink" title="5.学生时代所有自己开发的项目视频"></a>5.学生时代所有自己开发的项目视频</h3><blockquote>
<p>链接：<a href="https://pan.baidu.com/s/14Zvq1LSM9zYgEhwsgpxEIg">https://pan.baidu.com/s/14Zvq1LSM9zYgEhwsgpxEIg</a><br>提取码：547s<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>垃圾回收机制(四)</title>
    <url>/2021/01/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E5%9B%9B/</url>
    <content><![CDATA[<h4 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1. 垃圾回收算法"></a>1. 垃圾回收算法</h4><h5 id="1-1-复制算法-Copying"><a href="#1-1-复制算法-Copying" class="headerlink" title="1.1 复制算法(Copying)"></a>1.1 复制算法(Copying)</h5><p>​    将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p>
<p>​    专家经过大量实验发现：新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>​    HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<h5 id="1-2-标记-清除算法-Mark-Sweep"><a href="#1-2-标记-清除算法-Mark-Sweep" class="headerlink" title="1.2 标记-清除算法(Mark-Sweep)"></a>1.2 标记-清除算法(Mark-Sweep)</h5><p>​    标记-清除算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>​    它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h5 id="1-3-标记-整理算法-Mark-Compact"><a href="#1-3-标记-整理算法-Mark-Compact" class="headerlink" title="1.3 标记-整理算法(Mark-Compact)"></a>1.3 标记-整理算法(Mark-Compact)</h5><p>​    首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法虽然没有内存碎片，但是效率偏低。</p>
<h4 id="2-JVM垃圾回收器"><a href="#2-JVM垃圾回收器" class="headerlink" title="2. JVM垃圾回收器"></a>2. JVM垃圾回收器</h4><p>​    在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，因此在新生代通常使用的是复制算法。</p>
<p>​    而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<h5 id="2-1-垃圾回收器分类"><a href="#2-1-垃圾回收器分类" class="headerlink" title="2.1 垃圾回收器分类"></a>2.1 垃圾回收器分类</h5><p>​    JVM常见的垃圾回收器分为三类：单线程垃圾回收器、多线程<strong>并行</strong>垃圾回收器和多线程<strong>并发</strong>垃圾回收器。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7b5dc78164b2a636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垃圾回收器.png"></p>
<h4 id="3-各类垃圾收集器的介绍"><a href="#3-各类垃圾收集器的介绍" class="headerlink" title="3 各类垃圾收集器的介绍"></a>3 各类垃圾收集器的介绍</h4><h5 id="3-1-单线程垃圾回收器"><a href="#3-1-单线程垃圾回收器" class="headerlink" title="3.1 单线程垃圾回收器"></a>3.1 单线程垃圾回收器</h5><p>​    在JDK1.3.1之前，单线程回收器是唯一的选择。它的单线程意义不仅仅是说它只会使用一个CPU或一个收集线程去完成垃圾收集工作。而且它进行垃圾回收的时候，必须暂停其他所有的工作线程（Stop The World,STW），直到它收集完成。它适合Client模式的应用，在单CPU环境下，它简单高效，由于没有线程交互的开销，专心垃圾收集自然可以获得最高的单线程效率。</p>
<p>​    串行的垃圾收集器有两种，Serial与Serial Old，一般两者搭配使用。新生代采用Serial，是利用复制算法；老年代使用Serial Old采用标记-整理算法。Client应用或者命令行程序可以，通过-XX:+UseSerialGC可以开启上述回收模式。下图是其运行过程示意图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-163d08fcb16ad6ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单线程垃圾回收器.png"></p>
<h5 id="3-2-多线程并行垃圾回收器"><a href="#3-2-多线程并行垃圾回收器" class="headerlink" title="3.2 多线程并行垃圾回收器"></a>3.2 多线程并行垃圾回收器</h5><p>​    ParNew和Parallel Scavenge都属于并行垃圾回收器，使用多线程并行处理的方式来减少垃圾收集时间，让用户代码获得更长的运行时间。并行垃圾回收器最终的关注点是<strong>高吞吐量</strong>。</p>
<p>​    ParNew和Parallel Scavenge都是新生代的回收器，采用的是复制算法来多线程回收对象。</p>
<p>​    垃圾回收过程和单线程回收比较类似，只是在上图<strong>回收阶段</strong>JVM开启多线程来收集待回收的对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cfaa49d757b17323.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程并行垃圾回收器.png"></p>
<h5 id="3-3-多线程并发垃圾回收器"><a href="#3-3-多线程并发垃圾回收器" class="headerlink" title="3.3 多线程并发垃圾回收器"></a>3.3 多线程并发垃圾回收器</h5><p>​    CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。通过垃圾回收线程和用户线程并发的方式，来实现及时响应的需求。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-aad651e97ff53aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CMS.png"></p>
<p>​    从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对复杂一些，整个过程分为4个步骤，包含：</p>
<ul>
<li><strong>初始标记</strong>：耗时短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</li>
<li><strong>并发标记</strong>：和用户的应用程序同时进行，进行GC Roots追踪的过程。</li>
<li><strong>重新标记</strong>：短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li>
<li><strong>并发清除</strong>：和用户线程一起请求待回收对象。</li>
</ul>
<p>​    由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>​    <strong>浮动垃圾：</strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<h5 id="3-4-G1回收器"><a href="#3-4-G1回收器" class="headerlink" title="3.4 G1回收器"></a>3.4 G1回收器</h5><p>​    G1垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器。G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<h5 id="3-4-1-G1回收器的内存分块"><a href="#3-4-1-G1回收器的内存分块" class="headerlink" title="3.4.1 G1回收器的内存分块"></a>3.4.1 G1回收器的内存分块</h5><p>本质上来说，G1垃圾回收器依然是一个分代垃圾回收器。但是它与一般的回收器所不同的是，它引入了额外的概念-Region。G1垃圾回收器把堆划分成一个个大小相同的Region。在HotSpot的实现中，整个堆被划分成2048左右个Region。每个Region的大小在1-32MB之间，具体多大取决于堆的大小。</p>
<p>G1垃圾回收器的分代也是建立在这些Region的基础上的。对于Region来说，它会有一个分代的类型，并且是唯一一个。即每一个Region，它要么是young的，要么是old的。</p>
<p>还有一类十分特殊的Humongous。所谓的Humongous，就是一个对象的大小超过了某一个阈值——HotSpot中是Region的1/2，那么它会被标记为Humongous。如果我们审视HotSpot的其余的垃圾回收器，可以发现这种对象以前被称为大对象，会被直接分配老年代。而在G1回收器中，则是做了特殊的处理。<br> G1并不要求相同类型的region要相邻。换言之，就是G1回收器不要求它们连续。当然在逻辑上，分代依旧是连续的。因此，G1回收器的堆区内存划分如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f1d742d27c4a079c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="G1内存划分.png"></p>
<p><strong>注：</strong>其中E代表的是Eden，S代表的是Survivor，H代表的是Humongous，剩余的深蓝色代表的是Old（或者Tenured），灰色的代表的是空闲的region</p>
<p>一个Region是G1回收器一次回收的最小单元。即每一次回收都是回收N个Region。这个N是多少，主要受到G1回收的效率和用户设置的软实时目标有关。每一次的回收，G1会选择可能回收最多垃圾的Region进行回收。与此同时，G1回收器会维护一个空间Region的链表。每次回收之后的Region都会被加入到这个链表中。</p>
<h5 id="3-4-2-G1的回收流程"><a href="#3-4-2-G1的回收流程" class="headerlink" title="3.4.2 G1的回收流程"></a>3.4.2 G1的回收流程</h5><p>​    G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p>
<p>​    在初始标记阶段，G1会STW标记GC-Roots，在程序运行期间不断监控GC-Roots，并且标记要回收的对象。在最终标记阶段，会多线程并行标记新产生的待回收对象，最后根据用户配置，筛选可能回收最多垃圾的Region进行回收。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e37fc78f778c4969.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="G1处理流程.png"></p>
<h5 id="3-5-垃圾回收器对比"><a href="#3-5-垃圾回收器对比" class="headerlink" title="3.5 垃圾回收器对比"></a>3.5 垃圾回收器对比</h5><p><strong>新生代垃圾回收器对比：</strong></p>
<table>
<thead>
<tr>
<th>回收器</th>
<th>回收算法</th>
<th>回收器类型</th>
<th>回收对象</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>复制算法</td>
<td>单线程</td>
<td>新生代</td>
</tr>
<tr>
<td>ParNew</td>
<td>复制算法</td>
<td>并行的多线程收集器</td>
<td>新生代</td>
</tr>
<tr>
<td>Parallel  Scavenge (侧重吞吐量)</td>
<td>复制算法</td>
<td>并行的多线程收集器</td>
<td>新生代</td>
</tr>
</tbody></table>
<p><strong>老年代垃圾回收器对比：</strong></p>
<table>
<thead>
<tr>
<th>回收器</th>
<th>回收算法</th>
<th>收集器类型</th>
<th>回收对象</th>
</tr>
</thead>
<tbody><tr>
<td>Serial  Old</td>
<td>标记整理算法</td>
<td>单线程</td>
<td>老年代</td>
</tr>
<tr>
<td>Parallel  Old</td>
<td>标记整理算法</td>
<td>并行的多线程收集器</td>
<td>老年代</td>
</tr>
<tr>
<td>CMS (侧重及时响应)</td>
<td>标记清除算法</td>
<td>并行与并发收集器</td>
<td>老年代</td>
</tr>
<tr>
<td>G1</td>
<td>标记整理 + 化整为零</td>
<td>并行与并发收集器</td>
<td>跨新生代和老年代</td>
</tr>
</tbody></table>
<p>注：吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)</p>
<p>垃圾收集时间= 垃圾回收频率 * 单次垃圾回收时间</p>
<h4 id="4-垃圾回收器的配合使用场景"><a href="#4-垃圾回收器的配合使用场景" class="headerlink" title="4. 垃圾回收器的配合使用场景"></a>4. 垃圾回收器的配合使用场景</h4><ul>
<li>场景1：服务器在client模式下，限定单个CPU的环境中使用Serial收集器<ul>
<li>指令：-XX:+UseSerialGC</li>
</ul>
</li>
<li>场景2：服务器在Server模式多核处理器，对用户响应速度有要求的情况下，使用ParNew+CMS组合<ul>
<li>指令：-XX:+UseConcMarkSweepGC 指定使用CMS后，会默认使用ParNew作为新生代收集器</li>
</ul>
</li>
<li>场景3：服务器在高吞吐量为目标，应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互的场景中，使用Parallel Scavenge收集器。<ul>
<li>指令：-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间，大于0的毫秒数</li>
<li>指令：-XX:GCTimeRatio 设置垃圾收集时间占总时间的比率，0&lt;n&lt;100的整数，默认值是1%–1/(1+99)，即n=99</li>
<li>指令：-XX:+UseParallelGC强制使用该收集器，打开该收集器后，将使用Parallel Scavenge（年轻代）+Serial Old(老年代)的组合进行GC</li>
<li>指令：-XX:+UseParallelOldGC，打开该收集器后，将使用Parallel Scavenge（年轻代）+Parallel Old（老年代）的组合进行GC</li>
</ul>
</li>
<li>场景4：面向服务端应用，针对具有大内存、多处理器的机器的情况，可以考虑使用G1垃圾回收器。<ul>
<li>指令：-XX:+UseG1GC 指定使用G1收集器；</li>
<li>指令：-XX:InitiatingHeapOccupancyPercent 当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；</li>
<li>指令：-XX:MaxGCPauseMillis 为G1设置暂停时间目标，默认值为200毫秒；</li>
<li>指令：-XX:G1HeapRegionSize 设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region</li>
</ul>
</li>
</ul>
<h4 id="5-常量池与String"><a href="#5-常量池与String" class="headerlink" title="5. 常量池与String"></a>5. 常量池与String</h4><p>常量池有很多概念，包括运行时常量池、class常量池、字符串常量池。虚拟机规范只规定以上区域属于方法区，并没有规定虚拟机厂商的实现。</p>
<p>严格来说是<strong>静态常量池和运行时常量池</strong>，静态常量池是存放字符串字面量、符号引用以及类和方法的信息，而运行时常量池存放的是运行时一些直接引用。</p>
<ul>
<li>运行时常量池是在类加载完成之后，将静态常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用。这两个常量池在JDK1.7版本之后，就移到堆内存中了，这里指的是物理空间，而逻辑上还是属于方法区（方法区是逻辑分区）。</li>
</ul>
<p><strong>字面量</strong><br>给基本类型变量赋值的方式就叫做字面量或者字面值。比如：int i=120; long j=10L;</p>
<p><strong>符号引用</strong>：包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。</p>
<p><strong>直接引用：</strong>具体对象的索引值。</p>
<h4 id="6-String类的实现"><a href="#6-String类的实现" class="headerlink" title="6.String类的实现"></a>6.String类的实现</h4><p>​    String 类被 final 关键字修饰，而且变量 char 数组也被 final 修饰。我们知道类被 final 修饰代表该类不可继承，而 char[]被 private+final 修饰，代表了 String 对象不可被更改。Java 实现的这个特性叫作 String 对象的不可变性，即 String 对象一旦创建成功，就不能再对它进行改变。</p>
<p>​    在 Java 中，通常有两种创建字符串对象的方式，</p>
<ul>
<li><p>一种是通过字符串常量的方式创建，如 String str=“abc”；</p>
<ul>
<li>这种方式首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</li>
</ul>
</li>
<li><p>另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。</p>
<ul>
<li>这种方式，首先在编译类文件时，”abc”常量字符串将会放入到常量结构中，在类加载时，“abc”将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的”abc” 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。</li>
</ul>
</li>
</ul>
<p>​    如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串的引用，如果没有会把首次遇到的字符串的引用添加到常量池中；如果有，就返回常量池中的字符串引用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>基于源码从零开始编译第一个app</title>
    <url>/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="%5Bhttp://jackou.top/2021/02/10/%E5%BE%92%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81-%E6%89%8B%E6%8A%8A%E6%89%8B%EF%BC%8C%E5%98%B4%E5%AF%B9%E5%98%B4%E7%89%88%E6%9C%AC/%5D(http://jackou.top/2021/02/10/%E5%BE%92%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81-%E6%89%8B%E6%8A%8A%E6%89%8B%EF%BC%8C%E5%98%B4%E5%AF%B9%E5%98%B4%E7%89%88%E6%9C%AC/)">《Android源码编译》</a>中我详细叙述了有了源码之后，如何把原生的代码编译成功的过程。现在有了原生的系统镜像之后，我们是不是也应该编一个app在系统中运行呀，好，那就开始吧，一切从HelloWorld开始。</p>
<h3 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1.创建工程"></a>1.创建工程</h3><h4 id="1-1-搭建最小工程模块"><a href="#1-1-搭建最小工程模块" class="headerlink" title="1.1 搭建最小工程模块"></a>1.1 搭建最小工程模块</h4><p>还记得以前学习单片机的时候，都是从最小系统搭起，那么我们创建工程，最小的工程目录会包含哪些东西呢。见下图，至少包含：</p>
<ul>
<li>AndroidManifest.xml配置文件</li>
<li>Android.mk 编译脚本文件</li>
<li>res目录    用于放资源文件</li>
<li>src目录    用于放源码文件</li>
</ul>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\最小代码模块.png" alt="最小代码模块"></p>
<h4 id="1-2-编写代码"><a href="#1-2-编写代码" class="headerlink" title="1.2 编写代码"></a>1.2 编写代码</h4><p>这个是我在AS中自动生成的工程，代码及其简单。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//AndroidManifest.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.android.helloworld&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//activity_main.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Hello World!&quot;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.android.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\工程目录树.png" alt="工程目录树"></p>
<h4 id="1-3-编写mk文件"><a href="#1-3-编写mk文件" class="headerlink" title="1.3 编写mk文件"></a>1.3 编写mk文件</h4><p>下面介绍部分常用的配置用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义模块标签，build系统根据标签决定哪些模块需要安装</span></span><br><span class="line"><span class="meta">#</span><span class="bash">user:  指该模块只在user版本下才编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">eng:  指该模块只在eng版本下才编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tests: 指该模块只在tests版本下才编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">optional:指该模块在所有版本下都编译</span></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> $(call all-java-files-under, &lt;src&gt;)：获取指定目录下的所有java文件。</span></span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用指定目录下的manifest文件（如果不与mk文件在同一目录的话必须定义）</span></span><br><span class="line">LOCAL_MANIFEST_FILE := src/main/AndroidManifest.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">资源文件目录，可选定义，不定义也没问题</span></span><br><span class="line">LOCAL_RESOURCE_DIRS := $(LOCAL_PATH)/src/main/res</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">模块名称，apk一般使用LOCAL_PACKAGE_NAME，其它使用LOCAL_MODULE</span></span><br><span class="line">LOCAL_PACKAGE_NAME := helloworld</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果导入第三方jar包才使用这句</span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义引用别名   xxxxx为jar包的别名，可以随便取，只要与下面相对应就行</span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := xxxxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">签署当前应用的证书名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用于指定签名时使用的KEY，如果不指定，默认使用testkey，LOCAL_CERTIFICATE可设置的值如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  LOCAL_CERTIFICATE:= platform</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  LOCAL_CERTIFICATE:= shared</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  LOCAL_CERTIFICATE:= media</span></span><br><span class="line"><span class="meta">#</span><span class="bash">而在Android.mk中的这些配置，需要在APK源码的AndroidManifest.xml文件中的manifest节点添加如下内容：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  android:sharedUserId=<span class="string">&quot;android.uid.system&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  android:sharedUserId=<span class="string">&quot;android.uid.shared&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  android:sharedUserId=<span class="string">&quot;android.media&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">这些刚好与上面的mk文件里的配置对应上。</span></span><br><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以声明app需要放在/system/priv-app下</span></span><br><span class="line">LOCAL_PRIVILEGED_MODULE := true</span><br><span class="line"></span><br><span class="line">LOCAL_SDK_VERSION := current</span><br><span class="line"></span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##############################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果jar包放在libs目录下，且libs与Android.mk文件是同级目录，则jar包路径如下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##############################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := xxxxx:libs/3part.jar       // 引用名：jar包名路径</span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br></pre></td></tr></table></figure>
<p>我编helloword工程用到的脚本如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"></span><br><span class="line">LOCAL_PACKAGE_NAME := HelloWorld</span><br><span class="line">LOCAL_SDK_VERSION := current</span><br><span class="line"></span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use the following include to make our <span class="built_in">test</span> apk.</span></span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>


<h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h3><p>使用如下指令初始化指令环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure>


<p>然后使用mm或者mmm来编译即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">- croot: Changes directory to the top of the tree.</span><br><span class="line">- m: Makes <span class="keyword">from</span> the top of the tree.</span><br><span class="line">- mm: Builds all of the modules <span class="keyword">in</span> the current directory.</span><br><span class="line">- mmm: Builds all of the modules <span class="keyword">in</span> the supplied directories.</span><br><span class="line">- cgrep: Greps <span class="keyword">on</span> all local C/C++ files.</span><br><span class="line">- jgrep: Greps <span class="keyword">on</span> all local Java files.</span><br><span class="line">- resgrep: Greps <span class="keyword">on</span> all local res<span class="comment">/*.xml files.</span></span><br><span class="line"><span class="comment">- godir: Go to the directory containing a file.</span></span><br></pre></td></tr></table></figure>
<p>mm是编译当前目录下的所有模块<br>mmm是编译指定目录的所有模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//编译Launcher2模块</span><br><span class="line">mmm packages/apps/Launcher2/</span><br><span class="line"></span><br><span class="line">//编译当前目录下的模块</span><br><span class="line">jackou@ubuntu:~/work_directory/pdk/apps/HelloWorld$ mm</span><br></pre></td></tr></table></figure>


<p>因为我就在工程目录，就直接使用mm即可，可以看到提示了很多配置信息，其中最后一个OUT_DIR就是编译完成的app会放在out目录下。</p>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\mm.png" alt="mm"></p>
<h4 id="3-编译成功"><a href="#3-编译成功" class="headerlink" title="3.编译成功"></a>3.编译成功</h4><p>我们可以看到最后一行编程成功，然后apk放在out/target/product…c/system/app/HelloWorld目录下。</p>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\编译完成.png" alt="编译完成"></p>
<p><img src="/2021/02/26/%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E7%AC%AC%E4%B8%80%E4%B8%AAapp/blog\source_posts\基于源码从零开始编译第一个app\apk.png" alt="apk"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>编译Android源码</tag>
        <tag>编译apk</tag>
      </tags>
  </entry>
  <entry>
    <title>多态、虚函数、纯虚函数、模板函数</title>
    <url>/2021/06/10/%E5%A4%9A%E6%80%81%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1-属性初始化"><a href="#1-属性初始化" class="headerlink" title="1. 属性初始化"></a>1. 属性初始化</h4><p>第一种方式：直接在构造函数后面给对象赋值</p>
<p>第二种方式：在构造函数后面调对象属性构造函数进行赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// 已经声明了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 注意：string 是 std 命名空间里面的成员，C++源码是这种写法std::string</span></span><br><span class="line">    <span class="comment">// string内部其实就是对 char*的封装</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) :name(name), age(age) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 课程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Course(<span class="built_in">string</span> name) :name(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 如果定义的是对象成员，必须这样初始化(构造函数的后面 : 对象成员(内容))  使用我们的第二种方式</span></span><br><span class="line">    Course course; <span class="comment">// 对象成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, Course course1, <span class="built_in">string</span> courseNameInfo)</span><br><span class="line">    :Person(name, age) <span class="comment">// 既然继承了父类就必须给父类的构造函数初始化</span></span><br><span class="line">    <span class="comment">// course(course1) // 第二种方式，编译阶段认可的 对象=对象   对象直接的赋值而已</span></span><br><span class="line">    ,</span><br><span class="line">     course(courseNameInfo) <span class="comment">// 第三种方式， 对象(string内容)  直接初始化Course对象 --- 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// this-&gt;course = course1; // 第一种方式（对象=对象） 编译阶段不认可，无法监测到你是否真的给course对象成员初始化了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Course <span class="title">c</span><span class="params">(<span class="string">&quot;C++&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">student</span><span class="params">(<span class="string">&quot;Jack&quot;</span>, <span class="number">30</span>, c, <span class="string">&quot;NDK内容真多&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h4><p><strong>重写属于动态多态，重载属于静态多态</strong>。同一个方法有不同的实现。</p>
<h5 id="2-1-动态多态"><a href="#2-1-动态多态" class="headerlink" title="2.1 动态多态"></a>2.1 动态多态</h5><p>动态多态是只有在运行时才知道调用那个方法。</p>
<blockquote>
<p>Java语言默认支持多态<br>C++默认关闭多态，怎么开启多态？ 虚函数  在父类上给函数增加 virtual关键字</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android标准</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加上virtual关键字之后，C++就支持多态了</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写父类的函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;HomeActivity onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写父类的函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LoginActivity onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此函数 体现多态，例如：你传入HomeActivity，我就帮你运行HomeActivity</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startToActivity</span><span class="params">(BaseActivity * baseActivity)</span> </span>&#123;</span><br><span class="line">    baseActivity-&gt;onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 第一个版本</span></span><br><span class="line">    HomeActivity *homeActivity = <span class="keyword">new</span> HomeActivity();</span><br><span class="line">    LoginActivity *loginActivity = <span class="keyword">new</span> LoginActivity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如下调用输出BaseActivity的onstart()</span></span><br><span class="line">    <span class="comment">// 因此C++默认不支持多态</span></span><br><span class="line">    startToActivity(homeActivity);</span><br><span class="line">    startToActivity(loginActivity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (homeActivity &amp;&amp; loginActivity) <span class="keyword">delete</span> homeActivity; <span class="keyword">delete</span> loginActivity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二个版本</span></span><br><span class="line">    BaseActivity * activity1 = <span class="keyword">new</span> HomeActivity();</span><br><span class="line">    BaseActivity * activity2 = <span class="keyword">new</span> LoginActivity();</span><br><span class="line">    startToActivity(activity1);</span><br><span class="line">    startToActivity(activity2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-2-静态多态"><a href="#2-2-静态多态" class="headerlink" title="2.2 静态多态"></a>2.2 静态多态</h5><p>在编译器就确定调用某个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number1 + number2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> number1, <span class="keyword">float</span> number2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number1 + number2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> number1, <span class="keyword">double</span> number2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number1 + number2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add(<span class="number">10000</span>, <span class="number">10000</span>);</span><br><span class="line">    add(<span class="number">1.9f</span>, <span class="number">2.8f</span>);</span><br><span class="line">    add(<span class="number">545.4</span>, <span class="number">654.54</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-纯虚函数"><a href="#3-纯虚函数" class="headerlink" title="3. 纯虚函数"></a>3. 纯虚函数</h4><p>在C++中不支持抽象类和接口的定义，所以就引出了纯虚函数和全纯虚函数。</p>
<p><strong>纯虚函数相等于JAVA中的抽象类；全纯虚函数相当于JAVA中的接口。</strong></p>
<p>纯虚函数定义最后要有 “= 0”字样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 纯虚函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类/纯虚函数： 分为：1.普通函数， 2.抽象函数/纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="built_in">string</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;XmlResourceParser解析布局文件信息... 反射&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1.普通函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setContentView(getLayoutID());</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line">        initData();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纯虚函数是必须继承的（如果子类没有重写纯虚函数，子类就是抽象类）， 虚函数是不是不必须的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.抽象函数/纯虚函数</span></span><br><span class="line">    <span class="comment">// virtual string getLayoutID(); // 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getLayoutID</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initListener</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 MainActivity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> :</span> <span class="keyword">public</span> BaseActivity &#123; <span class="comment">// MainActivity如果没有重新父类的纯虚函数，自己就相当于 抽象类了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getLayoutID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;R.layout.activity_main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// Button btLogin = findViewById(R.id.bt_login);</span></span><br><span class="line">        <span class="comment">// Button btRegister = findViewById(R.id.bt_register);</span></span><br><span class="line">        <span class="comment">// TextView tvInfo = findViewById(R.id.tv_info);</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tvInfo.setText(&quot;info...&quot;);</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*btLogin.setOnClickListener(new View.OnClickListener() &#123;</span></span><br><span class="line"><span class="comment">                   @Override</span></span><br><span class="line"><span class="comment">                   public void onClick(View v) &#123;</span></span><br><span class="line"><span class="comment">                       // 点击做事情</span></span><br><span class="line"><span class="comment">                   &#125;</span></span><br><span class="line"><span class="comment">               &#125;);*/</span></span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：抽象类型 MainActivity 绝对不能实例化</span></span><br><span class="line">    <span class="comment">// MainActivity mainActivity;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新了父类所有的纯虚函数</span></span><br><span class="line">    MainActivity mainActivity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全纯虚函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此类所有的函数 ，都是纯虚函数，就相当于 Java的接口了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISudent_DB</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">(<span class="keyword">int</span> _id)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(<span class="keyword">int</span> _id, Student student)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Student <span class="title">queryByStudent</span><span class="params">(Student student)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_DBImpl1</span> :</span> <span class="keyword">public</span> ISudent_DB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">(<span class="keyword">int</span> _id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(<span class="keyword">int</span> _id, Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">queryByStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询操作，省略代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student_DBImpl1 studentDbImpl1;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-模板函数"><a href="#4-模板函数" class="headerlink" title="4. 模板函数"></a>4. 模板函数</h4><p>C++中模板函数非常类似JAVA中泛型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加分合集  int double float ... 你都要考虑，你是不是要定义很多的 函数</span></span><br><span class="line"><span class="comment">/*void addAction(int n1, int n2) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;addAction(int n1, int n2):&quot; &lt;&lt; n1 + n1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void addAction(float n1, float n2) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;addAction(int n1, int n2):&quot; &lt;&lt; n1 + n1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void addAction(double n1, double n2) &#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;addAction(int n1, int n2):&quot; &lt;&lt; n1 + n1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数  == Java的泛型解决此问题</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAction</span><span class="params">(TT n1, TT n2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;模板函数：&quot;</span> &lt;&lt; n1 + n2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addAction(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    addAction(<span class="number">10.2f</span>, <span class="number">20.3f</span>);</span><br><span class="line">    addAction(<span class="number">545.34</span>, <span class="number">324.3</span>);</span><br><span class="line">    addAction&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为是一个TT，类型必须要统一</span></span><br><span class="line">    <span class="comment">/*addAction(2, 324.3);</span></span><br><span class="line"><span class="comment">    addAction(54, 324.3f);*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-继承关系中构造函数和析构函数调用顺序"><a href="#5-继承关系中构造函数和析构函数调用顺序" class="headerlink" title="5.继承关系中构造函数和析构函数调用顺序"></a>5.继承关系中构造函数和析构函数调用顺序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    Person(<span class="built_in">string</span> name) : name(name) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    ~Person()  &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父 test...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    Student(<span class="built_in">string</span> name) : Person(name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Person::test();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Student()  &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;子 test...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">student</span><span class="params">(<span class="string">&quot;Jack&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Person构造函数</span></span><br><span class="line">    <span class="comment">// Student构造函数</span></span><br><span class="line">    <span class="comment">// Student析构函数</span></span><br><span class="line">    <span class="comment">// Person析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">student1</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line">    student1.test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(七) -- AQS</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E4%B8%83-AQS/</url>
    <content><![CDATA[<h4 id="1-AQS是什么"><a href="#1-AQS是什么" class="headerlink" title="1. AQS是什么"></a>1. AQS是什么</h4><p>​    队列同步器(AbstractQueuedSynchronizer,AQS)，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<h4 id="2-AQS使用方式和其中的设计模式"><a href="#2-AQS使用方式和其中的设计模式" class="headerlink" title="2.AQS使用方式和其中的设计模式"></a>2.AQS使用方式和其中的设计模式</h4><p>​    AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p>
<p>​    同步器使用的设计模式：<strong>模板方法</strong>的设计模式。</p>
<p>​    在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p>
<p>​    <strong>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器</strong>。可以这样理解二者之间的关系：</p>
<p>​    <strong>锁是面向使用者的</strong>，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；</p>
<p>​    <strong>同步器面向的是锁的实现者</strong>，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<p>​    <strong>实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</strong></p>
<h4 id="3-AQS中的方法"><a href="#3-AQS中的方法" class="headerlink" title="3.AQS中的方法"></a>3.AQS中的方法</h4><p>​    在AQS抽象类中定义了以下模板方法，分为三类：<strong>独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-43425442cd07b3be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS模板方法.png"></p>
<p>可供子类重写的方法如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-59cc20b24965de2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS独占式可重写方法.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cecc3ff6a0d1fb79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS共享式可重写方法.png"></p>
<h5 id="3-2-AQS和synchronznized底层实现区别"><a href="#3-2-AQS和synchronznized底层实现区别" class="headerlink" title="3.2 AQS和synchronznized底层实现区别"></a>3.2 AQS和synchronznized底层实现区别</h5><p>​    AQS是基于LockSupport等待超时来实现锁机制，底层实现是基于volatile和cas实现。</p>
<p>​    synchronznized映射成字节码指令就是增加两个指令：monitorenter、monitorexit；</p>
<p>​    当一条线程执行时遇到monitorenter指令时，它会尝试去获得锁，如果获得锁，那么所计数器+1（为什么要加1，因为它是可重入锁，可根据这个琐计数器判断锁状态），如果没有获得锁，那么阻塞；当它遇到一个monitoerexit时，琐计数器会-1，当计数器为0时，就释放锁。</p>
<h5 id="3-3-如何自定义一个锁"><a href="#3-3-如何自定义一个锁" class="headerlink" title="3.3 如何自定义一个锁"></a>3.3 如何自定义一个锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line">    <span class="comment">// 用静态代理的方法，包装同步器方法，修改同步器state状态值</span></span><br><span class="line">    <span class="comment">// 实现可重入锁，state不为0，就是有一个或者多个线程持有锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*判断处于占用状态*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState()==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*获得锁*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*释放锁*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(getState()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//compareAndSetState(1,0);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ready get lock&quot;</span>);</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; already got lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ready release lock&quot;</span>);</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; already released lock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-AQS基本思想-CLH队列锁"><a href="#4-AQS基本思想-CLH队列锁" class="headerlink" title="4.AQS基本思想 CLH队列锁"></a>4.AQS基本思想 CLH队列锁</h4><p>​    CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。</p>
<p>​    CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p>
<p>​    AQS是CLH队列锁的一种变体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看等待队列中是否</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 遍历CLH队列</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// 获得前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">//如果是等待队列头节点并且拿到锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   </span><br><span class="line">                parkAndCheckInterrupt())    <span class="comment">// 拿锁失败，将线程阻塞</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-AQS原理"><a href="#5-AQS原理" class="headerlink" title="5.AQS原理"></a>5.AQS原理</h4><p>​    AQS内部有一个关键的成员变量state，用于记录当前的同步状态；第二需要实现自己的同步类的话，需要采用AQS的模板设计模式，实现模板方法；AQS内部本质上是一个CLH队列锁，每一个等待的线程都会被包装成一个节点，节点内容是：当前线程，前一个节点和是否需要获取锁状态。然后将该节点挂到一个链表上去。然后线程会检测前一个线程是否释放了锁，即locked标志位是否变成了false，如果变成了false自己就可以拿到这把锁。AQS在检查锁的时候，不会一直自旋的去查看locked的状态，会尝试去检查几次，如果前一个线程都没有释放，则自己进入block状态。</p>
<h4 id="6-公平锁和非公平锁"><a href="#6-公平锁和非公平锁" class="headerlink" title="6.公平锁和非公平锁"></a>6.公平锁和非公平锁</h4><p>​    公平锁：所有需要拿锁的线程都会被挂到队列锁的最后面。</p>
<p>​    非公平锁：在一个线程拿锁的时候，一个线程也同时来抢锁，这就形成了非公平锁。</p>
<p>​    ReentrantLock实现了公平锁和非公平锁，实现的具体差异在于hasQueuedPredecessors()的调用。上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 公平锁的实现有调用hasQueuedPredecessors()判断对待队列是否是有线程等待</span></span><br><span class="line">        <span class="comment">// 非公平锁没有调用该方法，所有等待队列线程和当前线程竞争拿锁。</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;   </span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;	</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-ReentrantLock锁的可重入-递归拿自己锁"><a href="#7-ReentrantLock锁的可重入-递归拿自己锁" class="headerlink" title="7.ReentrantLock锁的可重入(递归拿自己锁)"></a>7.ReentrantLock锁的可重入(递归拿自己锁)</h4><p>​    可以递归拿锁。每次拿锁之后，多记录一下同步的状态。<br>​    例如：如果锁不能重入，则会发生死锁，自己把自己锁死了。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void reenter(int x)&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;:递归层级:&quot;+x);</span><br><span class="line">        int y &#x3D; x - 1;</span><br><span class="line">        if (y&#x3D;&#x3D;0) return;</span><br><span class="line">        else&#123;</span><br><span class="line">            reenter(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    实现可重入锁方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否处于占用状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getExclusiveOwnerThread()==Thread.currentThread())&#123;</span><br><span class="line">            <span class="comment">// 如果自己线程拿到锁，将AQS中state状态值+1，为了释放使用</span></span><br><span class="line">            setState(getState()+<span class="number">1</span>);   </span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(getExclusiveOwnerThread()!=Thread.currentThread())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">        setState(getState()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(getState()==<span class="number">0</span>)&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试用例代码见： <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(五) -- 并发编程</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E4%BA%94-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h4><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>​    死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
<h5 id="1-2-产生死锁的必要条件"><a href="#1-2-产生死锁的必要条件" class="headerlink" title="1.2 产生死锁的必要条件"></a>1.2 产生死锁的必要条件</h5><ul>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<h5 id="1-3-如何解决死锁"><a href="#1-3-如何解决死锁" class="headerlink" title="1.3 如何解决死锁"></a>1.3 如何解决死锁</h5><p>​    知道死锁发生的原因，解决死锁的方法也有四种：</p>
<ul>
<li><p>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</p>
</li>
<li><p>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</p>
</li>
<li><p>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</p>
</li>
<li><p>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</p>
<p>避免死锁常见的算法有<strong>有序资源分配法、银行家算法</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产生死锁案例</span></span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>具体手段</strong>：(1)  内部确认拿锁顺序，修改拿锁和释放锁顺序；(2) 采用尝试拿锁的机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用手段1解决死锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">	<span class="comment">// do someThing</span></span><br><span class="line">	<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">        <span class="comment">// do someThing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用tryLock尝试拿锁的机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock No13 = <span class="keyword">new</span> ReentrantLock();<span class="comment">//第一个锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock No14 = <span class="keyword">new</span> ReentrantLock();<span class="comment">//第二个锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先尝试拿No13 锁，再尝试拿No14锁，No14锁没拿到，连同No13 锁一起释放掉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fisrtToSecond</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (No13.tryLock()) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; get 13&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (No14.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(threadName + <span class="string">&quot; get 14&quot;</span>);</span><br><span class="line">                            System.out.println(<span class="string">&quot;fisrtToSecond do work------------&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            No14.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    No13.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Thread.sleep(r.nextInt(3));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先尝试拿No14锁，再尝试拿No13锁，No13锁没拿到，连同No14锁一起释放掉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SecondToFisrt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (No14.tryLock()) &#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">&quot; get 14&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (No13.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(threadName + <span class="string">&quot; get 13&quot;</span>);</span><br><span class="line">                            System.out.println(<span class="string">&quot;SecondToFisrt do work------------&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            No13.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    No14.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 休眠是为了方式两个线程一直同时去抢锁，导致活锁现象</span></span><br><span class="line">            <span class="comment">//Thread.sleep(r.nextInt(3));  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.currentThread().setName(name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SecondToFisrt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;TestDeadLock&quot;</span>);</span><br><span class="line">        TestThread testThread = <span class="keyword">new</span> TestThread(<span class="string">&quot;SubTestThread&quot;</span>);</span><br><span class="line">        testThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fisrtToSecond();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="1-4-死锁的危害"><a href="#1-4-死锁的危害" class="headerlink" title="1.4 死锁的危害"></a>1.4 死锁的危害</h5><ul>
<li>线程不工作了，但是整个程序还是活着的</li>
<li>没有任何的异常信息可以供我们检查。</li>
<li>一旦程序发生了发生了死锁，是没有任何的办法恢复的，只能重启程序。</li>
<li>自身程序死锁了，还可能导致其他程序拿不到资源，导致其他程序crash。</li>
</ul>
<h4 id="2-活锁"><a href="#2-活锁" class="headerlink" title="2.活锁"></a>2.活锁</h4><p>​    两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。</p>
<blockquote>
<p>线程A B      锁1,2</p>
<p>拿锁顺序</p>
<p>A(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;–(1)&lt;2&gt;</p>
<p>B(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;–(2)&lt;1&gt;</p>
<p>以上现象会拉长拿锁周期，因为A拿到锁1，尝试拿锁2，但是拿不到锁2。B线程先拿到锁2，尝试拿锁1。就会导致活锁现象，线程也没有死，但是不能执行期望的代码。</p>
<p>解决办法：每个线程休眠随机数，错开拿锁的时间。</p>
</blockquote>
<h4 id="3-线程饥饿"><a href="#3-线程饥饿" class="headerlink" title="3.线程饥饿"></a>3.线程饥饿</h4><p>​    低优先级的线程，总是拿不到执行时间片。</p>
<h4 id="4-前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。"><a href="#4-前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。" class="headerlink" title="4.前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。"></a>4.前面《多线程并发总结录》中已经总结过Synchronized和ThreadLocal实现多线程安全。下面来总结一下CAS。在阐述CAS之前，需要先谈谈原子操作相关知识点。下面我们就开始吧。</h4><p>下面从what，how，why三个方面来引出CAS。</p>
<h5 id="4-1什么是原子操作？"><a href="#4-1什么是原子操作？" class="headerlink" title="4. 1什么是原子操作？"></a>4. 1什么是原子操作？</h5><p>​    有两个任务A,B，每个任务需要很多步骤执行；但是对于每个线程来说，要么任务执行并且执行完成，要么不执行。这样的操作就叫原子操作。</p>
<h5 id="4-2-如何实现原子操作？"><a href="#4-2-如何实现原子操作？" class="headerlink" title="4.2 如何实现原子操作？"></a>4.2 如何实现原子操作？</h5><p>​    实现原子操作可以使用锁，锁机制就可以满足基本需求了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁。</p>
<p>​    使用synchronized来实现会有以下几个问题：</p>
<ul>
<li>被阻塞的线程优先级很高很重要，可能会导致低优先级线程饥饿。</li>
<li>持锁线程一直不释放锁，可能会导致其他线程拿不到锁，一直无法执行(之前项目联调阶段遇到语音助理一直拿着音频焦点不释放，导致其他应用请求焦点一直拿不到焦点)</li>
<li>存在死锁的可能性</li>
<li>上下文切换比较耗时，对于简单的原子操作有些不划算</li>
</ul>
<p>​    基于以上使用synchronized来实现原子操作的缺点，CAS就应运而生了。</p>
<h5 id="4-3-CAS是什么？"><a href="#4-3-CAS是什么？" class="headerlink" title="4.3 CAS是什么？"></a>4.3 CAS是什么？</h5><p>​    CAS(Compare and Swap) ，通俗地讲：如果某个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿。</p>
<p>​    每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ai.getAndIncrement()); <span class="comment">//100   相当于i++;</span></span><br><span class="line">        System.out.println(ai.incrementAndGet()); <span class="comment">//102   相当于++i;</span></span><br><span class="line">        System.out.println(ai.addAndGet(<span class="number">20</span>)); <span class="comment">// 122      相当于 i+=20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-4-CAS实现原子操作的三大问题"><a href="#4-4-CAS实现原子操作的三大问题" class="headerlink" title="4.4 CAS实现原子操作的三大问题"></a>4.4 CAS实现原子操作的三大问题</h5><h5 id="4-4-1-ABA问题"><a href="#4-4-1-ABA问题" class="headerlink" title="4.4.1 ABA问题"></a>4.4.1 ABA问题</h5><p>​    因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>​    解决方案：在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用AtomicStampedReference或者AtomicMarkableReference来解决ABA问题，给每次修改打标签。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAtomicStampedReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;String&gt; asr</span><br><span class="line">            = <span class="keyword">new</span> AtomicStampedReference(<span class="string">&quot;Jack&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//拿到当前的版本号(旧)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldStamp = asr.getStamp();</span><br><span class="line">        <span class="keyword">final</span> String oldReference = asr.getReference();</span><br><span class="line">        System.out.println(oldReference + <span class="string">&quot;current stamp --&gt;&quot;</span> + oldStamp);</span><br><span class="line"></span><br><span class="line">        Thread rightStampThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:当前变量值：&quot;</span></span><br><span class="line">                        + oldReference + <span class="string">&quot;-当前版本戳：&quot;</span> + oldStamp + <span class="string">&quot;-&quot;</span></span><br><span class="line">                        + asr.compareAndSet(oldReference,</span><br><span class="line">                        oldReference + <span class="string">&quot;+Java&quot;</span>, oldStamp,</span><br><span class="line">                        oldStamp + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread errorStampThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String reference = asr.getReference();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;:当前变量值：&quot;</span></span><br><span class="line">                        + reference + <span class="string">&quot;-当前版本戳：&quot;</span> + asr.getStamp() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                        + asr.compareAndSet(reference,</span><br><span class="line">                        reference + <span class="string">&quot; + Java&quot;</span>, oldStamp,</span><br><span class="line">                        oldStamp + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        rightStampThread.start();</span><br><span class="line">        rightStampThread.join();</span><br><span class="line">        errorStampThread.start();</span><br><span class="line">        errorStampThread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(asr.getReference() + <span class="string">&quot;current stamp --&gt;&quot;</span> + asr.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>AtomicStampedReference和AtomicMarkableReference区别</p>
<p>相同点都是为了解决CAS原子操作中给每次修改做标记。</p>
<p>不同点是AtomicStampedReference有版本管理的概念，每次操作之后，给stamp值加1；而AtomicMarkableReference只是在每次修改之后，把mark标志位置位。</p>
</blockquote>
<h5 id="4-4-2-循环时间长开销大"><a href="#4-4-2-循环时间长开销大" class="headerlink" title="4.4.2 循环时间长开销大"></a>4.4.2 循环时间长开销大</h5><p>​    自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<h5 id="4-4-3只能保证一个共享变量的原子操作。"><a href="#4-4-3只能保证一个共享变量的原子操作。" class="headerlink" title="4.4.3只能保证一个共享变量的原子操作。"></a>4.4.3只能保证一个共享变量的原子操作。</h5><p>​    当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<p>​    还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用AtomicReference来解决CAS原子操作中对多个变量的修改，但是修改的变量太多，还是建议用锁的机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAtomicReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;UserInfo&gt; atomicUserRef;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserInfo user = <span class="keyword">new</span> UserInfo(<span class="string">&quot;DY&quot;</span>, <span class="number">10</span>);<span class="comment">//要修改的实体的实例</span></span><br><span class="line">        atomicUserRef = <span class="keyword">new</span> AtomicReference(user);</span><br><span class="line">        UserInfo updateUser = <span class="keyword">new</span> UserInfo(<span class="string">&quot;Jack&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        atomicUserRef.compareAndSet(user,updateUser);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicUserRef.get());</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个实体类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-5-悲观锁和乐观锁"><a href="#4-5-悲观锁和乐观锁" class="headerlink" title="4.5 悲观锁和乐观锁"></a>4.5 悲观锁和乐观锁</h5><p>synchronized属于悲观锁：</p>
<ul>
<li>始终感觉有“贼”想谋害朕，一拿到时间片就想办法去抢“锁”</li>
</ul>
<p>CAS属于乐观锁：</p>
<ul>
<li>每次尝试去修改，一次不行下次再来，知道修改成功为止。</li>
</ul>
<p><strong>测试用例代码见： <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(三) -- 线程间协作</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95-%E4%B8%89-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="1-线程间通知等待机制是什么？"><a href="#1-线程间通知等待机制是什么？" class="headerlink" title="1.线程间通知等待机制是什么？"></a>1.线程间通知等待机制是什么？</h4><p>​    通知等待机制是指一个线程A 调用了对象O 的wait()方法进入等待状态，而另一个线程B调用了对象O 的notify()或者notifyAll()方法，线程A 收到通知后从对象O 的wait()方法返回，进而执行后续操作。上述两个线程通过对象O 来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>​    <strong>notify()：</strong><br>​    通知一个在对象上等待的线程,使其从wait 方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING 状态。<br>​    <strong>notifyAll()：</strong><br>​    通知所有等待在该对象上的线程<br>​    <strong>wait():</strong><br>​    调用该方法的线程进入WAITING 状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁<br>​    <strong>wait(long)</strong><br>​    超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n 毫秒,如果没有通知就超时返回<br>​    <strong>wait (long,int)</strong><br>​    对于超时时间更细粒度的控制,可以达到纳秒</p>
<h4 id="2-线程协作机制如何使用？"><a href="#2-线程协作机制如何使用？" class="headerlink" title="2.线程协作机制如何使用？"></a>2.线程协作机制如何使用？</h4><p>等待方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）获取对象的锁。</span><br><span class="line"><span class="number">2</span>）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</span><br><span class="line"><span class="number">3</span>）条件满足则执行对应的逻辑。</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	<span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        lock.wait();  <span class="comment">// 释放持有的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行期待的程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）获得对象的锁。</span><br><span class="line"><span class="number">2</span>）改变条件。</span><br><span class="line"><span class="number">3</span>）通知所有等待在对象上的线程。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	<span class="comment">// 执行前置程序，修改条件</span></span><br><span class="line">    lock.notifyAll(); </span><br><span class="line">    <span class="comment">// notify()和notifAll()都不会对锁进行操作，所以一般会在synchronized最后一行才调用notify()或者notifyAll()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-等待超时模式实现一个连接池-Handler从消息队列拿消息也是这个原理"><a href="#3-等待超时模式实现一个连接池-Handler从消息队列拿消息也是这个原理" class="headerlink" title="3.等待超时模式实现一个连接池(Handler从消息队列拿消息也是这个原理)"></a>3.等待超时模式实现一个连接池(Handler从消息队列拿消息也是这个原理)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*容器，存放连接*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*限制了池的大小=20*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(SqlConnectImpl.fetchConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*释放连接,通知其他的等待连接的线程*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                <span class="comment">//通知其他等待连接的线程</span></span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取*/</span></span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null 1S</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">            <span class="comment">//永不超时</span></span><br><span class="line">            <span class="keyword">if</span>(mills&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pool.isEmpty())&#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/*超时时刻*/</span></span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis()+mills;</span><br><span class="line">                <span class="comment">/*等待时长*/</span></span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span>(pool.isEmpty()&amp;&amp;remaining&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    <span class="comment">/*唤醒一次，重新计算等待时长*/</span></span><br><span class="line">                    remaining = future-System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection connection = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 超时的情况下pool可能是空</span></span><br><span class="line">                <span class="keyword">if</span>(!pool.isEmpty())&#123;</span><br><span class="line">                    connection = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-调用yield-、sleep-、wait-、notify-等方法对锁有何影响？"><a href="#4-调用yield-、sleep-、wait-、notify-等方法对锁有何影响？" class="headerlink" title="4.调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？"></a>4.调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？</h4><ul>
<li>yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。</li>
<li>调用wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行wait 方法后面的代码。</li>
<li>调用notify()系列方法后，对锁无影响，线程只有在syn 同步代码执行完后才会自然而然的释放锁，所以notify()系列方法一般都是synchronized 同步代码的最后一行。</li>
</ul>
<p><strong>测试用例代码见： <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(二)--线程间共享</title>
    <url>/2021/01/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95-%E4%BA%8C-20-20%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="内置锁Synchronized"><a href="#内置锁Synchronized" class="headerlink" title="内置锁Synchronized"></a>内置锁Synchronized</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java 支持多个线程同时访问一个对象或者对象的成员变量，关键字<span class="keyword">synchronized</span> 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</span><br></pre></td></tr></table></figure>
<h4 id="Synchronized的用法和用处"><a href="#Synchronized的用法和用处" class="headerlink" title="Synchronized的用法和用处"></a>Synchronized的用法和用处</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用处：有多个线程会修改到某个属性的地方，需要对修改处加锁，保证每次只有一个线程可以修改。</span><br></pre></td></tr></table></figure>
<h4 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象锁是用于对象实例方法，或者一个对象实例上的。但是需要注意的是，被锁的对象不能发生改变，更不能创建对象，因为这会导致锁失效。不同对象的锁可以同时操作同一属性。</span><br></pre></td></tr></table></figure>
<h4 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类锁其实锁的是每个类对应的<span class="class"><span class="keyword">class</span> 对象，类锁是用于类的静态方法或者一个类的<span class="title">class</span> 对象上的</span></span><br></pre></td></tr></table></figure>


<h3 id="轻量级锁volatile的用法和使用场景"><a href="#轻量级锁volatile的用法和使用场景" class="headerlink" title="轻量级锁volatile的用法和使用场景"></a>轻量级锁volatile的用法和使用场景</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span>关键字可以保证不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>虽然保证了操作可见性，但是不能保证变量在多线程操作下的线程安全。所以<span class="keyword">volatile</span>的使用场景是：只有一个线程写，多个线程读的场景。</span><br></pre></td></tr></table></figure>


<h3 id="ThreadLocal的辨析"><a href="#ThreadLocal的辨析" class="headerlink" title="ThreadLocal的辨析"></a>ThreadLocal的辨析</h3><h4 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行3个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartThreadArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread[] runs = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;runs.length;i++)&#123;</span><br><span class="line">            runs[i]=<span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;runs.length;i++)&#123;</span><br><span class="line">            runs[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *类说明：测试线程，线程的工作是将ThreadLocal变量的值变化，并写回，看看线程之间是否会互相影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            threadLocal.set(<span class="string">&quot;线程&quot;</span>+id);</span><br><span class="line">            <span class="keyword">if</span>(id==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 只有当是线程1的时候才会执行</span></span><br><span class="line">                threadLocal2.set(id);</span><br><span class="line">                System.out.println(threadName+<span class="string">&quot;:&quot;</span>+threadLocal2.get());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadName+<span class="string">&quot;:&quot;</span>+threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       ThreadLocalTest test = <span class="keyword">new</span> ThreadLocalTest();</span><br><span class="line">        test.StartThreadArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">Thread-<span class="number">0</span>:线程<span class="number">0</span></span><br><span class="line">Thread-<span class="number">2</span>:线程<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>:线程<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，threadLocal在每个线程中都完成了安全的赋值，threadLocal2在线程1完成了线程安全的赋值。</p>
<p><strong>究竟ThreadLocal是如何保证线程安全的呢？</strong></p>
<p><strong>先说说结论：</strong>通过每个线程使用ThreadLocal的副本数据才保证线程安全的。意思是每个线程都会拿到threadLocal的初始值，然后在自己线程中备份一个这个值，当对这个值进行操作的时候，各自线程使用各自备份的这个值，其他线程无法修改自己线程的值，所以保证了线程安全。</p>
<h4 id="ThreadLocal实现解析"><a href="#ThreadLocal实现解析" class="headerlink" title="ThreadLocal实现解析"></a>ThreadLocal实现解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.lang.ThreadLocal中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到当前线程类中的threadLocals变量</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从map中拿到Entry， key是当前的threadlocal对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 从entry中拿到值</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.lang.Thread中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>从以上代码和如下ThreadLocal图解可知道，每一个线程都持有一个**ThreadLocalMap**对象，ThreadLocalMap中保存Entry对象，其中每一个Entry都包括&lt;Key，Value&gt;键值对，键是用户建的ThreadLocal对象，值是初始化值。然后当线程需要处理到ThreadLocal中的值时，每一个线程会将值拷贝一份到线程中进程独自操作这个值，从而实现了线程安全。
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-723ea1e3913372d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal图解.png"></p>
<h4 id="ThreadLocal引发的泄露问题"><a href="#ThreadLocal引发的泄露问题" class="headerlink" title="ThreadLocal引发的泄露问题"></a>ThreadLocal引发的泄露问题</h4><pre><code>(坚持三个原则：发现问题，定位问题，解决问题)
</code></pre>
<p><strong>发现问题：</strong></p>
<pre><code>运行一下代码(别释放remove注释)，设置一下堆区大小，很快就会发现OOM了。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Executor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;LocalValue&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalValue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    threadLocal.set(<span class="keyword">new</span> LocalValue());</span><br><span class="line">                    System.out.println(<span class="string">&quot;use thread local&quot;</span>);</span><br><span class="line">                    <span class="comment">// threadLocal.get(); 以下是使用threadlocal</span></span><br><span class="line">                    <span class="comment">// ....使用代码</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// threadLocal.remove();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>定位问题：</strong></p>
<pre><code>结合下图和从3.2分析可以看到，当前线程是会持有ThreadLocalMap对象，虽然map中key持有的threadlocal对象，他是弱引用，在GC的时候会被回收，但是Value值是强应用，在GC的时候，只要线程没有运行结束，value对象不会被释放。所以在线程里一直创建对象，就会导致内存泄漏。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6cc6d4f54f52655d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadLocal内存泄漏问题.png"></p>
<pre><code>其实我们在测试的过程中会发现只会泄漏一部分内存，原因是什么呢？

查看ThreadLocal中方法调用栈：

get() -&gt; replaceStaleEntry() -&gt; expungeStaleEntry()

set() -&gt; replaceStaleEntry() -&gt; expungeStaleEntry()

remove() -&gt; expungeStaleEntry()

**结论：从调用来看，get、set、remove最终都会调用到expungeStaleEntry()，expungeStaleEntry()会删除map中key为null的节点。但是每次get和set不会立马调用，所以才会导致泄漏一部分。**
</code></pre>
<p><strong>解决问题：</strong></p>
<pre><code>因为remove()方法会立马调用到expungeStaleEntry()来清除key为空的过时条目。所以在使用完成之后，最好调用一下remove()方法，尽快回收不用内存空间(如上面代码屏蔽掉的代码)。
</code></pre>
<h4 id="ThreadLocal的线程不安全"><a href="#ThreadLocal的线程不安全" class="headerlink" title="ThreadLocal的线程不安全"></a>ThreadLocal的线程不安全</h4><pre><code>运行如下代码可以发现如果Number声明成**静态对象**，到导致线程不安全。因为静态对象在堆空间中只有一份，每次修改之后ThreadLocal在每个线程中备份的那份都是随线程修改这个值一直改变的，所以会存在线程不安全。正确做法：**声明放在threadlocal中的对象不能是静态的即可。**
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUnsafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal使用静态的对象作value，会导致线程不安全</span></span><br><span class="line">    <span class="comment">// public static Number number = new Number(0);</span></span><br><span class="line">    <span class="keyword">public</span> Number number = <span class="keyword">new</span> Number(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个线程计数加一</span></span><br><span class="line">        number.setNum(number.getNum()+<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//将其存储到ThreadLocal中</span></span><br><span class="line">        value.set(number);</span><br><span class="line">        <span class="comment">//输出num值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&quot;</span>+value.get().getNum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Number&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Number&gt;() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalUnsafe()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Number [num=&quot;</span> + num + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Synchronized和ThreadLocal的区别"><a href="#Synchronized和ThreadLocal的区别" class="headerlink" title="Synchronized和ThreadLocal的区别"></a>Synchronized和ThreadLocal的区别</h4><pre><code>ThreadLocal是一个线程隔离的变量存储的管理实体（注意：不是存储用的），它以Java类方式表现；
synchronized是Java的一个保留字，只是一个代码标识符，它依靠JVM的锁机制来实现临界区的函数、变量在CPU运行访问中的原子性。

虽然两个实现线程安全的手段不同，设计初衷也不同，没有可比性。

但是我还是想简单的总结一下：**synchronized实现线程安全的方案是 时间换空间的方案；而ThreadLocal实现线程安全的方式是空间换时间的方案**
</code></pre>
<p><strong>测试用例代码见： <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(四) -- 并发工具类</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95-%E5%9B%9B-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="1-Fork-Join介绍"><a href="#1-Fork-Join介绍" class="headerlink" title="1 Fork/Join介绍"></a>1 Fork/Join介绍</h4><p>​    ForkJoin是实现多线程”分而治之”思想的框架，将一个大任务分成多个一个个小任务，然后对每个小任务执行并行计算，最后将结果合并起来。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cba18902f0674182.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fork_Join分治思想.png"></p>
<h4 id="1-2-Fork-Join使用"><a href="#1-2-Fork-Join使用" class="headerlink" title="1.2 Fork/Join使用"></a>1.2 Fork/Join使用</h4><p>​    在使用方面必须首先创建一个ForkJoin 任务。它提供在任务中执行fork 和join 的操作机制，通常不直接继承ForkjoinTask 类，只需要直接继承其子类。</p>
<ul>
<li><p>RecursiveAction，用于没有返回结果的任务</p>
</li>
<li><p>RecursiveTask，用于有返回值的任务</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承RecursiveAction的方式，不用返回值的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDirsFiles</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> File path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindDirsFiles</span><span class="params">(File path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;FindDirsFiles&gt; subTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File[] files = path.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">// 对每个子目录都新建一个子任务。</span></span><br><span class="line">                    subTasks.add(<span class="keyword">new</span> FindDirsFiles(file));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 遇到文件，检查。</span></span><br><span class="line">                    <span class="keyword">if</span> (file.getAbsolutePath().endsWith(<span class="string">&quot;txt&quot;</span>))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;文件:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!subTasks.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 在当前的 ForkJoinPool 上调度所有的子任务。</span></span><br><span class="line">                <span class="keyword">for</span> (FindDirsFiles subTask : invokeAll(subTasks)) &#123;</span><br><span class="line">                    subTask.join();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用一个 ForkJoinPool 实例调度总任务</span></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        FindDirsFiles task = <span class="keyword">new</span> FindDirsFiles(<span class="keyword">new</span> File(<span class="string">&quot;F:/&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步提交</span></span><br><span class="line">        pool.execute(task);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Task is Running......&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> otherWork = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            otherWork = otherWork+i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main Thread done sth......,otherWork=&quot;</span>+otherWork);</span><br><span class="line">        <span class="comment">// 阻塞方法，</span></span><br><span class="line">        task.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task end&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承RecursiveTask有返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = MakeArray.ARRAY_LENGTH / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] src;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecursiveTask</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断任务位置是否合适。</span></span><br><span class="line">        <span class="comment">// 如果合适就就直接运算返回结果，否则就细分任务</span></span><br><span class="line">        <span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;start work! fromIndex:&quot;</span> + from + <span class="string">&quot;,toIndex:&quot;</span> + to);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt;= to; i++) &#123;</span><br><span class="line">                sum += src[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (from + to) / <span class="number">2</span>;</span><br><span class="line">            MyRecursiveTask left = <span class="keyword">new</span> MyRecursiveTask(src, from, mid);</span><br><span class="line">            MyRecursiveTask right = <span class="keyword">new</span> MyRecursiveTask(src, mid + <span class="number">1</span>, to);</span><br><span class="line">            invokeAll(left, right);</span><br><span class="line">            <span class="keyword">return</span> left.join() + left.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建运算数组</span></span><br><span class="line">    <span class="keyword">int</span>[] src = MakeArray.makeArray();</span><br><span class="line">    <span class="comment">// 创建ForkJoin池</span></span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    MyRecursiveTask task = <span class="keyword">new</span> MyRecursiveTask(src, <span class="number">0</span>, src.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 执行任务得到结果</span></span><br><span class="line">    Integer invoke = pool.invoke(task);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;comsume: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="2. CountDownLatch"></a>2. CountDownLatch</h4><h5 id="2-1-CountDownLatch是什么？"><a href="#2-1-CountDownLatch是什么？" class="headerlink" title="2.1 CountDownLatch是什么？"></a>2.1 CountDownLatch是什么？</h5><p>​    CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</p>
<p>​    它是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p>
<p>​    如图所示，一个程序初始化需要五步，那就初始化CountDownLatch为5，每个线程初始化结束就对其进行”减一”操作，直到值减为零之后，等待线程被唤醒，继续执行主流程代码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7d2e42e180f0399b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CountDownLatch.png"></p>
<h5 id="2-2-CountDownLatch使用场景"><a href="#2-2-CountDownLatch使用场景" class="headerlink" title="2.2 CountDownLatch使用场景"></a>2.2 CountDownLatch使用场景</h5><p>​    一个APP初始化引入很多框架的时候，需要初始化，为了加快初始化速度，可以使用多线程来对各个框架进行初始化，当各个模块初始化结束之后，CountDownLatch值减成0后，说明所有线程初始化结束，可以开始主流程任务。 </p>
<h5 id="2-3-使用案例"><a href="#2-3-使用案例" class="headerlink" title="2.3 使用案例"></a>2.3 使用案例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCountDownLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InitThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                    + <span class="string">&quot; ready init work......&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; ........continue do its work&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusiThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;BusiThread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; do business-----&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; ready init work step 1st......&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;begin step 2nd.......&quot;</span>);</span><br><span class="line">                SleepTools.ms(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread_&quot;</span> + Thread.currentThread().getId()</span><br><span class="line">                        + <span class="string">&quot; ready init work step 2nd......&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusiThread()).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InitThread());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多少时间之后，没有执行就不阻塞，继续执行下去</span></span><br><span class="line">        latch.await(<span class="number">10</span>, TimeUnit.NANOSECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;Main do ites work........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试用例代码见： <a href="mailto:&#103;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>对泛型深入浅出的认识</title>
    <url>/2021/01/26/%E5%AF%B9%E6%B3%9B%E5%9E%8B%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>​    最近终于开始总结自己理解的东西，终于有时间写写自己对一些知识的认识。文笔不好，还望各位包含。</p>
<blockquote>
<p>本预先资料来源于Oracle官方文档Java™ 教程-Java Tutorials</p>
<p>官方文档:<a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">https://docs.oracle.com/javase/tutorial/java/generics/index.html</a></p>
<p>中文翻译:<a href="https://pingfangx.github.io/java-tutorials/java/generics/types.html">https://pingfangx.github.io/java-tutorials/java/generics/types.html</a></p>
</blockquote>
<p>下面我以问题的方式，阐明对泛型深入浅出的认识：</p>
<h4 id="1-泛型是什么？"><a href="#1-泛型是什么？" class="headerlink" title="1.泛型是什么？"></a>1.泛型是什么？</h4><p>​    泛型是JDK5引入的一种<strong>参数化类型</strong>特性。JDK7及以上，泛型的菱形可以推断参数化类型：把类型当参数一样传递。数据类型只能是引用类型。</p>
<p>举个栗子：Plate<T>中的T是类型参数；Plate<Banana>的Banana是实际类型参数；</Banana></T></p>
<p>​                   Plate<T>整个称为泛型类型；Plate<Banana>整个称为参数化的类型；</Banana></T></p>
<h4 id="2-为什么使用泛型，使用泛型的好处？"><a href="#2-为什么使用泛型，使用泛型的好处？" class="headerlink" title="2.为什么使用泛型，使用泛型的好处？"></a>2.为什么使用泛型，使用泛型的好处？</h4><ul>
<li>1.代码更健壮（只要在编译器没有警告，运行期就不会出现ClassCastException）；</li>
<li>2.代码更简洁(不用强转)</li>
<li>3.代码更灵活，可复用。</li>
</ul>
<h4 id="3-泛型包含哪些？"><a href="#3-泛型包含哪些？" class="headerlink" title="3.泛型包含哪些？"></a>3.泛型包含哪些？</h4><p>​    泛型只有三种情况：<strong>泛型接口，泛型类，泛型方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AiPlate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AiPlate</span><span class="params">(T t)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function"><span class="keyword">void</span> <span class="title">addFruit</span><span class="params">(U u)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-泛型限定有哪些？"><a href="#4-泛型限定有哪些？" class="headerlink" title="4.泛型限定有哪些？"></a>4.泛型限定有哪些？</h4><p>​    <strong>？无限定 ； extends 限定上界；super 限定下界</strong>    后面会以一个通熟易懂的口诀演示记住他</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;&#125;</span><br><span class="line"></span><br><span class="line">Interface C&#123;&#125;</span><br><span class="line"></span><br><span class="line">Interface D&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">C</span> &amp; <span class="title">D</span>&gt;</span>&#123;&#125;  <span class="comment">//this is ok  可以实现多个接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">B</span> &amp; <span class="title">C</span> &amp; <span class="title">D</span>&gt; //<span class="title">error</span>,  因为<span class="title">java</span> 只支持单继承</span></span><br></pre></td></tr></table></figure>
<p><strong>在这个体系中，上界通配符 “Plate&lt;？ extends Fruit&gt;” 覆盖下图中蓝色的区域。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c3bd93dc11ab8835.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><strong>Plate是Plate的基类，但是不是Plate的基类，对应上面例子，Plate覆盖的下图中红色的区域</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d124fd8e7b081274.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<h4 id="5-JAVA泛型的原理？什么是泛型擦除机制？"><a href="#5-JAVA泛型的原理？什么是泛型擦除机制？" class="headerlink" title="5. JAVA泛型的原理？什么是泛型擦除机制？"></a><strong>5. JAVA泛型的原理？什么是泛型擦除机制？</strong></h4><p>​    Java的泛型是JDK5新引入的特性，为了向下兼容，虚拟机其实是不支持泛型，所以Java实现的是一种<strong>伪泛型机制</strong>，也就是说Java在编译期擦除了所有的泛型信息，这样Java就不需要产生新的类型到字节码，所有的泛型类型最终都是一种原始类型，在Java运行时根本就不存在泛型信息。</p>
<p>​    泛型的擦除机制：<strong>如果有父类被擦除成父类，否则被擦除成Object</strong>。如果有继承，擦除之后会生成<strong>桥接方法</strong>，来解决类型擦除后保留泛型类型的多态性；桥方法在调用父类方法前，会将object进行强转成父类。</p>
<p>​    从 .java文件编译到.class文件会产生泛型擦除的残留，保留了定义的格式，方便分析字节码。类的常量池保留了泛型信息，可以通过反射API拿出type类型信息。</p>
<h4 id="6-Java编译器具体是如何擦除泛型的？"><a href="#6-Java编译器具体是如何擦除泛型的？" class="headerlink" title="6. Java编译器具体是如何擦除泛型的？"></a>6. Java编译器具体是如何擦除泛型的？</h4><ul>
<li>step 1. 检查泛型类型，获取目标类型</li>
<li>step 2. 擦除类型变量，并替换为限定类型</li>
</ul>
<p>​          如果泛型类型的类型变量没有限定(<T>),则用Object作为原始类型</T></p>
<p>​          如果有限定(<T extends xclass>),则用XClass作为原始类型</T></p>
<p>​           如果有多个限定(T extends XClass1&amp;XClass2),则使用第一个边界XClass1作为原始类</p>
<ul>
<li>step 3. 在必要时插入类型转换以保持类型安全</li>
<li>step 4. 生成桥方法以在扩展时保持多态性</li>
</ul>
<h4 id="7-使用了泛型，后留下很多“后遗症”"><a href="#7-使用了泛型，后留下很多“后遗症”" class="headerlink" title="7.使用了泛型，后留下很多“后遗症”"></a>7.使用了泛型，后留下很多“后遗症”</h4><h5 id="7-1-泛型类型变量不能使用基本数据类型"><a href="#7-1-泛型类型变量不能使用基本数据类型" class="headerlink" title="7.1 泛型类型变量不能使用基本数据类型"></a>7.1 泛型类型变量不能使用基本数据类型</h5><p>​    比如没有ArrayList<int>,只有ArrayList<Integer>.当类型擦除后，ArrayList的原始类中的类型变量(T)替换成Object,但Object类型不能存放int值</Integer></int></p>
<h5 id="7-2-不能使用instanceof-运算符"><a href="#7-2-不能使用instanceof-运算符" class="headerlink" title="7.2 不能使用instanceof 运算符"></a>7.2 不能使用instanceof 运算符</h5><p>​    因为擦除后，ArrayList<String>只剩下原始类型，泛型信息String不存在了，所有没法使用instanceof。</String></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(strings <span class="keyword">instanceof</span> ArrayList&lt;?&gt;)&#123;&#125; <span class="comment">//可以  被擦除之后的ArrayList本来就是未知的，所以这个可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(strings <span class="keyword">instanceof</span> ArrayList&lt;String&gt;) <span class="comment">//不可以</span></span><br></pre></td></tr></table></figure>


<h5 id="7-3-泛型在静态方法和静态类中的问题"><a href="#7-3-泛型在静态方法和静态类中的问题" class="headerlink" title="7.3 泛型在静态方法和静态类中的问题"></a>7.3 泛型在静态方法和静态类中的问题</h5><p>​    因为泛型类中的泛型参数的实例化在定义泛型类型对象(比如ArrayList<Integer>)的时候指定的，而静态成员是不需要使用对象来调用的，所有对象都没创建，编译器不知道如何确定这个泛型参数是什么。</Integer></p>
<h5 id="7-4-泛型类型中的方法可能会冲突"><a href="#7-4-泛型类型中的方法可能会冲突" class="headerlink" title="7.4 泛型类型中的方法可能会冲突"></a>7.4 泛型类型中的方法可能会冲突</h5><p>​    因为擦除后两个equals方法变成一样的了。擦除之后T变成Object，而Object中的equals是默认被实现了的。所以重复了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">super</span> <span class="title">equals</span><span class="params">(t)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">super</span> <span class="title">equals</span><span class="params">(obj)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>


<h5 id="7-5-没法创建泛型实例"><a href="#7-5-没法创建泛型实例" class="headerlink" title="7.5 没法创建泛型实例"></a>7.5 没法创建泛型实例</h5><p>​    因为类型不确定，没法直接new对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list)</span></span>&#123;</span><br><span class="line">	E elem = <span class="keyword">new</span> E（）; <span class="comment">//不行，因为不知道E的具体类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是下面这种方式是可以的，通过反射来new对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list, Class&lt;E&gt; cls)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	E elem = cls.newInstance（）;  <span class="comment">// OK</span></span><br><span class="line">	list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-6-没有泛型数组"><a href="#7-6-没有泛型数组" class="headerlink" title="7.6 没有泛型数组"></a>7.6 没有泛型数组</h5><p>答：因为数组可以协变，擦除后就没法满足数组协变的原则。</p>
<p>T[] arr = new T[10]  //不可以  不知道T代表那个类</p>
<p><strong>另外：Apple extends Fruit</strong></p>
<p>Apple[] 的父类是Fruit[] 这个叫数组的协变。</p>
<p>其中数组协变中：父类可以持有子类，子类持有父类可能会报转化异常。</p>
<p>List<Apple> 和 List<Fruit>在擦除之后运行期不知道是什么类型了，都是不满足协变原则了；数组是可以协变的，但是list是不会协变的。</Fruit></Apple></p>
<p>另外假如：A extends B</p>
<p>Plate<B> = Plate<A>是不允许的，因为在泛型中，不管AB是什么关系，Plate<A>和Plate<B>没有任何关系。</B></A></A></B></p>
<h4 id="8-通配符和泛型的关系？"><a href="#8-通配符和泛型的关系？" class="headerlink" title="8. 通配符和泛型的关系？"></a>8. 通配符和泛型的关系？</h4><p>​    通配符可以让泛型转化更灵活。</p>
<h4 id="9-说出以下类型的区别"><a href="#9-说出以下类型的区别" class="headerlink" title="9. 说出以下类型的区别?"></a>9. 说出以下类型的区别?</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Plate 普通的盘子类，编译时不会做类型检查</span><br><span class="line">Plate&lt;Object&gt; 参数化的plate类，他在编译之后，字节码的类中的方法是Object</span><br><span class="line">Plate&lt;?&gt; 非限定通配符下的泛型类，泛型？表示类型未知，等价于Plate&lt;? extends Object&gt;</span><br><span class="line">Plate&lt;T&gt; 泛型Plate类，T是未知类型，编译后会被擦除成Object对象</span><br><span class="line">Plate&lt;? extends T&gt; 限定上界的泛型类</span><br><span class="line">Plate&lt;? <span class="keyword">super</span> T&gt; 限定下界的泛型类</span><br></pre></td></tr></table></figure>


<h4 id="10-泛型边界的熟记口诀："><a href="#10-泛型边界的熟记口诀：" class="headerlink" title="10.泛型边界的熟记口诀："></a>10.泛型边界的熟记口诀：</h4><ul>
<li><p>extends 上界；super 下界</p>
</li>
<li><p>说明：以下方便记忆的：“上”表示父类，“下”表示子类</p>
</li>
<li><p><em>口诀：</em>*</p>
</li>
</ul>
<p><strong>上界只可往上读，往上赋值；方法只能传递自己或者子类</strong></p>
<p><strong>下界只可向下写，向下赋值；方法只能传递自己或者父类</strong></p>
<h5 id="验证口诀的正确性："><a href="#验证口诀的正确性：" class="headerlink" title="验证口诀的正确性："></a>验证口诀的正确性：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * extends 上界</span></span><br><span class="line"><span class="comment">* super 下界</span></span><br><span class="line"><span class="comment">* 说明：以下方便记忆的：“上”表示父类，“下”表示子类</span></span><br><span class="line"><span class="comment">* 口诀：</span></span><br><span class="line"><span class="comment">* 上界只可往上读，往上赋值；方法只能传递自己或者子类</span></span><br><span class="line"><span class="comment">* 下界只可向下写，向下赋值；方法只能传递自己或者父类</span></span><br><span class="line"><span class="comment">* * 类关系： apple extends fruit extends food */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBoundary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//演示extends赋值的上界</span></span><br><span class="line">        List&lt;Food&gt; foods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fruits = apples; //error 往上赋值需要 extends</span></span><br><span class="line">        List&lt;? extends Fruit&gt; fruits1 = apples; <span class="comment">//向上赋值成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示向上读取</span></span><br><span class="line">        Fruit fruit = fruits1.get(<span class="number">0</span>); <span class="comment">//ok 上界修饰的可以往上读</span></span><br><span class="line">        Food food = fruits1.get(<span class="number">0</span>); <span class="comment">//ok 上界修饰的可以往上读</span></span><br><span class="line">        Object object = fruits1.get(<span class="number">0</span>); <span class="comment">//ok 上界修饰的可以往上读</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Apple apple = fruits1.get(0); //error 不能往下读</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示方法传递</span></span><br><span class="line">        eat1(fruits); <span class="comment">//ok 传递自己</span></span><br><span class="line">        eat1(apples); <span class="comment">//ok 传递子类</span></span><br><span class="line">        <span class="comment">//eat1(foods); //error 传递了父类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示Super赋值的下界</span></span><br><span class="line">        List&lt;Food&gt; foodsLower = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Apple&gt; applesLower = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Fruit&gt; fruitsLower = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//fruitsLower = foodsLower; //error 往下赋值需要super修饰</span></span><br><span class="line">        List&lt;? <span class="keyword">super</span> Fruit&gt; fruitList = foodsLower; <span class="comment">// 向下赋值ok了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示向下写</span></span><br><span class="line">        fruitList.add(<span class="keyword">new</span> Apple(<span class="number">1</span>)); <span class="comment">//用下写是ok</span></span><br><span class="line">        <span class="comment">//fruitList.add(new Food()); //error 用上写是不行的；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示下界方法只能传递自己或者父类</span></span><br><span class="line">        eat2(fruitsLower); <span class="comment">//传递自己ok</span></span><br><span class="line">        eat2(foodsLower); <span class="comment">// 传递父类ok</span></span><br><span class="line">        <span class="comment">//eat2(applesLower); //传递子类error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat1</span><span class="params">(List&lt;? extends Fruit&gt; fruits)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat2</span><span class="params">(List&lt;? <span class="keyword">super</span> Fruit&gt; fruits)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="11-最后说了半天规则，用实例演示以下泛型有什么用处"><a href="#11-最后说了半天规则，用实例演示以下泛型有什么用处" class="headerlink" title="11.最后说了半天规则，用实例演示以下泛型有什么用处"></a>11.最后说了半天规则，用实例演示以下泛型有什么用处</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 泛型的简单应用</span></span><br><span class="line"><span class="comment">* 从没用泛型慢慢演进 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通不使用泛型的方法。</span></span><br><span class="line">    <span class="comment">//有个需求需要把香蕉或者更多水果copy一下，难道需要重新写N个copy方法么？</span></span><br><span class="line">    <span class="comment">//答案不是的，出现了泛型copy2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy1</span><span class="params">(List&lt;Apple&gt; dest,List&lt;Apple&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在可以把无数多相同的水果相互copy了，但是又有一个需求了</span></span><br><span class="line">    <span class="comment">//现在苹果是确定了的，我想想找一个水果list把苹果放进去，于是就出现了copy3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy2</span><span class="params">(List&lt;T&gt; dest,List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在找到一个水果list放苹果了。但是现在还有一个需求</span></span><br><span class="line">    <span class="comment">//就是现在水果list确定了，我要放的水果不确定，于是有了copy4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy3</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest,List&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个就是Collections.copy的终极用法了。</span></span><br><span class="line">    <span class="comment">//public static &lt;T&gt; void copy(@RecentlyNonNull List&lt;? super T&gt; dest, @RecentlyNonNull List&lt;? extends T&gt; src)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy4</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest,List&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">        Collections.copy(dest,src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//新建两个苹果list</span></span><br><span class="line">        List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple(<span class="number">1</span>));</span><br><span class="line">        List&lt;Apple&gt; apples1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        apples1.add(<span class="keyword">new</span> Apple(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建两个香蕉list</span></span><br><span class="line">        List&lt;Banana&gt; bananas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bananas.add(<span class="keyword">new</span> Banana(<span class="number">1</span>));</span><br><span class="line">        List&lt;Banana&gt; bananas1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bananas1.add(<span class="keyword">new</span> Banana(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建水果list</span></span><br><span class="line">        List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fruits.add(<span class="keyword">new</span> Apple(<span class="number">10</span>)) ;   <span class="comment">// 先要告诉编译器fruit是放的苹果，否者copy3的dest参数编译器不知道放什么</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通方法</span></span><br><span class="line">        copy1(apples,apples1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用泛型方法</span></span><br><span class="line">        copy2(bananas,bananas1);    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//苹果往水果盘子放</span></span><br><span class="line">        Test.&lt;Apple&gt;copy3(fruits,apples);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里苹果是确认的了</span></span><br><span class="line">        <span class="comment">//水果list确定了放任意水果</span></span><br><span class="line">        Test.&lt;Fruit&gt;copy4(fruits,apples);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>测试代码：</strong><a href="https://github.com/oujie123/UnderstandingOfGeneric">https://github.com/oujie123/UnderstandingOfGeneric</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>对象继承和操作符重载</title>
    <url>/2021/06/07/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="1-重载运算符"><a href="#1-重载运算符" class="headerlink" title="1. 重载运算符"></a>1. 重载运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类里重载操作符</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(Person person2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + person2.getX();</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + person2.getY();</span><br><span class="line"></span><br><span class="line">        <span class="function">Person <span class="title">res</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正规写法</span></span><br><span class="line">    <span class="comment">// 使用const person2为只读</span></span><br><span class="line">    <span class="comment">// 使用&amp; 直接引用，不构建新副本</span></span><br><span class="line">    Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person &amp; person2) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + person2.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + person2.y;</span><br><span class="line"></span><br><span class="line">        <span class="function">Person <span class="title">res</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 ++</span></span><br><span class="line">    <span class="comment">// ++对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++ ()&#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象++</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> ++ (<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义输出对象</span></span><br><span class="line">    <span class="comment">// istream 输入</span></span><br><span class="line">    <span class="comment">// ostream 输出</span></span><br><span class="line">    <span class="comment">// 输出单个</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> <span class="keyword">operator</span> &lt;&lt; (ostream &amp; _START, <span class="keyword">const</span> Person &amp; person) &#123;</span><br><span class="line">        _START &lt;&lt; person.x &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; person.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出多个对象</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; _START, <span class="keyword">const</span> Person &amp; person) &#123;</span><br><span class="line">        _START &lt;&lt; person.x &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; person.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> _START;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载加号  operator重载关键字</span></span><br><span class="line">Person operato+(Person person1, Person person2) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = person1.getX() + person2.getX();</span><br><span class="line">    <span class="keyword">int</span> y = person1.getY() + person2.getY();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">res</span><span class="params">(x,y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">person2</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Person person3 = person1 + person2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x:&quot;</span> &lt;&lt; person3.getX() &lt;&lt; <span class="string">&quot;y:&quot;</span> &lt;&lt; person3.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义输出对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-括号运算符重载"><a href="#2-括号运算符重载" class="headerlink" title="2. 括号运算符重载"></a>2. 括号运算符重载</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.括号运算符。   数组 系统源码把此括号[i]给重载，  系统重载后的样子 *(arr+i)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个小容器，模拟容器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// C++ 默认都是系统值  size 系统值 -13275</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>; <span class="comment">// 大小  开发过程中，给size赋默认值，不然会出现，后患无穷的问题</span></span><br><span class="line">    <span class="keyword">int</span> * arrayValue; <span class="comment">// 数组存放 int 类型的很多值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arrayValue[index] = value; <span class="comment">// []目前不是我的</span></span><br><span class="line">        size+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="comment">// size成员的目标：是为了循环可以遍历</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运算符重载 [index]</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;arrayValue[index]; <span class="comment">// 此[]是系统的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出容器的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfArryClass</span><span class="params">(ArrayClass arrayClass)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arrayClass.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayClass.getSize(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arrayClass[i] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// []是我们自己的 重载符号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 能在栈区的，尽量在栈区</span></span><br><span class="line">    <span class="comment">// 1.代码量少</span></span><br><span class="line">    <span class="comment">// 2.避免麻烦</span></span><br><span class="line">    <span class="comment">// 3.怕有问题</span></span><br><span class="line">    <span class="comment">// 4.栈区的回收，不是你负责的，责任推卸</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//目前arrayClass对象是在栈区    实例出来的对象，是在堆区了</span></span><br><span class="line">    ArrayClass arrayClass;  </span><br><span class="line"></span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">1</span>, <span class="number">2000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">2</span>, <span class="number">3000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">3</span>, <span class="number">4000</span>);</span><br><span class="line">    arrayClass.<span class="built_in">set</span>(<span class="number">4</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    printfArryClass(arrayClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-对象继承"><a href="#3-对象继承" class="headerlink" title="3. 对象继承"></a>3. 对象继承</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">int</span> age) : name(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person 构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.默认是 隐式代码： : private Person</span></span><br><span class="line"><span class="comment">// 2.私有继承：在子类里面是可以访问父类的成员，但是在类的外面不行</span></span><br><span class="line"><span class="comment">// 3.必须公开继承，才可以访问父类的成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 默认是私有的，在子类内部可以对父类进行访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * course;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// :父类 , 给自己子类成员初始化</span></span><br><span class="line">    Student(<span class="keyword">char</span> * name, <span class="keyword">int</span> age, <span class="keyword">char</span>* course) : Person(name, age) , course(course) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student 构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;李元霸&quot;</span>, <span class="number">99</span>, <span class="string">&quot;C++&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公开继承，才可以拿父类的成员</span></span><br><span class="line">    stu.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-C-多继承"><a href="#4-C-多继承" class="headerlink" title="4. C++多继承"></a>4. C++多继承</h4><p>在JAVA语言中只能单继承，可以多实现，很好解决了二义性。但是在C++中是支持多继承的，因此就会出现二义性，下面我们来看一下C++中是如何解决二义性的。</p>
<h5 id="4-1-明确指定对象的方法"><a href="#4-1-明确指定对象的方法" class="headerlink" title="4.1 明确指定对象的方法"></a>4.1 明确指定对象的方法</h5><p>方案一是明确指定要调用某个对象的方法；</p>
<p>方案二是在子类中实现父类的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity1 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity1 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity2 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity2 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity2 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity3 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity3 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;BaseActivity3 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 继承 三个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity1</span> :</span> <span class="keyword">public</span> BaseActivity1, <span class="keyword">public</span> BaseActivity2, <span class="keyword">public</span> BaseActivity3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 onCreate&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 onStart&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showSonInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 showSonInfo&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案二： 子类上 重写父类的show函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MainActivity1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个是优先寻找子类的函数，因为特别明确，没有问题，还没有产生歧义（二义性）</span></span><br><span class="line">    MainActivity1 mainActivity1; <span class="comment">// 子类</span></span><br><span class="line">    mainActivity1.onCreate();</span><br><span class="line">    mainActivity1.onStart();</span><br><span class="line">    mainActivity1.showSonInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: request for member &#x27;show&#x27; is ambiguous</span></span><br><span class="line">    <span class="comment">// 不明确，二义性，歧义</span></span><br><span class="line">    <span class="comment">// mainActivity1.show();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案一： 明确指定父类 ::</span></span><br><span class="line">    mainActivity1.BaseActivity3::show();</span><br><span class="line">    mainActivity1.BaseActivity2::show();</span><br><span class="line">    mainActivity1.BaseActivity1::show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案二： 子类上 重写父类的show函数</span></span><br><span class="line">    mainActivity1.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2重写成员属性"><a href="#4-2重写成员属性" class="headerlink" title="4.2重写成员属性"></a>4.2重写成员属性</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 祖父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity1</span> :</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity2</span> :</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> BaseActivity1, <span class="keyword">public</span> BaseActivity2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种解决方案： 在类中定义同名成员，覆盖掉父类的相关成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: request for member &#x27;show&#x27; is ambiguous  二义性 歧义</span></span><br><span class="line">    <span class="comment">// son.number = 2000;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种解决方案： :: 明确指定</span></span><br><span class="line">    son.BaseActivity1::number  = <span class="number">1000</span>;</span><br><span class="line">    son.BaseActivity2::number  = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种解决方案： 在类中定义同名成员，覆盖掉父类的相关成员</span></span><br><span class="line">    son.number = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-3使用虚函数来过渡继承"><a href="#4-3使用虚函数来过渡继承" class="headerlink" title="4.3使用虚函数来过渡继承"></a>4.3使用虚函数来过渡继承</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 祖父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object show run...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="comment">// public:int number; // 人为制作二义性  error: request for member &#x27;number&#x27; is ambiguous</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="comment">// public:int number;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> BaseActivity1, <span class="keyword">public</span> BaseActivity2 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line">    BaseActivity1 baseActivity1;</span><br><span class="line">    BaseActivity2 baseActivity2;</span><br><span class="line">    Son son;</span><br><span class="line"></span><br><span class="line">    object.number = <span class="number">100</span>;</span><br><span class="line">    baseActivity1.number = <span class="number">200</span>;</span><br><span class="line">    baseActivity2.number = <span class="number">300</span>;</span><br><span class="line">    son.number = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    object.show();</span><br><span class="line">    baseActivity1.show();</span><br><span class="line">    baseActivity2.show();</span><br><span class="line">    son.show();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; object.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; baseActivity1.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; baseActivity2.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; son.number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>应用沙盒</title>
    <url>/2021/03/15/%E5%BA%94%E7%94%A8%E6%B2%99%E7%9B%92/</url>
    <content><![CDATA[<h3 id="1-应用沙盒"><a href="#1-应用沙盒" class="headerlink" title="1.应用沙盒"></a>1.应用沙盒</h3><p>Android 平台利用基于用户的 Linux 保护机制识别和隔离应用资源，可将不同的应用分隔开来，并保护应用和系统免受恶意应用的攻击。为此，Android 会为每个 Android 应用分配一个独一无二的用户 ID (UID)，并让应用在自己的进程中运行。</p>
<p>Android 会使用该 UID 设置一个内核级应用沙盒。内核会在进程级别利用标准的 Linux 机制（例如，分配给应用的用户 ID 和组 ID）实现应用和系统之间的安全防护。默认情况下，应用不能彼此交互，而且对操作系统的访问权限会受到限制。如果应用 A 尝试执行恶意操作（例如在没有权限的情况下读取应用 B 的数据或拨打电话），系统会阻止此类行为，因为应用 A 没有相应的默认用户权限。这一沙盒机制非常简单，可审核，并且基于已有数十年历史的 UNIX 风格的进程用户隔离和文件权限机制。</p>
<p>由于应用沙盒位于内核层面，因此该安全模型的保护范围扩展到了原生代码和操作系统应用。位于更高层面的所有软件（例如，操作系统库、应用框架、应用运行时环境和所有应用）都会在应用沙盒中运行。某些平台会限制开发者只能使用特定的开发框架、API 或语言。在 Android 上，并没有为此而限制开发者必须如何编写应用；在这方面，原生代码与解释型代码一样进行沙盒化。</p>
<h3 id="2-保护机制"><a href="#2-保护机制" class="headerlink" title="2.保护机制"></a>2.保护机制</h3><p>通常，为了在经过适当配置的设备上攻破应用沙盒这道防线，必须先攻破 Linux 内核的安全功能。但是，与其他安全功能类似，强制执行应用沙盒的各种保护机制并非无懈可击，因此深度防御对于防止通过单个漏洞入侵操作系统或其他应用非常重要。</p>
<p>Android 依靠许多保护机制来强制执行应用沙盒。这些强制措施是随着时间的推移不断引入的，并且显著增强了基于 UID 的原始自主访问控制 (DAC) 沙盒的安全性。以前的 Android 版本包括以下保护机制：</p>
<ul>
<li>在 Android 5.0 中，SELinux 提供了强制访问控制 (MAC) 来将系统和应用分离开。但是，所有第三方应用都在相同的 SELinux 环境中运行，因此应用间的隔离主要由 UID DAC 强制执行。</li>
<li>在 Android 6.0 中，SELinux 沙盒经过扩展，可以跨各个物理用户边界隔离应用。此外，Android 还为应用数据设置了更安全的默认设置：对于 <code>targetSdkVersion &gt;= 24</code> 的应用，应用主目录上的默认 DAC 权限从 751 更改为 700。这为私有应用数据提供了更安全的默认设置（但应用可能会替换这些默认设置）。</li>
<li>在 Android 8.0 中，所有应用都设为使用 <code>seccomp-bpf</code> 过滤器运行，该过滤器可限制允许应用使用的系统调用，从而增强应用/内核边界的安全性。</li>
<li>在 Android 9 中，<code>targetSdkVersion &gt;= 28</code> 的所有非特权应用都必须在不同的 SELinux 沙盒中运行，并针对各个应用提供 MAC。这种保护机制可以提升应用隔离效果，防止替换安全默认设置，并且（最重要的是）防止应用的数据可让所有人访问。</li>
<li>在 Android 10 中，应用的文件系统的原始视图有限，且无法直接访问 /sdcard/DCIM 之类的路径。不过，应用保留对任何适用方法（例如 [Context.getExternalFilesDir()](<a href="https://developer.android.com/reference/android/content/Context.html#getExternalFilesDir">https://developer.android.com/reference/android/content/Context.html#getExternalFilesDir</a>(jav a.lang.String))）返回的软件包专用路径的完整原始访问权限。</li>
</ul>
<h3 id="3-共享文件指南"><a href="#3-共享文件指南" class="headerlink" title="3.共享文件指南"></a>3.共享文件指南</h3><p>将应用数据设为可供所有人访问从安全方面来讲是一种不好的做法，这会为所有人授予访问权限，并且无法限定只让目标受众访问这些数据。这种做法会导致信息披露泄露，让代理漏洞变得混乱，并会成为针对包含敏感数据的应用（例如电子邮件客户端）的恶意软件的首选目标。在 Android 9 及更高版本中，明确禁止 <code>targetSdkVersion&gt;=28</code> 的应用以这种方式共享文件。</p>
<p>在共享文件时，请遵循以下指南，而不是让应用数据可供所有人访问：</p>
<ul>
<li>如果您的应用需要与其他应用共享文件，请使用<a href="https://developer.android.com/guide/topics/providers/content-provider-basics.html">内容提供程序</a>。内容提供程序会以适当的粒度共享数据，并且不会出现使用所有人都可访问的 UNIX 权限会带来的诸多问题（如需了解详情，请参阅<a href="https://developer.android.com/guide/topics/providers/content-provider-basics.html">内容提供程序基础知识</a>）。</li>
<li>如果您的应用包含确实应让所有人访问的文件（例如照片），相应文件必须是媒体文件（仅限照片、视频和音频文件）且使用 <a href="https://developer.android.com/reference/android/provider/MediaStore">MediaStore</a> 类存储。（如需详细了解如何添加媒体内容，请参阅<a href="https://developer.android.com/training/data-storage/shared/media#add-item">访问共享存储空间中的媒体文件</a>）。</li>
</ul>
<p><strong>存储</strong>运行时权限控制着通过 <strong>MediaStore</strong> 对强类型媒体集合的访问权限。如需访问弱类型文件（例如 PDF）和 <a href="https://developer.android.com/reference/android/provider/MediaStore.Downloads">MediaStore.Downloads</a> 类，应用必须使用 <a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_OPEN_DOCUMENT">ACTION_OPEN_DOCUMENT</a> 等 intent。</p>
<p>如需实现 Android 10 行为，请使用 <code>requestLegacyExternalStorage</code> 清单属性，并遵循<a href="https://developer.android.com/training/permissions/usage-notes">应用权限最佳做法</a>。</p>
<ul>
<li>对于以 Android 9（及更低版本）为目标平台的应用，清单标记的默认值为 <code>true</code>。</li>
<li>对于以 Android 10 为目标平台的应用，默认值为 false。如需在以 Android 10 为目标平台的应用中暂时退出已过滤的存储空间视图，请将清单标记的值设置为 <code>true</code>。</li>
<li>使用受限权限，安装程序会将允许使用未进行沙盒化的存储的应用加入白名单。未加入白名单的应用会被沙盒化。</li>
</ul>
]]></content>
      <categories>
        <category>Android Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>应用沙盒</tag>
      </tags>
  </entry>
  <entry>
    <title>引用进阶与多线程</title>
    <url>/2021/06/14/%E5%BC%95%E7%94%A8%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="1-引用进阶"><a href="#1-引用进阶" class="headerlink" title="1. 引用进阶"></a>1. 引用进阶</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO ============================ [左值 右值 引用]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span>  info = <span class="string">&quot;AAA&quot;</span>; <span class="comment">// 旧变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种情况【getInfo函数的info 与 main函数的result 是旧与新的两个变量而已，他们是值传递，所以右值修改时，影响不了里面的旧变量】</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种情况【getInfo函数的info 与 main函数的result 是引用关系，一块内存空间 有多个别名而已，所以右值修改时，直接影响旧变量】</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回引用可以直接修改</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> &amp; <span class="title">getInfo_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*vector&lt;int&gt; v;</span></span><br><span class="line"><span class="comment">    int r = v.front(); // 左值 获取</span></span><br><span class="line"><span class="comment">    v.front() = 88; // 右值 修改*/</span></span><br><span class="line"></span><br><span class="line">    Student student;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种情况</span></span><br><span class="line">    student.getInfo() = <span class="string">&quot;九阳神功&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> result = student.getInfo();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一种情况:&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种情况</span></span><br><span class="line">    student.getInfo_front() = <span class="string">&quot;三分归元气&quot;</span>; <span class="comment">// 右值 修改内容</span></span><br><span class="line">    result = student.getInfo_front(); <span class="comment">// 左值 获取内容</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二种情况:&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-thread"><a href="#2-thread" class="headerlink" title="2. thread"></a>2. thread</h4><p>thread是C++ 11引入的一个线程类，主要也是封装pthread类，用起来更简单，但是阉割了部分功能，日常开发中主要还是使用pthread。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步线程 子线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runAction</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="comment">// 相当于 Java的 run函数一样</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;runAction：&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 方式一  main只等3秒钟，</span></span><br><span class="line">    <span class="comment">/*thread thread1(runAction, 100);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // sleep(3); // 我只等你三秒钟</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;main弹栈了&quot; &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 方式二  我等你执行完成后，我再执行</span></span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(runAction, <span class="number">100</span>)</span></span>;</span><br><span class="line">    thread2.join(); <span class="comment">// 我等runAction执行完成后，我再继续执行下面代码..</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main弹栈了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    runAction：100</span></span><br><span class="line"><span class="comment">    main弹栈了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-pthread用法"><a href="#3-pthread用法" class="headerlink" title="3. pthread用法"></a>3. pthread用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // Cygwin 有 pthreads支持</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customPthreadTask</span><span class="params">(<span class="keyword">void</span> * pVoid)</span> </span>&#123; <span class="comment">// 异步线程  相当于Java的Thread.run函数一样</span></span><br><span class="line">    <span class="comment">// C++转换static_cast  转换指针操作的</span></span><br><span class="line">    <span class="keyword">int</span> * number = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid); <span class="comment">// pVoid==number int的地址，所以我用int*接收，很合理</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程执行了:&quot;</span> &lt;&lt; *number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 坑 坑 坑，必须返回，否则有错误，不好查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      int pthread_create (pthread_t *,  // 参数一：线程ID</span></span><br><span class="line"><span class="comment">                        const pthread_attr_t *, // 参数二：线程属性</span></span><br><span class="line"><span class="comment">		                void *(*)(void *), // 参数三：函数指针的规则</span></span><br><span class="line"><span class="comment">		                void *); // 参数四：给函数指针传递的内容，void * 可以传递任何内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadID; <span class="comment">// 线程ID，每个线程都需要有的线程ID</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pthreadID, <span class="number">0</span>, customPthreadTask, &amp;number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-pthread的三种状态"><a href="#4-pthread的三种状态" class="headerlink" title="4. pthread的三种状态"></a>4. pthread的三种状态</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  pthread 的 三种情况分析 的</span></span><br><span class="line"><span class="comment">//  第一种情况，main函数只要结束，不等异步线程，全部结束</span></span><br><span class="line"><span class="comment">//  第二种情况，我们开发者，千万不要让 main函数睡眠的方式，去等待异步线程</span></span><br><span class="line"><span class="comment">//  第三种情况，main函数一直等待 异步线程，只有异步线程执行完成后，我在执行 join后面的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // Derry Cygwin 有 pthreads支持</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runTask</span><span class="params">(<span class="keyword">void</span> * pVoid)</span> </span>&#123; <span class="comment">// 异步线程  子线程</span></span><br><span class="line">    <span class="keyword">int</span> number = *<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程执行了:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;run:&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span>  pthreadID;</span><br><span class="line">    pthread_create(&amp;pthreadID, <span class="number">0</span>, runTask, &amp;number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了演示第二种情况</span></span><br><span class="line">    <span class="comment">// sleep(3); // main函数只 异步线程三秒钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步线程在执行的过程中，我们的main函数 相当于 阻塞在这里不动了，只有异步线程执行完成后，我才开始执行join后面的代码</span></span><br><span class="line">    pthread_join(pthreadID, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数即将弹栈...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-分离线程与非分离线程区别"><a href="#5-分离线程与非分离线程区别" class="headerlink" title="5. 分离线程与非分离线程区别"></a>5. 分离线程与非分离线程区别</h4><ul>
<li>分离线程： 各个线程都是自己运行自己的，老死不相往来，例如：main函数结束，全部结束，不会等待异步线程 【多线程独立计算情况下场景】</li>
<li>非分离线程： 线程有协作的能力，例如：main函数线程会等待 异步线程执行完成后，我再执行 后面main函数的代码【协作，顺序执行 场景】</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; // Derry Cygwin 有 pthreads支持</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runTask</span><span class="params">(<span class="keyword">void</span> * pVoid)</span> </span>&#123; <span class="comment">// 异步线程  子线程</span></span><br><span class="line">    <span class="keyword">int</span> number = *<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程执行了:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;run:&quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span>  pthreadID; <span class="comment">// Cygwin允许有野指针</span></span><br><span class="line">    pthread_create(&amp;pthreadID, <span class="number">0</span>, runTask, &amp;number);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthreadID, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数即将弹栈...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-互斥锁"><a href="#6-互斥锁" class="headerlink" title="6. 互斥锁"></a>6. 互斥锁</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // sleep（秒）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queueData; <span class="comment">// 定义一个全局的队列，用于 存储/获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">// 定义一个互斥锁，注意：（Cygwin平台 此互斥锁，不能有野指针，坑）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void *(*)(void *)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">task</span><span class="params">(<span class="keyword">void</span> *pVoid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*synchronize(锁) &#123;</span></span><br><span class="line"><span class="comment">        // code</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 锁住</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异步线程-当前线程的标记是:&quot;</span> &lt;&lt; *<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> *&gt;(pVoid) &lt;&lt; <span class="string">&quot;异步线程&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queueData.empty()) &#123; <span class="comment">// 有元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;异步线程-获取队列的数据:%d\n&quot;</span>, queueData.front());</span><br><span class="line">        queueData.pop(); <span class="comment">// 把数据弹出去，删除的意思</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;异步线程-队列中没有数据了\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给队列 初始化数据 手动增加数据进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10001</span>; i &lt; <span class="number">10011</span>; ++i) &#123;</span><br><span class="line">        queueData.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性定义10个线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadIDArray[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;pthreadIDArray[i], <span class="number">0</span>, task, &amp;i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能使用 join，如果使用（就变成顺序的方式，就没有多线程的意义了，所以不能写join）</span></span><br><span class="line">        <span class="comment">// pthread_join(pthreadIDArray[i], 0);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main函数等 异步线程</span></span><br><span class="line">    sleep(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁 互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数即将弹栈...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次运行 效果都不同：1，8，9，10，3，2，5，8</span></span><br><span class="line">    <span class="comment">// 每次运行 效果都是错乱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-多线程通知机制实现生产者消费者模型"><a href="#7-多线程通知机制实现生产者消费者模型" class="headerlink" title="7.  多线程通知机制实现生产者消费者模型"></a>7.  多线程通知机制实现生产者消费者模型</h4><p>建立一个队列，在get()，set()方法中使用互斥锁对队列存元素和元素进行加锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据工程实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//CPPCLIONPROJECT_SAFE_QUEUE_TOO_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">// 防止重复写 include 的控制</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模版函数 int double float == Java的泛型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeQueueClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;T&gt; <span class="built_in">queue</span>; <span class="comment">// 定义队列</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span>  mutex; <span class="comment">// 定义互斥锁（不允许有野指针）</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 条件变量，为了实现 等待 读取 等功能 （不允许有野指针）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SafeQueueClass() &#123;</span><br><span class="line">        <span class="comment">// 初始化 互斥锁</span></span><br><span class="line">        pthread_mutex_init(&amp;mutex, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 条件变量</span></span><br><span class="line">        pthread_cond_init(&amp;cond, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~SafeQueueClass() &#123;</span><br><span class="line">        <span class="comment">// 回收 互斥锁</span></span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收 条件变量</span></span><br><span class="line">        pthread_cond_destroy(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 加入到队列中（进行生成）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了安全 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>.push(t); <span class="comment">// 把数据加入到队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉消费者，我已经生产好了</span></span><br><span class="line">        <span class="comment">// pthread_cond_signal(&amp;cond) // Java notify 单个的</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond); <span class="comment">// Java notifyAll 所有的的</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;add queue.push 我已经notifyAll所有等待线程了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 从队列中获取（进行消费） 外面的人消费 你可以直接返回，你也可以采用引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(T &amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为了安全 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">queue</span>.empty()) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get empty 我已经乖乖等待中..&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// 相当于 Java的 wait 等待了[有可能被系统唤醒]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 证明被唤醒了</span></span><br><span class="line">        t = <span class="built_in">queue</span>.front(); <span class="comment">// 得到 队列中的元素数据 仅此而已</span></span><br><span class="line">        <span class="built_in">queue</span>.pop(); <span class="comment">// 删除元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;safe_queue_too.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">SafeQueueClass&lt;<span class="keyword">int</span>&gt; sq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 模拟演示 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">getMethod</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getMethod\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  value;</span><br><span class="line">        sq.get(value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者get 得到的数据:%d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你只要传入 -1 就结束当前循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == value) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消费者get 全部执行完毕\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 模拟演示 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">setMethod</span><span class="params">(<span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;setMethod\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你要生成的信息:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你只要传入 -1 就结束当前循环</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == value) &#123;</span><br><span class="line">            sq.add(value); <span class="comment">// 为了让消费者 可以结束循环</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消费者get 全部执行完毕\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sq.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadGet;</span><br><span class="line">    <span class="comment">//分别新建一个生产者消费者线程</span></span><br><span class="line">    pthread_create(&amp;pthreadGet, <span class="number">0</span>, getMethod, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// pthread_join(pthreadGet, 0); 不能这样写，否则，下面的代码，可能无法有机会执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pthreadSet;</span><br><span class="line">    pthread_create(&amp;pthreadSet, <span class="number">0</span>, setMethod, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthreadGet, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(pthreadSet, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2021/06/19/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>自C++11起，C++标准库提供了智能指针</p>
</blockquote>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><blockquote>
<p>操作引用计数实现共享式拥有的概念。多个智能指针可以指向相同的对象，这个对象和其相关资源会在最后一个被销毁时释放。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自动释放 引用计数为1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="comment">//退出方法 shared_ptr a本身释放，对内部的 A 对象引用计数减1 则为0 释放new 出来的A 对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然使用shared_ptr能够非常方便的为我们自动释放对象，但是还是会出现一些问题。最典型的就是循环引用问题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~B() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自动释放</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">//A引用计数为1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">//B引用计数为1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//查看内部对象引用计数</span></span><br><span class="line">	a-&gt;b = b;			<span class="comment">//A 引用计数为2</span></span><br><span class="line">	b-&gt;a = a;			<span class="comment">//B 引用计数为2</span></span><br><span class="line">	<span class="comment">//退出方法，a释放，A引用计数-1结果为1 不会释放 B也一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><blockquote>
<p>weak_ptr是为配合shared_ptr而引入的一种智能指针。主要用于观测资源的引用情况。</p>
<p>它的构造和析构不会引起引用记数的增加或减少。没有重载*和-&gt;但可以使用lock获得一个可用的shared_ptr对象。</p>
</blockquote>
<blockquote>
<p>配合shared_ptr解决循环引用问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~A() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	weak_ptr&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~B() &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	weak_ptr&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自动释放</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">//A引用计数为1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">//B引用计数为1</span></span><br><span class="line"></span><br><span class="line">	a-&gt;b = b;			<span class="comment">//weak_ptr 引用计数不增加</span></span><br><span class="line">	b-&gt;a = a;			<span class="comment">//weak_ptr 引用计数不增加</span></span><br><span class="line">	<span class="comment">//退出方法，A B释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>weak_ptr 提供expired 方法等价于 use_count == 0，当expired为true时，lock返回一个存储空指针的shared_ptr </p>
</blockquote>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><blockquote>
<p>实现独占式引用，保证同一时间只有一个智能指针指向内部对象。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>auto_ptr已经不推荐使用</p>
</blockquote>
<h3 id="手写智能指针"><a href="#手写智能指针" class="headerlink" title="手写智能指针"></a>手写智能指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Ptr() &#123;</span><br><span class="line">		count = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Ptr(T *t):t(t) &#123;</span><br><span class="line">		<span class="comment">//引用计数为1</span></span><br><span class="line">		count = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~Ptr() &#123;</span><br><span class="line">		<span class="comment">//引用计数-1 为0表示可以释放T了</span></span><br><span class="line">		<span class="keyword">if</span> (--(*count) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (t) &#123;</span><br><span class="line">				<span class="keyword">delete</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> count;</span><br><span class="line">			t = <span class="number">0</span>;</span><br><span class="line">			count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	Ptr(<span class="keyword">const</span> Ptr&lt;T&gt; &amp;p) &#123;</span><br><span class="line">		<span class="comment">//引用计数+1</span></span><br><span class="line">		++(*p.count);</span><br><span class="line">		t = p.t;</span><br><span class="line">		count = p.count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ptr&lt;T&gt;&amp; p) &#123;</span><br><span class="line">		++(*p.count);</span><br><span class="line">		<span class="comment">//检查老的数据是否需要删除</span></span><br><span class="line">		<span class="keyword">if</span> (--(*count) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (t) &#123;</span><br><span class="line">				<span class="keyword">delete</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> count;</span><br><span class="line">		&#125;</span><br><span class="line">		t = p.t;</span><br><span class="line">		count = p.count;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载-&gt; 操作T 类</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *t;</span><br><span class="line">	<span class="keyword">int</span> *count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重载=为什么返回引用，而不是对象？</p>
<p>return *this后马上就调用拷贝构造函数，将*this拷贝给一个匿名临时对象，然后在把临时对象拷贝给外部的左值(a=b,a为左值)，再释放临时对象。这样首先会造成不必要的开销。</p>
</blockquote>
<h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><blockquote>
<p> nullptr 出现的目的是为了替代 NULL。 同时拥有更多的特性 例如：可以调用到指针参数的函数。 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>* i)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在调用哪一个test？ test(int)</span></span><br><span class="line">test(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用test(int* i)</span></span><br><span class="line">test(<span class="literal">nullptr</span>); </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>徒手搭建编译环境，编译Android源码(手把手，嘴对嘴版本)</title>
    <url>/2021/02/10/%E5%BE%92%E6%89%8B%E6%90%AD%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E7%BC%96%E8%AF%91Android%E6%BA%90%E7%A0%81-%E6%89%8B%E6%8A%8A%E6%89%8B%EF%BC%8C%E5%98%B4%E5%AF%B9%E5%98%B4%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>作为有点点小追求的Android Developer，应该都需要拥有一套自己的Android源码吧，一方面方便自己对源码的理解，另一方面也方便自己验证自己的很多猜想。本文主要记录一下源码从下载到编译成功的一整套完整过程，以便以后自己在其他地方搭环境或者其他朋友搭建有借鉴的地方。</p>
<p>在Windows上从零开始搭建环境我理解分为以下几个步骤：</p>
<ul>
<li>搭建Linux运行环境，详见第一章</li>
<li>安装下载和编译需要的各种工具，详见第二章</li>
<li>下载源码</li>
<li>构建编译环境</li>
<li>编译源码</li>
<li>运行</li>
</ul>
<p>下面我就一个一个的记录所有的操作，尽量细致哈，哈哈哈哈</p>
<h3 id="1-安装VMWare和Ubuntu"><a href="#1-安装VMWare和Ubuntu" class="headerlink" title="1.安装VMWare和Ubuntu"></a>1.安装VMWare和Ubuntu</h3><p>参见</p>
<h3 id="2-安装下载和编译需要的工具"><a href="#2-安装下载和编译需要的工具" class="headerlink" title="2.安装下载和编译需要的工具"></a>2.安装下载和编译需要的工具</h3><p>参见</p>
<h3 id="3-下载源码"><a href="#3-下载源码" class="headerlink" title="3.下载源码"></a>3.下载源码</h3><p>由于国内种种原因，我们访问qiang外的网站非常慢，甚至无法访问，导致下载源码真是要折磨死人。<br>好在各大高校提供了国内的镜像源，可以供国内的小伙伴们一起学习交流，目前中国科学技术大学和清华大学的比较稳定，其具体使用都差不多，我就以清华源的镜像进行一步一步搭建吧。（<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp/">科大源</a>、<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华源</a>）</p>
<p><strong>3.1 创建源目录</strong></p>
<p>创建源代码目录，主要用于将所有源代码，以后编译出来的中间产物等都放着这里面方便管理。<br>这个源文件目录随便创建，但是方便看，我们就在自己用户目录下创建source目录吧。</p>
<p><strong>3.1.1 创建目录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mkdir ~/work_directory</span><br><span class="line">cd ~/work_directory</span><br></pre></td></tr></table></figure>


<p><strong>3.1.2 初始化仓库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repo init -u https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest</span></span><br></pre></td></tr></table></figure>
<p>如果执行该命令的过程中,如果提示无法连接到 gerrit.googlesource.com，那么我们只需要编辑 ~/bin/repo文件，找到REPO_URL这一行,然后将其内容修改为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">REPO_URL = <span class="string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-673bf5c2e80190aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改repo.png"></p>
<p>PS:由于我希望下Android P的代码，使用-b参数来指定哪个分支，所有我的初始化仓库为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repo init -u git:<span class="comment">//mirrors.ustc.edu.cn/aosp/platform/manifest -b android-9.0.0_r33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//坑点：大家不要下清华源的android-9.0.0_r1,访问我同步下来是编不过的。</span></span><br><span class="line"><span class="comment">// 如果下载Android9的话，建议下载：android-9.0.0_r8或者android-9.0.0_r33，亲测可以编过</span></span><br></pre></td></tr></table></figure>
<p>具体 Android 版本(<a href="https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds">列表</a>)</p>
<p><strong>3.1.3 同步代码到本地</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure>
<p>！！！一直！！！使用以上代码即可完成代码同步。</p>
<p>同步代码是一个非常耗费人力的事情，反正我睡前开始第一步同步，半夜起来同步了几次，第二天一直守着电脑，一旦出现：repo sync has finished successfully.我就再用repo sync再次看看同步结果没有，结果还要无休止的同步…….大家耐心等待吧，至少折磨一天，反正目前我到了这一步还在同步，一天了….  </p>
<p>一直等此次同步结束，然后再执行repo sync…..如此往复就行了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1514cee998488f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此次同步结束.png"></p>
<h3 id="3-1-4-自动化脚本"><a href="#3-1-4-自动化脚本" class="headerlink" title="3.1.4 自动化脚本"></a>3.1.4 自动化脚本</h3><p>是不是看了3.1.3然后自己一直repo sync，等，repo sync……如此循环都快绝望了。别绝望，下面介绍一个脚本，自动下载。</p>
<p>首先，在工作目录下创建一个python脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//step1 创建脚本文件</span><br><span class="line">vim ~/download.sh</span><br><span class="line">    </span><br><span class="line">// step2 在脚本中输入</span><br><span class="line">echo &quot;======start repo sync======&quot;</span><br><span class="line">repo sync</span><br><span class="line">while [ $? == 1 ]; do</span><br><span class="line">echo &quot;======sync failed, re-sync again======&quot;</span><br><span class="line">sleep 30</span><br><span class="line">repo sync</span><br><span class="line">done </span><br><span class="line">    </span><br><span class="line">// step3 赋权限</span><br><span class="line">chmod a+x download.sh</span><br><span class="line">    </span><br><span class="line">// step4 执行即可</span><br><span class="line">./download.sh</span><br></pre></td></tr></table></figure>
<p>可以洗洗睡了，第二天看看下完没有吧，准备开始编译吧。</p>
<h3 id="4-构建编译环境"><a href="#4-构建编译环境" class="headerlink" title="4.构建编译环境"></a>4.构建编译环境</h3><p>源码下载完成后,就可以构建编译环境了.在开始之前,我们先来看看一些编译要求:</p>
<p><strong>4.1 硬件要求:</strong><br> 64位的操作系统只能编译2.3.x以上的版本,如果你想要编译2.3.x以下的,那么需要32位的操作系统.<br> 磁盘空间越多越好,至少在100GB以上.意思就是,你可以去买个大点的硬盘了啊<br> 如果你想要在是在虚拟机运行linux,那么至少需要16GB的RAM/swap.<br> (实际上,我非常不推荐在虚拟机中编译2.3.x以上的代码.)</p>
<p><strong>4.2 软件要求:</strong><br> <em>1. 操作系统要求</em><br> 在<a href="https://link.jianshu.com/?t=https://android.googlesource.com/">AOSP开源</a>中,主分支使用Ubuntu长期版本开发和测试的,因此也建议你使用Ubuntu进行编译,下面我们列出不同版本的的Ubuntu能够编译那些android版本:</p>
<table>
<thead>
<tr>
<th>Android版本</th>
<th>编译要求的Ubuntu最低版本</th>
</tr>
</thead>
<tbody><tr>
<td>Android 6.0至AOSP master</td>
<td>Ubuntu 14.04</td>
</tr>
<tr>
<td>Android 2.3.x至Android 5.x</td>
<td>Ubuntu 12.04</td>
</tr>
<tr>
<td>Android 1.5至Android 2.2.x</td>
<td>Ubuntu 10.04</td>
</tr>
</tbody></table>
<p><em>2. JDK版本要求</em><br> 除了操作系统版本这个问题外,我们还需要关注JDK版本问题,为了方便,同样我们也列出的不同Android版本的源码需要用到的JDK版本:</p>
<table>
<thead>
<tr>
<th>Android版本</th>
<th>编译要求的JDK版本</th>
</tr>
</thead>
<tbody><tr>
<td>AOSP的Android主线</td>
<td>OpenJDK 8</td>
</tr>
<tr>
<td>Android 5.x至android 6.0</td>
<td>OpenJDK 7</td>
</tr>
<tr>
<td>Android 2.3.x至Android 4.4.x</td>
<td>Oracle JDK 6</td>
</tr>
<tr>
<td>Android 1.5至Android 2.2.x</td>
<td>Oracle JDK 5</td>
</tr>
</tbody></table>
<p>更具体的可以参看:<a href="https://link.jianshu.com/?t=https://source.android.com/source/requirements.html">Google源码编译要求</a></p>
<p>我现在在Ubuntu 16.04下编译AOSP主线代码,因此需要安装OpenJDK 8,执行命令如下:<br> <code>sudo apt-get install openjdk-8-jdk</code><br> 如果你需要在Ubuntu 14.04下编译AOSP主线代码,同样需要安装OpenJDK 8,此时需要执行如下命令:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install openjdk<span class="number">-8</span>-jdk</span><br></pre></td></tr></table></figure>
<p>如果你要编译的是Android 5.x到android 6.0之间的系统版本,需要采用openjdk7.但是在Ubuntu 15.04及之后的版本的在线安装库中只支持openjdk8和openjdk9的安装.因此,如果你想要安装openjdk 7需要首先设置ppa:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">add</span>-apt-repository ppa:openjdk-r/ppa </span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br></pre></td></tr></table></figure>
<p>然后再执行安装命令:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install openjdk<span class="number">-7</span>-jdk </span><br></pre></td></tr></table></figure>
<p>有时候,我们需要编译不同版本的android系统,就可能使用不同的jdk版本.关于jdk版本切换,可以使用如下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-alternative --config java</span><br><span class="line">sudo update-alternative --config javac</span><br></pre></td></tr></table></figure>
<p><em>3. 其他要求</em></p>
<p><a href="https://link.jianshu.com/?t=https://source.android.com/source/initializing.html">Google官方构建编译环境指南</a>中已经说明了Ubuntu14.04,Ubuntu 12.04,Ubuntu 10.04需要添加的依赖,这里我们就不做介绍了.我原先以为,Ubuntu16.04的设置和Ubuntu14.04的依赖设置应该差不多,但是只能说too young too simple.<br> 下面是Ubuntu16.04中的依赖设置:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install libx11<span class="operator">-</span>dev:i386 libreadline6<span class="operator">-</span>dev:i386 libgl1<span class="operator">-</span>mesa<span class="operator">-</span>dev g<span class="operator">++-</span>multilib </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install <span class="operator">-</span>y git flex bison gperf build<span class="operator">-</span>essential libncurses5<span class="operator">-</span>dev:i386 </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install tofrodos python<span class="operator">-</span>markdown libxml2<span class="operator">-</span>utils xsltproc zlib1g<span class="operator">-</span>dev:i386 </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install dpkg<span class="operator">-</span>dev libsdl1.<span class="number">2</span><span class="operator">-</span>dev libesd0<span class="operator">-</span>dev</span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install git<span class="operator">-</span>core gnupg flex bison gperf build<span class="operator">-</span>essential  </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install zip curl zlib1g<span class="operator">-</span>dev gcc<span class="operator">-</span>multilib g<span class="operator">++-</span>multilib </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install libc6<span class="operator">-</span>dev<span class="operator">-</span>i386 </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install lib32ncurses5<span class="operator">-</span>dev x11proto<span class="operator">-</span>core<span class="operator">-</span>dev libx11<span class="operator">-</span>dev </span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install libgl1<span class="operator">-</span>mesa<span class="operator">-</span>dev libxml2<span class="operator">-</span>utils xsltproc unzip m4</span><br><span class="line">sudo apt<span class="operator">-</span><span class="keyword">get</span> install lib32z<span class="operator">-</span>dev ccache</span><br></pre></td></tr></table></figure>
<p>(其中几个命令中参数是重复的,但不妨碍我们)</p>
<h3 id="5-编译系统"><a href="#5-编译系统" class="headerlink" title="5.编译系统"></a>5.编译系统</h3><h4 id="5-1-初始化编译环境"><a href="#5-1-初始化编译环境" class="headerlink" title="5.1 初始化编译环境"></a>5.1 初始化编译环境</h4><p>在工作目录使用以下指令初始化编译环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure>
<p>执行命令之后：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-fc6c952a9e6c8711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化编译环境.png"></p>
<p>不难发现该命令只是引入了其他执行脚本,至于这些脚本做什么,目前不在本文中细说.该命令执行成功后,我们会得到了一些有用的命令,比如最下面要用到的lunch命令.</p>
<h4 id="5-2-选择编译目标"><a href="#5-2-选择编译目标" class="headerlink" title="5.2 选择编译目标"></a>5.2 选择编译目标</h4><p>使用lunch指令选择编译目标。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-70a723ef6c2eac71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择编译目标.png"></p>
<p>使用lunch指令之后会出现上图的结果，让我们选择要编译的目标系统。因为我希望编译车机的系统，我选择10，于是输入“10”，然后回车。会出现如下结果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e31f0eac9442899b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译车机系统.png"></p>
<h4 id="5-3-开始编译"><a href="#5-3-开始编译" class="headerlink" title="5.3 开始编译"></a>5.3 开始编译</h4><p>通过make指令进行代码编译,该指令通过<code>-j</code>参数来设置参与编译的线程数量,以提高编译速度.比如这里我们设置8个线程同时编译:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>需要注意的是,参与编译的线程并不是越多越好,通常是根据你机器cup的核心来确定:core*2,即当前cpu的核心的2倍.比如,我现在的笔记本是双核四线程的,因此根据公式,最快速的编译可以make -j8.<br> (通过<code>cat /proc/cpuinfo</code>查看相关cpu信息)</p>
<p><strong>注意：</strong>使用j8参数一定要注意，最好电脑配置要高，反正我笔记本使用j8开始报oom，然后直接卡死…..</p>
<p>建议直接使用make指令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>


<p>如果一切顺利，出现：***#### build completed successfully (06:43 (mm:ss)) ####***</p>
<p>那就恭喜你，编程完成了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-75ad995e983eac7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译成功.png"></p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h3><blockquote>
<p>XH分支</p>
<ul>
<li><p>repo环境配置：<br>mkdir /home/xxx/bin &amp;&amp; cp repo /home/xxx/bin<br>export PATH= /home/xxx/bin:$PATH</p>
</li>
<li><p>代码下载：<br>mkdir a55 &amp;&amp; cd a55<br>repo init -u ssh://<a href="mailto:&#120;&#120;&#x78;&#64;&#49;&#48;&#46;&#x35;&#46;&#50;&#48;&#46;&#x36;&#x38;">&#120;&#120;&#x78;&#64;&#49;&#48;&#46;&#x35;&#46;&#50;&#48;&#46;&#x36;&#x38;</a>:29418/8155_a55/manifest.git -b master –repo-url=<a href="https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/">https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/</a><br>repo sync</p>
</li>
<li><p>代码编译<br>./build_target.sh msmnile_gvmq -a</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>编译Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>数字证书_证书格式说明_keystore</title>
    <url>/2021/07/08/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6-%E8%AF%81%E4%B9%A6%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E-keystore/</url>
    <content><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>X509就是数字证书的标准，规定了数字证书的格式。</p>
<p>PKCS，全称是公钥密码标准。</p>
<p>keystore是存放应用签名的文件，包含两个部分：</p>
<ul>
<li>密钥实体(key entity),私钥(secret key)或者私钥与配对的公钥。</li>
<li>可信任的证书实体（trusted certificate entries）——只包含公钥</li>
</ul>
<h4 id="2-证书格式"><a href="#2-证书格式" class="headerlink" title="2.证书格式"></a>2.证书格式</h4><p>[PKCS（Public-Key Cryptography Standards）](<a href="https://www.rsa.com/en-us/company/insight">RSA Insight and Thought Leadership – RSA Security</a>)是由美国RSA<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/3204964">数据安全</a>公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">数字签名</a>、<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81">数字信封</a>的格式等方面的一系列相关协议。</p>
<blockquote>
<p>PKCS 目前共发布过 15 个标准：</p>
<p>（1）PKCS#1：RSA加密标准。PKCS#1定义了RSA公钥函数的基本格式标准，特别是数字签名。它定义了数字签名如何计算，包括待签名数据和签名本身的格式；它也定义了PSA公/私钥的语法。</p>
<p>（2）PKCS#2：涉及了RSA的消息摘要加密，这已被并入PKCS#1中。</p>
<p>（3）PKCS#3：Diffie-Hellman密钥协议标准。PKCS#3描述了一种实现Diffie- Hellman密钥协议的方法。</p>
<p>（4）PKCS#4：最初是规定RSA密钥语法的，现已经被包含进PKCS#1中。</p>
<p>（5）PKCS#5：基于口令的加密标准。PKCS#5描述了使用由口令生成的密钥来加密8位位组串并产生一个加密的8位位组串的方法。PKCS#5可以用于加密私钥，以便于密钥的安全传输（这在PKCS#8中描述）。</p>
<p>（6）PKCS#6：扩展证书语法标准。PKCS#6定义了提供附加实体信息的X.509证书属性扩展的语法（当PKCS#6第一次发布时，X.509还不支持扩展。这些扩展因此被包括在X.509中）。</p>
<p>（7）PKCS#7：密码消息语法标准。PKCS#7为使用密码算法的数据规定了通用语法，比如数字签名和数字信封。PKCS#7提供了许多格式选项，包括未加密或签名的格式化消息、已封装（加密）消息、已签名消息和既经过签名又经过加密的消息。</p>
<p>（8）PKCS#8：私钥信息语法标准。PKCS#8定义了私钥信息语法和加密私钥语法，其中私钥加密使用了PKCS#5标准。</p>
<p>（9）PKCS#9：可选属性类型。PKCS#9定义了PKCS#6扩展证书、PKCS#7数字签名消息、PKCS#8私钥信息和PKCS#10证书签名请求中要用到的可选属性类型。已定义的证书属性包括E-mail地址、无格式姓名、内容类型、消息摘要、签名时间、签名副本（counter signature）、质询口令字和扩展证书属性。</p>
<p>（10）PKCS#10：证书请求语法标准。PKCS#10定义了证书请求的语法。证书请求包含了一个唯一识别名、公钥和可选的一组属性，它们一起被请求证书的实体签名（证书管理协议中的PKIX证书请求消息就是一个PKCS#10）。</p>
<p>（11）PKCS#11：密码令牌接口标准。PKCS#11或“Cryptoki”为拥有密码信息（如加密密钥和证书）和执行密码学函数的单用户设备定义了一个应用程序接口（API）。智能卡就是实现Cryptoki的典型设备。注意：Cryptoki定义了密码函数接口，但并未指明设备具体如何实现这些函数。而且Cryptoki只说明了密码接口，并未定义对设备来说可能有用的其他接口，如访问设备的文件系统接口。</p>
<p>（12）PKCS#12：个人信息交换语法标准。PKCS#12定义了个人身份信息（包括私钥、证书、各种秘密和扩展字段）的格式。PKCS#12有助于传输证书及对应的私钥，于是用户可以在不同设备间移动他们的个人身份信息。</p>
<p>（13）PDCS#13：椭圆曲线密码标准。PKCS#13标准当前正在完善之中。它包括椭圆曲线参数的生成和验证、密钥生成和验证、数字签名和公钥加密，还有密钥协定，以及参数、密钥和方案标识的ASN.1语法。</p>
<p>（14）PKCS#14：伪随机数产生标准。PKCS#14标准当前正在完善之中。为什么随机数生成也需要建立自己的标准呢？PKI中用到的许多基本的密码学函数，如密钥生成和Diffie-Hellman共享密钥协商，都需要使用随机数。然而，如果“随机数”不是随机的，而是取自一个可预测的取值集合，那么密码学函数就不再是绝对安全了，因为它的取值被限于一个缩小了的值域中。因此，安全伪随机数的生成对于PKI的安全极为关键。</p>
<p>（15）PKCS#15：密码令牌信息语法标准。PKCS#15通过定义令牌上存储的密码对象的通用格式来增进密码令牌的互操作性。在实现PKCS#15的设备上存储的数据对于使用该设备的所有应用程序来说都是一样的，尽管实际上在内部实现时可能所用的格式不同。PKCS#15的实现扮演了翻译家的角色，它在卡的内部格式与应用程序支持的数据格式间进行转换。</p>
</blockquote>
<p>X.509是一种非常通用的证书格式，X509就是数字证书的标准，规定了数字证书的格式。</p>
<blockquote>
<p>在一份证书中，必须证明<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%85%AC%E9%92%A5">公钥</a>及其所有者的姓名是一致的。对X.509证书来说，认证者总是<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/CA">CA</a>或由CA指定的人，一份X.509证书是一些标准字段的集合，这些字段包含有关用户或设备及其相应公钥的信息。X.509标准定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的(即数据格式)。</p>
</blockquote>
<p>PKCS#7 常用的后缀是： .P7B .P7C .SPC<br>PKCS#12 常用的后缀有： .P12 .PFX<br>X.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT<br>X.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT<br>.cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥。<br>.pem跟crt/cer的区别是它以Ascii来表示。<br>pfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式<br>p10是证书请求<br>p7r是CA对证书请求的回复，只用于导入<br>p7b以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。</p>
<h4 id="3-证书生成方式"><a href="#3-证书生成方式" class="headerlink" title="3.证书生成方式"></a>3.证书生成方式</h4><p>3.1 用openssl创建CA证书的RSA密钥(PEM格式)：<br>openssl genrsa -des3 -out ca.key 1024</p>
<p>3.2 用openssl创建CA证书(PEM格式,假如有效期为一年)：<br>openssl req -new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf<br>openssl是可以生成DER格式的CA证书的，最好用IE将PEM格式的CA证书转换成DER格式的CA证书。</p>
<p>3.3 x509到pfx<br>pkcs12 -export –in keys/client1.crt -inkey keys/client1.key -out keys/client1.pfx</p>
<p>3.4  PEM格式的ca.key转换为Microsoft可以识别的pvk格式。<br> pvk -in ca.key -out ca.pvk -nocrypt -topvk</p>
<p>3.5 PKCS#12 到 PEM 的转换<br>openssl pkcs12 -nocerts -nodes -in cert.p12 -out private.pem<br>验证 openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</p>
<p>3.6 从 PFX 格式文件中提取私钥格式文件 (.key)<br>openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key</p>
<p>3.7 转换 pem 到到 spc<br>openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc<br>用 -outform -inform 指定 DER 还是 PAM 格式。例如：<br>openssl x509 -in Cert.pem -inform PEM -out cert.der -outform DER</p>
<p>3.8 PEM 到 PKCS#12 的转换，<br>openssl pkcs12 -export -in Cert.pem -out Cert.p12 -inkey key.pem</p>
<h4 id="4-密钥库文件格式【Keystore】"><a href="#4-密钥库文件格式【Keystore】" class="headerlink" title="4.密钥库文件格式【Keystore】"></a>4.密钥库文件格式【Keystore】</h4><p> 格式   : JKS<br> 扩展名 : .jks/.ks<br> 描述   : 【Java Keystore】密钥库的Java实现版本，provider为SUN<br> 特点   : 密钥库和私钥用不同的密码进行保护</p>
<p> 格式   : JCEKS<br> 扩展名 : .jce<br> 描述   : 【JCE Keystore】密钥库的JCE实现版本，provider为SUN JCE<br> 特点   : 相对于JKS安全级别更高，保护Keystore私钥时采用TripleDES</p>
<p> 格式   : PKCS12<br> 扩展名 : .p12/.pfx<br> 描述   : 【PKCS #12】个人信息交换语法标准<br> 特点   : 1、包含私钥、公钥及其证书<br>        2、密钥库和私钥用相同密码进行保护</p>
<p> 格式   : BKS<br> 扩展名 : .bks<br> 描述   : Bouncycastle Keystore】密钥库的BC实现版本，provider为BC<br> 特点   : 基于JCE实现</p>
<p> 格式   : UBER<br> 扩展名 : .ubr<br> 描述   : 【Bouncycastle UBER Keystore】密钥库的BC更安全实现版本，provider为BC</p>
<h4 id="5-证书文件格式【Certificate】"><a href="#5-证书文件格式【Certificate】" class="headerlink" title="5.证书文件格式【Certificate】"></a>5.证书文件格式【Certificate】</h4><p>格式     : DER<br>扩展名    : .cer/.crt/.rsa</p>
<p>描述     : 【ASN .1 DER】用于存放证书<br>特点     : 不含私钥、二进制</p>
<p>格式     : PKCS7<br>扩展名    : .p7b/.p7r<br>描述     : 【PKCS #7】加密信息语法标准</p>
<p>特点     : 1、p7b以树状展示证书链，不含私钥<br>         2、p7r为CA对证书请求签名的回复，只能用于导入</p>
<p>格式     : CMS<br>扩展名    : .p7c/.p7m/.p7s<br>描述     : 【Cryptographic Message Syntax】<br>特点     : 1、p7c只保存证书<br>         2、p7m：signature with enveloped data<br>         3、p7s：时间戳签名文件</p>
<p>格式     : PEM<br>扩展名    : .pem<br>描述     : 【Printable Encoded Message】<br>特点     : 1、该编码格式在RFC1421中定义，其实PEM是【Privacy-Enhanced Mail】的简写，但他也同样广泛运用于密钥管理<br>         2、ASCII文件<br>         3、一般基于base 64编码</p>
<p>格式     :  PKCS10<br>扩展名   : .p10/.csr<br>描述     : 【PKCS #10】公钥加密标准【Certificate Signing Request】<br>特点     : 1、证书签名请求文件<br>         2、ASCII文件<br>         3、CA签名后以p7r文件回复</p>
<p>格式     : SPC<br>扩展名   : .pvk/.spc<br>描述     : 【Software Publishing Certificate】<br>特点     : 微软公司特有的双证书文件格式，经常用于代码签名，其中<br>         1、pvk用于保存私钥<br>         2、spc用于保存公钥</p>
<h4 id="6-生成证书"><a href="#6-生成证书" class="headerlink" title="6.生成证书"></a>6.生成证书</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./development/tools/make_key  mytest &#x27;/C=CN/ST=YourProvince/L=YourLocation/O=YourOrganization/OU=YourOrganizationalUnit/CN=YourName&#x27;</span><br></pre></td></tr></table></figure>
<p>使用如上命令会在当前目录下生成一个二进制形式（DER）的私钥文件“mytest.pk8”和一个对应的公钥证书文件“mytest.x509.pem”。</p>
<p>其中，/C表示“Country Code”，/ST表示“State or Province”，/L表示“City or Locality”，/O表示“Organization”，/OU表示“Organizational Unit”，/CN表示“Name”</p>
<p>生成.pk8和.pem之后就可以使用如下指令对apk进行签名</p>
<blockquote>
<p>签名：java -jar signapk.jar platform.x509.pem platform.pk8 Gaei_Setting.apk Gaei_Setting_sign.apk<br>验证签名：jarsigner -verify -verbose -certs *.apk</p>
</blockquote>
<p>也可以制作keystore直接在android studio中签名</p>
<blockquote>
<p>(1) 生成platform.pem文件<br>openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out platform.pem<br>(2) 生成platform.p12文件，设置别名和密码，即AS打包APK时输入的别名和密码<br>openssl pkcs12 -export -in platform.x509.pem -out platform.p12 -inkey platform.pem -password pass:android -name key<br>(3) 生成platform.jks(钥匙文件) （-srcstorepass android）是.jks文件的密码<br>keytool -importkeystore -deststorepass android -destkeystore ./platform.jks -srckeystore ./platform.p12 -srcstoretype PKCS12 -srcstorepass android<br>(4) 生成PKCS12格式的jks<br>keytool -importkeystore -srckeystore ./platform.jks -destkeystore ./platform.jks -deststoretype pkcs12</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java反射</title>
    <url>/2021/01/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h4><p>​    主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>
<h4 id="2-Java反射提供了什么能力？"><a href="#2-Java反射提供了什么能力？" class="headerlink" title="2. Java反射提供了什么能力？"></a>2. Java反射提供了什么能力？</h4><p>​    在Java运行时环境中，对于任意一个类，都知道这个类有哪些属性和方法，对于任意一个对象都能调用它的任意一个方法。具体的能力如下：</p>
<ul>
<li>1.在运行时判断任意一个对象所属的类。</li>
<li>2.在运行时构造任意一个类的对象。</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>4.在运行时调用任意一个对象的方法。 </li>
</ul>
<h4 id="3-反射的作用是什么？"><a href="#3-反射的作用是什么？" class="headerlink" title="3.反射的作用是什么？"></a>3.反射的作用是什么？</h4><p>​    反射可以在程序运行的时候，动态修改程序的某些属性，使得程序按照我们设计的流程运行。大量开源框架都会用到反射机制，例如：</p>
<ul>
<li>腾讯的Tinker热修复框架会反射DexPathList类拿到dexElements变量，将补丁dex文件放入到dexElements数组的第一个，让ClassLoader首先加载已修复的类。</li>
<li>360的DroidPlugin等插件化框架会反射AMS偷梁换柱intent，来绕过AMS对待启动的Activity是否注册Mainifest的验证。</li>
<li>ARouter、ButterKnife、Retrofit、Dagger2等等开源框架都会通过反射拿到用户使用注解的类，然后完成参数注入或者获取。</li>
</ul>
<p><strong>下面用一张图来解释一下反射来实现Hook的原理：</strong></p>
<p>​    横轴是程序正常运行的时间轴，我们通过反射机制在编译期或者运行时拿到程序中的某个类，动态修改该类中的一些属性，使程序按照我们期望的点运行。该机制主要还是用于我们无法修改到别人的代码，又要借助别人的代码实现自己期望的逻辑的场景。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-84550dadd657939a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反射图解.png"></p>
<h4 id="4-反射有什么缺点？"><a href="#4-反射有什么缺点？" class="headerlink" title="4. 反射有什么缺点？"></a>4. 反射有什么缺点？</h4><p>​    大量运用反射会导致程序变慢，但是经过测试，一般使用反射的数量级在1000以下，几乎可以忽略影响。那么为什么反射会导致程序性能变差呢：</p>
<ul>
<li>在使用反射的过程中会产生大量的临时对象</li>
<li>虚拟机在检查对象可见性的时候是会消耗CPU资源</li>
<li>反射会生成没有优化的字节码</li>
<li>进行拆箱、装箱、类型转换的时候会消耗资源</li>
</ul>
<h4 id="5-如何使用反射？"><a href="#5-如何使用反射？" class="headerlink" title="5. 如何使用反射？"></a>5. 如何使用反射？</h4><p>​    在JDK中主要有以下类来实现反射机制，这些（除了第一个）都位于rt.jar的java.lang.reflect包中</p>
<ul>
<li>Class类：代表一个类，位于java.lang包下。</li>
<li>Field类：代表类的成员变量（成员变量也称为类的属性）。</li>
<li>Method类：代表类的方法。</li>
<li>Constructor类：代表类的构造方法。</li>
<li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法。</li>
</ul>
<p>详细API我先用一张图展示出来，然后一个一个阐述用法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a7fa332bd1fc472e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反射.png"></p>
<h5 id="5-1-Class类的6种获取方式"><a href="#5-1-Class类的6种获取方式" class="headerlink" title="5.1 Class类的6种获取方式"></a>5.1 Class类的6种获取方式</h5><ul>
<li><p>类名.class。  例如: MainActivity.class;</p>
</li>
<li><p>对象.getClass()。  例如: View view; view.getClass();</p>
</li>
<li><p>Class.forName(“全限定名”)。  例如: Class.forName(“java.lang.String”);</p>
</li>
<li><p>类.class.getClassLoader().loadClass(“全限定名”)。 </p>
<p>例如: MainActivity.class.getClassLoader().loadClass(“java.lang.String”);</p>
</li>
<li><p>子类.class.getSuperClass()。  例如: MainActivity.class.getSuperclass();</p>
</li>
<li><p>包装类.class。  例如: Integer.class、ContextThemeWrapper.class</p>
</li>
</ul>
<h5 id="5-2-根据类获取类名、全限定名和包名"><a href="#5-2-根据类获取类名、全限定名和包名" class="headerlink" title="5.2 根据类获取类名、全限定名和包名"></a>5.2 根据类获取类名、全限定名和包名</h5><ul>
<li>getName() 获取全限定名。  例如: MainActivity.class.getName()</li>
<li>getSimpleName() 获得类名。例如: MainActivity.class.getSimpleName()</li>
<li>getPackage().getName()包名。 例如: MainActivity.class.getPackage().getName()</li>
</ul>
<h5 id="5-3-获取变量、属性"><a href="#5-3-获取变量、属性" class="headerlink" title="5.3 获取变量、属性"></a>5.3 获取变量、属性</h5><ul>
<li>getField(“属性名”) 获取public公共属性，包括可以获取父类的</li>
<li>getName() 属性名</li>
<li>getModifiers() 修饰符</li>
<li>getType() 数据类型</li>
<li>set(对象名，属性值)  给属性赋值。相当于 对象名.set属性名   </li>
<li>get(对象名) 获取属性。相当于 对象名.get属性名  </li>
<li>getDeclearedField(“属性名”)  获取指定属性</li>
<li>setAccessible(true) 放开private属性访问权</li>
<li>getDeclearedFields()  获取类的全部属性</li>
</ul>
<h5 id="5-4-获取类中的方法"><a href="#5-4-获取类中的方法" class="headerlink" title="5.4 获取类中的方法"></a>5.4 获取类中的方法</h5><ul>
<li>getMethod(方法名，参数数据类型(没有参数传null))  获取public方法</li>
<li>getDeclearedMethod(方法名，参数数据类型(没有参数传null))  获取类中所有方法</li>
<li>invoke(对象名，参数列表) 执行方法。相当于  对象名.方法名    如果是静态方法对象名传入<strong>null</strong></li>
<li>getParameterTypes() 得到返回参数列表</li>
<li>getDeclearedMethods() 得到类的所有的方法</li>
<li>getReturnType() 获取返回值的数据类型</li>
</ul>
<h5 id="5-5-获取和调用构造方法"><a href="#5-5-获取和调用构造方法" class="headerlink" title="5.5 获取和调用构造方法"></a>5.5 获取和调用构造方法</h5><ul>
<li>Class对象.getConstructor() 得到构造方法</li>
<li>Class对象.getConstructors() 得到所有构造方法</li>
<li>Class对象.getDeclaredConstructor 获取Class类中的构造方法</li>
<li>newInstance(参数) 调用构造方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>源码编译引入第三方库</title>
    <url>/2021/03/05/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<h3 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h3><p>在Android工程开发中难免会有引入第三方库的需求，例如GSON，Okhttp，Glide等等，但是在源码中用makefile编译如何让编译器知道你引入的库呢？下面我举一个例子来说明</p>
<ul>
<li>例如我们工程需要引入GSON库，没引入的时候编译报错如下图。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6290edf6a973d4a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译报错.png"></p>
<ul>
<li>引入库制定编译规则<br><img src="https://upload-images.jianshu.io/upload_images/13838098-49354c71db02cb34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖库问题.png"></li>
</ul>
<h3 id="2-寻找原因"><a href="#2-寻找原因" class="headerlink" title="2. 寻找原因"></a>2. 寻找原因</h3><p>原因的话编译器已经报出来了，就是找不到对应的类，也就是找不到对应的库文件。</p>
<h3 id="3-解决办法-引入第三方库方法"><a href="#3-解决办法-引入第三方库方法" class="headerlink" title="3. 解决办法(引入第三方库方法)"></a>3. 解决办法(引入第三方库方法)</h3><p>在解决问题之前首先介绍一下这两个编译参数：<strong>BUILD_JAVA_LIBRARY 与 BUILD_STATIC_JAVA_LIBRARY</strong></p>
<p>​    在Android.mk中可通过调用include $(BUILD_JAVA_LIBRARY)和include $(BUILD_STATIC_JAVA_LIBRARY)来分别生成目标设备上的共享JAVA库与静态JAVA库。</p>
<p>​    二者的区别在于<strong>静态JAVA库是由.class文件打包而成JAR包，它在任何一个JAVA虚拟机上都可以运行</strong>；而<strong>共享JAVA库则是在静态库的基础上进一步打包成的.dex文件</strong>，众所周知，dex是在android系统上所使用的文件格式。</p>
<p>​    由以上结论可做出进一步的推论：即Android.mk中变量LOCAL_JAVA_LIBRARIES所指定的为android系统使用的dex类库；而LOCAL_STATIC_JAVA_LIBRARIES变量所指定的则是.class文件打包而成的JAR文件：即静态JAVA库。</p>
<p>​    <strong>BUILD_STATIC_JAVA_LIBRARY</strong>会生成out/target/common/obj/JAVA_LIBRARIES/lib名_intermediates目录及其下的JAR文件；而<strong>BUILD_JAVA_LIBRARY</strong>生成此目录的同时会将其中的JAR包复制到out/target/product/<product-name>/system/framework/中；除此之外，还存在<strong>BUILD_HOST_JAVA_LIBRARY</strong>命令则是在out/host/linux-x86/framework目录下生成相应的JAR包。分别使用此三条命令执行的结果如下所示：注意其中带有红色下划线的LOG信息。</product-name></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译第三方库基本用法</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在Android.mk目录下建立libs,然后将jar包放入libs，先预编译到out/target/product/generic/obj/JAVA_LIBRARIES下，然后本项目就会找到依赖的者jar包了</span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := gson:libs/gson-2.8.2.jar</span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################以下是顺带的说明########################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################完整的mk文件###########################</span></span></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_PACKAGE_NAME := Permission</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">LOCAL_SDK_VERSION 和LOCAL_PRIVATE_PLATFORM_APIS在Android.mk中必须用一个</span></span><br><span class="line"><span class="meta">#</span><span class="bash">LOCAL_SDK_VERSION := current  意思是编译时忽略系统隐藏类(@hide)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">LOCAL_PRIVATE_PLATFORM_APIS := <span class="literal">true</span> 表示可以应用系统的API(@hide或者@SystemApi)</span></span><br><span class="line">LOCAL_PRIVATE_PLATFORM_APIS := true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭混淆优化器，没有这个配置，会报:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">there were 194 unresolved references to program class members.Your input classes appear to be inconsistent.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">there were 2494 unresolved references to library class members. You probably need to update the library versions. Alternatively, you may have to specify the option</span> </span><br><span class="line">LOCAL_PROGUARD_ENABLED := disabled</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"><span class="meta">#</span><span class="bash">编译aidl文件</span></span><br><span class="line">LOCAL_SRC_FILES += $(call all-Iaidl-files-under,src/com/xh/permission) \</span><br><span class="line">                    src/com/xh/permission/ICarPermissionManager.aidl</span><br><span class="line"></span><br><span class="line">LOCAL_AIDL_INCLUDES := $(LOCAL_PATH)/src/com/xh/permission</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">应用第三方库</span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := gson \</span><br><span class="line">	android-support-v7-appcompat \</span><br><span class="line">	xhframework</span><br><span class="line"></span><br><span class="line">LOCAL_STATIC_ANDROID_LIBRARIES := android-support-annotations</span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############我是分割线#####################</span></span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := gson</span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := gson:libs/gson-2.8.2.jar</span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br></pre></td></tr></table></figure>


<h3 id="4-扩展点"><a href="#4-扩展点" class="headerlink" title="4.扩展点"></a>4.扩展点</h3><p>如果在Android FrameWork集成第三方SDK的jar包和so库，首先在framework/opt/建立XXXSDK的文件夹讲jar包和so库拷贝进去。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-685d49a988fde6a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="framework依赖库编译.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##################### mk文件如下 ################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copyright (C) 2009 The Android Open Source Project</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you may not use this file except <span class="keyword">in</span> compliance with the License.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You may obtain a copy of the License at</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#      http://www.apache.org/licenses/LICENSE-2.0</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See the License <span class="keyword">for</span> the specific language governing permissions and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> limitations under the License.</span></span><br><span class="line"> </span><br><span class="line">LOCAL_PATH := $(my-dir)</span><br><span class="line"> </span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"> </span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := okhttp-3.12.0.jar \</span><br><span class="line">                                        rxjava-2.1.12.jar \</span><br><span class="line">                                        sqlite.jar</span><br><span class="line"> </span><br><span class="line">include $(BUILD_MULTI_PREBUILT)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlife</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlife.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlifeserver</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlifeserver.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlifeservicejni</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlifeservicejni.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#################################################</span></span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := libcarlifevehicle</span><br><span class="line">LOCAL_SRC_FILES := libs/libcarlifevehicle.so</span><br><span class="line">LOCAL_MODULE_SUFFIX := .so</span><br><span class="line">LOCAL_MODULE_CLASS := SHARED_LIBRARIES</span><br><span class="line"> </span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"> </span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>生成签名文件和签名应用</title>
    <url>/2021/03/11/%E7%94%9F%E6%88%90%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%E5%92%8C%E7%AD%BE%E5%90%8D%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-签名文件简介"><a href="#1-签名文件简介" class="headerlink" title="1.签名文件简介"></a>1.签名文件简介</h3><p><a href="https://android.googlesource.com/platform/build/+/donut-release/target/product/security">签名文件说明出处</a>，标准的测试秘钥包含四个部分：testkey、platform、shared和media。</p>
<blockquote>
<p>The following standard test keys are currently included:</p>
<p>testkey – a generic key for packages that do not otherwise specify a key.<br>platform – a test key for packages that are part of the core platform.<br>shared – a test key for things that are shared in the home/contacts process.<br>media – a test key for packages that are part of the media/download system.</p>
</blockquote>
<ul>
<li>testkey是没有指定特定秘钥的通用秘钥，可以用于开发阶段的普通apk签名(没有签名系统可能会在安装的时候就报错，不让安装)</li>
<li>platform主要用于平台app做签名，例如某个平台app需要访问到@SystemApi或者@hide注解的方法，就需要使用platform文件来签名应用。</li>
<li>shared 用于一些要共享数据应用数据的应用签名</li>
<li>media 用于媒体和系统下载应用签名</li>
</ul>
<h3 id="2-签名文件的生成"><a href="#2-签名文件的生成" class="headerlink" title="2.签名文件的生成"></a>2.签名文件的生成</h3><h4 id="2-1命令行生成方式"><a href="#2-1命令行生成方式" class="headerlink" title="2.1命令行生成方式"></a>2.1命令行生成方式</h4><ul>
<li><p>生成秘钥对：openssl genrsa -3 -out testkey.pem 2048</p>
</li>
<li><p>生成pem格式的证书：openssl req -new -x509 -key testkey.pem -out testkey.x509.pem -days 10000   -subj ‘/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=<a href="mailto:&#x61;&#110;&#x64;&#114;&#x6f;&#x69;&#100;&#64;&#97;&#110;&#100;&#x72;&#x6f;&#105;&#100;&#x2e;&#99;&#111;&#x6d;">&#x61;&#110;&#x64;&#114;&#x6f;&#x69;&#100;&#64;&#97;&#110;&#100;&#x72;&#x6f;&#105;&#100;&#x2e;&#99;&#111;&#x6d;</a>‘</p>
</li>
<li><p>生成私钥文件：openssl pkcs8 -in testkey.pem -topk8 -outform DER -out testkey.pk8 -nocrypt</p>
</li>
</ul>
<h4 id="2-2脚本生成证书方式"><a href="#2-2脚本生成证书方式" class="headerlink" title="2.2脚本生成证书方式"></a>2.2脚本生成证书方式</h4><p>在源码**development/tools/**目录中，有一个make_key脚本，可以使用这个脚本来生成证书</p>
<p>Step 1：cd到development/tools/目录</p>
<p>Step 2：运行make_key脚本： sudo ./make_key platform ‘/C=CN/ST=YourProvince/L=YourLocation/O=YourOrganization/OU=YourOrganizationalUnit/CN=YourName’</p>
<p>说明：testkey是生成的文件名，后面是证书里面的内容</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/C</td>
<td>国家代号</td>
</tr>
<tr>
<td>/ST</td>
<td>省份代号</td>
</tr>
<tr>
<td>/L</td>
<td>位置代号</td>
</tr>
<tr>
<td>/O</td>
<td>组织代号</td>
</tr>
<tr>
<td>/OU</td>
<td>单位代号</td>
</tr>
<tr>
<td>/CN</td>
<td>名称</td>
</tr>
</tbody></table>
<p>Step 3：输入自定义密码</p>
<p>此时就会生成：platform.x509.pem和platform.pk8</p>
<p>此时就可以使用**out/host/linux-x86/framework/**目录下的signapk.jar包来对apk进行签名了</p>
<h4 id="2-3-生成signapk-jar"><a href="#2-3-生成signapk-jar" class="headerlink" title="2.3 生成signapk.jar"></a>2.3 生成signapk.jar</h4><ul>
<li>在源码根目录使用<strong>source build/envsetup.sh</strong>创建指令环境</li>
<li>进入/build/tools/signapk/目录</li>
<li>执行指令：mm</li>
<li>在out/host/linux-x86/framework/目录找到signapk.jar</li>
</ul>
<h4 id="2-4-生成DM-verity的verity-key"><a href="#2-4-生成DM-verity的verity-key" class="headerlink" title="2.4 生成DM-verity的verity key"></a>2.4 生成DM-verity的verity key</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">choosecombo</span><br><span class="line">make generate_verity_key (mmm system/extras/verity/)</span><br></pre></td></tr></table></figure>
<p>generate_verity_key是将 *.x509.pem 转换成 verity key</p>
<p>generate_verity_key 的代码位于：system/extra/verity/generate_verity_key.c</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">out/host/linux-x86/bin/generate_verity_key -convert mykey.x509.pem verity_key</span><br></pre></td></tr></table></figure>
<p>拷贝mykey.pk8，mykey.x509.pem，verity_key.pub 至 <code>build/target/product/security/</code> 目录，将其重命名: verity.pk8， verity.x509.pem，verity_key ，并替换默认的开发 key。</p>
<h3 id="3-对apk进行签名"><a href="#3-对apk进行签名" class="headerlink" title="3.对apk进行签名"></a>3.对apk进行签名</h3><h4 id="3-1-使用指令签名"><a href="#3-1-使用指令签名" class="headerlink" title="3.1 使用指令签名"></a>3.1 使用指令签名</h4><p>如果使用原生的证书，目录在**/build/target/product/security/**中可以找到platform.pk8 platform.x509.pem文件，如果有我们上面生成的也可以。</p>
<p>将要打包的apk、证书和signapk.jar放到一个目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar signapk.jar  platform.x509.pem platform.pk8　old.apk new.apk</span><br></pre></td></tr></table></figure>


<h4 id="3-2-使用Android-Studio签名"><a href="#3-2-使用Android-Studio签名" class="headerlink" title="3.2 使用Android Studio签名"></a>3.2 使用Android Studio签名</h4><p>要使用Android Studio对应用自动签名，需要生成.jks的证书，该二进制格式的证书，同时包含证书和私钥，一般有密码保护。</p>
<p><strong>如果是没有密码的pem格式的证书生成.jks文件方式如下：</strong></p>
<ul>
<li>生成platform.pem文件<br>openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out platform.pem</li>
<li>生成platform.p12文件，设置别名和密码，即AS打包APK时输入的别名和密码<br>openssl pkcs12 -export -in platform.x509.pem -out platform.p12 -inkey platform.pem -password pass:android -name key</li>
<li>生成platform.jks(钥匙文件) （-srcstorepass android）是.jks文件的密码<br>keytool -importkeystore -deststorepass android -destkeystore ./platform.jks -srckeystore ./platform.p12 -srcstoretype PKCS12 -srcstorepass android</li>
</ul>
<p><strong>有密码的pem格式的证书生成.jks文件的方式：</strong></p>
<p>假如密码是：c6a04bdc7236f5d18c75840f50dee482b36ad4cc</p>
<ul>
<li><p>生成platform.pem文件</p>
<p>openssl pkcs8 -inform DER -passin pass:c6a04bdc7236f5d18c75840f50dee482b36ad4cc -in platform.pk8 -out platform.pem</p>
</li>
<li><p>生成platform.p12文件，设置别名和密码，即AS打包APK时输入的别名和密码</p>
<p>openssl pkcs12 -export -in platform.x509.pem -out platform.p12 -inkey platform.pem -password pass:android -name key</p>
</li>
<li><p>生成platform.jks(钥匙文件) （-srcstorepass android）是.jks文件的密码</p>
<p>keytool -importkeystore -deststorepass android -destkeystore ./platform.jks -srckeystore ./platform.p12 -srcstoretype PKCS12 -srcstorepass android</p>
</li>
</ul>
<p>生成.jks文件之后，导入as中，编译工程的时候，选择<strong>Generate Signed Bundle or APK</strong>按照上面生成输入的昵称和密码一直下一步就可以完成工程签名了。</p>
<h3 id="4-验证是否签名成功"><a href="#4-验证是否签名成功" class="headerlink" title="4.验证是否签名成功"></a>4.验证是否签名成功</h3><ul>
<li>将apk直接用zip等解压工具直接解压到本地目录</li>
<li>进入到<strong>META-INF</strong>目录找到：CERT.RSA文件</li>
<li>在<strong>META-INF</strong>目录打开控制台输入：keytool -printcert -file CERT.RSA    即可看到签名文件的输出</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2479c61c2e762bd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="签名文件内容.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>签名文件</tag>
      </tags>
  </entry>
  <entry>
    <title>算法包</title>
    <url>/2021/06/14/%E7%AE%97%E6%B3%95%E5%8C%85/</url>
    <content><![CDATA[<h4 id="1-函数适配器-bind2nd"><a href="#1-函数适配器-bind2nd" class="headerlink" title="1. 函数适配器(bind2nd)"></a>1. 函数适配器(bind2nd)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;算法包&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>, less&lt;<span class="built_in">string</span>&gt;&gt; setVar;</span><br><span class="line">    setVar.insert(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    setVar.insert(<span class="string">&quot;BBBB&quot;</span>);</span><br><span class="line">    setVar.insert(<span class="string">&quot;CCCC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator iteratorVar = setVar.begin(); iteratorVar != setVar.end() ; iteratorVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iteratorVar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find_if</span></span><br><span class="line">    <span class="comment">// equal_to 比较用的</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>, less&lt;<span class="built_in">string</span>&gt;&gt;::iterator iteratorResult =</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解决尴尬的问题  equal_to 需要比较的 内容没有 使用 函数适配器 解决</span></span><br><span class="line">            <span class="comment">// 现在的问题是： 没有办法把 CCCC 传递给 const _Tp&amp; __y，就没法去比较</span></span><br><span class="line">            <span class="comment">// find_if(setVar.begin(), setVar.end(), equal_to&lt;string&gt;(&quot;CCCC&quot;), &quot;CCCC&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// bind2nd作用是讲第二个参数注入func的第二个参数。</span></span><br><span class="line">            <span class="comment">// 使用函数适配器后，就能够 CCCC 传递给了  const _Tp&amp; __y，</span></span><br><span class="line">            <span class="comment">// setVar.begin(), setVar.end() 会把这些元素取出来 const _Tp&amp; __x</span></span><br><span class="line">            <span class="comment">// x == y 的比较</span></span><br><span class="line">            find_if(setVar.begin(), setVar.end(), bind2nd(equal_to&lt;<span class="built_in">string</span>&gt;(), <span class="string">&quot;CCCC&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iteratorResult != setVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有查找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>


<h4 id="2-for-each遍历"><a href="#2-for-each遍历" class="headerlink" title="2. for_each遍历"></a>2. for_each遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">F</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;自定义一元谓词:&quot;</span> &lt;&lt; __first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">50000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">    for_each(vectorVar.begin(), vectorVar.end(), __F());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-transform变换操作符"><a href="#3-transform变换操作符" class="headerlink" title="3. transform变换操作符"></a>3. transform变换操作符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">unary_op</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __first + <span class="number">9</span>; <span class="comment">// 修改每个元素 +9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种方式  类似于 RxJava map 变化操作符  【不看API，直接看算法包源码 印象非常深刻的】</span></span><br><span class="line">    <span class="comment">// 迭代器 result == 参数三</span></span><br><span class="line">    transform(vectorVar.begin(), vectorVar.end(), vectorVar.begin(), __unary_op());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vectorVar.begin(); it != vectorVar.end() ; it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一种方式:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三个参数接收返回值有啥用？没感受出来</span></span><br><span class="line">    <span class="comment">// ==================================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种方式</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVarResult; <span class="comment">// vectorVarResult 大小空间</span></span><br><span class="line">    vectorVarResult.resize(vectorVar.size());</span><br><span class="line">    transform(vectorVar.begin(), vectorVar.end(), vectorVarResult.begin(), __unary_op());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vectorVarResult.begin(); it != vectorVarResult.end() ; it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二种方式:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-查找函数"><a href="#4-查找函数" class="headerlink" title="4.查找函数"></a>4.查找函数</h4><h5 id="4-1-find函数"><a href="#4-1-find函数" class="headerlink" title="4.1 find函数"></a>4.1 find函数</h5><p>find函数直接接受需要查找的内容，不接收仿函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find 没有自定义仿函数</span></span><br><span class="line">    <span class="keyword">auto</span> iteratorVar = find(vectorVar.begin(), vectorVar.end(), <span class="number">40000</span>);</span><br><span class="line">    <span class="keyword">if</span> (iteratorVar != vectorVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    find(_InputIterator __first,  开始位置 迭代器</span></span><br><span class="line"><span class="comment">     _InputIterator __last, 结束位置 迭代器</span></span><br><span class="line"><span class="comment">         const _Tp&amp; __val) 需要查找的元素 40000</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ....</span></span><br><span class="line"><span class="comment">        结论：对__find_if的封装而已</span></span><br><span class="line"><span class="comment">        return std::__find_if(__first, __last,</span></span><br><span class="line"><span class="comment">                              __gnu_cxx::__ops::__iter_equals_val(__val));</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-find-if函数"><a href="#4-2-find-if函数" class="headerlink" title="4.2 find_if函数"></a>4.2 find_if函数</h5><p>find_if函数可以接收一个仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">pred</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    __pred(<span class="keyword">int</span> number) : number(number) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number == value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">10000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">20000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">30000</span>);</span><br><span class="line">    vectorVar.insert(vectorVar.begin(), <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = find_if(vectorVar.begin(), vectorVar.end(), __pred(<span class="number">30000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vectorVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  知道怎么阅读算法包源码 1</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    find_if(_InputIterator __first,  开始位置 迭代器</span></span><br><span class="line"><span class="comment">      _InputIterator __last, 结束位置 迭代器</span></span><br><span class="line"><span class="comment">	    _Predicate __pred)  自定义仿函数</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">     ... 监测工作而已</span></span><br><span class="line"><span class="comment">      return std::__find_if(__first, __last,</span></span><br><span class="line"><span class="comment">			    __gnu_cxx::__ops::__pred_iter(__pred));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    __find_if(_InputIterator __first, 开始位置 迭代器</span></span><br><span class="line"><span class="comment">           _InputIterator __last, 结束位置 迭代器</span></span><br><span class="line"><span class="comment">	      _Predicate __pred,   TODO 自定义仿函数</span></span><br><span class="line"><span class="comment">	      ....)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      while (__first != __last &amp;&amp; !__pred(__first)) //  __pred(__first)  自定义仿函数 怎么写  返回值bool 传入int类型</span></span><br><span class="line"><span class="comment">		++__first;  // 迭代器从开始位置挪动     算法思路： 指针++</span></span><br><span class="line"><span class="comment">      return __first;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-统计元素个数"><a href="#5-统计元素个数" class="headerlink" title="5. 统计元素个数"></a>5. 统计元素个数</h4><h5 id="5-1-count函数和count-if函数"><a href="#5-1-count函数和count-if函数" class="headerlink" title="5.1 count函数和count_if函数"></a>5.1 count函数和count_if函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count 没有自定义仿函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.push_back(<span class="number">1</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">2</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">3</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">2</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">4</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">6</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">8</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number = count(vectorVar.begin(), vectorVar.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;等于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++ 源码 函数适配器</span></span><br><span class="line">    number = count_if(vectorVar.begin(), vectorVar.end(), bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)); <span class="comment">// 函数适配器 配合 less   &lt;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    number = count_if(vectorVar.begin(), vectorVar.end(), bind2nd(greater&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)); <span class="comment">// 函数适配器 配合 less &gt;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    number = count_if(vectorVar.begin(), vectorVar.end(), bind2nd(equal_to&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>)); <span class="comment">// 函数适配器 配合 less =</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;等于2的个数是:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count_if 源码分析...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    count_if(_InputIterator __first,   迭代器 开始位置</span></span><br><span class="line"><span class="comment">      _InputIterator __last,  迭代器 结束位置</span></span><br><span class="line"><span class="comment">      _Predicate __pred) 自定义仿函数  __pred在源码里面可以知道 我们去写自定义仿函数的规则</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">       .... 省略  监测工作而已</span></span><br><span class="line"><span class="comment">      return std::__count_if(__first, __last,</span></span><br><span class="line"><span class="comment">			     __gnu_cxx::__ops::__pred_iter(__pred));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">    __count_if(_InputIterator __first,</span></span><br><span class="line"><span class="comment">     _InputIterator __last,</span></span><br><span class="line"><span class="comment">     _Predicate __pred)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      typename iterator_traits&lt;_InputIterator&gt;::difference_type __n = 0;  int __n</span></span><br><span class="line"><span class="comment">      for (; __first != __last; ++__first)  思路：迭代器 ++ 挪动位置</span></span><br><span class="line"><span class="comment">	    if (__pred(__first))  自定义仿函数  返回bool类型   ？？？ 迭代器类型</span></span><br><span class="line"><span class="comment">	    ++__n;</span></span><br><span class="line"><span class="comment">        return __n; // 最终 count_if 是返回int类型   __n  ++后的  统计元素的个数</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-合并函数-merge"><a href="#6-合并函数-merge" class="headerlink" title="6. 合并函数(merge)"></a>6. 合并函数(merge)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar1;</span><br><span class="line">    vectorVar1.push_back(<span class="number">10</span>);</span><br><span class="line">    vectorVar1.push_back(<span class="number">20</span>);</span><br><span class="line">    vectorVar1.push_back(<span class="number">30</span>);</span><br><span class="line">    vectorVar1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar2;</span><br><span class="line">    vectorVar2.push_back(<span class="number">50</span>);</span><br><span class="line">    vectorVar2.push_back(<span class="number">60</span>);</span><br><span class="line">    vectorVar2.push_back(<span class="number">70</span>);</span><br><span class="line">    vectorVar2.push_back(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并成一个容器 result</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorResult;</span><br><span class="line">    vectorResult.resize(vectorVar1.size() + vectorVar2.size());</span><br><span class="line"></span><br><span class="line">    merge(vectorVar1.begin(), vectorVar1.end(), vectorVar2.begin(), vectorVar2.end(), vectorResult.begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorResult.begin(); itVar != vectorResult.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    merge(_InputIterator1 __first1, _InputIterator1 __last1,  第一个容器 位置</span></span><br><span class="line"><span class="comment">	  _InputIterator2 __first2, _InputIterator2 __last2,  第二个容器 位置</span></span><br><span class="line"><span class="comment">	  _OutputIterator __result) 最终合并后的结果</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      .... 监测工作而已</span></span><br><span class="line"><span class="comment">      return _GLIBCXX_STD_A::__merge(__first1, __last1,</span></span><br><span class="line"><span class="comment">				     __first2, __last2, __result,</span></span><br><span class="line"><span class="comment">				     __gnu_cxx::__ops::__iter_less_iter());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    template&lt;typename _InputIterator1, typename _InputIterator2,</span></span><br><span class="line"><span class="comment">	   typename _OutputIterator, typename _Compare&gt;</span></span><br><span class="line"><span class="comment">    _GLIBCXX20_CONSTEXPR</span></span><br><span class="line"><span class="comment">    _OutputIterator</span></span><br><span class="line"><span class="comment">    __merge(_InputIterator1 __first1, _InputIterator1 __last1, 第一个容器 位置</span></span><br><span class="line"><span class="comment">	    _InputIterator2 __first2, _InputIterator2 __last2, 第二个容器 位置</span></span><br><span class="line"><span class="comment">	    _OutputIterator __result, 最终合并后的结果</span></span><br><span class="line"><span class="comment">       _Compare __comp)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      while (__first1 != __last1 &amp;&amp; __first2 != __last2)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      做 合并 算法处理工作</span></span><br><span class="line"><span class="comment">	  if (__comp(__first2, __first1))</span></span><br><span class="line"><span class="comment">	    &#123;</span></span><br><span class="line"><span class="comment">	      *__result = *__first2;</span></span><br><span class="line"><span class="comment">	      ++__first2;</span></span><br><span class="line"><span class="comment">	    &#125;</span></span><br><span class="line"><span class="comment">	  else</span></span><br><span class="line"><span class="comment">	    &#123;</span></span><br><span class="line"><span class="comment">	      *__result = *__first1;</span></span><br><span class="line"><span class="comment">	      ++__first1;</span></span><br><span class="line"><span class="comment">	    &#125;</span></span><br><span class="line"><span class="comment">	  ++__result;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      // 拷贝剩余数组1的值然后拷贝数组2的值</span></span><br><span class="line"><span class="comment">      return std::copy(__first2, __last2,</span></span><br><span class="line"><span class="comment">		       std::copy(__first1, __last1, __result));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-对容器进行排序"><a href="#7-对容器进行排序" class="headerlink" title="7. 对容器进行排序"></a>7. 对容器进行排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar;</span><br><span class="line">    vectorVar.push_back(<span class="number">10</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">30</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (__comp(__i, __first)) 自定义仿函数规则  返回值 bool     第一个参数int    第二个参数 是int 吗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内置 的 仿函数 less&lt;int&gt;()</span></span><br><span class="line">    <span class="comment">// less&lt;int&gt;() 里面泛型==函数模版  没法确定好 第二个参数的类型【到底是什么类型？】</span></span><br><span class="line"></span><br><span class="line">     sort(vectorVar.begin(), vectorVar.end(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="comment">//    sort(vectorVar.begin(), vectorVar.end(), greater&lt;int&gt;());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorVar.begin(); itVar != vectorVar.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-对容器元素进行打乱"><a href="#8-对容器元素进行打乱" class="headerlink" title="8. 对容器元素进行打乱"></a>8. 对容器元素进行打乱</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar; <span class="comment">// vector默认是没有排序功能的，默认输出： 65 53 84</span></span><br><span class="line">    vectorVar.push_back(<span class="number">65</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">53</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">84</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">11</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">22</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">33</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sort(vectorVar.begin(), vectorVar.end(), less&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 排序后 53 65 82</span></span><br><span class="line"></span><br><span class="line">    random_shuffle(vectorVar.begin(), vectorVar.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorVar.begin(); itVar != vectorVar.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        <span class="comment">// 84	65	53</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="9-复制"><a href="#9-复制" class="headerlink" title="9. 复制"></a>9. 复制</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar; <span class="comment">// vector默认是没有排序功能的，默认输出： 65 53 84</span></span><br><span class="line">    vectorVar.push_back(<span class="number">100</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">200</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">300</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">400</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">500</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">600</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorResult;</span><br><span class="line">    vectorResult.resize(vectorVar.size());</span><br><span class="line"></span><br><span class="line">    copy(vectorVar.begin(), vectorVar.end(), vectorResult.begin());</span><br><span class="line">    <span class="comment">// 100	200	300	400	500	600	700</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorResult.begin(); itVar != vectorResult.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="10-替换"><a href="#10-替换" class="headerlink" title="10. 替换"></a>10. 替换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // stl包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    ::age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vectorVar; <span class="comment">// vector默认是没有排序功能的，默认输出： 65 53 84</span></span><br><span class="line">    vectorVar.push_back(<span class="number">100</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">200</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">300</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">400</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">500</span>);</span><br><span class="line">    vectorVar.push_back(<span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 100 ~ 200 范围</span></span><br><span class="line">    <span class="comment">// replace(vectorVar.begin(), vectorVar.begin() + 2, 200, 222);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有范围</span></span><br><span class="line">    replace(vectorVar.begin(), vectorVar.end(), <span class="number">300</span>, <span class="number">333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接打印 vectorVar容器  此时 是不是就已经排序了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itVar = vectorVar.begin(); itVar != vectorVar.end() ; itVar++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *itVar &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络能力理解(NetworkCapabilities)</title>
    <url>/2021/04/06/%E7%BD%91%E7%BB%9C%E8%83%BD%E5%8A%9B%E7%90%86%E8%A7%A3-NetworkCapabilities/</url>
    <content><![CDATA[<p>声明: 以下枚举值基于Android Api 30</p>
<p>NetworkCapabilities这个类取代了旧版的TYPE_MOBILE网络选择，当一个更快没有风险的网络出现，且一个应用需要这个网络时，就切换到该网络，而不是继续连接WIFI；类似的，当一个应用需要批量上传文件，需要不计量网络的时候，应该切换到wifi传输。</p>
<h3 id="1-网络能力枚举"><a href="#1-网络能力枚举" class="headerlink" title="1.网络能力枚举"></a>1.网络能力枚举</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该网络能连接到运营商MMSC服务器，可以用来接收和发送彩信</span></span><br><span class="line">NET_CAPABILITY_MMS = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商SUPL服务器，用户可以接收到GPS信息</span></span><br><span class="line">NET_CAPABILITY_SUPL = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的DUN服务器或者以太网网关</span></span><br><span class="line">NET_CAPABILITY_DUN = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的FOTA服务器，专门用于OTA升级</span></span><br><span class="line">NET_CAPABILITY_FOTA = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的IMS服务器，用于网络注册和信令</span></span><br><span class="line">NET_CAPABILITY_IMS = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的CBS服务器，用于运营商特定的服务</span></span><br><span class="line">NET_CAPABILITY_CBS = <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能到达WIFI直连</span></span><br><span class="line">NET_CAPABILITY_WIFI_P2P = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该网络能连接到运营商的初始连接服务器</span></span><br><span class="line">NET_CAPABILITY_IA = <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够连接运营商的RCS服务器的网络，用于富通信服务。</span></span><br><span class="line">NET_CAPABILITY_RCS = <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够连接到运营商的XCAP服务器的网络，用于配置和控制。</span></span><br><span class="line">NET_CAPABILITY_XCAP = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够到达运营商的紧急IMS服务器或其他服务的网络，用于紧急呼叫期间的网络信令。</span></span><br><span class="line">NET_CAPABILITY_EIMS = <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络未定义</span></span><br><span class="line">NET_CAPABILITY_NOT_METERED = <span class="number">11</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络应能够访问互联网。</span></span><br><span class="line">NET_CAPABILITY_INTERNET = <span class="number">12</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络可用于一般用途</span></span><br><span class="line">NET_CAPABILITY_NOT_RESTRICTED = <span class="number">13</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示用户已指示此网络的隐式信任</span></span><br><span class="line">NET_CAPABILITY_TRUSTED = <span class="number">14</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络不是VPN</span></span><br><span class="line">NET_CAPABILITY_NOT_VPN = <span class="number">15</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示此网络上的连接已成功验证</span></span><br><span class="line">NET_CAPABILITY_VALIDATED = <span class="number">16</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络在上次探测时被发现有一个强制门户</span></span><br><span class="line">NET_CAPABILITY_CAPTIVE_PORTAL = <span class="number">17</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络不是漫游，Android 10新加</span></span><br><span class="line">NET_CAPABILITY_NOT_ROAMING = <span class="number">18</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此网络可供应用程序使用，而不是后台网络，以便于快速网络切换的网络</span></span><br><span class="line">NET_CAPABILITY_FOREGROUND = <span class="number">19</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络不是拥堵的。如果网络处于拥堵状态，应用应该将请求网络的行为延后一段时间，例如上报采集信息。</span></span><br><span class="line">NET_CAPABILITY_NOT_CONGESTED = <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络当前没有挂起。</span></span><br><span class="line"><span class="comment">// 网络被挂起:IP地址和链接都是有效的，但是暂时不能传数据，例如进入隧道，蜂窝网络暂时进入暂时丢失状态。这种网络不会被挂起，仍然可以传输数据。</span></span><br><span class="line">NET_CAPABILITY_NOT_SUSPENDED = <span class="number">21</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示通过此网络的流量由oem支付。例如，这个网络可以被系统应用程序用来上传遥测数据。</span></span><br><span class="line">NET_CAPABILITY_OEM_PAID = <span class="number">22</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示这是一个能够访问运营商的关键任务服务器的网络。</span></span><br><span class="line">NET_CAPABILITY_MCX = <span class="number">23</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示该网络用于测试，仅仅提供部分连接功能</span></span><br><span class="line">NET_CAPABILITY_PARTIAL_CONNECTIVITY = <span class="number">24</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此功能将为通常已计量但当前未计量的网络设置，例如，因为用户位于特定区域。此功能可以随时更改。当它被删除时，应用程序负责停止任何不应该在按流量计费的网络上发生的数据传输。</span></span><br><span class="line">NET_CAPABILITY_TEMPORARILY_NOT_METERED = <span class="number">25</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-网络传输类型"><a href="#2-网络传输类型" class="headerlink" title="2.网络传输类型"></a>2.网络传输类型</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 表示该网络使用蜂窝流量传输</span><br><span class="line">TRANSPORT_CELLULAR &#x3D; 0,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用wifi传输</span><br><span class="line">TRANSPORT_WIFI &#x3D; 1,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用蓝牙传输</span><br><span class="line">TRANSPORT_BLUETOOTH &#x3D; 2,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用以太网传输</span><br><span class="line">TRANSPORT_ETHERNET &#x3D; 3,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用VPN传输</span><br><span class="line">TRANSPORT_VPN &#x3D; 4,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用WIFI-AWARE传输</span><br><span class="line">TRANSPORT_WIFI_AWARE &#x3D; 5,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该网络使用LoWPAN传输</span><br><span class="line">TRANSPORT_LOWPAN &#x3D; 6,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试虚拟网络接口</span><br><span class="line">TRANSPORT_TEST &#x3D; 7,</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-Apn参数组成"><a href="#3-Apn参数组成" class="headerlink" title="3.Apn参数组成"></a>3.Apn参数组成</h3><p>例：移动apn，把所有的属性都放在一起如下</p>
<p>apn carrier=”中国移动彩信 (China Mobile)”<br>mcc=”460”<br>mnc=”00”<br>apn=”cmwap”<br>proxy=”10.0.0.172”<br>port=”80”<br>mmsc=”<a href="http://mmsc.monternet.com”/">http://mmsc.monternet.com”</a><br>mmsproxy=”10.0.0.172”<br>mmsport=”80”<br>user=”mms”<br>password=”mms”<br>type=”mms”<br>authtype=”1”<br>protocol=”IPV4V6” </p>
<p><strong>其对应的属性定义如下：</strong></p>
<p>Carrier：apn的名字，可为空，只用来显示apn列表中此apn的显示名字。<br>Mcc：由三位数组成。 用于识别移动用户的所在国家;<br>Mnc：由两位或三位组成。 用于识别移动用户的归属PLMN。 MNC的长度（两位或三位数）取决于MCC的值。<br>Apn：APN网络标识（接入点名称），是APN参数中的必选组成部分。此标识由运营商分配。<br>Proxy：代理服务器的地址<br>Port：代理服务器的端口号<br>Mmsc：MMS中继服务器/多媒体消息业务中心，是彩信的交换服务器。<br>Mmsproxy：彩信代理服务器的地址<br>Mmsport：彩信代理服务器的端口号<br>Protocol：支持的协议，不配置默认为IPV4。<br>User：用户<br>Password：密码<br>Authtype：apn的认证协议，PAP为口令认证协议，是二次握手机制。CHAP是质询握手认证协议，是三次握手机制。</p>
<table>
<thead>
<tr>
<th>None</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>PAP</td>
<td>1</td>
</tr>
<tr>
<td>CHAP</td>
<td>2</td>
</tr>
<tr>
<td>PAP or CHAP</td>
<td>3</td>
</tr>
</tbody></table>
<p>Type: apn的接入点类型</p>
<table>
<thead>
<tr>
<th>Default</th>
<th>默认网络连接</th>
</tr>
</thead>
<tbody><tr>
<td>Mms</td>
<td>彩信专用连接，此连接与default类似，用于与载体的多媒体信息服务器对话的应用程序</td>
</tr>
<tr>
<td>Supl</td>
<td>是Secure User Plane Location“安全用户面定位”的简写，此连接与default类似，用于帮助定位设备与载体的安全用户面定位服务器对话的应用程序</td>
</tr>
<tr>
<td>Dun</td>
<td>Dial Up Networking拨号网络的简称，此连接与default连接类似，用于执行一个拨号网络网桥，使载体能知道拨号网络流量的应用程序</td>
</tr>
<tr>
<td>Hipri</td>
<td>高优先级网络，与default类似，但路由设置不同。只有当进程访问移动DNS服务器，并明确要求使用requestRouteToHost(int, int)才会使用此连接</td>
</tr>
</tbody></table>
<p>注意：此表中的数据连接优先级是由低到高，即default数据连接的优先级最低，而hipri数据连接的优先级最高。比如：手机上网聊天，建立的是default数据连接。如果此时接到一条彩信，由于彩信的数据连接是mms，优先级比default高，所以会先断开default数据连接，建立mms数据连接，让手机先收到彩信。所以收发彩信的同时不能上网。（单条pdp连接的情况）</p>
<p>注：mnc的位数由mcc决定。比如，墨西哥334020，此国家的mnc为020，mccmnc的值都固定在了SIM卡保存的IMSI中，配置apn参数时mnc不可简洁为20，否则apn列表中将读取不到此国家的334020运营商的参数。</p>
<h3 id="4-原生网络方案"><a href="#4-原生网络方案" class="headerlink" title="4.原生网络方案"></a>4.原生网络方案</h3><p><a href="https://blog.csdn.net/sjz4860402/article/details/78522001">UICC框架初识</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78524091">AsyncChannel的工作机制</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78531626">StateMachine状态机初识</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78532856">ConnectivityService框架初识</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/78613015">路由配置信息的获取</a></p>
<p><a href="https://blog.csdn.net/sjz4860402/article/details/79836065">ServiceStateTracker网络状态的处理</a></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>网络能力</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装Unbuntu 16.04</title>
    <url>/2021/02/09/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Unbuntu-16-04/</url>
    <content><![CDATA[<h3 id="1-准备Ubuntu虚拟机"><a href="#1-准备Ubuntu虚拟机" class="headerlink" title="1.准备Ubuntu虚拟机"></a>1.准备Ubuntu虚拟机</h3><p>因为我准备编译Android P的源码，所以至少需要安装16.04版本，如果编译Android M的源码，可以安装14.04的。这个就不多介绍了，直接上Ubuntu链接(墙裂不建议在官网下，没墙出去，贼慢！)，各位看哪个信源快自己选择吧。</p>
<blockquote>
<p>官方下载地址（不推荐）<br><a href="https://www.ubuntu.com/download">https://www.ubuntu.com/download</a><br>中科大源<br><a href="http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/">http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/</a><br>阿里云开源镜像站<br><a href="http://mirrors.aliyun.com/ubuntu-releases/16.04/">http://mirrors.aliyun.com/ubuntu-releases/16.04/</a><br>北京理工大学开源<br><a href="http://mirror.bit.edu.cn/ubuntu-releases/16.04/">http://mirror.bit.edu.cn/ubuntu-releases/16.04/</a><br>浙江大学<br><a href="http://mirrors.zju.edu.cn/ubuntu-releases/16.04/">http://mirrors.zju.edu.cn/ubuntu-releases/16.04/</a></p>
</blockquote>
<h3 id="2-安装Ubuntu虚拟机"><a href="#2-安装Ubuntu虚拟机" class="headerlink" title="2.安装Ubuntu虚拟机"></a>2.安装Ubuntu虚拟机</h3><p><strong>2.1 点击文件 -&gt; 新建虚拟机</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5492dbb603f35746.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建虚拟机.png"></p>
<p><strong>2.2 选择“自定义(高级)”，然后选择虚拟机兼容设置，直接选择“下一步”</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-da112db8fe01e15d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚拟机向导.png"></p>
<p><strong>2.3 选择“安装程序光盘映像文件(iso)”，然后找到第一小节下载的Ubuntu镜像文件</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b7520ad539733544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择镜像安装.png"></p>
<p><strong>2.4 填写ubuntu基本信息</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-88f7d06104bd89d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本信息填写.png"></p>
<p><strong>2.5 给虚拟机取个名字，和选择虚拟机存放的位置</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-12ec53f348ae0b23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命名并选择存放的位置.png"></p>
<p><strong>2.6 给虚拟机分配处理器和内核数</strong></p>
<ul>
<li><p>处理器数量表示有几个处理器；</p>
</li>
<li><p>总处理器核心数 = 处理器数量 * 每个处理器的核心数；</p>
</li>
<li><p>线程数可以右键“电脑”属性查看。</p>
<p>这个看自己需求来定，如果主要在虚拟机办公了，那就多分配几个内核数来处理虚拟机的事务，如果主要在window下办公，就处理器申请1，内核数分配2-3就差不多。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4e69bb67deaddcaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="给虚拟机分配处理器和内核数.png"></p>
<p><strong>2.7 分配虚拟机内存</strong></p>
<p>还是看需求定，分配多了window会卡一点，分配少了虚拟机会卡。不经常不用虚拟机就分配1G就行，我要编系统，分配4G。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-23251e953d397f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配虚拟机内存.png"></p>
<p><strong>2.8 后面的网络类型、I/O控制器、创建磁盘、使用磁盘以及磁盘大小直接选择的默认选项。</strong></p>
<p>关于磁盘分配，因为Android原生代码特别大，我建议分配100G，小了后面要扩展，很麻烦。现在分配100G也不是真实用到的100G，只是最大100G。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-a1723ce659171fac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配磁盘.png"></p>
<p><strong>2.9 确认配置，就创建好虚拟机了。</strong></p>
<p>最后就等系统自动安装就行了，等待的时间有点久，至少20多分钟吧，慢慢等就行。最后出现登录界面，登录进图就大功告成了，后面可以安装一些工具。<br><img src="https://upload-images.jianshu.io/upload_images/13838098-cb5a4470319a1da1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确认配置.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e9ce4a244c9f942f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录界面.png"></p>
<h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><p><img src="/2021/02/09/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Unbuntu-16-04/blog\source_posts\虚拟机安装Unbuntu-16-04\无法打开配置文件.png" alt="无法打开配置文件"></p>
<p>解决办法：直接以管理员身份运行虚拟机即可</p>
<p>![Intel VT-x被禁用](G:\blog\source_posts\虚拟机安装Unbuntu-16-04\Intel VT-x被禁用.png)</p>
<p>解决办法：在bios中使能Intel Virtualization Technology开关即可</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>VmWare</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo引入图床，手机和web不显示图片的问题</title>
    <url>/2021/03/23/%E8%A7%A3%E5%86%B3hexo%E5%BC%95%E5%85%A5%E5%9B%BE%E5%BA%8A%EF%BC%8C%E6%89%8B%E6%9C%BA%E5%92%8Cweb%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>hexo引入图片的方式有很多种：</p>
<ul>
<li>从本地文件加载，方法参见参考文献一。</li>
<li>使用图床，markdown中直接引用图床的链接。</li>
</ul>
<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>Hexo使用图床的方式加载在blog中加载图片，会在非本人的电脑或者手机端报“html访问图片资源403问题(http referrer)”，导致采用图床方式加载的图片全部无法加载。</p>
<h3 id="2-问题原因"><a href="#2-问题原因" class="headerlink" title="2.问题原因"></a>2.问题原因</h3><p>http请求体的header中有一个referrer字段，用来表示发起http请求的源地址信息，这个referrer信息是可以省略但是不可修改的，就是说你只能设置是否带上这个referrer信息，不能定制referrer里面的值。</p>
<p>服务器端在拿到这个referrer值后就可以进行相关的处理，比如图片资源，可以通过referrer值判断请求是否来自本站，若不是则返回403或者重定向返回其他信息，从而实现图片的防盗链。上面出现403就是因为，请求的是别人服务器上的资源，但把自己的referrer信息带过去了，被对方服务器拦截返回了403。</p>
<p>在前端可以通过meta来设置referrer policy(来源策略)，具体可以设置哪些值以及对应的结果参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy">这里</a>。所以针对上面的403情况的解决方法，就是把referrer设置成<code>no-referrer</code>，这样发送请求不会带上referrer信息，对方服务器也就无法拦截了。</p>
<p>浏览器中referrer默认的值是<code>no-referrer-when-downgrade</code>，就是除了降级请求的情况以外都会带上referrer信息。降级请求是指https协议的地址去请求http协议，所以上面403的情况还有另一种解决方法就是，请求的图片地址换成http协议，自己的地址使用http协议，这样降级请求也不会带上referrer。</p>
<h3 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h3><h4 id="3-1-butterfly主题"><a href="#3-1-butterfly主题" class="headerlink" title="3.1 butterfly主题"></a>3.1 butterfly主题</h4><p>在G:\blog\themes\butterfly\layout\includes目录下有一个head.pug文件，修改该文件的meta信息，会使生成的所有页面都带有该head。在head.pug文件中添加如下内容，结果参见图片。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">meta(name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1b07689b2e132b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="butterfly添加头.png"></p>
<h4 id="3-2-yilia主题"><a href="#3-2-yilia主题" class="headerlink" title="3.2 yilia主题"></a>3.2 yilia主题</h4><p>在G:\blog\themes\yilia\layout_partial目录下有一个head.ejs，同样在head.ejs文件中添加如下meta信息即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>


<h3 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用hexo g 重新生成一下工程</span><br></pre></td></tr></table></figure>
<p>在G:\blog\public\2021目录下就是所有21年生成的blog，找到该目录下的任意一个index.html，用文本编辑器打开就可以看到已经自动生成了referrer标签了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-56e5002b6d7d74d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成的html中包含有referrer头.png"></p>
<p>然后使用hexo d指令将工程同步到github即可</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://blog.csdn.net/qq_38148394/article/details/79997971">1. 加载本地图片的方法</a></p>
<p><a href="https://www.jianshu.com/p/56df73d0d128">2. html访问图片资源403问题(http referrer)</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ndk工具编译so库问题</title>
    <url>/2021/04/02/%E8%A7%A3%E5%86%B3ndk%E5%B7%A5%E5%85%B7%E7%BC%96%E8%AF%91so%E5%BA%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>使用ndk-build编译so库的时候，控制台会报</p>
<blockquote>
<p>Android NDK: Could not find application project directory !<br>Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.<br>F:\Sdk\ndk-bundle\build\..\build\core\build-local.mk:151: *** Android NDK: Aborting    .  Stop.</p>
</blockquote>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>见文献1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//在&lt;工程path&gt;/app目录</span><br><span class="line">// your_project_path是jni的目录，注意，目录一定要是jni,在AS中自动存放cpp文件的是cpp目录，需要改成jni才可以编译。</span><br><span class="line">ndk-build -C your_project_path</span><br></pre></td></tr></table></figure>


<h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote>
<p>Android NDK: WARNING: APP_PLATFORM android-16 is higher than android:minSdkVersion 1 in G:/android_project/PlatformService_X5R/app/src/main/AndroidManifest.xml. NDK binaries will <em>not</em> be compatible with devices older than android-1.6<br>See <a href="https://android.googlesource.com/platform/ndk/+/master/docs/user/common_problems.md">https://android.googlesource.com/platform/ndk/+/master/docs/user/common_problems.md</a> for more information.</p>
</blockquote>
<h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>在Application.mk文件中加</p>
<blockquote>
<p>APP_PLATFORM := android-16</p>
</blockquote>
<p><strong>参考文献</strong></p>
<p><a href="https://stackoverflow.com/questions/14156596/ndk-cant-find-the-application-directory">解决：Could not find application project directory</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>解决编译系统时报:ckati failed with: signal: killed</title>
    <url>/2021/04/28/%E8%A7%A3%E5%86%B3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E6%97%B6%E6%8A%A5-ckati-failed-with-signal-killed/</url>
    <content><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>刚把1804虚拟机搭建起来，然后迫不及待的把Android Q代码编译起来，结果每次在编译一两分钟之后就把如下错误，也不报具体源码哪里有问题，搞的脑子着实大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vendor/qcom/build/tasks/generate_extra_images.mk:<span class="number">558</span>: warning: overriding commands <span class="keyword">for</span> target `kernelclean<span class="string">&#x27;</span></span><br><span class="line"><span class="string">device/qcom/common/generate_extra_images.mk:558: warning: ignoring old commands for target `kernelclean&#x27;</span></span><br><span class="line">vendor/ts/build/tasks/gen_vehiclecfg_img.mk:<span class="number">87</span>: warning: overriding commands <span class="keyword">for</span> target `out/target/product/msmnile_gvmq/vehicledefcfg.img<span class="string">&#x27;</span></span><br><span class="line"><span class="string">build/make/core/Makefile:1869: warning: ignoring old commands for target `out/target/product/msmnile_gvmq/vehicledefcfg.img&#x27;</span></span><br><span class="line">vendor/ts/build/tasks/gen_vehiclecfg_img.mk:<span class="number">123</span>: warning: overriding commands <span class="keyword">for</span> target `out/target/product/msmnile_gvmq/vehicleconfig.img<span class="string">&#x27;</span></span><br><span class="line"><span class="string">build/make/core/Makefile:1916: warning: ignoring old commands for target `out/target/product/msmnile_gvmq/vehicleconfig.img&#x27;</span></span><br><span class="line"><span class="comment">// 留意一下这个错误</span></span><br><span class="line"><span class="number">18</span>:<span class="number">30</span>:<span class="number">48</span> ckati failed with: signal: killed</span><br></pre></td></tr></table></figure>
<p>以上错误ckati构建系统强行把编译行为中止了。</p>
<p>找了好多资料都没有找到原因是啥，平白无故的将我的编译行为杀掉了，我就猜测是不是什么系统资源不够了？因为之前把内存调到4G的时候，系统经常不报代码原因，直接被干掉了。</p>
<p>于是基于这一点，查到<strong>默认安装的Ubuntu18</strong>，分区是自动分的， <strong>swap 分区只给了2G</strong>。但是电脑内存16G，一般swap分区要大于或等于物理内存(1-1.5倍)，而且刚跑程序电脑卡死无奈重启，top命令最后引起我注意的是进场command：kswapd0， 所以摁下重启键回来增大swap分区试试。</p>
<h4 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h4><p>增加交换分区步骤如下：</p>
<ul>
<li>1.查看内存情况：<code>free -m</code></li>
<li>2.创建一个新的swap文件<br><code>sudo dd if=/dev/zero of=swap bs=1G count=24</code><br>count的值是24G， 创建文件名为swap。（<strong>这步应该在/路径下执行了</strong>）</li>
<li>3.创建swap文件系统<br><code>sudo mkswap -f swap</code></li>
<li>4.开启新的swap<br><code>sudo swapon swap</code></li>
<li>5.关闭并删除原有的swap文件<br><code>sudo swapoff swapfile</code><br><code>sudo rm /swapfile</code></li>
<li>6.设置开机启动<br><code>sudo subl /etc/fstab</code><br>将原有的swapfile改为swap</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>安装如上配置之后，就可以开开心心编译系统了。经过半天的编译，正常情况下就会编译成功了</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bb4a986a91b95b92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译Android成功.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-37a1d23cd71dbf3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译系统整包成功.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>交换空间不足</tag>
      </tags>
  </entry>
  <entry>
    <title>解决自定义rc文件启动不生效问题</title>
    <url>/2021/05/14/%E8%A7%A3%E5%86%B3%E8%87%AA%E5%AE%9A%E4%B9%89rc%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-自定义rc文件"><a href="#1-自定义rc文件" class="headerlink" title="1.自定义rc文件"></a>1.自定义rc文件</h3><p>自定义一个标签，找一个可以执行的rc文件赋值进去。我是保存在/device/<vendor>/<product>/init.target.rc中。</product></vendor></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service firewalldaemon /vendor/bin/firewalldaemon</span><br><span class="line">    class main</span><br><span class="line">    user system</span><br><span class="line">    group system inet net_admin</span><br><span class="line">    disabled</span><br><span class="line">    capabilities NET_ADMIN NET_RAW</span><br><span class="line">    socket firewall stream 0660 root system</span><br><span class="line"></span><br><span class="line">on zygote-start</span><br><span class="line">    start firewalldaemon</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android.mk文件</span></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">#LOCAL_PROPRIETARY_MODULE := true</span><br><span class="line">LOCAL_VENDOR_MODULE := <span class="keyword">true</span></span><br><span class="line">LOCAL_MODULE := firewalldaemon</span><br><span class="line">LOCAL_INIT_RC := firewalldaemon.rc</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line">LOCAL_CPPFLAGS := -Wall \</span><br><span class="line">                  -Werror \</span><br><span class="line">                  -Wno-unused-parameter \</span><br><span class="line">                  -DLOG_TAG=\<span class="string">&quot;FirewallDaemon\&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LOCAL_SRC_FILES := src/ServerSocket.cpp \</span></span><br><span class="line"><span class="string">                   src/Socket.cpp \</span></span><br><span class="line"><span class="string">                   src/main.cpp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LOCAL_C_INCLUDES := src/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LOCAL_SHARED_LIBRARIES := \</span></span><br><span class="line"><span class="string">    liblogwrap \</span></span><br><span class="line"><span class="string">    libcutils \</span></span><br><span class="line"><span class="string">    libutils \</span></span><br><span class="line"><span class="string">    liblog</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">include $(GEN_PREBUILT_PACKAGE)</span></span><br><span class="line"><span class="string">include $(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure>


<p>编译出来一个firewalldaemon可执行文件。</p>
<p>将firewalldaemon PUSH到/vendor/bin目录下。</p>
<p>然后修改/vendor/etc/init/hw/init.qcom.rc，将上面rc标签复制到这个文件末尾，重启车机会发现我们标签声明的文件根本没有执行。</p>
<h4 id="2-调查问题"><a href="#2-调查问题" class="headerlink" title="2.调查问题"></a>2.调查问题</h4><h4 id="2-1-Selinux权限问题"><a href="#2-1-Selinux权限问题" class="headerlink" title="2.1 Selinux权限问题"></a>2.1 Selinux权限问题</h4><p>猜测是不是selinux没有给权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:/ # getenforce</span><br><span class="line">Permissive</span><br></pre></td></tr></table></figure>
<p>发现是在兼容模式，讲道理应该只是有日志输出来，不会拦截呀。排除这个可能。</p>
<h4 id="2-2-ramdisk介绍与定制"><a href="#2-2-ramdisk介绍与定制" class="headerlink" title="2.2 ramdisk介绍与定制"></a>2.2 ramdisk介绍与定制</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-4718e1679166d3f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="randisk介绍.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-61adaba8d46c0cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存磁盘镜像.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ad6b9bb1e9b405e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="烧写镜像.png"></p>
<p>最后发现车机高通的系统修改了RC文件，重启之后RC文件并没有被替换成boot.img中的文件。说明修改是生效了的。但是服务还是无法启动。</p>
<h4 id="2-3启动指令启动服务"><a href="#2-3启动指令启动服务" class="headerlink" title="2.3启动指令启动服务"></a>2.3启动指令启动服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:/ # setprop ctl.start firewalldaemon</span><br><span class="line">setprop ctl.start firewalldaemon</span><br></pre></td></tr></table></figure>
<p>我写的firewalldaemon是一个while(1)不会退出程序，结果通过指令也无法启动，查看dmesg信息，报如下问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:/ # dmesg|grep -ie firewall</span><br><span class="line">dmesg|grep -ie firewall</span><br><span class="line">[ 6592.467286] init: Received control message &#x27;start&#x27; for &#x27;firewalldaemon&#x27; from pid: 29798 (setprop ctl.start firewalldaemon)</span><br><span class="line">[ 6592.467412] init: Could not ctl.start for service firewalldaemon: File /vendor/bin/firewalldaemon(labeled &quot;u:object_r:vendor_file:s0&quot;) has incorrect label or no domain transition from u:r:init:s0 to another SELinux domain defined. Have you configured your service correctly? https://source.android.com/security/selinux/device-policy#label_new_services_and_address_denials</span><br></pre></td></tr></table></figure>
<p>此消息说明即使Selinux是Permissive模式也不行，因为进程还没有起来，进程起来之后才可以通过Permissive模式配置规则。</p>
<p>于是开始配置规则。 </p>
<ul>
<li>step 1:  为<code>/vendor/bin/firewalldaemon</code> 添加标签</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//在device/qcom/sepolicy/vendor/common/file_contexts 添加</span><br><span class="line"></span><br><span class="line">/vendor/bin/firewalldaemon                      u:object_r:firewalldaemon_exec:s0</span><br></pre></td></tr></table></figure>
<ul>
<li>step 2: 创建一个新网域“firewalldaemon”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 创建device/qcom/sepolicy/vendor/common/firewalldaemon.te</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewalldaemon service</span></span><br><span class="line">type firewalldaemon, domain;</span><br><span class="line">type firewalldaemon_exec, vendor_file_type, exec_type, file_type;</span><br><span class="line"></span><br><span class="line">init_daemon_domain(firewalldaemon)</span><br></pre></td></tr></table></figure>
<ul>
<li>step 3: 在init.target.rc中添加需要启动的服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;device&#x2F;qcom&#x2F;msmnile_gvmq&#x2F;init.target.rc</span><br><span class="line"></span><br><span class="line">service firewalldaemon &#x2F;vendor&#x2F;bin&#x2F;firewalldaemon</span><br><span class="line">    class main</span><br><span class="line">    user system</span><br><span class="line">    group system inet net_admin</span><br><span class="line">    disabled</span><br><span class="line">    capabilities NET_ADMIN NET_RAW</span><br><span class="line">    socket tsfirewall stream 0660 root system</span><br></pre></td></tr></table></figure>
<ul>
<li>重新编译系统并且烧写img</li>
</ul>
<h4 id="2-4-编译问题"><a href="#2-4-编译问题" class="headerlink" title="2.4 编译问题"></a>2.4 编译问题</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 编译日志输出：</span><br><span class="line">make -j4 2&gt;&amp;1 | tee android_build_log.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4db44212aa601751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译报错.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4cb7fd1c1b88af12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错原因.png"></p>
<p>报错信息：执行文件需要vendor file域，需要在firewalldaemon.te中添加vendor_file_type</p>
<h4 id="2-5-生成vendor-img"><a href="#2-5-生成vendor-img" class="headerlink" title="2.5 生成vendor.img"></a>2.5 生成vendor.img</h4><p>使用fastboot烧写img</p>
<p>进入fastboot模式按住“Q”开机启动，但是串口无法输入。查看USB驱动是否有，查看串口工具配置，记得关闭“流控”。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4355be37af916991.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="串口配置.png"></p>
<p>连接成功，进入到fastboot模式</p>
<p>使用电脑CMD查看连接设备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 查看设备</span><br><span class="line">fastboot devices -l</span><br><span class="line"></span><br><span class="line">// 烧写img</span><br><span class="line">fastboot flash la_vendor_a C:\Users\81566\Desktop\vendor.img</span><br><span class="line"></span><br><span class="line">// 可刷写的img</span><br><span class="line">fastboot flash la_system_a system.img</span><br><span class="line">fastboot flash la_vendor_a vendor.img</span><br><span class="line">fastboot flash la_userdata userdata.img</span><br><span class="line">fastboot flash la_persist persist.img</span><br><span class="line">fastboot flash vbmeta_a vbmeta.img</span><br><span class="line">fastboot flash dtbo_a dtbo.img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 重启车机</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5458deb41b1a40c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="烧写成功.png"></p>
<h4 id="2-6-重启车机见证奇迹的时刻"><a href="#2-6-重启车机见证奇迹的时刻" class="headerlink" title="2.6 重启车机见证奇迹的时刻"></a>2.6 重启车机见证奇迹的时刻</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-403ac01278d9064a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="firewall服务自启动.png"></p>
<h4 id="3-编译报缺少classes-head-jar"><a href="#3-编译报缺少classes-head-jar" class="headerlink" title="3.编译报缺少classes-head.jar"></a>3.编译报缺少classes-head.jar</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-0fe54998d6f715c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译缺少classes-header.png"></p>
<p>解决办法：将工程移入到/vendor/ts/proprietary</p>
<p>然后正常编译即可</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Android应用签名和校验方法</title>
    <url>/2021/01/27/%E8%A7%A3%E6%9E%90Android%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D%E5%92%8C%E6%A0%A1%E9%AA%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用keytool指令</p>
<p>在jdk的bin目录下找到keytool执行如下：</p>
<p>keytool -list -printcert -jarfile D:\GoogleNewTest\sdkgoogle.apk</p>
<p>一般结果是这样：</p>
<p>签名者 #1:</p>
<p>签名:</p>
<p>所有者: O=wildstone</p>
<p>发布者: O=wildstone</p>
<p>序列号: 5619594d</p>
<p>有效期开始日期: Tue Mar 27 11:17:06 CST 2018, 截止日期: Wed Mar 14 11:17:06 CST</p>
<p>2068</p>
<p>证书指纹:</p>
<p>MD5: B4:8A:9A:73:28:37:D0:1B:AE:3F:35:5B:25:61:66:DA</p>
<p>SHA1: 36:C7:87:8C:FC:D4:40:9E:D6:A0:B7:8B:3A:4E:AB:A2:F2:2C:7E:37</p>
<p>SHA256: C0:23:9C:9D:8C:EA:A8:50:9F:5D:27:7A:F6:C4:7D:EB:8D:39:CB:96:18:</p>
<p>45:D4:2C:3A:45:5A:F2:FF:28:FC:44</p>
<p>签名算法名称: SHA1withRSA</p>
<p>版本: 3</p>
<p>本次双签名的问题是如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-92fcebe3d0065c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>2.查看文件</p>
<p>解压apk查看META-INF的文件夹内容</p>
<p>1）正常情况，如下图3个文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ccbb502b602aa1d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>2）双签名的apk，如下图5个文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-da3d263ded5effba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>正常情况下的几个文件签名逻辑</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2b9aac9eb377022c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d6f79a4fcd9bc80e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>app签名过程</tag>
        <tag>证书内容</tag>
      </tags>
  </entry>
  <entry>
    <title>解析dumpsys cpuinfo</title>
    <url>/2021/08/12/%E8%A7%A3%E6%9E%90dumpsys-cpuinfo/</url>
    <content><![CDATA[<h4 id="1-车机原始数据"><a href="#1-车机原始数据" class="headerlink" title="1.车机原始数据"></a>1.车机原始数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Load: <span class="number">14.49</span> / <span class="number">8.82</span> / <span class="number">7.01</span></span><br><span class="line">CPU usage from 9057ms to 1851<span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">39.845</span> to <span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">47.051</span>)</span>:</span></span><br><span class="line"><span class="function">  79% 792/system_server: 44% user + 35% kernel / faults: 1774 minor</span></span><br><span class="line"><span class="function">  46% 485/surfaceflinger: 24% user + 21% kernel / faults: 1815 minor</span></span><br><span class="line"><span class="function">  20% 1513/com.gxa.service.systemui: 19% user + 0.4% kernel / faults: 22 minor</span></span><br><span class="line"><span class="function">  17% 452/android.hardware.graphics.composer@2.2-service: 10% user + 6.6% kernel</span></span><br><span class="line"><span class="function">  14% 446/android.hardware.broadcastradio@2.0-service.g6: 1.6% user + 13% kernel</span></span><br><span class="line"><span class="function">  4.8% 23782/adbd: 0.2% user + 4.5% kernel / faults: 39003 minor</span></span><br><span class="line"><span class="function">  4.7% 293/logd: 1.1% user + 3.6% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  3.8% 1099/com.android.bluetooth: 1.9% user + 1.9% kernel / faults: 141 minor</span></span><br><span class="line"><span class="function">  2.7% 461/android.hardware.usb@1.0-service: 0% user + 2.7% kernel</span></span><br><span class="line"><span class="function">  2.6% 2501/com.iflytek.autofly.avatar: 1.8% user + 0.8% kernel / faults: 16 minor</span></span><br><span class="line"><span class="function">  1.8% 3511/com.gxatek.cockpit.scenesengine: 1.6% user + 0.1% kernel / faults: 15 minor</span></span><br><span class="line"><span class="function">  1.8% 21524/kworker/1:1: 0% user + 1.8% kernel</span></span><br><span class="line"><span class="function">  1.3% 357/vendor.ts.systemlog@1.0-service: 0% user + 1.3% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0.5% 444/android.hardware.bluetooth@1.0-service-qti: 0.5% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.3% 13161/kworker/1:2: 0% user + 0.3% kernel</span></span><br><span class="line"><span class="function">  1.2% 2612/com.iflytek.autofly.dms: 0.2% user + 0.9% kernel / faults: 3 minor</span></span><br><span class="line"><span class="function">  1.1% 24014/logcat: 0.1% user + 0.9% kernel</span></span><br><span class="line"><span class="function">  0.8% 195/spi1: 0% user + 0.8% kernel</span></span><br><span class="line"><span class="function">  0.8% 1347/cds_ol_rx_threa: 0% user + 0.8% kernel</span></span><br><span class="line"><span class="function">  0.8% 32737/kworker/u16:8: 0% user + 0.8% kernel</span></span><br><span class="line"><span class="function">  0.6% 1<span class="comment">//init: 0.1% user + 0.5% kernel / faults: 413 minor</span></span></span><br><span class="line"><span class="function">  0.6% 215/irq/136-8804000: 0% user + 0.6% kernel</span></span><br><span class="line"><span class="function">  0.6% 359/netd: 0.2% user + 0.4% kernel / faults: 14 minor</span></span><br><span class="line"><span class="function">  0.6% 2397/platformservice.Services: 0.4% user + 0.2% kernel / faults: 85 minor</span></span><br><span class="line"><span class="function">  0.6% 32618/com.iflytek.autofly.systemserver: 0.1% user + 0.5% kernel / faults: 274 minor</span></span><br><span class="line"><span class="function">  0.5% 455/android.hardware.memtrack@1.0-service: 0.1% user + 0.4% kernel</span></span><br><span class="line"><span class="function">  0.5% 457/android.hardware.sensors@1.0-service: 0.1% user + 0.4% kernel</span></span><br><span class="line"><span class="function">  0.5% 2594/com.gxa.service.bluetooth: 0.2% user + 0.2% kernel / faults: 90 minor</span></span><br><span class="line"><span class="function">  0.5% 30761/com.android.commands.monkey: 0.2% user + 0.2% kernel / faults: 36 minor</span></span><br><span class="line"><span class="function">  0.5% 30967/kworker/u16:5: 0% user + 0.5% kernel</span></span><br><span class="line"><span class="function">  0.4% 1772/com.android.car: 0.2% user + 0.1% kernel / faults: 48 minor</span></span><br><span class="line"><span class="function">  0.4% 32143/com.gxatek.cockpit.carservice: 0.2% user + 0.1% kernel / faults: 347 minor</span></span><br><span class="line"><span class="function">  0.2% 471/vendor.ts.gnssext@1.0-service: 0.2% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.2% 742/mdnsd: 0.2% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.2% 1225/com.core.system.service: 0.1% user + 0.1% kernel / faults: 91 minor</span></span><br><span class="line"><span class="function">  0.2% 1451/com.gxa.car.power: 0.1% user + 0.1% kernel / faults: 48 minor</span></span><br><span class="line"><span class="function">  0.2% 2782/com.iflytek.autofly.mediax: 0.1% user + 0.1% kernel / faults: 16 minor</span></span><br><span class="line"><span class="function">  0% 8/ksoftirqd/0: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 9/rcu_preempt: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 24/ksoftirqd/2: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 30/ksoftirqd/3: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 305/android.hardware.automotive.vehicle@2.0-service.g6: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 309/com.desaysv.vehiclelan.proxy@1.0-service: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 349/kworker/u17:1: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 353/ais_v4l2_proxy: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 447/android.hardware.camera.provider@2.4-service_64: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0% 451/android.hardware.dsp@1.0-service: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 463/android.hardware.wifi@1.0-service: 0.1% user + 0% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0% 464/vendor.desaysv.hardware.tbox@1.0-service: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 609/cnss-daemon: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 724/wlan_logging_th: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0.1% 1243/com.android.systemui: 0.1% user + 0% kernel / faults: 69 minor</span></span><br><span class="line"><span class="function">  0.1% 1381/com.gxa.service.account: 0.1% user + 0% kernel / faults: 44 minor</span></span><br><span class="line"><span class="function">  0.1% 2567/com.gac.cloud.app: 0.1% user + 0% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0.1% 2643/com.gxa.appservice.platformadapter.adaptermainservice: 0.1% user + 0% kernel / faults: 53 minor</span></span><br><span class="line"><span class="function">  0.1% 3104/com.iflytek.autofly.mediax:remote: 0.1% user + 0% kernel / faults: 1 minor</span></span><br><span class="line"><span class="function">  0.1% 3252/android.ext.services: 0.1% user + 0% kernel / faults: 12 minor</span></span><br><span class="line"><span class="function">  0.1% 3267/android.ext.services: 0.1% user + 0% kernel / faults: 14 minor</span></span><br><span class="line"><span class="function">  0.1% 10320/com.iflytek.autofly.accountcenter: 0.1% user + 0% kernel</span></span><br><span class="line"><span class="function">  0% 18185/kworker/3:3: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">  0.1% 20603/kworker/u16:3: 0% user + 0.1% kernel</span></span><br><span class="line"><span class="function">  0% 30508/kworker/6:0: 0% user + 0% kernel</span></span><br><span class="line"><span class="function"> +0% 1090/sh: 0% user + 0% kernel</span></span><br><span class="line"><span class="function"> +0% 1103/dumpsys: 0% user + 0% kernel</span></span><br><span class="line"><span class="function"> +0% 1153/qti: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">29% TOTAL: 13% user + 12% kernel + 0% iowait + 2.5% irq + 0.7% softirq</span></span><br><span class="line"><span class="function">------finish dumpsys cpuinfo------</span></span><br></pre></td></tr></table></figure>


<h4 id="2-负载参数解读"><a href="#2-负载参数解读" class="headerlink" title="2.负载参数解读"></a>2.负载参数解读</h4><h5 id="2-1-参数解读"><a href="#2-1-参数解读" class="headerlink" title="2.1 参数解读"></a>2.1 参数解读</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Load: <span class="number">14.49</span> / <span class="number">8.82</span> / <span class="number">7.01</span></span><br></pre></td></tr></table></figure>
<p>此行显示CPU负载的平均值，这三个数字表示逐渐变长的时间段（平均一分钟，五分钟和十五分钟）的平均值，如果数字较小则说明负载在降低，数字越大表示问题或机器过载。由于当前测试车机是八核处理器，我们以单核处理器来说明以上参数。</p>
<p>CPU处理代码相当于车辆过桥一样，单核处理器相当于桥梁，代码相当于车辆。代码在处理器上运行相当于车辆在桥上跑一样。因此，以上数字含义：</p>
<ul>
<li>0.00表示桥上根本没有流量。实际上，介于0.00和1.00之间意味着没有备份，而到达的汽车将直接开启。</li>
<li>1.00表示桥梁正好处于饱和容量状态。一切都还不错，但如果流量变得更重，事情就会变慢。</li>
<li>超过1.00表示有拥堵。那么，2.00意味着总共有两条车道 - 一条车道的价值在桥上，一条车道值得等待。3.00意味着总共有三条车道 - 桥上有一条车道，两条车道值得等待。</li>
</ul>
<p>这基本上就是CPU负载。代码(“汽车”)是使用一段CPU时间片（“过桥”）或排队使用CPU的过程。Unix将此称为<code>运行队列长度</code>：当前运行的进程数加上等待（排队）运行的进程数之和。</p>
<h5 id="2-2-理想负载"><a href="#2-2-理想负载" class="headerlink" title="2.2 理想负载"></a>2.2 理想负载</h5><p>如果单核处理器一直处于1，那么说明当前处理器一直在满负荷运行，没有任何余量。CPU长时间处于满负荷或者超负荷运行将导致CPU大量发热，或者降低CPU寿命。因此需要一个参考值来衡量当前系统CPU是否健康。经验参考值如下(单核)：</p>
<ul>
<li>阈值大于0.7：如果长时间平均阈值大于0.7，需要在事态进一步恶化之前进行调查。</li>
<li>阈值大于1.0：如果长时间平均阈值大于1.0，需要找到问题并立即修复，否者可能将面临半夜起来调查问题的情况</li>
<li>阈值大于5.0：如果长时间平均值大于5.0,系统一定出现严重异常，紧要任务是立即排除严重故障，否则影响cpu寿命等不可预知的问题。当前系统处于长时间没有响应，或者接近死机了。你不应该让系统达到这个值。</li>
</ul>
<h5 id="2-3-多核和多处理器"><a href="#2-3-多核和多处理器" class="headerlink" title="2.3 多核和多处理器"></a>2.3 多核和多处理器</h5><p>经常有听到有多少个处理器，一个处理器有多少核，让我们谈谈多核与多处理器。出于性能目的，具有单个双核处理器的机器基本上等同于具有两个处理器的机器，每个处理器具有一个核心？是的，这里有许多关于缓存数量，处理器之间的进程切换频率等的细微之处。尽管有这些更精细的点，但为了确定CPU负载值的大小，核心的总数是重要的，无论如何这些核心分布在许多物理处理器上。因此无论多少处理器，我们主要考虑<strong>该机器上有多少核！！</strong>因此又出现两个经验法则：</p>
<ul>
<li><em>“核心数=最大负载”经验</em>法则：在多核系统上，您的负载不应超过可用核心数</li>
<li>该<em>“内核是内核”</em>经验法则：不管核心是如何分布在CPU的无所谓，两个四核==四个双核==八个单核。这些都是用于这些目的的八个核心。</li>
</ul>
<h5 id="2-4-如何观察这三个参数"><a href="#2-4-如何观察这三个参数" class="headerlink" title="2.4 如何观察这三个参数"></a>2.4 如何观察这三个参数</h5><p>上面提到以上三个参数代表：一分钟，五分钟，十五分钟平均值。那么我们如何观察并采取行动呢？</p>
<ul>
<li>一分钟：如果监控中显示一分钟cpu负载大于核心数，可以暂时不采取行动，可能是因为开机启动，突然有高cpu进程运行等原因。</li>
<li>五分钟：如果监控中显示五分钟cpu负载大于核心数，需要结合需求调查对高负荷进程进行调查</li>
<li>十五分钟：如果监控中显示十五分钟cpu负荷大于核心数，需要评估高负荷进程CPU消耗原因或者CPU硬件瓶颈</li>
</ul>
<p>获取机器CPU信息指令，每一块信息代表一个核的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>


<h4 id="3-单应用参数解读"><a href="#3-单应用参数解读" class="headerlink" title="3. 单应用参数解读"></a>3. 单应用参数解读</h4><h5 id="3-1-时间戳解析"><a href="#3-1-时间戳解析" class="headerlink" title="3.1 时间戳解析"></a>3.1 时间戳解析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java</span></span><br><span class="line">CPU usage from 9057ms to 1851<span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">39.845</span> to <span class="number">2021</span>-08-<span class="number">12</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">47.051</span>)</span>:</span></span><br><span class="line"><span class="function"><span class="comment">// 9057ms == mLastSampleTime</span></span></span><br><span class="line"><span class="function"><span class="comment">// 1851ms == mCurrentSampleTime</span></span></span><br><span class="line"><span class="function"><span class="comment">// 后面()是系统时间戳，相减也等于上面两个变量相减的时间，记录这段时间cpu上执行过的代码</span></span></span><br></pre></td></tr></table></figure>


<h5 id="3-2-单应用解析"><a href="#3-2-单应用解析" class="headerlink" title="3.2 单应用解析"></a>3.2 单应用解析</h5><p>Dumpsys cpuinfo计算cpu使用率是基于 SystemClock.uptimeMillis()差值来计算得到的。详细见：<a href="https://blog.csdn.net/oujunli/article/details/51463707">《Android CPU使用率：top和dump cpuinfo的不同》</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">79</span>% <span class="number">792</span>/system_server: <span class="number">44</span>% user + <span class="number">35</span>% kernel / faults: <span class="number">1774</span> minor</span><br><span class="line"><span class="comment">// 79% 代表当前进程CPU使用占比</span></span><br><span class="line"><span class="comment">// 792 进程id，即pid</span></span><br><span class="line"><span class="comment">// system_server 进程名</span></span><br><span class="line"><span class="comment">// 44% 用户空间使用44%</span></span><br><span class="line"><span class="comment">// 35% 内核空间使用35%</span></span><br><span class="line"><span class="comment">// faults: 1774 minor  下面说明</span></span><br></pre></td></tr></table></figure>


<h5 id="3-3-minor解析"><a href="#3-3-minor解析" class="headerlink" title="3.3 minor解析"></a>3.3 minor解析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] PROCESS_STATS_FORMAT = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_PARENS,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 10: minor faults</span></span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 12: major faults</span></span><br><span class="line">        PROC_SPACE_TERM,</span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 14: utime</span></span><br><span class="line">        PROC_SPACE_TERM|PROC_OUT_LONG,                  <span class="comment">// 15: stime</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCpuTimeForPid</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSinglePidStatsData) &#123;</span><br><span class="line">            <span class="keyword">final</span> String statFile = <span class="string">&quot;/proc/&quot;</span> + pid + <span class="string">&quot;/stat&quot;</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span>[] statsData = mSinglePidStatsData;</span><br><span class="line">            <span class="keyword">if</span> (Process.readProcFile(statFile, PROCESS_STATS_FORMAT,</span><br><span class="line">                    <span class="keyword">null</span>, statsData, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">long</span> time = statsData[PROCESS_STAT_UTIME]</span><br><span class="line">                        + statsData[PROCESS_STAT_STIME];</span><br><span class="line">                <span class="keyword">return</span> time * mJiffyMillis;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出minor代表<strong>小错误</strong>，通过读取/proc/<pid>/stat中第10个数值获取的。至于minor是什么，详见《<a href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">4.Understanding page faults and memory swap-in/outs: when should you worry?</a>》</pid></p>
<h4 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">29</span>% TOTAL: <span class="number">13</span>% user + <span class="number">12</span>% kernel + <span class="number">0</span>% iowait + <span class="number">2.5</span>% irq + <span class="number">0.7</span>% softirq</span><br><span class="line"><span class="comment">// 29% 代表总共cpu消耗占比</span></span><br><span class="line"><span class="comment">// 13% 代表用户空间总消耗</span></span><br><span class="line"><span class="comment">// 12% 代表内核空间总消耗</span></span><br><span class="line"><span class="comment">// 0% 代表CPU在I/O请求中消耗等待时间占比</span></span><br><span class="line"><span class="comment">// 2.5% 代表硬中断执行消耗</span></span><br><span class="line"><span class="comment">// 0.7% 代表中断执行消耗</span></span><br></pre></td></tr></table></figure>


<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.cnblogs.com/muahao/p/6492665.html">1.理解Linux CPU负载和 CPU使用</a></p>
<p><a href="https://scoutapm.com/blog/understanding-load-averages">2.Understanding Linux CPU Load - when should you be worried?</a></p>
<p><a href="https://stackoverflow.com/questions/40186347/dumpsys-cpuinfo-in-android-interpreting-the-results-of-this-command">3.dumpsys cpuinfo in Android: Interpreting the results of this command</a></p>
<p><a href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">4.Understanding page faults and memory swap-in/outs: when should you worry?</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>cpuinfo</tag>
      </tags>
  </entry>
  <entry>
    <title>调查Android P持续打印non-protected broadcast 问题</title>
    <url>/2021/08/04/%E8%B0%83%E6%9F%A5Android-P%E6%8C%81%E7%BB%AD%E6%89%93%E5%8D%B0non-protected-broadcast-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>​    在logcat日志和dropbox日志中持续打印 E/ActivityManager( 803): Sending non-protected broadcast android.intent.action.VIEW from system 3235:com.iflytek.cutefly.speechclient.hmi/1000 pkg com.iflytek.cutefly.speechclient.hmi</p>
<h4 id="2-问题定位"><a href="#2-问题定位" class="headerlink" title="2.问题定位"></a>2.问题定位</h4><p>查看logcat，持续输出日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E/ActivityManager( <span class="number">803</span>): Sending non-<span class="keyword">protected</span> broadcast android.intent.action.VIEW from system <span class="number">3235</span>:com.iflytek.cutefly.speechclient.hmi/<span class="number">1000</span> pkg com.iflytek.cutefly.speechclient.hmi</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): java.lang.Throwable</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. checkBroadcastFromSystem(ActivityManagerService.java:<span class="number">21241</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. broadcastIntentLocked(ActivityManagerService.java:<span class="number">21845</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. broadcastIntent(ActivityManagerService.java:<span class="number">21987</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at android.app.IActivityManager$Stub. onTransact$broadcastIntent$(IActivityManager.java:<span class="number">10171</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at android.app.IActivityManager$Stub. onTransact(IActivityManager.java:<span class="number">167</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at com.android.server.am.ActivityManagerService. onTransact(ActivityManagerService.java:<span class="number">3291</span>)</span><br><span class="line">E/ActivityManager( <span class="number">803</span>): at android.os.Binder.execTransact(Binder.java:<span class="number">731</span>)</span><br><span class="line"><span class="comment">// ActivityManager打印com.iflytek.cutefly.speechclient.hmi发送了未受保护的广播</span></span><br><span class="line">I/am_wtf ( <span class="number">803</span>): [<span class="number">0</span>,<span class="number">803</span>,system_server,-<span class="number">1</span>,ActivityManager,Sending non-<span class="keyword">protected</span> broadcast android.intent.action.VIEW from system <span class="number">3235</span>:com.iflytek.cutefly.speechclient.hmi/<span class="number">1000</span> pkg com.iflytek.cutefly.speechclient.hmi]</span><br></pre></td></tr></table></figure>


<p>撸出源码，grep报错日志，定位到ActivityManagerService中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是系统应用，则判断声明发送的广播都声明成protect-broadcast</span></span><br><span class="line"><span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">	checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">		isProtectedBroadcast, registeredReceivers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkBroadcastFromSystem</span><span class="params">(Intent intent, ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">       String callerPackage, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> isProtectedBroadcast, List receivers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((intent.getFlags() &amp; Intent.FLAG_RECEIVER_FROM_SHELL) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t yell about broadcasts sent via shell</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    	<span class="comment">// 如果是受保护的广播或者下面枚举的广播，直接返回，不处理</span></span><br><span class="line">        <span class="keyword">if</span> (isProtectedBroadcast</span><br><span class="line">            || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)</span><br><span class="line">            || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)</span><br><span class="line">            || Intent.ACTION_MEDIA_BUTTON.equals(action)</span><br><span class="line">            || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)</span><br><span class="line">            || Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)</span><br><span class="line">            || Intent.ACTION_MASTER_CLEAR.equals(action)</span><br><span class="line">            || Intent.ACTION_FACTORY_RESET.equals(action)</span><br><span class="line">            || AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">            || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)</span><br><span class="line">            || LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)</span><br><span class="line">            || TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)</span><br><span class="line">            || SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)</span><br><span class="line">            || AudioEffect.ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION.equals(action)</span><br><span class="line">            || AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// Broadcast is either protected, or it&#x27;s a public action that</span></span><br><span class="line">			<span class="comment">// we&#x27;ve relaxed, so it&#x27;s fine for system internals to send.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This broadcast may be a problem...  but there are often system components that</span></span><br><span class="line">        <span class="comment">// want to send an internal broadcast to themselves, which is annoying to have to</span></span><br><span class="line">        <span class="comment">// explicitly list each action as a protected broadcast, so we will check for that</span></span><br><span class="line">        <span class="comment">// one safe case and allow it: an explicit broadcast, only being received by something</span></span><br><span class="line">        <span class="comment">// that has protected itself.</span></span><br><span class="line">        <span class="keyword">if</span> (intent.getPackage() != <span class="keyword">null</span> || intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (receivers == <span class="keyword">null</span> || receivers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Intent is explicit and there&#x27;s no receivers.</span></span><br><span class="line">                <span class="comment">// This happens, e.g. , when a system component sends a broadcast to</span></span><br><span class="line">                <span class="comment">// its own runtime receiver, and there&#x27;s no manifest receivers for it,</span></span><br><span class="line">                <span class="comment">// because this method is called twice for each broadcast,</span></span><br><span class="line">                <span class="comment">// for runtime receivers and manifest receivers and the later check would find</span></span><br><span class="line">                <span class="comment">// no receivers.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> allProtected = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = receivers.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                Object target = receivers.get(i);</span><br><span class="line">                <span class="keyword">if</span> (target <span class="keyword">instanceof</span> ResolveInfo) &#123;</span><br><span class="line">                    ResolveInfo ri = (ResolveInfo)target;</span><br><span class="line">                    <span class="comment">// 如果activity的exported是true，说明该activity有action过滤器，直接判断广播是否开启了保护模式</span></span><br><span class="line">                    <span class="keyword">if</span> (ri.activityInfo.exported &amp;&amp; ri.activityInfo.permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        allProtected = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    BroadcastFilter bf = (BroadcastFilter)target;</span><br><span class="line">                    <span class="keyword">if</span> (bf.requiredPermission == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        allProtected = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (allProtected) &#123;</span><br><span class="line">                <span class="comment">// All safe!</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The vast majority of broadcasts sent from system internals</span></span><br><span class="line">        <span class="comment">// should be protected to avoid security holes, so yell loudly</span></span><br><span class="line">        <span class="comment">// to ensure we examine these cases.</span></span><br><span class="line">    	<span class="comment">// 为了避免安全漏洞，系统应用的广播需要加受保护权限，打印wtf日志！！！</span></span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Sending non-protected broadcast &quot;</span> + action</span><br><span class="line">                + <span class="string">&quot; from system &quot;</span> + callerApp.toShortString() + <span class="string">&quot; pkg &quot;</span> + callerPackage,</span><br><span class="line">                    <span class="keyword">new</span> Throwable());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Sending non-protected broadcast &quot;</span> + action</span><br><span class="line">                            + <span class="string">&quot; from system uid &quot;</span> + UserHandle.formatUid(callingUid)</span><br><span class="line">                            + <span class="string">&quot; pkg &quot;</span> + callerPackage,</span><br><span class="line">                    <span class="keyword">new</span> Throwable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断系统应用是不是受保护的。这个状态是从PKMS启动扫描各个应用apk的时候存储的</span></span><br><span class="line">isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isProtectedBroadcast</span><span class="params">(String actionName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// allow instant applications</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mProtectedBroadcasts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mProtectedBroadcasts.contains(actionName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> remove these terrible hacks</span></span><br><span class="line">            <span class="keyword">if</span> (actionName.startsWith(<span class="string">&quot;android.net.netmon.lingerExpired&quot;</span>)</span><br><span class="line">            || actionName.startsWith(<span class="string">&quot;com.android.server.sip.SipWakeupTimer&quot;</span>)</span><br><span class="line">            || actionName.startsWith(<span class="string">&quot;com.android.internal.telephony.data-reconnect&quot;</span>)</span><br><span class="line">            || actionName.startsWith(<span class="string">&quot;android.net.netmon.launchCaptivePortalApp&quot;</span>)) &#123;</span><br><span class="line">            	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码可知，实际是PackageManagerService里面维护一个名为mProtectedBroadcasts的系统广播白名单。在PackageManagerService扫描系统App时会将AndroidManifest.xml中的所有protected-broadcast加入到此ArraySet变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitPackageSettings</span><span class="params">(PackageParser.Package pkg,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="meta">@Nullable</span> PackageParser.Package oldPkg, PackageSetting pkgSetting, UserHandle user,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> <span class="meta">@ScanFlags</span> <span class="keyword">int</span> scanFlags, <span class="keyword">boolean</span> chatty)</span> </span>&#123;</span><br><span class="line">					.........</span><br><span class="line">			<span class="keyword">if</span> (pkg.protectedBroadcasts != <span class="keyword">null</span>) &#123;</span><br><span class="line">				N = pkg.protectedBroadcasts.size();</span><br><span class="line">				<span class="keyword">synchronized</span> (mProtectedBroadcasts) &#123;</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">					mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;					</span><br><span class="line">	.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PackageManagerService每次启动时会扫描下面三个目录的App：<br>/system/app<br>/system/priv-app<br>/system/framework/framework-res.apk</p>
<p>所以理论上只要在自己App中的AndroidManifest.xml中将自己新增的广播声明为protected-broadcast即可，不应该会出现Sending non-protected broadcast才对。</p>
<p>但是PKMS中有个广播白名单机制，如果扫描的app不在priv-app目录，就会把protectedBroadcasts 标志位置为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyPolicy</span><span class="params">(PackageParser.Package pkg, <span class="keyword">final</span> <span class="meta">@ParseFlags</span> <span class="keyword">int</span> 	</span></span></span><br><span class="line"><span class="function"><span class="params">	parseFlags, <span class="keyword">final</span> <span class="meta">@ScanFlags</span> <span class="keyword">int</span> scanFlags, PackageParser.Package platformPkg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((scanFlags &amp; SCAN_AS_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 如果不是priv-app，将pkg.protectedBroadcasts置为空</span></span><br><span class="line">	<span class="keyword">if</span> ((scanFlags &amp; SCAN_AS_PRIVILEGED) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// clear protected broadcasts</span></span><br><span class="line">            pkg.protectedBroadcasts = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// ignore export request for single user receivers</span></span><br><span class="line">            <span class="keyword">if</span> (pkg.receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = pkg.receivers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> PackageParser.Activity receiver = pkg.receivers.get(i);</span><br><span class="line">                    <span class="keyword">if</span> ((receiver.info.flags &amp; ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">                        receiver.info.exported = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可知，PackageManagerService在扫描App时，发现如果App不是来自priv-app目录下的App（当然framework-res.apk除外），就会将此App的中声明的protected广播清空，这样这个广播就不会加入到白名单，所以才就一直打印上面的warning log</p>
<p>不过这个仅仅是warning的log而已，广播还是可以正常发送和接收的，该结果和金(磊)老板确认过，只是输出日志，不影响收发，但是对于在做系统稳定性的人来说，眼里容不下这种刺。</p>
<h4 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3.解决办法"></a>3.解决办法</h4><h5 id="3-1-修改原生代码"><a href="#3-1-修改原生代码" class="headerlink" title="3.1 修改原生代码"></a>3.1 修改原生代码</h5><p>将自定义的广播在frameworks/base/core/res/AndroidManifest.xml中声明为protected-broadcast，例如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Added in O --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protected-broadcast</span> <span class="attr">android:name</span>=<span class="string">&quot;android.app.action.APPLICATION_DELEGATION_SCOPES_CHANGED&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protected-broadcast</span> <span class="attr">android:name</span>=<span class="string">&quot;com.android.server.wm.ACTION_REVOKE_SYSTEM_ALERT_WINDOW_PERMISSION&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protected-broadcast</span> <span class="attr">android:name</span>=<span class="string">&quot;android.media.tv.action.PARENTAL_CONTROLS_ENABLED_CHANGED&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方案是不可取的。为了减少耦合，修改问题的原则尽量采用不修改原生的方式完成。</p>
<h5 id="3-2-修改应用的包位置"><a href="#3-2-修改应用的包位置" class="headerlink" title="3.2 修改应用的包位置"></a>3.2 修改应用的包位置</h5><p>如果不希望改Android的源码，可以将自己的App放置到/system/priv-app下，而不是默认的/system/app目录下:<br>可在自己app的Android.mk中指定路径：<br>LOCAL_MODULE_PATH := $(TARGET_OUT_APPS_PRIVILEGED)</p>
<p>但是特别注意的是：如果App放置到priv-app目录，是会一些权限限制的。</p>
<h4 id="4-问题回溯与反思"><a href="#4-问题回溯与反思" class="headerlink" title="4.问题回溯与反思"></a>4.问题回溯与反思</h4><p>针对Android P持续打印non-protected broadcast 问题，google很多地方考虑到安全漏洞：使用了平台签名的系统应用广播应该收到保护。虽然没有采取严厉的措施，只是打印wtf日志，但是我们做系统稳定性也要思考是否所有预装应用都赋予平台权限。赋予了平台权限的应用可以和SystemServer跑在一个进程中，如果应用crash了，极有可能导致系统崩溃。因此，系统稳定性下一步应该考虑的哪些应用可以赋予平台权限，哪些应用不必赋予平台权限。</p>
<p>例如HMI层的apk,几乎不会调用到系统隐藏api等，是否可以取消平台权限，加强系统稳定性。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>non-protected-broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title>调查车机无法上网</title>
    <url>/2021/04/01/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<p><a href="https://gw.tai.qq.com/">https://gw.tai.qq.com/</a></p>
<p>112.53.1.114</p>
<p><strong>1. 修改系统时间</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 默认格式MMDDhhmm[[CC]YY][.ss]</span><br><span class="line">date 040912542021.30 </span><br></pre></td></tr></table></figure>


<p><strong>2. ifconfig</strong></p>
<p>查看网卡是否已经起来了。</p>
<p>A55 Tbox网卡是usb0</p>
<p>与QNX交互的网卡是eth0</p>
<p>//启动网卡</p>
<p># ifconfig eth0 up</p>
<p>//设置IP</p>
<p># ifconfig eth0 192.168.1.2</p>
<p>//开启混杂模式的命令是：</p>
<p># ifconfig usb0 promisc</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/AB78C433C65E457EA6A8BD09446FB633/1017" alt="0"></p>
<p>开启混杂模式的命令是：ifconfig usb0 promisc</p>
<p><strong>3.ping 百度</strong></p>
<p>如果ping不通，如下图，可能是DNS问题</p>
<p><img src="/2021/04/01/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/blog\source_posts\调查车机无法上网\ping百度排查dns问题.png" alt="ping百度排查dns问题"></p>
<p><strong>4.ping 百度的ip</strong></p>
<p>//指定使用wlan0 ping百度</p>
<p># ping -I wlan0 183.232.231.172 </p>
<p>如果能ping通，说明就是DNS问题</p>
<p><strong>5.netstat</strong></p>
<p>//查看所有对应进程的网络连接情况</p>
<p># netstat -ap </p>
<p>//监听该设备的网络访问情况</p>
<p># ip monitor dev eth0</p>
<p><strong>6.路由表</strong></p>
<p># netstat -r</p>
<p># cat /proc/net/route</p>
<p>//查看路由表</p>
<p>msmnile_gvmq:/ # ip route</p>
<p>172.20.10.0/28 dev wlan0 proto kernel scope link src 172.20.10.7</p>
<p>192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</p>
<p>224.224.224.245 dev eth0 scope link</p>
<p>//查看具体的路由表</p>
<p>msmnile_gvmq:/ # ip route list table wlan0</p>
<p>default via 172.20.10.1 dev wlan0 proto static</p>
<p>172.20.10.0/28 dev wlan0 proto static scope link</p>
<p>// 添加路由表</p>
<p># ip route add default dev wlan0</p>
<p>//删除该路由表</p>
<p># ip route del default dev wlan0</p>
<p>如下表示172.20.10.0网段的ip都走wlan0网卡</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/9335E7756ECF45909C5F1624D51FBA1D/1016" alt="0"></p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/5AD0A765F78244AE8BAB901FEC33DFBE/1021" alt="0"></p>
<p><strong>路由规则</strong></p>
<p># ip rule</p>
<p># ip rule add from all fwmark 0x0/0xffff iif lo lookup wlan0 prio 22000</p>
<p># ip rule del</p>
<p><strong>DNS</strong></p>
<p>查看对应网络设备的DNS，每个设备一个DNS</p>
<p>msmnile_gvmq:/ # getprop|grep wlan0</p>
<p><strong>连上wifi后正常配置示例</strong></p>
<p>msmnile_gvmq:/ # getprop|grep wlan0</p>
<p>msmnile_gvmq:/ # ip route</p>
<p>172.20.10.0/28 dev wlan0 proto kernel scope link src 172.20.10.7</p>
<p>192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</p>
<p>224.224.224.245 dev eth0 scope link</p>
<p>msmnile_gvmq:/ # ip route list table wlan0</p>
<p>default via 172.20.10.1 dev wlan0 proto static</p>
<p>172.20.10.0/28 dev wlan0 proto static scope link</p>
<p>msmnile_gvmq:/ # ip rule</p>
<p>0:   from all lookup local</p>
<p>9998:  from all lookup main</p>
<p>9999:  from all lookup main</p>
<p>10000: from all fwmark 0xc0000/0xd0000 lookup legacy_system</p>
<p>10500: from all iif lo oif dummy0 uidrange 0-0 lookup dummy0</p>
<p>10500: from all iif lo oif wlan0 uidrange 0-0 lookup wlan0</p>
<p>13000: from all fwmark 0x10063/0x1ffff iif lo lookup local_network</p>
<p>13000: from all fwmark 0x10066/0x1ffff iif lo lookup wlan0</p>
<p>14000: from all iif lo oif dummy0 lookup dummy0</p>
<p>14000: from all iif lo oif wlan0 lookup wlan0</p>
<p>15000: from all fwmark 0x0/0x10000 lookup legacy_system</p>
<p>16000: from all fwmark 0x0/0x10000 lookup legacy_network</p>
<p>17000: from all fwmark 0x0/0x10000 lookup local_network</p>
<p>19000: from all fwmark 0x66/0x1ffff iif lo lookup wlan0</p>
<p>22000: from all fwmark 0x0/0xffff iif lo lookup wlan0</p>
<p>32000: from all unreachable</p>
<p>logcat -G 200M</p>
<p>logcat -v time | grep -iE -v ‘CAR|tsrsdk|Hidl|VHAL|hvsm|vehicle’</p>
<p>logcat -v time | grep -iE -v ‘CAR|tsrsdk|Hidl|VHAL|hvsm|vehicle’ &gt; /data/net2021.log</p>
<p><strong>A55 CS版本wifi不能上网问题排查</strong></p>
<p><strong>问题描述：</strong>CS版本连接wifi后，无法使用wifi上网，同步时间后可以使用。</p>
<p><strong>问题原因：</strong>eth0在A55被作为与QNX交互的虚拟网卡，在原生Android是以太网网卡，评分高于没有验证通过的WLAN，所以被当做默认上网网卡。</p>
<p>两个版本对eth0的配置有差异。</p>
<p>ES版本配置</p>
<p>​    eth1;;ip=2.2.2.2/24</p>
<p>​    eth0;;ip=192.168.1.2/24 gateway=192.168.1.1 dns=4.4.4.4,8.8.8.8</p>
<p>CS版本配置</p>
<p>​    eth0;12,13,14,15;ip=192.168.1.2/24 gateway=192.168.1.1 dns=4.4.4.4,8.8.8.8</p>
<p>CS版本采用ES版本的config仍会导致eth0的ip被清除，目前从netd及上层逻辑看无论是CS还是ES版本如果eth0没被配为INTERNET确实会被清除IP。</p>
<p>需确认ES版本vsomeipd是否有配置eth0的ip地方，而在CS版本上没有合入导致？</p>
<p><strong>临时解决：</strong>wifi验证的网址改为国内网址，使可以验证通过。</p>
<p>排查相关命令</p>
<p>logcat -v time | grep -iE “Connectivity”</p>
<p>logcat -v time | grep -iE “NetworkMonitor|ConnectivityService|NetworkFactory|yangx|CommandListener”</p>
<p>mount -o rw,remount /</p>
<p>网络配置文件</p>
<p>vi device/qcom/msmnile_gvmq/overlay/frameworks/base/core/res/res/values/config.xml</p>
<p>cd frameworks/base/services/core/java/com/android/server</p>
<p><strong>git指令</strong></p>
<p>查看ES与CS分支差异</p>
<p>git diff origin/cauchy-falcon-wukong origin/cauchy_p-falcon-wukong-LA.AU.0.0.1_rb2.16 IpClient.java</p>
<p>git log -p 指定文件</p>
<p>设置IP log</p>
<p>D/CommandListener( 377): Setting iface cfg</p>
<p>清除IP log</p>
<p>D/CommandListener( 315): Clearing all IP addresses on eth0</p>
<p>切换默认网络 log</p>
<p>D/ConnectivityService( 808): Switching to new default network:</p>
<p>修改获取settings值</p>
<p>settings put global disable_static_ip_assignment 1</p>
<p>settings list global | grep disable_static_ip_assignment</p>
<p><strong>网络评分机制：</strong></p>
<p>Wifi初始分值为60（WifiStateMachine.java）； </p>
<p>Ethernet初始分值为70（EthernetNetworkFactory.java）； </p>
<p>Mobile network初始分值为50（DataConnection.java）； </p>
<p>bt-pan初始分值为69（BluetoothTetheringNetworkFactory.java）： </p>
<p>当网络与internet不通时，分值减去40</p>
<p>如果用户指定，直接返回100</p>
<p><strong>网络优先级设置</strong></p>
<p>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/">frameworks</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/">base</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/">core</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/">res</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/">res</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/values/">values</a>/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/values/config.xml">config.xml</a></p>
<p>会被device/qcom/msmnile_gvmq/overlay/frameworks/base/core/res/res/values/<a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/res/res/values/config.xml">config.xml</a>覆盖</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/5BC4AEC6991443E983498E6AA22F9F99/1020" alt="0"></p>
<p>网卡配置</p>
<p>​    <img src="https://note.youdao.com/yws/public/resource/814f9f6c089a4f998f1b24ec2cab599b/xmlnote/9B8F39D556FA4051925AF1B7FC00E447/1018" alt="0"></p>
<p><strong>X5R项目：</strong></p>
<p>eth0网卡配置取消网络能力12 13 14 15</p>
<p>配置规则：</p>
<p>ip rule add from 192.168.1.3 table 100<br>ip rule add to 192.168.1.1 table 100<br>ip route add 192.168.1.0/24 dev eth0 src 192.168.1.3 table 100</p>
<p>拉起浏览器界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">am start -a android.intent.action.VIEW -d http://www.baidu.com</span><br></pre></td></tr></table></figure>


<h4 id="双APN配置："><a href="#双APN配置：" class="headerlink" title="双APN配置："></a>双APN配置：</h4><p><img src="/2021/04/01/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/blog\source_posts\调查车机无法上网\双APN配置.png" alt="双APN配置"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>车机无法上网</tag>
      </tags>
  </entry>
  <entry>
    <title>调查车机重启_RescueParty机制</title>
    <url>/2021/07/27/%E8%B0%83%E6%9F%A5%E8%BD%A6%E6%9C%BA%E9%87%8D%E5%90%AF-RescueParty%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>​    车机开启之后，一直重启，仪表屏幕正常。通过CAN工具可以和仪表交互。</p>
<h4 id="2-问题定位"><a href="#2-问题定位" class="headerlink" title="2.问题定位"></a>2.问题定位</h4><p>​    因为我们车机是QNX和Android双系统，从现象来看，仪表正常，说明QNX是正常的，初步定位是Android系统重启。拼手速导出log/log中的日志开始分析。</p>
<pre><code> 首先一想Android系统重启，必然是系统服务出了问题，一般应用重启不会导致系统重启。Android O中增加了一个新的功能，当核心系统组件发生循环崩溃的时候，就会触发“救援程序”。
</code></pre>
<p>搜先搜索：<strong>“AndroidRuntime”</strong>可以看到哪些进程出问题了，被系统杀掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> I/CarAudioManager( <span class="number">1599</span>): reconnect service</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): FATAL EXCEPTION: main</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): Process: com.android.car, PID: <span class="number">2632</span></span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): java.lang.RuntimeException: Unable to create service com.android.car.CarService: java.lang.IllegalStateException: Vehicle HAL service is not available.</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3582</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.access$<span class="number">1300</span>(ActivityThread.java:<span class="number">200</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">1672</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.os.Handler.dispatchMessage(Handler.java:<span class="number">106</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.os.Looper.loop(Looper.java:<span class="number">193</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6718</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">493</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">858</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): Caused by: java.lang.IllegalStateException: Vehicle HAL service is not available.</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at com.android.car.CarService.onCreate(CarService.java:<span class="number">82</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3570</span>)</span><br><span class="line"><span class="number">1</span> E/AndroidRuntime( <span class="number">2632</span>): ... <span class="number">8</span> more</span><br></pre></td></tr></table></figure>
<p>从上面日志可以看出CarService一直再重启，但是服务一直重启为什么会导致系统重启呢？</p>
<p>为了方便观看，省略时间戳等非必要信息，搜索:”RescueParty”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">0</span> in last <span class="number">7</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">12</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">13</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">13</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">13</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level RESET_SETTINGS_UNTRUSTED_DEFAULTS</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">14</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level RESET_SETTINGS_UNTRUSTED_CHANGES</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level RESET_SETTINGS_TRUSTED_DEFAULTS</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">1</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">15</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">2</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">3</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">4</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Noticed <span class="number">5</span> events <span class="keyword">for</span> UID <span class="number">1000</span> in last <span class="number">16</span> sec</span><br><span class="line"><span class="number">1</span> W/RescueParty( <span class="number">765</span>): Attempting rescue level FACTORY_RESET</span><br><span class="line"><span class="number">1</span> I<span class="comment">//system/bin/uncrypt( 2649): --reason=RescueParty</span></span><br></pre></td></tr></table></figure>
<p>原因就在这里，Android从O版本之后退出了系统救援机制，当系统关键服务或者重启之后都会做一个标记，如果超过阈值了，就会恢复出厂设置，重启车机。</p>
<h4 id="3-RescueParty机制"><a href="#3-RescueParty机制" class="headerlink" title="3.RescueParty机制"></a>3.RescueParty机制</h4><p>先把结论说出来，然后一一代码证实。</p>
<p><strong>结论：</strong>救援机制把救援事件分成5类，每次应用或者systemserver在一定时间重启5次，救援级别就会加一，当达到4级救援，就恢复出厂设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 救援级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_NONE = <span class="number">0</span>;   <span class="comment">// 默认救援为0级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_FACTORY_RESET = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>上述的一定时间是：SystemServer在5分钟内重启五次触发一次救援。persistent app在30秒内重启5次触发一次救援。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BootThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We&#x27;re interested in 5 events in any 300 second period; this</span></span><br><span class="line">    <span class="comment">// window is super relaxed because booting can take a long time if</span></span><br><span class="line">    <span class="comment">// forced to dexopt things.</span></span><br><span class="line">    <span class="comment">// 5代表5次，300代表300s</span></span><br><span class="line">    <span class="keyword">super</span>(android.os.Process.ROOT_UID, <span class="number">5</span>, <span class="number">300</span> * DateUtils.SECOND_IN_MILLIS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AppThreshold</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We&#x27;re interested in 5 events in any 30 second period; apps crash</span></span><br><span class="line">    <span class="comment">// pretty quickly so we can keep a tight leash on them.</span></span><br><span class="line">    <span class="comment">// 5代表5次，30代表30s</span></span><br><span class="line">    <span class="keyword">super</span>(uid, <span class="number">5</span>, <span class="number">30</span> * DateUtils.SECOND_IN_MILLIS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>好了，阈值我们设置好了，那我们来看看在哪里标记的呢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app crash</span></span><br><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/AppErrors.java中 </span></span><br><span class="line"><span class="comment">// crashApplicationInner()方法，当应用crash了就判断是不是persistent应用，如果是就标记一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If a persistent app is stuck in a crash loop, the device isn&#x27;t very</span></span><br><span class="line"><span class="comment">// usable, so we want to consider sending out a rescue party.</span></span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.persistent) &#123;</span><br><span class="line">	RescueParty.notePersistentAppCrash(mContext, r.uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemServer.java</span></span><br><span class="line"><span class="comment">// 当SystemServer启动的时候，调用救援服务做一个标记</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	.....</span><br><span class="line">	<span class="comment">// Now that we have the bare essentials of the OS up and running, take</span></span><br><span class="line">    <span class="comment">// note that we just booted, which might send out a rescue party if</span></span><br><span class="line">    <span class="comment">// we&#x27;re stuck in a runtime restart loop.</span></span><br><span class="line">    RescueParty.noteBoot(mSystemContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以看到当应用crash和SystemServer重启都会调用到RescueParty的方法取做标记。</p>
<p>下面我们来看一下RescueParty的两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noteBoot</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDisabled()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// incrementAndTest()判断是否需要提升救援级别。如果在上诉的时间内启动达到5次就提升救援级别</span></span><br><span class="line">    <span class="keyword">if</span> (sBoot.incrementAndTest()) &#123;</span><br><span class="line">        sBoot.reset();</span><br><span class="line">        <span class="comment">//提升救援级别</span></span><br><span class="line">        incrementRescueLevel(sBoot.uid);</span><br><span class="line">        <span class="comment">// 执行救援级别，当达到4级就恢复出厂设置</span></span><br><span class="line">        executeRescueLevel(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notePersistentAppCrash</span><span class="params">(Context context, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDisabled()) <span class="keyword">return</span>;</span><br><span class="line">    Threshold t = sApps.get(uid);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> AppThreshold(uid);</span><br><span class="line">        sApps.put(uid, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无论app还是systemserver都会调到这里面去。</span></span><br><span class="line">    <span class="keyword">if</span> (t.incrementAndTest()) &#123;</span><br><span class="line">        t.reset();</span><br><span class="line">        incrementRescueLevel(t.uid);</span><br><span class="line">        executeRescueLevel(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从上面方法看到，无论app crash还是systemserver启动都会调到以下三个方法：</p>
<ul>
<li>incrementAndTest()：判断是否需要提升救援级别。如果在上诉的时间内启动达到5次就提升救援级别</li>
<li>incrementRescueLevel(t.uid)：提升指定UID的救援级别</li>
<li>executeRescueLevel(context)：执行救援服务</li>
</ul>
<p>下面我们分别分析上诉三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">incrementAndTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> window = now - getStart();</span><br><span class="line">    <span class="comment">// 如果小于阈值时间，更新时间</span></span><br><span class="line">    <span class="keyword">if</span> (window &gt; triggerWindow) &#123;</span><br><span class="line">        setCount(<span class="number">1</span>);</span><br><span class="line">        setStart(now);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> count = getCount() + <span class="number">1</span>;</span><br><span class="line">        setCount(count);  <span class="comment">// 设置阈值次数</span></span><br><span class="line">        EventLogTags.writeRescueNote(uid, count, window);</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Noticed &quot;</span> + count + <span class="string">&quot; events for UID &quot;</span> + uid + <span class="string">&quot; in last &quot;</span></span><br><span class="line">        + (window / <span class="number">1000</span>) + <span class="string">&quot; sec&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (count &gt;= triggerCount);  <span class="comment">// 如果大于阈值次数返回true，提升救援级别</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incrementRescueLevel</span><span class="params">(<span class="keyword">int</span> triggerUid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前级别并且级别加1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> level = MathUtils.constrain(</span><br><span class="line">    	SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE) + <span class="number">1</span>,</span><br><span class="line">   		LEVEL_NONE, LEVEL_FACTORY_RESET);</span><br><span class="line">    <span class="comment">// 设置到属性服务中</span></span><br><span class="line">    SystemProperties.set(PROP_RESCUE_LEVEL, Integer.toString(level));</span><br><span class="line"></span><br><span class="line">    EventLogTags.writeRescueLevel(level, triggerUid);</span><br><span class="line">    logCriticalInfo(Log.WARN, <span class="string">&quot;Incremented rescue level to &quot;</span></span><br><span class="line">    	+ levelToString(level) + <span class="string">&quot; triggered by UID &quot;</span> + triggerUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeRescueLevel</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 从属性服务中获取救援级别</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> level = SystemProperties.getInt(PROP_RESCUE_LEVEL, LEVEL_NONE);</span><br><span class="line">        <span class="keyword">if</span> (level == LEVEL_NONE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Attempting rescue level &quot;</span> + levelToString(level));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 救援级别执行对应任务</span></span><br><span class="line">            executeRescueLevelInternal(context, level);</span><br><span class="line">            EventLogTags.writeRescueSuccess(level);</span><br><span class="line">            logCriticalInfo(Log.DEBUG,</span><br><span class="line">                    <span class="string">&quot;Finished rescue level &quot;</span> + levelToString(level));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">final</span> String msg = ExceptionUtils.getCompleteMessage(t);</span><br><span class="line">            EventLogTags.writeRescueFailure(level, msg);</span><br><span class="line">            logCriticalInfo(Log.ERROR,</span><br><span class="line">                    <span class="string">&quot;Failed rescue level &quot;</span> + levelToString(level) + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeRescueLevelInternal</span><span class="params">(Context context, <span class="keyword">int</span> level)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_RESET_SETTINGS_UNTRUSTED_DEFAULTS:</span><br><span class="line">                <span class="comment">// 单纯更新状态</span></span><br><span class="line">                resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_DEFAULTS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_RESET_SETTINGS_UNTRUSTED_CHANGES:</span><br><span class="line">                resetAllSettings(context, Settings.RESET_MODE_UNTRUSTED_CHANGES);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_RESET_SETTINGS_TRUSTED_DEFAULTS:</span><br><span class="line">                resetAllSettings(context, Settings.RESET_MODE_TRUSTED_DEFAULTS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEVEL_FACTORY_RESET:</span><br><span class="line">                <span class="comment">// 达到恢复出厂级别，才真正有事情干</span></span><br><span class="line">                RecoverySystem.rebootPromptAndWipeUserData(context, TAG);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>从executeRescueLevelInternal方法中可以看到，真正干事的是达到<code>LEVEL_FACTORY_RESET</code>级别，才有事情干。因此直接分析rebootPromptAndWipeUserData()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建重启指令，调用bootCommand()重启车机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebootPromptAndWipeUserData</span><span class="params">(Context context, String reason)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String reasonArg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">            reasonArg = <span class="string">&quot;--reason=&quot;</span> + sanitizeArg(reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String localeArg = <span class="string">&quot;--locale=&quot;</span> + Locale.getDefault().toString();</span><br><span class="line">        bootCommand(context, <span class="keyword">null</span>, <span class="string">&quot;--prompt_and_wipe_data&quot;</span>, reasonArg, localeArg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bootCommand</span><span class="params">(Context context, String... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        LOG_FILE.delete();</span><br><span class="line">        StringBuilder command = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] var3 = args;</span><br><span class="line">        <span class="keyword">int</span> var4 = args.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String arg = var3[var5];</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(arg)) &#123;</span><br><span class="line">                command.append(arg);</span><br><span class="line">                command.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 重启车机</span></span><br><span class="line">        RecoverySystem rs = (RecoverySystem)context.getSystemService(<span class="string">&quot;recovery&quot;</span>);</span><br><span class="line">        rs.rebootRecoveryWithCommand(command.toString());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Reboot failed (no permissions?)&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-问题回溯"><a href="#4-问题回溯" class="headerlink" title="4.问题回溯"></a>4.问题回溯</h4><p>可以从第二节看到，CarService发生crash，触发了<code>FACTORY_RESET</code>救援，所以车机恢复出厂设置，然后重启了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>系统重启</tag>
      </tags>
  </entry>
  <entry>
    <title>调用Android原生@SystemApi、@Hide方法和解决混淆问题</title>
    <url>/2021/03/08/%E8%B0%83%E7%94%A8Android%E5%8E%9F%E7%94%9F-SystemApi%E5%92%8C-Hide%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-关于-SystemApi和-Hide方法"><a href="#1-关于-SystemApi和-Hide方法" class="headerlink" title="1.关于@SystemApi和@Hide方法"></a>1.关于@SystemApi和@Hide方法</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-9e5be0ee94f529c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统api.png"></p>
<p>如上图所示，PackageManager.getPermissionFlags()方法是被@SystemApi注解修饰过的方法，@SystemApi 只允许system app 调用或者用反射方法调用, 反射方法实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.mPackageManager = context.getPackageManager();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = mPackageManager.getClass(). getMethod(<span class="string">&quot;getPermissionFlags&quot;</span>);</span><br><span class="line">    method.invoke(mPackageManager, permName, packageName, user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是非 system app 用反射方法调用SystemApi，即使编译通过， 实际运行是还会遇到permission check。例如getPermissionFlags就需要GRANT_RUNTIME_PERMISSIONS，REVOKE_RUNTIME_PERMISSIONS，GET_RUNTIME_PERMISSIONS中的任意一个，如果应用没有申请这其中的任意一个权限，运行是也会报错。申请了以上三个中任意一个权限，就需要有系统签名。归根究底，要调用系统API就必须要系统签名，否则即使编译成功了，运行时也会报错。</p>
<h3 id="2-源码编译模块"><a href="#2-源码编译模块" class="headerlink" title="2.源码编译模块"></a>2.源码编译模块</h3><p>在使用mk文件编译的时候，会有<strong>LOCAL_PRIVATE_PLATFORM_APIS</strong>和<strong>LOCAL_SDK_VERSION</strong>参数选择，在mk文件中声明这两个参数的时候是互斥的，意思是只能<strong>声明其中一个</strong>。</p>
<ul>
<li><strong>LOCAL_PRIVATE_PLATFORM_APIS</strong>设置之后，如果模块中有用到系统api，会使用sdk的hide的api来编译。</li>
<li><strong>LOCAL_SDK_VERSION</strong>设置之后，编译的应用不能访问hide的api，会报找不到该方法错误。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//报错内容</span></span><br><span class="line">pdk/apps/Permission/src/com/xh/permission/server/CarPermissionManagerService.java:<span class="number">269</span>: error: cannot find symbol</span><br><span class="line">     <span class="keyword">int</span> flags = <span class="keyword">this</span>.mPackageManager.getPermissionFlags(permissionInfo.name, packageInfo.packageName, Process.myUserHandle());</span><br><span class="line">                         ^</span><br><span class="line">  	symbol:   <span class="function">method <span class="title">getPermissionFlags</span><span class="params">(String,String,UserHandle)</span></span></span><br><span class="line"><span class="function"> 	location: variable mPackageManager of type PackageManager</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5f51673cf8003d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译找不到方法.png"></p>
<h3 id="3-调用原生api总结"><a href="#3-调用原生api总结" class="headerlink" title="3.调用原生api总结"></a>3.调用原生api总结</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以调用系统的api，但是需要给apk系统签名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LOCAL_CERTIFICATE := platform</span></span><br><span class="line">LOCAL_PRIVATE_PLATFORM_APIS := true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译时忽略系统隐藏类(@hide)</span></span><br><span class="line">LOCAL_SDK_VERSION := current</span><br></pre></td></tr></table></figure>


<h3 id="4-编译混淆问题"><a href="#4-编译混淆问题" class="headerlink" title="4.编译混淆问题"></a>4.编译混淆问题</h3><p>在编译过程中如果遇到如下图编译报错，或者如下提示：</p>
<blockquote>
<ol>
<li>If there are unresolved references to class members in <em>program classes</em>, your compiled class files are most likely inconsistent. Possibly, some class file didn’t get recompiled properly, or some class file was left behind after its source file was removed. Try removing all compiled class files and rebuilding your project.</li>
<li>If there are unresolved references to class members in <em>library classes</em>, your compiled class files are inconsistent with the libraries. You may need to recompile the class files, or otherwise upgrade the libraries to consistent versions.</li>
</ol>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-16e869614f36b453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未配置混淆文件报错.png"></p>
<p>就可以归纳为<a href="https://www.guardsquare.com/en/products/proguard/manual/troubleshooting#unresolvedprogramclassmember">代码混淆配置问题</a>。</p>
<h3 id="5-解决办法"><a href="#5-解决办法" class="headerlink" title="5.解决办法"></a>5.解决办法</h3><p>源码编译时会用ProGuard混淆器做代码混淆、优化，过程中可能会删除掉个别类里的个别方法。</p>
<p>处理代码混淆问题有两个方法：</p>
<ul>
<li>在mk文件里加上一句：LOCAL_PROGUARD_ENABLED := disabled，禁用混淆器。</li>
<li>在mk文件里加上一句：LOCAL_PROGUARD_FLAG_FILES := proguard.flags，然后创建一个配置文件”proguard.flags”，配置部分类/方法/属性禁止混淆。(可以参照源码环境下的Settings里写法) </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####################以下是原生设置的混淆文件#######################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##########还有很多其他规则，这里不详细列举，度娘一下，你就知道##########</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a configuration file <span class="keyword">for</span> ProGuard.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> http://proguard.sourceforge.net/index.html<span class="comment">#manual/usage.html</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep all Fragments <span class="keyword">in</span> this package, <span class="built_in">which</span> are used by reflection.</span></span><br><span class="line">-keep public class com.android.settings.** extends android.app.Fragment</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep all preference controllers needed by slice and DashboardFragment.</span></span><br><span class="line">-keep class * extends com.android.settings.core.BasePreferenceController &#123;</span><br><span class="line">    *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keep class * extends com.android.settings.core.TogglePreferenceController &#123;</span><br><span class="line">    *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> We want to keep methods <span class="keyword">in</span> Activity that could be used <span class="keyword">in</span> the XML attribute onClick.</span></span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">    public void *(android.view.View);</span><br><span class="line">    public void *(android.view.MenuItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep setters <span class="keyword">in</span> Views so that animations can still work.</span></span><br><span class="line">-keep public class * extends android.view.View &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class="line"></span><br><span class="line">    void set*(***);</span><br><span class="line">    *** get*();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep classes that may be inflated from XML.</span></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">&#125;</span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class="line">&#125;</span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int, int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep annotated classes or class members.</span></span><br><span class="line">-keep @android.support.annotation.Keep class *</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep *;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep specific fields used via reflection.</span></span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    public static ** SEARCH_INDEX_DATA_PROVIDER;</span><br><span class="line">    public static ** SUMMARY_PROVIDER_FACTORY;</span><br><span class="line">&#125;</span><br><span class="line">-keep class android.support.v4.app.CoreComponentFactory</span><br></pre></td></tr></table></figure>
<h3 id="6-编译成功"><a href="#6-编译成功" class="headerlink" title="6.编译成功"></a>6.编译成功</h3><p>最后模块编译成功之后会提示如下结果</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-accf096c4234d491.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模块编译成功.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
      </tags>
  </entry>
  <entry>
    <title>静态缓存与Native异常</title>
    <url>/2021/06/29/%E9%9D%99%E6%80%81%E7%BC%93%E5%AD%98%E4%B8%8ENative%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h4 id="1-非静态缓存案例分析"><a href="#1-非静态缓存案例分析" class="headerlink" title="1.非静态缓存案例分析"></a>1.非静态缓存案例分析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_localCache(JNIEnv *env, jclass clazz, jstring name) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态缓存</span></span><br><span class="line">    jfieldID f_id = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f_id == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次调用localCache方法都会获取一次jfieldID，如果频繁调用该方法会影响性能</span></span><br><span class="line">        f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name1&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;空的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_id, name); <span class="comment">// 修改 AAA</span></span><br><span class="line"></span><br><span class="line">    f_id = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-静态缓存"><a href="#2-静态缓存" class="headerlink" title="2. 静态缓存"></a>2. 静态缓存</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在方法外定义需要静态缓存的变量</span></span><br><span class="line"><span class="keyword">static</span> jfieldID f_name1_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name2_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name3_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name4_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name5_id = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name6_id = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化缓存变量，</span></span><br><span class="line"><span class="comment">// 先缓存。此方法应该在java构造方法中调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_initStaticCache(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    f_name1_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name1&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name2_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name2&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name3_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name3&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name4_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name4&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name5_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name5&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    f_name6_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name6&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用缓存变量</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_staticCache(JNIEnv *env, jclass clazz, jstring name) &#123;</span><br><span class="line">    <span class="comment">// 不会反复 GetStaticFieldID 提供性能</span></span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name1_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name2_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name3_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name4_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name5_id, name);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, f_name6_id, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.清除缓存变量</span></span><br><span class="line"><span class="comment">// 清除，此方法应该在onDestory中调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity2_clearStaticCache(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    f_name1_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name2_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name3_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name4_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name5_id = <span class="literal">nullptr</span>;</span><br><span class="line">    f_name6_id = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-Native异常监测"><a href="#3-Native异常监测" class="headerlink" title="3. Native异常监测"></a>3. Native异常监测</h4><h5 id="3-1-方法内部补救"><a href="#3-1-方法内部补救" class="headerlink" title="3.1 方法内部补救"></a>3.1 方法内部补救</h5><p>native方法中监控异常，如果有的话就处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_derry_as_1jni_1project_MainActivity3_exception(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    <span class="comment">// 假设现在想操作 name999 ，没有name999就会在native层奔溃掉</span></span><br><span class="line">    jfieldID f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name999&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1 补救措施</span></span><br><span class="line">	<span class="comment">// 监测本次执行，到底有没有异常   JNI函数里面代码有问题</span></span><br><span class="line">    jthrowable thr =  env-&gt;ExceptionOccurred(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(thr) &#123; <span class="comment">// 非0 进去，监测到有异常</span></span><br><span class="line">        LOGD(<span class="string">&quot;C++层有异常 监测到了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env-&gt;ExceptionClear(); <span class="comment">// 此异常被清除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 补救措施</span></span><br><span class="line">        jfieldID f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name1&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-2-向java层抛异常"><a href="#3-2-向java层抛异常" class="headerlink" title="3.2 向java层抛异常"></a>3.2 向java层抛异常</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_derry_as_1jni_1project_MainActivity3_exception2(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    <span class="comment">// 假设现在想操作 name999 ，没有name999就会在native层奔溃掉</span></span><br><span class="line">    jfieldID f_id = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;name8888&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2 往Java层抛</span></span><br><span class="line"></span><br><span class="line">    jthrowable jthrowable = env-&gt;ExceptionOccurred(); <span class="comment">// 监测本次执行，到底有没有异常   JNI函数里面代码有问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(jthrowable) &#123; <span class="comment">// 非0 进去，监测到有异常</span></span><br><span class="line">        LOGD(<span class="string">&quot;C++层有异常 监测到了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env-&gt;ExceptionClear(); <span class="comment">// 此异常被清除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Throw抛一个 Java的对象     java/lang/String    java/xxxxx/xxx/NullExxx</span></span><br><span class="line">        jclass clz = env-&gt;FindClass(<span class="string">&quot;java/lang/NoSuchFieldException&quot;</span>);</span><br><span class="line">        env-&gt;ThrowNew(clz, <span class="string">&quot;NoSuchFieldException 实在是找不到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-Native监控java抛的异常"><a href="#3-3-Native监控java抛的异常" class="headerlink" title="3.3 Native监控java抛的异常"></a>3.3 Native监控java抛的异常</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java直接抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> throws Exception </span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;show: 1111&quot;</span>);</span><br><span class="line">    Log.d(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;show: 1111&quot;</span>);</span><br><span class="line">    Log.d(<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;show: 1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;我是Java中抛出的异常，我的show方法里面发送了Java逻辑错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_Jack_as_1jni_1project_MainActivity3_exception3(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    jmethodID showID = env-&gt;GetStaticMethodID(clazz, <span class="string">&quot;show&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="comment">// 会不会立马崩溃？</span></span><br><span class="line">    <span class="comment">// 不会，只是CallStaticVoidMethod调用引起的，但是不会崩溃，因为ExceptionCheck()会监测此处崩溃，并且打出日志</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(clazz, showID); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExceptionCheck 《==》 慢慢的奔溃的，相当于给了你空余时间，既然不是马上奔溃，我就可以检测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JNI函数里面代码有问题 没有问题，给你空余时间，慢慢的奔溃的</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        env-&gt;ExceptionDescribe(); <span class="comment">// 输出描述 信息</span></span><br><span class="line">        env-&gt;ExceptionClear(); <span class="comment">// 此异常被清除    业务逻辑控制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意实现：</span></span><br><span class="line">    <span class="comment">/*// 奔溃后，下面的语句，照样打印</span></span><br><span class="line"><span class="comment">    LOGI(&quot;C++层&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1&quot;);</span></span><br><span class="line"><span class="comment">    LOGI(&quot;C++层&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;2&quot;);</span></span><br><span class="line"><span class="comment">    LOGI(&quot;C++层&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;3&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    env-&gt;NewStringUTF(&quot;AAAA&quot;); // 局部引用 崩溃被消除*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频基础</title>
    <url>/2021/07/19/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="1-音视频解码播放流程"><a href="#1-音视频解码播放流程" class="headerlink" title="1.音视频解码播放流程"></a>1.音视频解码播放流程</h4><p>.mp4、.avi、.rmvb等格式文件是用于封装音频流和视频流的。ffmpeg在处理该类视频的流程如下，首先会解封装，将封装格式的音视频文件分成音频压缩数据和视频压缩数据。音频压缩数据然后通过解码转化为音频原始数据，最后通过音频重采样，将双声道音频转化为单声道经过扬声器播放出来；视频压缩数据通过视频解码转化为视频原始数据，然后将YUV格式的原始数据转化为RGBA通过显示器显示出来。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-28385ad168b34cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="音视频解码播放流程.png"></p>
<h4 id="2-音视频录制过程"><a href="#2-音视频录制过程" class="headerlink" title="2.音视频录制过程"></a>2.音视频录制过程</h4><p>音视频录制过程和播放过程是恰恰相反的过程。麦克风采集到pcm原始数据之后经过音频编码成acc压缩文件；原始视频文件通过编码成H.264格式的压缩数据。最后通过封包封装成mp4等视频格式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bd137e7a0ebb77e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="音视频录制编码流程.png"></p>
<h4 id="3-视频源码原理"><a href="#3-视频源码原理" class="headerlink" title="3.视频源码原理"></a>3.视频源码原理</h4><p>​    视频是连续的图像序列，由连续的帧构成，一帧即为一幅图像。由于人眼的视觉暂留效应，当帧序列以一定的速率播放时，我们看到的就是动作连续的视频。这么多连续的图像数据如果不经过编码的数据量太大了。<br>比如一个1920x1080分辨率，32位,四个字节(RGBA)，每秒30帧的视频，一秒钟需要1920x1080x4x30，大小大概为243MB数据。因此，视频需要编码压缩后保存。</p>
<h5 id="3-1-空间冗余"><a href="#3-1-空间冗余" class="headerlink" title="3.1 空间冗余"></a>3.1 空间冗余</h5><p>空间冗余：图像内部相邻像素之间存在较强的相关性多造成的冗余。</p>
<h5 id="3-2-时间冗余"><a href="#3-2-时间冗余" class="headerlink" title="3.2 时间冗余"></a>3.2 时间冗余</h5><p>时间冗余：视频图像序列中的不同帧之间的相关性所造成的冗余。</p>
<h5 id="3-3-视觉冗余"><a href="#3-3-视觉冗余" class="headerlink" title="3.3 视觉冗余"></a>3.3 视觉冗余</h5><p>视觉冗余：是指人眼不能感知或不敏感的那部分图像信息。人类对颜色的亮度不敏感，对颜色值敏感。</p>
<h5 id="3-4-信息熵冗余"><a href="#3-4-信息熵冗余" class="headerlink" title="3.4 信息熵冗余"></a>3.4 信息熵冗余</h5><p>信息熵冗余：也称编码冗余，人们用于表达某一信息所需要的比特数总比理论上表示该信息所需要的最少比特 数要大，它们之间的差距就是信息熵冗余，或称编码冗余。</p>
<h5 id="3-5-知识冗余"><a href="#3-5-知识冗余" class="headerlink" title="3.5 知识冗余"></a>3.5 知识冗余</h5><p>知识冗余：是指在有些图像中还包含与某些验证知识有关的信息</p>
<h4 id="4-帧的概念"><a href="#4-帧的概念" class="headerlink" title="4.帧的概念"></a>4.帧的概念</h4><p>视频中的帧分为I帧、B帧、P帧</p>
<ul>
<li>I帧：帧内编码帧，关键帧，I帧可以看作一个图像经过压缩之后的产物，可以单独解码出一个完整的图像； （压缩率最低）</li>
<li>P帧：前向预测/参考编码帧，记录了本帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画 面叠加上本帧定义的差别，生成最终画面。    （压缩率比I帧高，比B帧低，属于适中情况）</li>
<li>B帧：双向预测/参考    编码帧，记录了本帧与前后帧的差别，解码需要参考前面一个I帧或者P帧，同时也需要 后面的P帧才能解码一张完整的图像。    （参考前后的预测得到的，压缩率是最高，但是耗时）</li>
</ul>
<h4 id="5-H-264数据分析"><a href="#5-H-264数据分析" class="headerlink" title="5. H.264数据分析"></a>5. H.264数据分析</h4><h5 id="5-1-H-264分层结构-VCL与NAL"><a href="#5-1-H-264分层结构-VCL与NAL" class="headerlink" title="5.1 H.264分层结构(VCL与NAL)"></a>5.1 H.264分层结构(VCL与NAL)</h5><ul>
<li>VCL（Video Coding Layer，视频编码层）：负责高效的视频内容表示， VCL数据即编码处理的输出，它表示被压缩编码后的视频数据序列。</li>
<li>NAL（Network Abstraction Layer，网络提取层）：负责以网络所要求的恰当的方式对数据进行打包和 传送， 是传输层。不管在本地播放还是网络播放，都要通过这一层来传输。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-35e8bc4f754ba1b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VCL与NAL的关系图.png"></p>
<p>NAL片：一帧图片经过 H.264 编码器之后，NAL单元就是装载着这些片（被编码为一个或多个片 slice）, 每片包<br>含整数个宏块（至少一个宏块，最多包含整个图像宏块）。</p>
<p>H.264编码器的默认输出为：起始码+NALU（Nal单元）。起始码为：0x00000001或者0x000001，可以通过010editor工具看到。一个NALU包含：PPS, I帧，B帧，P帧。</p>
<p><strong>起始码主要用于每一个NALU之间的分割：</strong></p>
<ul>
<li>0x00000001 起始码代表：一个NALU里面有很多片。</li>
<li>0x000001 起始码代表：    一个NALU里面一个片。</li>
</ul>
<p>每一个NALU包含：<code>起始码</code> + <code>1个字节的Nal Header</code> + <code>若干整数字节的负荷数据EBSP</code>构成。</p>
<table>
<thead>
<tr>
<th>nal_unit_type</th>
<th>nal类型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>未使用</td>
</tr>
<tr>
<td>1</td>
<td>不分区，非IDR图像的片</td>
</tr>
<tr>
<td>2</td>
<td>片分区A</td>
</tr>
<tr>
<td>3</td>
<td>片分区B</td>
</tr>
<tr>
<td>4</td>
<td>片分区C</td>
</tr>
<tr>
<td>5</td>
<td>IDR图像中的片</td>
</tr>
<tr>
<td>6</td>
<td>补充增强信息单元（SEI）</td>
</tr>
<tr>
<td>7</td>
<td>序列参数集(SPS)</td>
</tr>
<tr>
<td>8</td>
<td>图像参数集(PPS)</td>
</tr>
<tr>
<td>9</td>
<td>分隔符</td>
</tr>
<tr>
<td>10</td>
<td>序列结束</td>
</tr>
<tr>
<td>11</td>
<td>码流结束</td>
</tr>
<tr>
<td>12</td>
<td>填充</td>
</tr>
<tr>
<td>13-23</td>
<td>保留</td>
</tr>
<tr>
<td>14-31</td>
<td>未使用</td>
</tr>
</tbody></table>
<p>nal头部分为八位：01100111</p>
<ul>
<li><p>第1位禁止位，值为1表示语法出错</p>
</li>
<li><p>第2~3位为参考级别(重要级别)</p>
</li>
<li><p>第4~8为是nal单元类型</p>
</li>
</ul>
<p><strong>其中0x67的二进制码为：</strong><br>0110 0111<br>4-8为00111，转为十进制7，7对应序列参数集SPS</p>
<p><strong>其中0x68的二进制码为：</strong><br>0110 1000<br>4-8为01000，转为十进制8，8对应图像参数集PPS</p>
<p><strong>其中0x65的二进制码为：</strong><br>0110 0101<br>4-8为00101，转为十进制5，6代表重要，5对应IDR图像中的片(I帧)</p>
<p><strong>其中0x61/0x41的二进制码为：</strong><br>0110 0001 / 0100 0001<br>4-8为00001，转为十进制1，6和4代表重要，1对应非IDR图像中的片(P帧)</p>
<p><strong>其中0x01的二进制码为：</strong><br>0000 0001<br>4-8为00001，转为十进制1，0代表不重要，1对应非IDR图像中的片(B帧)</p>
<h4 id="6-PTS与DTS"><a href="#6-PTS与DTS" class="headerlink" title="6.PTS与DTS"></a>6.PTS与DTS</h4><p>DTS表示解码时间戳，在什么时候解码这一帧的数据；PTS表示显示时间戳，在什么时候显示这一帧。</p>
<p>在没有B帧的情况下，DTS和PTS的输出顺序是一样的。因为B帧打乱了解码和显示的顺序（要解码B帧需要先解码后面的P帧），所以一旦存在B帧，PTS和DTS就会不同。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-726f6b29680fe2fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GOP.jpg"></p>
<p>GOP是用于表示两个I帧之间的分组。例如：I P B P B P B P B I 一组</p>
<h4 id="7-ffmpeg解封装解码流程"><a href="#7-ffmpeg解封装解码流程" class="headerlink" title="7.ffmpeg解封装解码流程"></a>7.ffmpeg解封装解码流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-e22d2c930bb8ee84.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ffmpeg解封装解码流程API概况.jpg"></p>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>预编译与常用jni函数</title>
    <url>/2021/06/25/%E9%A2%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%B8%B8%E7%94%A8jni%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1-预编译器"><a href="#1-预编译器" class="headerlink" title="1. 预编译器"></a>1. 预编译器</h4><p>预处理器不是编译器，预处理器主要完成文本替换的操作，主要完成文本拷贝或者替换工作。预处理器都是用 #xxx 的写法，并不是注释。预处理器主要对<code>#</code>标记的内容进行处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include  导入头文件</span><br><span class="line">#if       if判断操作  【if的范畴 必须endif】</span><br><span class="line">#elif     else if</span><br><span class="line">#else     else</span><br><span class="line">#endif    结束if</span><br><span class="line">#define   定义一个宏</span><br><span class="line">#ifdef    如果定义了这个宏 【if的范畴 必须endif】</span><br><span class="line">#ifndef   如果没有定义这个宏 【if的范畴 必须endif】</span><br><span class="line">#undef    取消宏定义</span><br><span class="line">#pragma   设定编译器的状态</span><br></pre></td></tr></table></figure>


<h5 id="1-1-宏函数的优缺点"><a href="#1-1-宏函数的优缺点" class="headerlink" title="1.1 宏函数的优缺点"></a>1.1 宏函数的优缺点</h5><ul>
<li>优点：文本替换，不会造成函数的调用开销(开辟栈空间，形参压栈，函数弹栈释放。</li>
<li>缺点：会导致代码体积增大</li>
</ul>
<h5 id="1-2-宏函数"><a href="#1-2-宏函数" class="headerlink" title="1.2 宏函数"></a>1.2 宏函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(V) cout &lt;&lt; V &lt;&lt; endl; <span class="comment">// 参数列表 无需类型  返回值 看不到</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(n1, n2) n1 + n2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHE(n1, n2) n1 * n2 <span class="comment">// 故意制作问题 ，宏函数的注意事项,*可能替换后会优先运算乘积</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂的宏函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGIN(V) <span class="meta-keyword">if</span>(V==1) &#123;                         \</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;满足 你输入的是:&quot;</span> &lt;&lt; V &lt;&lt; <span class="built_in">endl</span>;        \</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                                             \</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不满足 你输入的是:&quot;</span> &lt;&lt; V &lt;&lt; <span class="built_in">endl</span>;       \</span><br><span class="line">&#125; <span class="comment">// 这个是结尾，不需要加 \</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SHOW(<span class="number">8</span>);</span><br><span class="line">    SHOW(<span class="number">8.8f</span>);</span><br><span class="line">    SHOW(<span class="number">8.99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = ADD(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    r = ADD(<span class="number">1</span>+<span class="number">1</span>, <span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r = CHE(1+1, 2+2);</span></span><br><span class="line">    r = <span class="number">1</span>+<span class="number">1</span> * <span class="number">2</span>+<span class="number">2</span>; <span class="comment">// 文本替换：1+1 * 2+2  先算乘法  最终等于 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 我们认为的是8，   但是打印5</span></span><br><span class="line"></span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    LOGIN(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 会导致代码体积增大</span></span><br><span class="line"></span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    show();</span><br><span class="line">    <span class="comment">// 普通函数，每次都会进栈 弹栈 ，不会导致代码体积增大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-操作java对象"><a href="#2-操作java对象" class="headerlink" title="2. 操作java对象"></a>2. 操作java对象</h4><h5 id="2-1-函数签名"><a href="#2-1-函数签名" class="headerlink" title="2.1 函数签名"></a>2.1 函数签名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;签名规则 大写</span><br><span class="line">&#x2F;&#x2F; MainActivity必须是.class</span><br><span class="line">javap -s -p MainActivity     </span><br><span class="line"></span><br><span class="line">Java的boolean  --- Z  注意点</span><br><span class="line">Java的byte  --- B</span><br><span class="line">Java的char  --- C</span><br><span class="line">Java的short  --- S</span><br><span class="line">Java的int  --- I</span><br><span class="line">Java的long  --- J     注意点</span><br><span class="line">Java的float  --- F</span><br><span class="line">Java的double  --- D</span><br><span class="line">Java的void  --- V</span><br><span class="line">Java的引用类型  --- Lxxx&#x2F;xxx&#x2F;xx&#x2F;类名;</span><br><span class="line">Java的String  --- Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">Java的array  int[]  --- [I         double[][][][]  --- [[[D</span><br><span class="line">int add(char c1, char c2) ---- (CC)I</span><br><span class="line">void a()     &#x3D;&#x3D;&#x3D;  ()V</span><br><span class="line"></span><br><span class="line">javap -s -p xxx.class    -s 输出xxxx.class的所有属性和方法的签名，   -p 忽略私有公开的所有属性方法全部输出</span><br></pre></td></tr></table></figure>


<h5 id="2-2-log工具宏"><a href="#2-2-log工具宏" class="headerlink" title="2.2 log工具宏"></a>2.2 log工具宏</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NDK工具链里面的 log 库 引入过来</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">&quot;JACK&quot;</span></span></span><br><span class="line"><span class="comment">// ... 我都不知道传入什么  借助JNI里面的宏来自动帮我填充</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>


<h5 id="2-3-方法定义说明"><a href="#2-3-方法定义说明" class="headerlink" title="2.3 方法定义说明"></a>2.3 方法定义说明</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extern &quot;C&quot;： 必须采用C的编译方式，为什么，请看JNIEnv内部源码</span></span><br><span class="line"><span class="comment">// // 无论是C还是C++ 最终是调用到 C的JNINativeInterface，所以必须采用C的方式 extern &quot;C&quot;</span></span><br><span class="line"><span class="comment">// 函数的实现</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT  <span class="comment">// 标记该方法可以被外部调用（VS上不加入 运行会报错， AS上不加入运行没有问题）</span></span><br><span class="line"><span class="comment">// Linux运行不加入，不报错,  Win 你必须加入 否则运行报错</span></span><br><span class="line"></span><br><span class="line">jstring <span class="comment">// Java &lt;---&gt; native 转换用的</span></span><br><span class="line"></span><br><span class="line">JNICALL <span class="comment">// 代表是 JNI标记，可以少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java_包名_类名_方法名  ，注意：我们的包名 _     native _1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JNIEnv * env  JNI：的桥梁环境    300多个函数，所以的JNI操作，必须靠他</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jobject jobj  谁调用，就是谁的实例  MainActivity this</span></span><br><span class="line"><span class="comment">// jclass clazz 谁调用，就是谁的class MainActivity.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包名代下划线，声明出来的函数名会以“1 2 3”表示包名中下划线个数</span></span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_getStringPwd</span><br><span class="line">        (JNIEnv * env, jobject jobj) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-4-静态函数定义"><a href="#2-4-静态函数定义" class="headerlink" title="2.4 静态函数定义"></a>2.4 静态函数定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数2是jclass</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_getStringPwd2(JNIEnv *env, jclass clazz) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement getStringPwd2()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-5-普通函数"><a href="#2-5-普通函数" class="headerlink" title="2.5 普通函数"></a>2.5 普通函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是jobject</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jcak_as_1jni_1project_MainActivity_changeName(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">   <span class="comment">// 获取class</span></span><br><span class="line">   jclass j_cls = env-&gt;GetObjectClass(thiz);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取属性  L对象类型 都需要L</span></span><br><span class="line">   <span class="comment">// jfieldID GetFieldID(MainActivity.class, 属性名, 属性的签名)</span></span><br><span class="line">   jfieldID j_fid = env-&gt;GetFieldID(j_cls, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 转换工作 jobject转化jstring从父转化成子使用静态转化</span></span><br><span class="line">   jstring j_str = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;GetObjectField(thiz ,j_fid));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打印字符串目标，GetStringUTFChars返回const char *，接收需要常量转化</span></span><br><span class="line">   <span class="keyword">char</span> * c_str = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(env-&gt;GetStringUTFChars(j_str, <span class="literal">NULL</span>));</span><br><span class="line">    LOGD(<span class="string">&quot;native : %s\n&quot;</span>, c_str);</span><br><span class="line">    LOGE(<span class="string">&quot;native : %s\n&quot;</span>, c_str);</span><br><span class="line">    LOGI(<span class="string">&quot;native : %s\n&quot;</span>, c_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改成 Beyond</span></span><br><span class="line">    jstring jName = env-&gt;NewStringUTF(<span class="string">&quot;Beyond&quot;</span>);</span><br><span class="line">    env-&gt;SetObjectField(thiz, j_fid, jName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// printf()  C</span></span><br><span class="line">   <span class="comment">// cout &lt;&lt; &lt;&lt; endl; // C++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-6-修改静态变量"><a href="#2-6-修改静态变量" class="headerlink" title="2.6 修改静态变量"></a>2.6 修改静态变量</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_changeAge(JNIEnv *env, jclass jcls) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> * sig = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	<span class="comment">//获取静态变量</span></span><br><span class="line">   jfieldID j_fid = env-&gt;GetStaticFieldID(jcls, <span class="string">&quot;age&quot;</span>, sig);</span><br><span class="line">	<span class="comment">// 获取值</span></span><br><span class="line">   jint age = env-&gt;GetStaticIntField(jcls, j_fid);</span><br><span class="line"></span><br><span class="line">   age += <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 修改值</span></span><br><span class="line">   env-&gt;SetStaticIntField(jcls, j_fid, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-7-C调用java方法"><a href="#2-7-C调用java方法" class="headerlink" title="2.7 C调用java方法"></a>2.7 C调用java方法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_callAddMethod(JNIEnv *env, jobject job) &#123;</span><br><span class="line">    <span class="comment">// 自己得到 MainActivity.class</span></span><br><span class="line">    jclass  mainActivityClass = env-&gt;GetObjectClass(job);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetMethodID(MainActivity.class, 方法名, 方法的签名)</span></span><br><span class="line">   jmethodID j_mid = env-&gt;GetMethodID(mainActivityClass, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;(II)I&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 Java的方法</span></span><br><span class="line">   jint sum = env-&gt;CallIntMethod(job, j_mid, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">   LOGE(<span class="string">&quot;sum result:%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-8-操作数组"><a href="#2-8-操作数组" class="headerlink" title="2.8 操作数组"></a>2.8 操作数组</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jint == int</span></span><br><span class="line"><span class="comment">// jstring == String</span></span><br><span class="line"><span class="comment">// jintArray == int[]</span></span><br><span class="line"><span class="comment">// jobjectArray == 引用类型对象，例如 String[]   Test[]   Student[]  Person[]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_testArrayAction(JNIEnv *env, jobject thiz,</span><br><span class="line">                                                             jint count,</span><br><span class="line">                                                             jstring text_info,</span><br><span class="line">                                                             jintArray ints,</span><br><span class="line">                                                             jobjectArray strs) &#123;</span><br><span class="line">    <span class="comment">// ① 基本数据类型  jint count， jstring text_info， 最简单的</span></span><br><span class="line">    <span class="keyword">int</span> countInt = count; <span class="comment">// jint本质是int，所以可以用int接收</span></span><br><span class="line">    LOGI(<span class="string">&quot;参数一 countInt:%d\n&quot;</span>, countInt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const char* GetStringUTFChars(jstring string, jboolean* isCopy)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * textInfo = env-&gt;GetStringUTFChars(text_info, <span class="literal">NULL</span>);</span><br><span class="line">    LOGI(<span class="string">&quot;参数二 textInfo:%s\n&quot;</span>, textInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 把int[] 转成 int*</span></span><br><span class="line">    <span class="comment">// jint* GetIntArrayElements(jintArray array, jboolean* isCopy)</span></span><br><span class="line">    <span class="keyword">int</span>* jintArray = env-&gt;GetIntArrayElements(ints, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java层数组的长度</span></span><br><span class="line">    <span class="comment">// jsize GetArrayLength(jarray array) // jintArray ints 可以放入到 jarray的参数中去</span></span><br><span class="line">    jsize size = env-&gt;GetArrayLength(ints);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        *(jintArray+i) += <span class="number">100</span>; <span class="comment">// C++的修改，影响不了Java层</span></span><br><span class="line">        LOGI(<span class="string">&quot;参数三 int[]:%d\n&quot;</span>, *jintArray+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目前无法控制Java的数组 变化 +100</span></span><br><span class="line">    <span class="comment">// 操作杆 ----&gt; JMV</span></span><br><span class="line">    <span class="comment">// env-&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0:           刷新Java数组，并 释放C++层数组</span></span><br><span class="line"><span class="comment">     * JNI_COMMIT:  只提交 只刷新Java数组，不释放C++层数组</span></span><br><span class="line"><span class="comment">     * JNI_ABORT:   只释放C++层数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    env-&gt;ReleaseIntArrayElements(ints, jintArray, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③：jobjectArray 代表是Java的引用类型数组，不一样</span></span><br><span class="line">    jsize  strssize = env-&gt;GetArrayLength(strs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strssize; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        jstring jobj = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;GetObjectArrayElement(strs, i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模糊：isCopy内部启动的机制</span></span><br><span class="line">        <span class="comment">// const char* GetStringUTFChars(jstring string, jboolean* isCopy)</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * jobjCharp = env-&gt;GetStringUTFChars(jobj, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        LOGI(<span class="string">&quot;参数四 引用类型String 具体的：%s\n&quot;</span>, jobjCharp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放jstring</span></span><br><span class="line">        env-&gt;ReleaseStringUTFChars(jobj, jobjCharp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-9-对象处理"><a href="#2-9-对象处理" class="headerlink" title="2.9 对象处理"></a>2.9 对象处理</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jobject student == Student</span></span><br><span class="line"><span class="comment">// jstring str  == String</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_putObject(JNIEnv *env,</span><br><span class="line">                                                       jobject thiz,</span><br><span class="line">                                                       jobject student,</span><br><span class="line">                                                       jstring str) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * strChar = env-&gt;GetStringUTFChars(str, <span class="literal">NULL</span>);</span><br><span class="line">    LOGI(<span class="string">&quot;strChar：%s\n&quot;</span>, strChar);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(str, strChar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------</span></span><br><span class="line">    <span class="comment">// 1.寻找类 Student</span></span><br><span class="line">    <span class="comment">// jclass studentClass = env-&gt;FindClass(&quot;com/jack/as_jni_project/Student&quot;); // 第一种</span></span><br><span class="line">    jclass studentClass =  env-&gt;GetObjectClass(student); <span class="comment">// 第二种</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.Student类里面的函数规则  签名</span></span><br><span class="line">    jmethodID setName = env-&gt;GetMethodID(studentClass, <span class="string">&quot;setName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jmethodID getName = env-&gt;GetMethodID(studentClass, <span class="string">&quot;getName&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    jmethodID showInfo = env-&gt;GetStaticMethodID(studentClass, <span class="string">&quot;showInfo&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.调用 setName</span></span><br><span class="line">    jstring value = env-&gt;NewStringUTF(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(student, setName, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.调用 getName</span></span><br><span class="line">    jstring getNameResult = <span class="keyword">static_cast</span>&lt;jstring&gt;(env-&gt;CallObjectMethod(student, getName));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * getNameValue = env-&gt;GetStringUTFChars(getNameResult, <span class="literal">NULL</span>);</span><br><span class="line">    LOGE(<span class="string">&quot;调用到getName方法，值是:%s\n&quot;</span>, getNameValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.调用静态showInfo</span></span><br><span class="line">    jstring  jstringValue = env-&gt;NewStringUTF(<span class="string">&quot;静态方法你好，我是C++&quot;</span>);</span><br><span class="line">    env-&gt;CallStaticVoidMethod(studentClass, showInfo, jstringValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-10-对象处理进阶"><a href="#2-10-对象处理进阶" class="headerlink" title="2.10 对象处理进阶"></a>2.10 对象处理进阶</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_insertObject(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    <span class="comment">// 1.通过包名+类名的方式 拿到 Student class  凭空拿class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *studentstr = <span class="string">&quot;com/jack/as_jni_project/Student&quot;</span>;</span><br><span class="line">    jclass studentClass = env-&gt;FindClass(studentstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过student的class  实例化此Student对象   C++ new Student</span></span><br><span class="line">    jobject studentObj = env-&gt;AllocObject(studentClass); <span class="comment">// AllocObject 只实例化对象，不会调用对象的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法签名的规则</span></span><br><span class="line">    jmethodID setName = env-&gt;GetMethodID(studentClass, <span class="string">&quot;setName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jmethodID setAge = env-&gt;GetMethodID(studentClass, <span class="string">&quot;setAge&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    jstring strValue = env-&gt;NewStringUTF(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(studentObj, setName, strValue);</span><br><span class="line">    env-&gt;CallVoidMethod(studentObj, setAge, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// env-&gt;NewObject() // NewObject 实例化对象，会调用对象的构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ====================  下面是 Person对象  调用person对象的  setStudent 函数等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通过包名+类名的方式 拿到 Student class  凭空拿class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *personstr = <span class="string">&quot;com/jack/as_jni_project/Person&quot;</span>;</span><br><span class="line">    jclass personClass = env-&gt;FindClass(personstr);</span><br><span class="line"></span><br><span class="line">    jobject personObj = env-&gt;AllocObject(personClass); <span class="comment">// AllocObject 只实例化对象，不会调用对象的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setStudent 此函数的 签名 规则</span></span><br><span class="line">    jmethodID setStudent = env-&gt;GetMethodID(personClass, <span class="string">&quot;setStudent&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(Lcom/jack/as_jni_project/Student;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env-&gt;CallVoidMethod(personObj, setStudent, studentObj);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 第一类</span></span><br><span class="line">    env-&gt;DeleteLocalRef(studentClass);</span><br><span class="line">    env-&gt;DeleteLocalRef(personClass);</span><br><span class="line">    env-&gt;DeleteLocalRef(studentObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(personObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二类</span></span><br><span class="line">    <span class="comment">// env-&gt;ReleaseStringUTFChars()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 局部引用： jobject jclass jstring ...  【函数结束后，会自动释放】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-11-全局引用与局部引用理解"><a href="#2-11-全局引用与局部引用理解" class="headerlink" title="2.11 全局引用与局部引用理解"></a>2.11 全局引用与局部引用理解</h5><p>使用NewGlobalRef创建全局引用，否者都是局部引用，出栈之后，dogclass会成为悬空指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">jclass dogClass; <span class="comment">// 你以为这个是全局引用，实际上他还是局部引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_testQuote(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dogClass) &#123;</span><br><span class="line">        <span class="comment">/*const char * dogStr = &quot;com/jack/as_jni_project/Dog&quot;;</span></span><br><span class="line"><span class="comment">        dogClass = env-&gt;FindClass(dogStr);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 升级全局引用： JNI函数结束也不释放，反正就是不释放，必须手动释放   ----- 相当于： C++ 对象 new、手动delete</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * dogStr = <span class="string">&quot;com/jack/as_jni_project/Dog&quot;</span>;</span><br><span class="line">        jclass temp = env-&gt;FindClass(dogStr);</span><br><span class="line">        dogClass = <span class="keyword">static_cast</span>&lt;jclass&gt;(env-&gt;NewGlobalRef(temp)); <span class="comment">// 提升全局引用</span></span><br><span class="line">        <span class="comment">// 记住：用完了，如果不用了，马上释放</span></span><br><span class="line">        env-&gt;DeleteLocalRef(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;init&gt; V  是构造函数名不会变的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数一</span></span><br><span class="line">    jmethodID init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    jobject dog = env-&gt;NewObject(dogClass, init);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数2</span></span><br><span class="line">    init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    dog = env-&gt;NewObject(dogClass, init, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数3</span></span><br><span class="line">    init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(II)V&quot;</span>);</span><br><span class="line">    dog = env-&gt;NewObject(dogClass, init, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数4</span></span><br><span class="line">    init = env-&gt;GetMethodID(dogClass, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(III)V&quot;</span>);</span><br><span class="line">    dog = env-&gt;NewObject(dogClass, init, <span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    env-&gt;DeleteLocalRef(dog); <span class="comment">// 释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JNI函数结束，会释放局部引用   dogClass虽然被释放，但是还不等于NULL，只是一个悬空指针而已，所以第二次进不来IF，会奔溃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非常方便，可以使用了</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> age; <span class="comment">// 声明age</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>; <span class="comment">// 声明show函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动释放全局引用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_jack_as_1jni_1project_MainActivity_delQuote(JNIEnv *env, jobject thiz) &#123;</span><br><span class="line">   <span class="keyword">if</span> (dogClass != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       LOGE(<span class="string">&quot;全局引用释放完毕，上面的按钮已经失去全局引用，再次点击会报错&quot;</span>);</span><br><span class="line">       env-&gt;DeleteGlobalRef(dogClass);</span><br><span class="line">       dogClass = <span class="literal">NULL</span>; <span class="comment">// 最好给一个NULL，指向NULL的地址，不要去成为悬空指针</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 测试下</span></span><br><span class="line">   show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>(3)iptables匹配条件总结</title>
    <url>/2021/05/21/3-iptables%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1-配置多源ip或者网段限制"><a href="#1-配置多源ip或者网段限制" class="headerlink" title="1.配置多源ip或者网段限制"></a>1.配置多源ip或者网段限制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 丢弃掉来自192.168.1.111,192.168.1.112的所有报文</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.111,192.168.1.112 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> DROP掉某个网段的报文</span></span><br><span class="line">iptables -t filter -I INPUT -s 10.6.0.0/16 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对来源地址取反，只要发往本机的报文的源地址不是192.168.1.146，就接受报文</span></span><br><span class="line">iptables -t filter -I INPUT ! -s 192.168.1.146 -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="2-配置对目标ip的限制"><a href="#2-配置对目标ip的限制" class="headerlink" title="2.配置对目标ip的限制"></a>2.配置对目标ip的限制</h4><p>是用<code>-d</code> 参数对目的地址进行限制。注意，如果是对源和目标地址都有限制，<strong>需要同时满足</strong>才会执行对应规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止报文从192.168.1.146发到192.168.1.156</span></span><br><span class="line">iptables -t filter INPUT -s 192.168.1.146 -d 192.168.1.156 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止报文发到192.168.1.156的所有报文</span></span><br><span class="line">iptables -t filter INPUT -d 192.168.1.156 -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="3-协议类型匹配"><a href="#3-协议类型匹配" class="headerlink" title="3.协议类型匹配"></a>3.协议类型匹配</h4><p>使用 <code>-p</code> 参数对报文协议进行匹配，协议内容包含: tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> REJECT掉发往192.168.1.156的tcp协议报文</span></span><br><span class="line">iptables -t filter -I INPUT -d 192.168.1.156 -p tcp -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="4-匹配网卡"><a href="#4-匹配网卡" class="headerlink" title="4.匹配网卡"></a>4.匹配网卡</h4><p>使用<code>-i</code>对车机报文通过某一网卡<strong>流入</strong>进行限制，使用<code>-o</code> 对车机报文通过某一网卡流出进行限制。</p>
<p><code>-i</code>选项只能用于PREROUTING链、INPUT链、FORWARD链，那么<code>-o</code>选项只能用于FORWARD链、OUTPUT链、POSTROUTING链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> DROP掉经过wlan0口的ping报文</span></span><br><span class="line">iptables -t filter -I INPUT -i wlan0 -p icmp -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="5-限制端口"><a href="#5-限制端口" class="headerlink" title="5.限制端口"></a>5.限制端口</h4><h5 id="5-1-限制目标端口"><a href="#5-1-限制目标端口" class="headerlink" title="5.1 限制目标端口"></a>5.1 限制目标端口</h5><p>使用 <code>--dport</code>限制目标端口。在使用<code>--dport</code>选项时，必须事先指定了使用哪种协议，即必须先使用<code>-p</code>选项。</p>
<p>使用<code>-–dport</code>之前，我们使用<code>-m</code>选项，指定了对应的扩展模块为tcp，也就是说，如果想要使用<code>-–dport</code>这个扩展匹配条件，则必须依靠某个扩展模块完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> REJECT 外来报文的目标端口为本机的22号端口（ssh默认端口）</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 22 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  -m tcp表示使用tcp扩展模块，–dport表示tcp扩展模块中的一个扩展匹配条件，可用于匹配报文的目标端口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  注意，-p tcp与 -m tcp并不冲突，-p用于匹配报文的协议，-m 用于指定扩展模块的名称，正好，这个扩展模块也叫tcp。</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport 22 -j REJECT</span><br></pre></td></tr></table></figure>


<h5 id="5-2-限制源端口"><a href="#5-2-限制源端口" class="headerlink" title="5.2 限制源端口"></a>5.2 限制源端口</h5><p>使用<code>--sport</code>可以判断报文是否从指定的端口发出，即匹配报文的源端口是否与指定的端口一致</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --sport 22 -j REJECT</span><br></pre></td></tr></table></figure>


<h5 id="5-3-限制端口范围"><a href="#5-3-限制端口范围" class="headerlink" title="5.3 限制端口范围"></a>5.3 限制端口范围</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> REJECT目标端口为22到25之间的所有端口</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport 22:25 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示匹配0号到22号之间的所有端口</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport :22 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示匹配80号端口以及其以后的所有端口（直到65535）</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp --dport :22 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 管理多个离散的源端口</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dport 22,36,88 -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="6-iprange扩展模块"><a href="#6-iprange扩展模块" class="headerlink" title="6. iprange扩展模块"></a>6. iprange扩展模块</h4><p><code>-s</code>选项与<code>-d</code>选项并不能一次性的指定一段连续的IP地址范围，如果我们需要指定一段连续的IP地址范围，可以使用iprange扩展模块。</p>
<p>iprange扩展模块中有两个扩展匹配条件可以使用: –src-range 和 –dst-range</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果报文的源IP地址如果在192.168.1.127到192.168.1.146之间，则丢弃报文</span></span><br><span class="line">iptables -t filter -I INPUT -m iprange --src-rang 192.168.1.127-192.168.1.146 -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="7-String扩展模块"><a href="#7-String扩展模块" class="headerlink" title="7.String扩展模块"></a>7.String扩展模块</h4><p>使用string扩展模块，可以指定要匹配的字符串，如果报文中包含对应的字符串，则符合匹配条件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -m string --algo bm --string &quot;xxxx&quot; -j REJECT</span><br></pre></td></tr></table></figure>
<p><code>-m string</code>表示使用string模块，<code>--algo bm</code>表示使用bm算法去匹配指定的字符串，<code>--string &quot;xxxx&quot;</code>则表示我们想要匹配的字符串为”xxxx”.</p>
<ul>
<li>–algo：用于指定匹配算法，可选的算法有bm与kmp，此选项为必须选项，我们不用纠结于选择哪个算法，但是我们必须指定一个。</li>
<li>–string：用于指定需要匹配的字符串。</li>
</ul>
<h4 id="8-time扩展模块"><a href="#8-time扩展模块" class="headerlink" title="8.time扩展模块"></a>8.time扩展模块</h4><p>可以通过time扩展模块，根据时间段区匹配报文，如果报文到达的时间在指定的时间范围以内，则符合匹配条件。</p>
<p>8.1 约束在晚上12点-早上7点不能上网，保证充足睡眠。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 限制http端口</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --timestart 00:00:00 --timestop 07:00:00 -j REJECT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 限制https端口</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --timestart 00:00:00 --timestop 07:00:00 -j REJECT</span><br></pre></td></tr></table></figure>


<p>8.2 约束周末不能上网</p>
<p><code>--weekdays</code>可以取反</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --weekdays 6,7 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --weekdays 6,7 -j REJECT</span><br></pre></td></tr></table></figure>


<p>8.3 约束每月某些天不能上网</p>
<p><code>--monthdays</code> 可以取反</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --monthdays 10,11 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --monthdays 10,11 -j REJECT</span><br></pre></td></tr></table></figure>


<p>8.4 限制时间段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 80 -m time --datestart 2021-05-24 --datestop 2021-05-30 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 443 -m time --datestart 2021-05-24 --datestop 2021-05-30 -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="9-connlimit扩展模块"><a href="#9-connlimit扩展模块" class="headerlink" title="9.connlimit扩展模块"></a>9.connlimit扩展模块</h4><p>使用connlimit扩展模块，可以限制每个IP地址同时链接到server端的链接数量，注意：我们不用指定IP，其默认就是针对”每个客户端IP”，即对单IP的并发连接数限制。</p>
<p>9.1 限制每个IP地址最多只能占用两个ssh链接远程到server端</p>
<p>使用<code>–connlimit-above 2</code>表示限制每个IP的链接数量上限为2，再配合<code>-p tcp</code>, <code>–dport 22</code>，即表示限制每个客户端IP的ssh并发链接数量不能高于2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 22 -m connlimt --connlimit-above 2 -j ACCEPT</span><br></pre></td></tr></table></figure>


<p>9.2 限制某个网段，最多多少个链接</p>
<p>使用<code>--connlimit-mask</code>限制某个网段，<code>–connlimit-mask 27</code>表示某个C类网段，这个网段中最多只能有30台机器（30个IP），这30个IP地址最多只能有10个ssh连接同时连接到服务器端。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp --dport 22 -m connlimt --connlimit-above 10 --connlimit-mask 27 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>mask是子网掩码的意思，通过子网掩码来限制ip段。</p>
<h4 id="10-limit扩展模块"><a href="#10-limit扩展模块" class="headerlink" title="10.limit扩展模块"></a>10.limit扩展模块</h4><p>使用limit模块是对”报文到达速率”进行限制，可以以秒为单位进行限制，也可以以分钟、小时、天作为单位进行限制。</p>
<p>10.1 限制，外部主机对本机进行ping操作时，本机最多每6秒中放行一个ping。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m limit --limit 10/minute -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>如果单是以上规则，是无法限制每6秒到来的报文的。因为当1-5秒到来的报文，会走默认规则，默认是ACCEPT。</p>
<p>因此，还需要添加默认的匹配规则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -j REJECT</span><br></pre></td></tr></table></figure>
<p>需要注意的是，需要先配置接受规则，再配置拒绝规则。</p>
<p>如上配置之后，我们看看现象如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-720e7548317b545d.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="令牌桶算法.PNG"></p>
<p>可以看到1-5的报文没有被过滤到，后面的报文每6秒接受到一次，以满足拦截需求的。</p>
<p>出现这个现象的原因是：limit模块使用了<strong>令牌桶算法</strong>。</p>
<p><strong>令牌桶算法</strong>：我们可以这样想象，有一个木桶，木桶里面放了5块令牌，而且这个木桶最多也只能放下5块令牌，所有报文如果想要出关入关，都必须要持有木桶中的令牌才行，这个木桶有一个神奇的功能，就是每隔6秒钟会生成一块新的令牌，如果此时，木桶中的令牌不足5块，那么新生成的令牌就存放在木桶中，如果木桶中已经存在5块令牌，新生成的令牌就无处安放了，只能溢出木桶（令牌被丢弃），如果此时有5个报文想要入关，那么这5个报文就去木桶里找令牌，正好一人一个，于是他们5个手持令牌，快乐的入关了，此时木桶空了，再有报文想要入关，已经没有对应的令牌可以使用了，但是，过了6秒钟，新的令牌生成了，此刻，正好来了一个报文想要入关，于是，这个报文拿起这个令牌，就入关了，在这个报文之后，如果很长一段时间内没有新的报文想要入关，木桶中的令牌又会慢慢的积攒了起来，直到达到5个令牌，并且一直保持着5个令牌，直到有人需要使用这些令牌，这就是令牌桶算法的大致逻辑。</p>
<p>因此，我们可以<code>–limit-burst</code>来限制桶的令牌数目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m limit --limit-burst 3 --limit 10/minute -j ACCEPT</span><br></pre></td></tr></table></figure>


<h4 id="11-匹配TCP报文头标志位"><a href="#11-匹配TCP报文头标志位" class="headerlink" title="11.匹配TCP报文头标志位"></a>11.匹配TCP报文头标志位</h4><p>可以使用<code>--tcp-flags</code> 匹配报文tcp头部的标志位。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匹配第一次握手</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</span><br></pre></td></tr></table></figure>
<p>”SYN,ACK,FIN,RST,URG,PSH SYN”, 这串字符就是用于配置我们要匹配的标志位的，我们可以把这串字符拆成两部分去理解，第一部分为”SYN,ACK,FIN,RST,URG,PSH”，第二部分为”SYN”。</p>
<p>第一部分表示：我们需要匹配报文tcp头中的哪些标志位，那么上例的配置表示，我们需要匹配报文tcp头中的6个标志位，这6个标志位分别为为”SYN、ACK、FIN、RST、URG、PSH”，我们可以把这一部分理解成需要匹配的标志位列表。</p>
<p>第二部分表示：第一部分的标志位列表中，哪些标志位必须为1，上例中，第二部分为SYN，则表示，第一部分需要匹配的标志位列表中，SYN标志位的值必须为1，其他标志位必须为0。</p>
<p>所以，上例中的”SYN,ACK,FIN,RST,URG,PSH SYN”表示，需要匹配报文tcp头中的”SYN、ACK、FIN、RST、URG、PSH”这些标志位，其中SYN标志位必须为1，其他的5个标志位必须为0 .</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匹配第二次握手</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --sport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN,ACK -j REJECT</span><br></pre></td></tr></table></figure>


<p>以上两条可以简写为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags ALL SYN -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p tcp -m tcp --sport 22 --tcp-flags ALL SYN,ACK -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="12-icmp扩展"><a href="#12-icmp扩展" class="headerlink" title="12.icmp扩展"></a>12.icmp扩展</h4><p>我们平常使用ping命令ping某主机时，如果主机可达，对应主机会对我们的ping请求做出回应（此处不考虑禁ping等情况），也就是说，我们发出ping请求，对方回应ping请求，虽然ping请求报文与ping回应报文都属于ICMP类型的报文，但是如果在概念上细分的话，它们所属的类型还是不同的，我们发出的ping请求属于类型8的icmp报文，而对方主机的ping回应报文则属于类型0的icmp报文，根据应用场景的不同，icmp报文被细分为如下各种类型。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-696ef0c3d77e584e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="icmp协议.png"></p>
<p>从上图可以看出，所有表示”目标不可达”的icmp报文的type码为3，而”目标不可达”又可以细分为多种情况，是网络不可达呢？还是主机不可达呢？再或者是端口不可达呢？所以，为了更加细化的区分它们，icmp对每种type又细分了对应的code，用不同的code对应具体的场景，  所以，我们可以使用type/code去匹配具体类型的ICMP报文，比如可以使用”3/1″表示主机不可达的icmp报文。</p>
<p>上图中的第一行就表示ping回应报文，它的type为0，code也为0，从上图可以看出，ping回应报文属于查询类（query）的ICMP报文，从大类上分，ICMP报文还能分为查询类与错误类两大类，目标不可达类的icmp报文则属于错误类报文。</p>
<p>而我们发出的ping请求报文对应的type为8，code为0。</p>
<p>12.1 此时我们只想要ping通别人，但是不想让别人ping通我们</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8 -j REJECT</span><br><span class="line">// echo-request是协议名，中间空格用‘-’代替</span><br><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type &quot;echo-request&quot; -j REJECT</span><br></pre></td></tr></table></figure>
<p>使用”-m icmp”表示使用icmp扩展，因为上例中使用了”-p icmp”，所以”-m icmp”可以省略，使用”–icmp-type”选项表示根据具体的type与code去匹配对应的icmp报文，而上图中的”–icmp-type 8/0″表示icmp报文的type为8，code为0才会被匹配到，也就是只有ping请求类型的报文才能被匹配到，所以，别人对我们发起的ping请求将会被拒绝通过防火墙，而我们之所以能够ping通别人，是因为别人回应我们的报文的icmp type为0，code也为0，所以无法被上述规则匹配到，所以我们可以看到别人回应我们的信息。</p>
<h4 id="13-判断报文是来自回应还是请求"><a href="#13-判断报文是来自回应还是请求" class="headerlink" title="13.判断报文是来自回应还是请求"></a>13.判断报文是来自回应还是请求</h4><p>我们可以使用state模块的<code>--state</code>来追踪链接的状态。</p>
<p>对于state模块的连接而言，”连接”其中的报文可以分为5种状态，报文状态可以为NEW、ESTABLISHED、RELATED、INVALID、UNTRACKED。(详细定义参考文档)</p>
<ul>
<li><p><strong>NEW</strong>：连接中的第一个包，状态就是NEW，我们可以理解为新连接的第一个包的状态为NEW。</p>
</li>
<li><p><strong>ESTABLISHED</strong>：我们可以把NEW状态包后面的包的状态理解为ESTABLISHED，表示连接已建立。</p>
</li>
<li><p><strong>RELATED</strong>：从字面上理解RELATED译为关系，但是这样仍然不容易理解，我们举个例子。</p>
</li>
</ul>
<p>比如FTP服务，FTP服务端会建立两个进程，一个命令进程，一个数据进程。</p>
<p>命令进程负责服务端与客户端之间的命令传输（我们可以把这个传输过程理解成state中所谓的一个”连接”，暂称为”命令连接”）。</p>
<p>数据进程负责服务端与客户端之间的数据传输 ( 我们把这个过程暂称为”数据连接” )。</p>
<p>但是具体传输哪些数据，是由命令去控制的，所以，”数据连接”中的报文与”命令连接”是有”关系”的。</p>
<p>那么，”数据连接”中的报文可能就是RELATED状态，因为这些报文与”命令连接”中的报文有关系。</p>
<p>(注：如果想要对ftp进行连接追踪，需要单独加载对应的内核模块nf_conntrack_ftp，如果想要自动加载，可以配置/etc/sysconfig/iptables-config文件)</p>
<ul>
<li><p><strong>INVALID</strong>：如果一个包没有办法被识别，或者这个包没有任何状态，那么这个包的状态就是INVALID，我们可以主动屏蔽状态为INVALID的报文。</p>
</li>
<li><p><strong>UNTRACKED</strong>：报文的状态为untracked时，表示报文未被追踪，当报文的状态为Untracked时通常表示无法找到相关的连接。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -j REJECT</span><br></pre></td></tr></table></figure>


<h4 id="14-禁止某个域名访问"><a href="#14-禁止某个域名访问" class="headerlink" title="14.禁止某个域名访问"></a>14.禁止某个域名访问</h4><p>禁止 包含qq.com的域名访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I OUTPUT -p tcp -m string --string &quot;qq.com&quot; --algo bm -j DROP</span><br><span class="line">iptables -I OUTPUT -p udp -m string --string &quot;qq.com&quot; --algo kmp -j DROP</span><br></pre></td></tr></table></figure>


<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.linuxtopia.org/Linux_Firewall_iptables/x1347.html">User-land states定义</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Iptables</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>Android启动时验证</title>
    <url>/2021/03/15/Android%E5%90%AF%E5%8A%A8%E6%97%B6%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h3 id="1-设备状态"><a href="#1-设备状态" class="headerlink" title="1.设备状态"></a>1.设备状态</h3><p>设备状态用于指明能够以多大的自由度将软件刷写到设备上，以及是否强制执行验证。设备状态为 <code>LOCKED</code> 和 <code>UNLOCKED</code>。状态为 <code>LOCKED</code> 的设备禁止您将新软件刷写到设备上，而状态为 <code>UNLOCKED</code> 的设备允许您进行修改。</p>
<p>当设备开机后，引导加载程序会先检查设备状态是 <code>LOCKED</code> 还是 <code>UNLOCKED</code>。如果设备状态为 <code>UNLOCKED</code>，引导加载程序会向用户显示警告，然后继续启动，即使加载的操作系统不是由信任根签名也是如此。</p>
<p>如果设备状态为 <code>LOCKED</code>，引导加载程序会完成<a href="https://source.android.com/security/verifiedboot/verified-boot">验证启动</a>中的步骤，验证该设备的软件。只有在加载的操作系统是由信任根正确签名时，状态为 <code>LOCKED</code> 的设备才会启动。如需了解详情，请参阅<a href="https://source.android.com/security/verifiedboot/boot-flow">启动流程</a>。</p>
<h4 id="1-1-更改设备状态"><a href="#1-1-更改设备状态" class="headerlink" title="1.1 更改设备状态"></a>1.1 更改设备状态</h4><p>如需<a href="https://source.android.com/devices/bootloader/unlock-trusty">更改设备状态</a>，请使用 <code>fastboot flashing [unlock | lock]</code> 命令。为了保护用户数据，只要设备状态发生变化，都会先清除 data 分区中的数据，并会在删除数据之前要求用户确认。<br>当用户购买二手开发设备后，应该将设备状态从 <code>UNLOCKED</code> 改为 <code>LOCKED</code>。锁定设备后，只要没有警告，用户应该就能确信设备处于设备制造商开发的状态。如果开发者出于开发目的希望停用设备上的验证功能，应该将设备状态从 <code>LOCKED</code> 改为 <code>UNLOCKED</code>。</p>
<h4 id="1-2-信任根"><a href="#1-2-信任根" class="headerlink" title="1.2 信任根"></a>1.2 信任根</h4><p>信任根是用于为设备上存储的 Android 副本签名的加密密钥。信任根的不公开部分只有设备制造商才知道，用于为旨在分发的每个 Android 版本签名。信任根的公开部分嵌入在设备中并存储在一个不会被篡改的位置（通常是只读存储区）。<br>加载 Android 时，引导加载程序会使用信任根来验证真实性。如需详细了解此流程，请参阅<a href="https://source.android.com/security/verifiedboot/verified-boot">验证启动</a>。设备可能具有多个引导加载程序，因此可能有多个加密密钥。</p>
<h4 id="1-3-可由用户设置的信任根"><a href="#1-3-可由用户设置的信任根" class="headerlink" title="1.3 可由用户设置的信任根"></a>1.3 可由用户设置的信任根</h4><p>设备可以根据需要选择允许用户配置信任根（例如，公钥）。设备可以使用此可由用户设置的信任根（而非内置的信任根）进行启动时验证。这样，用户既可以安装并使用自定义的 Android 版本，又不会牺牲启动时验证这项安全改进功能。</p>
<p>如果实现了可由用户设置的信任根，则应满足以下要求：</p>
<ul>
<li>需要进行物理确认才能设置/清除可由用户设置的信任根。</li>
<li>可由用户设置的信任根只能由最终用户设置，而不能在出厂时或在最终用户获得设备之前的任意中间点设置。</li>
<li>可由用户设置的信任根存储在防篡改的存储空间中。“防篡改”是指可以检测到 Android 数据是否遭到篡改（例如，数据是否被覆盖或更改）。</li>
<li>如果设置了可由用户设置的信任根，则设备应该允许启动使用内置信任根或可由用户设置的信任根签名的 Android 版本。</li>
<li>设备每次使用可由用户设置的信任根启动时，系统都应通知用户设备正在加载自定义的 Android 版本。例如，警告屏幕，请参阅<a href="https://source.android.com/security/verifiedboot/boot-flow#locked-devices-with-custom-key-set">状态为 <code>LOCKED</code> 并已设置自定义密钥的设备</a>。</li>
</ul>
<p>实现可由用户设置的信任根的一种方法是，将虚拟分区设置为仅当设备处于 <code>UNLOCKED</code> 状态时才能刷写或清除。Google Pixel 2 设备使用此方法以及名为 <code>avb_custom_key</code> 的虚拟分区。<code>avbtool extract_public_key</code> 命令会输出此分区中数据的格式。以下示例展示了如何设置可由用户设置的信任根：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avbtool extract_public_key --key key.pem --output pkmd.bin</span><br><span class="line">fastboot flash avb_custom_key pkmd.bin</span><br></pre></td></tr></table></figure>
<p>可由用户设置的信任根可通过发出以下命令来清除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastboot erase avb_custom_key</span><br></pre></td></tr></table></figure>


<h3 id="2-验证启动"><a href="#2-验证启动" class="headerlink" title="2.验证启动"></a>2.验证启动</h3><p>对于要启动的 Android 版本中包含的所有可执行代码和数据，启动时验证均要求在使用前以加密形式对其进行验证，其中包括内核（从 <code>boot</code> 分区加载）、设备树（从 <code>dtbo</code> 分区加载）、<code>system</code> 分区和 <code>vendor</code> 分区等。</p>
<p>对于 <code>boot</code> 和 <code>dtbo</code> 这类仅读取一次的小分区，通常是通过将整个内容加载到内存中，然后计算其哈希值来进行验证。接下来，系统会将计算出的哈希值与预期哈希值进行比较。如果值不一致，则 Android 将无法加载。如需了解详情，请参阅<a href="https://source.android.com/security/verifiedboot/boot-flow">启动流程</a>。</p>
<p>内存装不下的较大分区（如文件系统）可能会使用哈希树；在这种情况下，验证流程会在将数据加载到内存的过程中持续进行。对于这种情况，系统会在运行时计算哈希树的根哈希值，并将其与预期根哈希值进行比较。Android 包含用于验证较大分区的 <a href="https://source.android.com/security/verifiedboot/dm-verity">dm-verity 驱动程序</a>。如果在某个时刻计算出的根哈希值与预期根哈希值不一致，系统便不会使用相应数据，而且 Android 会出现错误。如需了解详情，请参阅 <a href="https://source.android.com/security/verifiedboot/boot-flow#dm-verity-corruption">dm-verity 损坏</a>。</p>
<p>预期哈希值通常存储在每个经过验证的分区的末尾或开头、专用分区中，或同时存储在以上两个位置。最重要的是，这些哈希值已由信任根以直接或间接的方式签名。举个例子，AVB 实现就支持这两种方式；如需了解详情，请参阅 <a href="https://source.android.com/security/verifiedboot/avb">Android 启动时验证</a>。</p>
<h4 id="2-1回滚保护"><a href="#2-1回滚保护" class="headerlink" title="2.1回滚保护"></a>2.1回滚保护</h4><p>即使更新流程完全安全，攻击者仍可能会利用非永久性 Android 内核漏洞来手动安装更易受攻击的旧版 Android 系统，重新启动进入易受攻击的版本，然后通过该 Android 版本来安装永久性漏洞。在这种情况下，攻击者可通过这种漏洞永久拥有相应设备，并可以执行任何操作（包括停用更新）。</p>
<p>防范这类攻击的保护措施称为“回滚保护”。“回滚保护”通常通过以下方式实现：使用防篡改的存储空间来记录最新的 Android 版本，并在 Android 版本低于记录的版本时拒绝启动 Android。系统通常会针对每个分区来跟踪版本。</p>
<p>如需详细了解 AVB 处理回滚保护的方式，请参阅 AVB <a href="https://android.googlesource.com/platform/external/avb/+/master/README.md#Rollback-Protection">README</a>。</p>
<h4 id="2-2-处理验证错误"><a href="#2-2-处理验证错误" class="headerlink" title="2.2 处理验证错误"></a>2.2 处理验证错误</h4><p>如果验证在运行时失败，恢复流程就会更复杂一些。如果设备使用的是 dm-verity，则应在 <code>restart</code> 模式下进行配置。在 <code>restart</code> 模式下，如果遇到验证错误，设备会立即重启，并设置特定标记以表明错误原因。引导加载程序应该会注意到该标记，并将 dm-verity 切换为使用 I/O 错误 (<code>eio</code>) 模式并保持该模式，直到安装新的更新为止。</p>
<h3 id="3-启动流程"><a href="#3-启动流程" class="headerlink" title="3.启动流程"></a>3.启动流程</h3><p><img src="/2021/03/15/Android%E5%90%AF%E5%8A%A8%E6%97%B6%E9%AA%8C%E8%AF%81/blog\source_posts\Android启动时验证\verified-boot-flow.png" alt="verified-boot-flow"></p>
<h4 id="3-1-适用于-A-B-设备的流程"><a href="#3-1-适用于-A-B-设备的流程" class="headerlink" title="3.1 适用于 A/B 设备的流程"></a>3.1 适用于 A/B 设备的流程</h4><p>如果设备使用的是 A/B 系统，则启动流程略有不同。必须先使用<a href="https://android.googlesource.com/platform/hardware/interfaces/+/master/boot/1.0/IBootControl.hal">启动控件 HAL</a> 将要启动的槽位标记为 <code>SUCCESSFUL</code>，然后再更新回滚保护 (Rollback Protection) 元数据。</p>
<p>如果平台更新失败（未标记 <code>SUCCESSFUL</code>），A/B 堆栈便会回退至仍具有先前 Android 版本的其他槽位。不过，如果已设置回滚保护元数据，之前的版本会因回滚保护而无法启动。</p>
<h4 id="3-2-将启动时验证状态传达给-Android"><a href="#3-2-将启动时验证状态传达给-Android" class="headerlink" title="3.2 将启动时验证状态传达给 Android"></a>3.2 将启动时验证状态传达给 Android</h4><p>引导加载程序通过内核命令选项将启动时验证状态传达给 Android。它会将 <code>androidboot.verifiedstate</code> 选项设置为以下其中一个值：</p>
<ul>
<li><code>green</code>：如果设备处于<code>LOCKED</code>状态且未使用可由用户设置的信任根</li>
<li><code>yellow</code>：如果设备处于<code>LOCKED</code>状态且使用了可由用户设置的信任根</li>
<li><code>orange</code>：如果设备处于<code>UNLOCKED</code>状态</li>
</ul>
<p><code>androidboot.veritymode</code> 选项设置为 <code>eio</code> 或 <code>restart</code>，具体取决于启动加载程序在处理 dm-verity 错误时所处的状态。如需了解详情，请参阅<a href="https://source.android.com/security/verifiedboot/verified-boot#handling-verification-errors">处理验证错误</a>。</p>
<h3 id="4-实现-dm-verity"><a href="#4-实现-dm-verity" class="headerlink" title="4.实现 dm-verity"></a>4.实现 dm-verity</h3><p>Android 4.4 及更高版本支持通过可选的 device-mapper-verity (dm-verity) 内核功能进行启动时验证，以便对块存储设备进行透明的完整性检查。dm-verity 有助于阻止可以持续保有 Root 权限并入侵设备的持续性 Rootkit。验证启动功能有助于 Android 用户在启动设备时确定设备状态与上次使用时是否相同。</p>
<p>具有 Root 权限的可能有害的应用 (PHA) 可以躲开检测程序的检测，并以其他方式掩蔽自己。可以获取 Root 权限的软件就能够做到这一点，因为它通常比检测程序的权限更高，从而能够“欺骗”检测程序。</p>
<p>通过 dm-verity 功能，您可以查看块设备（文件系统的底部存储层），并确定它是否与预期配置一致。该功能是利用加密哈希树做到这一点的。对于每个块（通常为 4k），都有一个 SHA256 哈希。</p>
<p>由于哈希值存储在页面树中，因此顶级“根”哈希必须可信，才能验证树的其余部分。能够修改任何块相当于能够破坏加密哈希。下图描绘了此结构。</p>
<p><img src="/2021/03/15/Android%E5%90%AF%E5%8A%A8%E6%97%B6%E9%AA%8C%E8%AF%81/blog\source_posts\Android启动时验证\dm-verity-hash-table.png" alt="dm-verity-hash-table"></p>
<p>启动分区中包含一个公钥，该公钥必须已由设备制造商在外部进行验证。该密钥用于验证相应哈希的签名，并用于确认设备的系统分区是否受到保护且未被更改。</p>
<h4 id="4-1-具体实施措施"><a href="#4-1-具体实施措施" class="headerlink" title="4.1 具体实施措施"></a>4.1 具体实施措施</h4><p>dm-verity 保护机制位于内核中。因此，如果获取 Root 权限的软件在内核启动之前入侵系统，它将会一直拥有该权限。为了降低这种风险，大多数制造商都会使用烧录到设备的密钥来验证内核。该密钥在设备出厂后即无法更改(OTP寄存器保证？)。</p>
<p> dm-verity 只有在各个块被访问时才会对其进行单独验证。将块读入内存时，会以并行方式对其进行哈希处理。然后，会从第一级开始逐级验证整个哈希树的哈希。</p>
<p>如果验证失败，设备会生成 I/O 错误，指明无法读取相应块。设备看起来与文件系统损坏时一样，也与预期相同。</p>
<p>应用可以选择在没有结果数据的情况下继续运行，例如，当这些结果并不是应用执行主要功能所必需的数据时。不过，如果应用在没有这些数据的情况下无法继续运行，则会失败。</p>
<h4 id="4-2前向纠错"><a href="#4-2前向纠错" class="headerlink" title="4.2前向纠错"></a>4.2前向纠错</h4><p>Android 7.0 及更高版本通过前向纠错 (FEC) 功能提高了 dm-verity 的稳健性。AOSP 实现首先使用常用的 <a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction">Reed-Solomon</a> 纠错码，并应用一种称为交错的技术来减少空间开销并增加可以恢复的损坏块的数量。有关 FEC 的更多详情，请参阅<a href="https://android-developers.googleblog.com/2016/07/strictly-enforced-verified-boot-with.html">严格强制执行的启动时验证与纠错</a>。</p>
<h4 id="4-3实现dm-verity步骤"><a href="#4-3实现dm-verity步骤" class="headerlink" title="4.3实现dm-verity步骤"></a>4.3实现dm-verity步骤</h4><ul>
<li>生成 EXT4 系统映像。</li>
<li>为该映像<a href="https://source.android.com/security/verifiedboot/dm-verity#hash-tree">生成哈希树</a>。</li>
<li>为该哈希树<a href="https://source.android.com/security/verifiedboot/dm-verity#mapping-table">构建 dm-verity 表</a>。</li>
<li><a href="https://source.android.com/security/verifiedboot/dm-verity#signing">为该 dm-verity 表签名</a>以生成表签名。</li>
<li>将表签名和 dm-verity 表<a href="https://source.android.com/security/verifiedboot/dm-verity#metadata">绑定</a>到 Verity 元数据。</li>
<li>将系统映像、Verity 元数据和哈希树连接起来。</li>
</ul>
<p>如需关于哈希树和 dm-verity 表的详细说明，请参阅 <a href="http://www.chromium.org/chromium-os/chromiumos-design-docs/verified-boot">Chromium 项目 - 启动时验证</a>。</p>
<h5 id="4-3-1-生成哈希树"><a href="#4-3-1-生成哈希树" class="headerlink" title="4.3.1  生成哈希树"></a>4.3.1  生成哈希树</h5><p>如简介中所述，哈希树是 dm-verity 不可或缺的一部分。<a href="https://gitlab.com/cryptsetup/cryptsetup/wikis/DMVerity">cryptsetup</a> 工具将为您生成哈希树。</p>
<p>为了形成哈希，该工具会将系统映像在第 0 层拆分成 4k 大小的块，并为每个块分配一个 SHA256 哈希。然后，通过仅将这些 SHA256 哈希组合成 4k 大小的块来形成第 1 层，从而产生一个小得多的映像。接下来再使用第 1 层的 SHA256 哈希以相同的方式形成第 2 层。</p>
<p>直到前一层的 SHA256 哈希可以放到一个块中，该过程就完成了。获得该块的 SHA256 哈希后，就相当于获得了树的根哈希。</p>
<p>哈希树的大小（以及相应的磁盘空间使用量）会因已验证分区的大小而异。在实际中，哈希树一般都比较小，通常不到 30 MB。</p>
<p>如果某个层中的某个块无法由前一层的哈希正好填满，您应在其中填充 0 来获得所需的 4k 大小。这样一来，您就知道哈希树没有被移除，而是填入了空白数据。</p>
<p>为了生成哈希树，需要将第 2 层哈希组合到第 1 层哈希的上方，将第 3 层哈希组合到第 2 层哈希的上方，依次类推。然后将所有这些数据写入到磁盘中。请注意，这种方式不会引用根哈希的第 0 层。</p>
<p>总而言之，构建哈希树的一般算法如下：</p>
<ol>
<li><p>选择一个随机盐（十六进制编码）。</p>
</li>
<li><p>将系统映像拆分成 4k 大小的块。</p>
</li>
<li><p>获取每个块的加盐 SHA256 哈希。</p>
</li>
<li><p>组合这些哈希以形成层。</p>
</li>
<li><p>在层中填充 0，直至达到 4k 块的边界。</p>
</li>
<li><p>将层组合到哈希树中。</p>
</li>
<li><p>重复第 2-6 步（使用前一层作为下一层的来源），直到最后只有一个哈希。</p>
</li>
</ol>
<h5 id="4-3-2-构建-dm-verity-映射表"><a href="#4-3-2-构建-dm-verity-映射表" class="headerlink" title="4.3.2 构建 dm-verity 映射表"></a>4.3.2 构建 dm-verity 映射表</h5><p>构建 dm-verity 映射表，该映射表会标明内核的块存储设备（或目标）以及哈希树的位置（是同一个值）。在生成 <code>fstab</code>和设备启动时会用到此映射。该映射表还会标明块的大小和 hash_start，即哈希树的起始位置（具体来说，就是哈希树在映像开头处的块编号）。</p>
<p>如需关于 Verity 目标映射表字段的详细说明，请参阅 <a href="https://code.google.com/p/cryptsetup/wiki/DMVerity">cryptsetup</a>。</p>
<h5 id="4-3-3为-dm-verity-表签名"><a href="#4-3-3为-dm-verity-表签名" class="headerlink" title="4.3.3为 dm-verity 表签名"></a>4.3.3为 dm-verity 表签名</h5><p>为 dm-verity 表签名以生成表签名。在验证分区时，会首先验证表签名。该验证是对照位于启动映像上某个固定位置的密钥来完成的。密钥通常包含在制造商的编译系统中，以便自动添加到设备上的固定位置。</p>
<p>如需使用这种签名和密钥的组合来验证分区，请执行以下操作：</p>
<ol>
<li>将一个格式与 libmincrypt 兼容的 RSA-2048 密钥添加到 <code>/verity_key</code> 分区的 <code>/boot</code> 中。确定用于验证哈希树的密钥所在的位置。</li>
<li>在相关条目的 fstab 中，将 <code>verify</code> 添加到 <code>fs_mgr</code> 标记。</li>
</ol>
<h5 id="4-3-4将表签名绑定到元数据"><a href="#4-3-4将表签名绑定到元数据" class="headerlink" title="4.3.4将表签名绑定到元数据"></a>4.3.4将表签名绑定到元数据</h5><p>将表签名和 dm-verity 表绑定到 Verity 元数据。为整个元数据块添加版本号，以便它可以进行扩展，例如添加第二种签名或更改某些顺序。</p>
<p>一个魔数（作为一个健全性检查项目）会与每组表元数据相关联，以协助标识表。由于长度包含在 EXT4 系统映像标头中，因此这为您提供了一种在不知道数据本身内容的情况下搜索元数据的方式。</p>
<p>这可确保您未选择验证未验证的分区。如果是这样，缺少此魔数将会导致验证流程中断。该数字类似于：<br>0xb001b001</p>
<p>十六进制的字节值为：</p>
<ul>
<li>第一字节 = b0</li>
<li>第二字节 = 01</li>
<li>第三字节 = b0</li>
<li>第四字节 = 01</li>
</ul>
<p>下图展示了 Verity 元数据的细分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;magic number&gt;|&lt;version&gt;|&lt;signature&gt;|&lt;table length&gt;|&lt;table&gt;|&lt;padding&gt;</span><br><span class="line">\-------------------------------------------------------------------&#x2F;</span><br><span class="line">\----------------------------------------------------------&#x2F;   |</span><br><span class="line">                            |                                  |</span><br><span class="line">                            |                                 32K</span><br><span class="line">                       block content</span><br></pre></td></tr></table></figure>
<p>下表介绍了这些元数据字段。</p>
<p>**表 1.**Verity 元数据字段</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">用途</th>
<th align="left">大小</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">魔数</td>
<td align="left">供 fs_mgr 用作一个健全性检查项目</td>
<td align="left">4 个字节</td>
<td align="left">0xb001b001</td>
</tr>
<tr>
<td align="left">版本</td>
<td align="left">用于为元数据块添加版本号</td>
<td align="left">4 个字节</td>
<td align="left">目前为 0</td>
</tr>
<tr>
<td align="left">签名</td>
<td align="left">PKCS1.5 填充形式的表签名</td>
<td align="left">256 个字节</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">表长度</td>
<td align="left">dm-verity 表的长度（以字节数计）</td>
<td align="left">4 个字节</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">表</td>
<td align="left">上文介绍的 dm-verity 表</td>
<td align="left">字节数与表长度相同</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">填充</td>
<td align="left">此结构会通过填充 0 达到 32k 长度</td>
<td align="left"></td>
<td align="left">0</td>
</tr>
</tbody></table>
<h5 id="4-3-5优化-dm-verity"><a href="#4-3-5优化-dm-verity" class="headerlink" title="4.3.5优化 dm-verity"></a>4.3.5优化 dm-verity</h5><p>为了充分发挥 dm-verity 的最佳性能，您应该：</p>
<ul>
<li>在内核中开启 NEON SHA-2（如果是 ARMv7）或 SHA-2 扩展程序（如果是 ARMv8）。</li>
<li>使用不同的预读设置和 prefetch_cluster 设置进行实验，找出适合您设备的最佳配置。</li>
</ul>
<h3 id="5-验证-system-other-分区实现"><a href="#5-验证-system-other-分区实现" class="headerlink" title="5.验证 system_other 分区实现"></a>5.验证 system_other 分区实现</h3><p>搭载 Android 9 及更低版本且具有 A/B 分区的 Android 设备可以使用闲置的 <code>system_other</code> 分区（例如，当 <code>slot_a</code> 处于活动状态时，<code>system_b</code> 闲置）存储预优化的 VDEX/ODEX 文件。使用 <code>system_other</code> 时，<code>ro.cp_system_other_odex</code> 被设置为 1，以便软件包管理器服务设置 <code>sys.cppreopt=requested</code>，使 <code>cppreopts.rc</code>能对其执行操作。</p>
<p>Android 10 中引入了 <a href="https://android.googlesource.com/platform/system/core/+/refs/heads/master/fs_mgr/libfs_avb/"><code>libfs_avb</code></a>，以便支持对 <code>system_other</code> 分区进行独立的 AVB 验证。此类分区的 VBMeta 结构附加在分区末尾，将由文件系统中的预期公钥验证。Android 构建系统支持对 <code>system_other.img</code> 签名，并将相应的签名密钥包含在 <code>/product/etc/security/avb/system_other.avbpubkey</code> 下。发布工具 <code>sign_target_files_apks.py</code> 还支持将签名密钥替换为发布版本。</p>
<p>如果 A/B 设备搭载的 Android 版本低于 Android 10，即便升级到 Android 10 并将 <code>PRODUCT_RETROFIT_DYNAMIC_PARTITIONS</code> 设置为 <code>true</code>，也具有一个 <code>system_other</code> 物理分区。</p>
<p><strong>注意</strong>：建议不要在这些设备上启用 AVB。无线下载软件包中不包含 <code>system_other.img</code>，这可能会在一些 A/B 更新后导致验证错误。</p>
<p>搭载 Android 10 的 A/B 设备必须具有一个 <code>system_other</code> 逻辑分区。以下示例显示了对 <code>system_other</code> 启用 AVB 的典型 <code>fstab.postinstall</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&lt;dev&gt; &lt;mnt_point&gt; &lt;<span class="built_in">type</span>&gt;  &lt;mnt_flags options&gt;  &lt;fs_mgr_flags&gt;</span></span><br><span class="line">system /postinstall ext4 ro,nosuid,nodev,noexec</span><br><span class="line">slotselect_other,logical,avb_keys=/product/etc/security/avb/system_other.avbpubkey</span><br></pre></td></tr></table></figure>
<p>需要对 <code>system_other</code> 分区启用 AVB 的设备应将 <code>fstab</code> 文件放到产品分区中，并将属性 <code>ro.postinstall.fstab.prefix</code> 设置为 <code>/product</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Use /product/etc/fstab.postinstall to mount system_other. PRODUCT_PRODUCT_PROPERTIES += \</span></span><br><span class="line"><span class="bash">ro.postinstall.fstab.prefix=/product</span></span><br><span class="line"></span><br><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line"><span class="meta">$</span><span class="bash">(LOCAL_PATH)/fstab.postinstall:$(TARGET_COPY_OUT_PRODUCT)/etc/fstab.postinstall</span></span><br></pre></td></tr></table></figure>


<h3 id="6-Android-启动时验证"><a href="#6-Android-启动时验证" class="headerlink" title="6.Android 启动时验证"></a>6.Android 启动时验证</h3><p>Android 8.0 及更高版本包含启动时验证的一个供参考的实现，名为 Android 启动时验证 (Android Verified Boot , AVB) 或启动时验证 2.0。AVB 是支持 <a href="https://source.android.com/devices/architecture#hidl">Project Treble</a> 架构的一个启动时验证版本，可以将 Android 框架与底层供应商实现分离开来。</p>
<p>AVB 与 Android 构建系统相集成，并通过一行代码（负责生成所有必要的 dm-verity 元数据并为其签名）进行启用。如需了解详情，请参阅<a href="https://android.googlesource.com/platform/external/avb/+/master/README.md#Build-System-Integration">构建系统集成</a>。</p>
<p>AVB 提供 libavb，后者是一个在启动时用于验证 Android 的 C 库。您可以通过以下方式将 libavb 与引导加载程序集成在一起：针对 I/O 实现<a href="https://android.googlesource.com/platform/external/avb/+/master/libavb/avb_ops.h">特定于平台的功能</a>，提供信任根，并获取/设置回滚保护元数据。</p>
<p>AVB 的主要功能包括：针对不同分区委托更新、提供用于对分区进行签名的通用页脚格式，以及防止攻击者回滚到存在漏洞的 Android 版本。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://source.android.com/security/verifiedboot/device-state">Android关于启动时安全的验证</a></li>
<li><a href="https://blog.csdn.net/shangyexin/article/details/86649504">Android Verified Boot 2.0 最新安卓P AVB详解</a></li>
<li><a href="https://source.android.com/security">Android安全概述全集</a></li>
</ul>
]]></content>
      <categories>
        <category>Android Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AVB</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide源码分析--生命周期管理</title>
    <url>/2021/02/23/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>声明：</strong>我目前分析的源码是最新的Glide源码：4.12.0版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.github.bumptech.glide:glide:4.12.0&#x27;</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.github.bumptech.glide:compiler:4.12.0&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-Glide简介"><a href="#1-Glide简介" class="headerlink" title="1. Glide简介"></a>1. Glide简介</h3><p>Glide是一个支持拉取，解码和展示视频快照，图片，和GIF动画的框架，正如它的名字翻译一样：滑翔。让用户加载任何形式的图片列表尽可能地变得更快、更平滑。</p>
<p>Glide 使用简明灵活的流式语法API，允许你在大部分情况下一行代码搞定需求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">     .load(url)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>
<p>默认情况下，Glide使用的是一个定制化的基于<code>HttpUrlConnection</code>的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</p>
<h3 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h3><p>Glide 充分考虑了Android图片加载性能的两个关键方面：</p>
<ul>
<li><p>图片解码速度</p>
</li>
<li><p>解码图片带来的资源压力</p>
</li>
</ul>
<p>为了让用户拥有良好的App使用体验，图片不仅要快速加载，而且还不能因为过多的主线程I/O或频繁的垃圾回收导致页面的闪烁和抖动现象。Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p>
<ul>
<li>自动、智能地下采样(<code>downsampling</code>)和缓存(<code>caching</code>)，以最小化存储开销和解码次数；</li>
<li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li>
<li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>
</ul>
<h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h3><p>关于<a href="https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html">Glide的详细使用介绍</a>，参见前面链接即可，但是分析源码也要有个开始吧，那我们就从最基本的用法入手，Glide最基本的用法就是三段论：with、load和into。那我们现在就先从with开始。</p>
<h4 id="3-1-生命周期的作用域（1-Application，-2-Activity，-3-Fragment）"><a href="#3-1-生命周期的作用域（1-Application，-2-Activity，-3-Fragment）" class="headerlink" title="3.1 生命周期的作用域（1.Application， 2.Activity， 3.Fragment）"></a>3.1 生命周期的作用域（1.Application， 2.Activity， 3.Fragment）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//com.bumptech.glide.Glide.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getRetriever(context)返回RequestManagerRetriever，下面的生命周期关联会用到</span></span><br><span class="line">    <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(fragment.getContext()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(<span class="meta">@NonNull</span> View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Glide.with()静态方法中，我们可以看到方法可以传入5个参数：Context、Activity、FragmentActivity、Fragment或者View。按照作用域分，我们可以把它分成两类：Application类和非Application类。</p>
<ul>
<li>Application类：它的生命周期是全局的，没有空白Fragment就绑定Activity/Fragment。</li>
<li>非Application类，它的生命周期跟随Activity和Fragment的生命周期，专门有一个空白Fragment绑定Activity/Fragment。</li>
</ul>
<p>从上面with的重载方法看出都会调用到getRetriever()方法，他其实最终就是返回RequestManagerRetriever对象，紧接着，我们看看RequestManagerRetriever的get方法。这里先分两个来看：</p>
<ul>
<li>Activity、FragmentActivity、Fragment和View</li>
<li>Context</li>
</ul>
<h5 id="3-1-1-Activity类的get"><a href="#3-1-1-Activity类的get" class="headerlink" title="3.1.1 Activity类的get()"></a>3.1.1 Activity类的get()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">       <span class="comment">//如果不是UI线程，生命周期划分到Application</span></span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext()); </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">    <span class="keyword">return</span> get((FragmentActivity) activity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertNotDestroyed(activity);</span><br><span class="line">    frameWaiter.registerSelf(activity);</span><br><span class="line">    android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">    <span class="comment">// 不管是Activity、FragmentActivity、Fragment和View的get()，最终都会调用到fragmentGet()</span></span><br><span class="line">    <span class="keyword">return</span> fragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终with返回绑定了代理Fragemnt的RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个没有UI的空Fragment来监控用户自定义的Activity生命周期</span></span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//创建Glide实例</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      <span class="comment">//绑定Glide和空白的Fragemnt</span></span><br><span class="line">      <span class="comment">//注意！！:这里创建RequestManager的时候会传入Lifecycle,后面会根据这个lifecycle来透传fragment的生命周期给Glide</span></span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">        requestManager.onStart();</span><br><span class="line">      &#125;</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-1-2-Context类的get"><a href="#3-1-2-Context类的get" class="headerlink" title="3.1.2 Context类的get()"></a>3.1.2 Context类的get()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="comment">// 如果在UI线程，并且是3.1.1小节的组件，就调用Activity类的get()，返回绑定了空Fragment的requestManager</span></span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper</span><br><span class="line">        &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 作用域是Application返回的返回绑定了空Fragment的requestManager</span></span><br><span class="line">  <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Either an application context or we&#x27;re on a background thread.</span></span><br><span class="line">    <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//生命周期和Application一致</span></span><br><span class="line">          Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">          applicationManager =</span><br><span class="line">              factory.build(</span><br><span class="line">                  glide,</span><br><span class="line">                  <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                  <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                  context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> applicationManager;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-1-3-小结"><a href="#3-1-3-小结" class="headerlink" title="3.1.3 小结"></a>3.1.3 小结</h5><p>Glide的with()生命周期总结如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c39dde94e49da200.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作用域总结.png"></p>
<ul>
<li>子线程中Glide调用get()、传入ApplicationContext和ServiceContext，对应的生命周期属于Application域，生命周期和Application一致</li>
<li>Activity、Fragment和View对应的生命周期是被代理Fragemnt监控的，Glide内部逻辑会根据Activity的生命周期做相应调整</li>
</ul>
<h4 id="3-2-Glide生命周期感知过程"><a href="#3-2-Glide生命周期感知过程" class="headerlink" title="3.2 Glide生命周期感知过程"></a>3.2 Glide生命周期感知过程</h4><p>如3.1.1小节中分析的，不管with传入的是fragment、Activity还是View，RequestManagerRetriever都会创建一个没有UI的Fragment(SupportRequestManagerFragment)来当代理,当用户自定义的Activity或者Fragment生命周期发生变化的时候，Glide内部可以通过代理Fragment知道生命周期发生的变化，因此内部也做相应的处理。例如下载并且加载是一个比较耗时操作，如果下载完成之后，Activity已经被销毁了，那就不用加载了，所有这就是Glide感知组件生命周期的意义，用户不用主动调用clear()方法来释放资源了。关联关系如下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-20b9b7768530ab59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期与组件关联.png"></p>
<h4 id="3-3-Glide与空Fragment绑定过程"><a href="#3-3-Glide与空Fragment绑定过程" class="headerlink" title="3.3 Glide与空Fragment绑定过程"></a>3.3 Glide与空Fragment绑定过程</h4><p>从3.1.3小结中可以知道，只有在<strong>主线程</strong>中调用with()并且传入Activity或者Fragment会绑定空Fragment。当传入的activity，这个activity上覆盖的空Fragment是RequestManagerFragment；当传入的是fragment，覆盖在上面的空fragment是SupportRequestManagerFragment。逻辑都是一样的，下面以传入fragment来分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Pending adds for SupportRequestManagerFragments. </span></span><br><span class="line"><span class="comment">* 空Fragment(SupportRequestManagerFragment)与FragmentManager的映射关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">final</span> Map&lt;FragmentManager, SupportRequestManagerFragment&gt; pendingSupportRequestManagerFragments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从三个地方去拿空Fragment，紧接着会分析</span></span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);</span><br><span class="line">    <span class="comment">// 从空Fragment中拿到requestManager</span></span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 实例化glide用于在创建requestManager的时候绑定glide</span></span><br><span class="line">      Glide glide = Glide.get(context);</span><br><span class="line">      <span class="comment">// 创建requestManager并且绑定glide</span></span><br><span class="line">      requestManager =</span><br><span class="line">          factory.build(</span><br><span class="line">              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">      <span class="comment">//如果父fragment可见，就通知glide的onStart()</span></span><br><span class="line">      <span class="keyword">if</span> (isParentVisible) &#123;</span><br><span class="line">        requestManager.onStart();</span><br><span class="line">      &#125;</span><br><span class="line">      current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SupportRequestManagerFragment <span class="title">getSupportRequestManagerFragment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> <span class="keyword">final</span> FragmentManager fm, <span class="meta">@Nullable</span> Fragment parentHint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个地方:先从FragmentManager中去拿</span></span><br><span class="line">    SupportRequestManagerFragment current =</span><br><span class="line">        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 第二个地方:从内存中去拿</span></span><br><span class="line">      current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//以上两个地方都没有,就创建一个空Fragment然后返回</span></span><br><span class="line">        current = <span class="keyword">new</span> SupportRequestManagerFragment();</span><br><span class="line">        current.setParentFragmentHint(parentHint);</span><br><span class="line">        <span class="comment">//记录映射关系在内存中，临时存的</span></span><br><span class="line">        pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">        <span class="comment">//提交Fragment事务</span></span><br><span class="line">        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">        <span class="comment">//如果提交成功之后就删除临时存的映射关系</span></span><br><span class="line">        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从supportFragmentGet()方法中我们看到了Glide内部逻辑和空Fragment的绑定过程。</p>
<p>不知道大家有没有疑惑：<strong>为什么在getSupportRequestManagerFragment()方法中要在pendingSupportRequestManagerFragments中临时保存空Fragment？</strong></p>
<p>其实就是为了<strong>避免 SupportRequestManagerFragment 在一个作用域中重复创建。</strong><br>因为commitAllowingStateLoss() 是将事务 post 到消息队列中的，也就是说，事务是异步处理的，而不是同步处理的。假设没有临时保存记录，一旦在事务异步等待执行时调用了Glide.with(…) ，就会在该作用域中重复创建 Fragment。</p>
<h4 id="3-4-生命周期的详细监听过程"><a href="#3-4-生命周期的详细监听过程" class="headerlink" title="3.4 生命周期的详细监听过程"></a>3.4 生命周期的详细监听过程</h4><p>从上面小节分析可以看出，生命周期的管理，主要对Activity、Fragment和View(实质也是Activity或Fragment)有效，其他的都是Application域，没必须分析。所以后面的分析都是基于Activity或者Fragment的生命周期，而这两个逻辑都是一样的，我们还是以Fragment的分析为例。</p>
<p>从前面看出，每个Activity或者Fragment域都会创建一个空Fragment盖在上面。下来我们就从这个空Fragment开始分析Glide的生命周期是如何受影响的。Fragment盖的空Fragment是SupportRequestManagerFragment.java，那我们就从这里开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportRequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ActivityFragmentLifecycle lifecycle;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> ActivityFragmentLifecycle());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="meta">@SuppressLint(&quot;ValidFragment&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SupportRequestManagerFragment</span><span class="params">(<span class="meta">@NonNull</span> ActivityFragmentLifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    lifecycle.onStart();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function">ActivityFragmentLifecycle <span class="title">getGlideLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">  ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从3.1.1小节可以看到，创建RequestManager时是通过工厂创建的，那我们在看看这个工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RequestManagerRetriever.java中</span></span><br><span class="line"><span class="comment">//创建Glide实例</span></span><br><span class="line">Glide glide = Glide.get(context);</span><br><span class="line">requestManager =factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//factory接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestManagerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">RequestManager <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Glide glide,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> RequestManagerTreeNode requestManagerTreeNode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Context context)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的RequestManager工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestManagerFactory DEFAULT_FACTORY =</span><br><span class="line">    <span class="keyword">new</span> RequestManagerFactory() &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">build</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Glide glide,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> RequestManagerTreeNode requestManagerTreeNode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestManager(glide, lifecycle, requestManagerTreeNode, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>RequestManager工厂在创建RequestManager的时候，传入了glide和lifecycle，在RequestManager中完成绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span>, <span class="title">LifecycleListener</span>,...</span>&#123;</span><br><span class="line">    </span><br><span class="line">    RequestManager(</span><br><span class="line">        Glide glide,</span><br><span class="line">        Lifecycle lifecycle,</span><br><span class="line">        RequestManagerTreeNode treeNode,</span><br><span class="line">        RequestTracker requestTracker,</span><br><span class="line">        ConnectivityMonitorFactory factory,</span><br><span class="line">        Context context) &#123;</span><br><span class="line">      <span class="keyword">this</span>.glide = glide;</span><br><span class="line">      <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">      <span class="keyword">this</span>.treeNode = treeNode;</span><br><span class="line">      <span class="keyword">this</span>.requestTracker = requestTracker;</span><br><span class="line">      <span class="keyword">this</span>.context = context;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        Util.postOnUiThread(addSelfToLifecycle);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//lifecycle的生命周期回调加入到RequestManager中</span></span><br><span class="line">        lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        resumeRequests();</span><br><span class="line">        <span class="comment">// targetTracker维持着Traker列表,每个Traker属于Glide内部需要监听生命周期的逻辑</span></span><br><span class="line">        targetTracker.onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseRequests();</span><br><span class="line">        targetTracker.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，生命周期的详细监听过程就通了。</p>
<p><strong>总结：</strong>调用with()创建RequestManager，创建RequestManager传入Lifecycle对象(这个对象是在无界面 Fragment 中创建的)，RequestManager通过Lifecycle通知Glide内部的各个业务Traker。</p>
<p>当 Fragment 的生命周期变化时，无界面 Fragment会感知到生命周期变化，然后通过Lifecycle 对象将事件分发到 RequestManager，RequestManager的onStart()将事件分发给targetTracker，targetTracker分发给Glide内部逻辑。</p>
<p><strong>参考文档：</strong></p>
<p><a href="https://muyangmin.github.io/glide-docs-cn/">1.Glide简介</a></p>
<p><a href="https://blog.csdn.net/guolin_blog/article/details/53939176">2.郭霖关于Glide的源码分析</a></p>
]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>-Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>调查Launcher无法启动原因</title>
    <url>/2021/07/09/%E8%B0%83%E6%9F%A5Launcher%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>车机启动之后，Launcher应用无法展示，导致车机桌面乃至依赖UI-Framework的应用都无法启动。</p>
<h4 id="2-问题调查"><a href="#2-问题调查" class="headerlink" title="2.问题调查"></a>2.问题调查</h4><p>取日志如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-79885217ee44d54b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="apk中找不到需要的类.png"></p>
<p>从日志中我们可以看出应用的BaseClassLoader无法从<code>DexPathList</code>中加载到<code>com.gxa.sdk.weather.WeatherChangeListener</code>类。</p>
<h4 id="3-分析原因"><a href="#3-分析原因" class="headerlink" title="3.分析原因"></a>3.分析原因</h4><h5 id="3-1分析类加载流程"><a href="#3-1分析类加载流程" class="headerlink" title="3.1分析类加载流程"></a>3.1分析类加载流程</h5><p>一看着ClassLoader就会联想到JAVA中类是如何加载的。一共分为七个步骤：</p>
<blockquote>
<p>类加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载</p>
<p>链接过程主要是将Java类的二进制代码合并到JVM的运行状态之中。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d8f7dfa7d6733e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类加载过程.png"></p>
<h5 id="3-1-1-类加载"><a href="#3-1-1-类加载" class="headerlink" title="3.1.1 类加载"></a>3.1.1 类加载</h5><p>​    将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。</p>
<h5 id="3-1-2-验证"><a href="#3-1-2-验证" class="headerlink" title="3.1 .2 验证"></a>3.1 .2 验证</h5><p>​    确保加载的类信息符合JVM规范，没有安全方面的问题。</p>
<h5 id="3-1-3-准备"><a href="#3-1-3-准备" class="headerlink" title="3.1 .3 准备"></a>3.1 .3 准备</h5><p>​    正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。</p>
<h5 id="3-1-4-解析"><a href="#3-1-4-解析" class="headerlink" title="3.1 .4 解析"></a>3.1 .4 解析</h5><p>​    虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。</p>
<h5 id="3-1-5-初始化"><a href="#3-1-5-初始化" class="headerlink" title="3.1 .5 初始化"></a>3.1 .5 初始化</h5><p>​    初始化阶段是执行类构造器<init>()方法的过程。类构造器<init>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和**静态语句块(static块)**中的语句合并产生的。</init></init></p>
<ul>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。</li>
<li>虚拟机会保证一个类的<init>()方法在多线程环境中被正确加锁和同步。</init></li>
</ul>
<h5 id="3-2-类初始化顺序"><a href="#3-2-类初始化顺序" class="headerlink" title="3.2 类初始化顺序"></a>3.2 类初始化顺序</h5><p>1、父类的静态变量<br> 2、父类的静态代码块<br> 3、子类的静态变量<br> 4、子类的静态代码块<br> 5、父类的非静态变量<br> 6、父类的非静态代码块<br> 7、父类的构造方法<br> 8、子类的非静态变量<br> 9、子类的非静态代码块<br> 10、子类的构造方法</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f4a83dac14f43c47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WeatherTimePresenter构造函数.png"></p>
<p>从第二小节可以看出是初始化WeatherTimePresenter报的异常。然后细化分析，是初始化WeatherTimeModel报的异常。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e8f65e87a9923c12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WetherTimeModel.png"></p>
<p>我们反编Launcher应用可以看到，WeatherChangeListener属于WeatherTimeModel的成员变量，会在类调用构造方法之前初始化。并且看左边框图目录树，并没有看到com.gxa.sdk.weather.WeatherChangeListener这个类。因此结合类加载<code>双亲委托机制</code>，可以判断到WeatherChangeListener即没有从<code>根（Bootstrap）类加载</code>中加载到，也没有从<code>应用类加载器</code>中加载到。</p>
<h5 id="3-3-双亲委托机制"><a href="#3-3-双亲委托机制" class="headerlink" title="3.3 双亲委托机制"></a>3.3 双亲委托机制</h5><p><strong>ClassLoader的双亲委托模式</strong>：classloader 按级别分为三个级别：最上级 ： bootstrap classLoader（根类加载器） ； 中间级：extension classLoader （扩展类加载器）  最低级 app classLoader（应用类加载器）。</p>
<ul>
<li><p><strong>根（Bootstrap）类加载器</strong>：该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。例如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。</p>
</li>
<li><p><strong>扩展（Extension）类加载器</strong>：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库，如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类。</p>
</li>
<li><p><strong>系统（System）类加载器</strong>：也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// classloader类</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    		<span class="comment">// 检查类是不是已经被加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有父亲就一直往上找</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 递归找父亲加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 根就是祖宗了，没有父亲了。</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//如果父亲和祖宗都没有加载到</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="comment">// 调用自己的findclass加载.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h4><p>我们知道了<code>双亲委托机制</code>,对于该问题就有了解决办法: </p>
<ul>
<li>父亲或者祖宗帮我把类找到</li>
<li>我自定义classloader去加载类</li>
</ul>
<h5 id="4-1-祖宗加载法"><a href="#4-1-祖宗加载法" class="headerlink" title="4.1 祖宗加载法"></a>4.1 祖宗加载法</h5><p>如果是自己做系统,有办法修改到祖宗的东西,我们就可以改为祖宗加载(bootstrap classLoader, 根加载器)。其实根加载器就是从**系统环境变量(BOOTCLASSPATH)**中定义的路径中去加载。</p>
<p>ui-framework属于系统包，最合理的方式还是系统加载。</p>
<p>因此，我们把自己需要加载的包(例如ui-framework)加入到环境变量区即可。</p>
<h5 id="4-1-1-BOOTCLASSPATH被赋值流程分析"><a href="#4-1-1-BOOTCLASSPATH被赋值流程分析" class="headerlink" title="4.1.1 BOOTCLASSPATH被赋值流程分析"></a>4.1.1 BOOTCLASSPATH被赋值流程分析</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在system/core/rootdir/init.environ.rc.in中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> up the global environment</span></span><br><span class="line">on init</span><br><span class="line">    export ANDROID_BOOTLOGO 1</span><br><span class="line">    export ANDROID_ROOT /system</span><br><span class="line">    export ANDROID_ASSETS /system/app</span><br><span class="line">    export ANDROID_DATA /data</span><br><span class="line">    export ANDROID_STORAGE /storage</span><br><span class="line">    export EXTERNAL_STORAGE /sdcard</span><br><span class="line">    export ASEC_MOUNTPOINT /mnt/asec</span><br><span class="line">    export BOOTCLASSPATH %BOOTCLASSPATH%</span><br><span class="line">    export SYSTEMSERVERCLASSPATH %SYSTEMSERVERCLASSPATH%</span><br><span class="line">    %EXPORT_GLOBAL_ASAN_OPTIONS%</span><br><span class="line">    %EXPORT_GLOBAL_GCOV_OPTIONS%</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们知道BOOTCLASSPATH环境变量等于%BOOTCLASSPATH%，那%BOOTCLASSPATH%是谁赋的值呢？难道是在Android.mk编译脚本中赋值的么，继续看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> system/core/rootdir/Android.mk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Regenerate init.environ.rc <span class="keyword">if</span> PRODUCT_BOOTCLASSPATH has changed.</span></span><br><span class="line">bcp_md5 := $(word 1, $(shell echo $(PRODUCT_BOOTCLASSPATH) $(PRODUCT_SYSTEM_SERVER_CLASSPATH) | $(MD5SUM)))</span><br><span class="line">bcp_dep := $(intermediates)/$(bcp_md5).bcp.dep</span><br><span class="line"><span class="meta">$</span><span class="bash">(bcp_dep) :</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) mkdir -p $(dir <span class="variable">$@</span>) &amp;&amp; rm -rf $(dir <span class="variable">$@</span>)*.bcp.dep &amp;&amp; touch <span class="variable">$@</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(LOCAL_BUILT_MODULE): $(LOCAL_PATH)/init.environ.rc.in $(bcp_dep)</span></span><br><span class="line">	@echo &quot;Generate: $&lt; -&gt; $@&quot;</span><br><span class="line">	@mkdir -p $(dir $@)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -e <span class="string">&#x27;s?%BOOTCLASSPATH%?$(PRODUCT_BOOTCLASSPATH)?g&#x27;</span> $&lt; &gt;<span class="variable">$@</span></span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -i -e <span class="string">&#x27;s?%SYSTEMSERVERCLASSPATH%?$(PRODUCT_SYSTEM_SERVER_CLASSPATH)?g&#x27;</span> <span class="variable">$@</span></span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -i -e <span class="string">&#x27;s?%EXPORT_GLOBAL_ASAN_OPTIONS%?$(EXPORT_GLOBAL_ASAN_OPTIONS)?g&#x27;</span> <span class="variable">$@</span></span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(hide) sed -i -e <span class="string">&#x27;s?%EXPORT_GLOBAL_GCOV_OPTIONS%?$(EXPORT_GLOBAL_GCOV_OPTIONS)?g&#x27;</span> <span class="variable">$@</span></span></span><br></pre></td></tr></table></figure>
<p>从注解可以看出如果<code>PRODUCT_BOOTCLASSPATH</code>变化了，init.environ.rc会重新生成。那么继续挖<code>PRODUCT_BOOTCLASSPATH</code>在哪里改变的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在build/make/core/dex_preopt.mk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> list of boot classpath jars <span class="keyword">for</span> dexpreopt</span></span><br><span class="line">DEXPREOPT_BOOT_JARS := $(subst $(space),:,$(PRODUCT_BOOT_JARS))</span><br><span class="line">DEXPREOPT_BOOT_JARS_MODULES := $(PRODUCT_BOOT_JARS)</span><br><span class="line">PRODUCT_BOOTCLASSPATH := $(subst $(space),:,$(foreach m,$(DEXPREOPT_BOOT_JARS_MODULES),/system/framework/$(m).jar))</span><br></pre></td></tr></table></figure>
<p>虽然看不大懂，但是从PRODUCT_BOOTCLASSPATH这一行我们大概都可以猜到逻辑，foreach遍历/system/framework/下的所有jar包，并且subst将遍历到的包名之间<strong>空格</strong>替换成**’ : ‘**。</p>
<p>从<code>PRODUCT_BOOTCLASSPATH</code>可以看到我们在系统中看到的环境遍历表示方式就类似于：**/system/framework/xx.jar:/system/framework/yy.jar:/system/framework/zz.jar**</p>
<p>然后看<code>DEXPREOPT_BOOT_JARS</code>猜这个标签就是<strong>收集所有的启动jar文件</strong>。继续顺藤grep。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在build/make/target/product/core_minimal.mk中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The order of PRODUCT_BOOT_JARS matters.</span></span><br><span class="line">PRODUCT_BOOT_JARS := \</span><br><span class="line">    core-oj \</span><br><span class="line">    core-libart \</span><br><span class="line">    conscrypt \</span><br><span class="line">    okhttp \</span><br><span class="line">    legacy-test \</span><br><span class="line">    bouncycastle \</span><br><span class="line">    ext \</span><br><span class="line">    framework \</span><br><span class="line">    telephony-common \</span><br><span class="line">    voip-common \</span><br><span class="line">    ims-common \</span><br><span class="line">    apache-xml \</span><br><span class="line">    org.apache.http.legacy.boot \</span><br><span class="line">    android.hidl.base-V1.0-java \</span><br><span class="line">    android.hidl.manager-V1.0-java</span><br></pre></td></tr></table></figure>
<p><strong>总结：在该文件里面定义那些module.jar需要放入环境变量中。后面根加载器就从环境变量中加载类。</strong>配置好之后，重新编系统试试吧。</p>
<h4 id="看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！"><a href="#看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！" class="headerlink" title="看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！"></a>看到此处，使用根加载器配置就剧终了！！！！！！！！！！！！！！！！</h4><h5 id="4-2-自定义加载器"><a href="#4-2-自定义加载器" class="headerlink" title="4.2 自定义加载器"></a>4.2 自定义加载器</h5><p>自定义加载器其基本原来就是替换app中的pathclassloader。将需要加载的dex包路径告诉自定义加载器去加载。</p>
<p>该方案也可以用于应用热修复。</p>
<p><strong>该方案是20年了解热修复框架的时候写的demo代码。</strong>经过呕心吐血调试，终于将ui-framework没有加载到的WeatherChangeListener类加载到了。</p>
<p>测试结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6cbe934a5bd9d0b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dex中获取.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-95061835acd368ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从jar中获取.png"></p>
<p>该工程代码开源到我的github《<a href="https://github.com/oujie123/JVMClassLoader">JVMClassLoader</a>》上了，明天下来集成试试。</p>
<h4 id="注意：自定义加载器的方案应该是项目备选方案。"><a href="#注意：自定义加载器的方案应该是项目备选方案。" class="headerlink" title="注意：自定义加载器的方案应该是项目备选方案。"></a><strong>注意：自定义加载器的方案应该是项目备选方案。</strong></h4><p><strong>自定义加载器方案优点</strong>：稳定好使，但是需要应用集成<code>HotFix.installPatchDex(this,new File(patchPath));</code>这么一句代码。<br><strong>根加载器方案：</strong>ui-framework，car-framework作为公共组件库，还是应该采用4.1中描述的祖宗加载法，系统自动加载类，让应用零代码集成。</p>
<h4 id="自定义加载器代码：https-github-com-oujie123-JVMClassLoader"><a href="#自定义加载器代码：https-github-com-oujie123-JVMClassLoader" class="headerlink" title="自定义加载器代码：https://github.com/oujie123/JVMClassLoader"></a><strong>自定义加载器代码：</strong><a href="https://github.com/oujie123/JVMClassLoader">https://github.com/oujie123/JVMClassLoader</a></h4>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>桌面无法启动</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler机制</title>
    <url>/2021/01/27/Handler%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="1-Handler的诞生"><a href="#1-Handler的诞生" class="headerlink" title="1.Handler的诞生"></a>1.Handler的诞生</h3><p>由于Android采用的是单线程模式，开发者无法在子线程中更新 UI，因此在Android开发中，经常会在子线程中进行一些操作，当操作完成之后，将结果发送到主线程进行显示。探索其背后的模式：子线程、Handler和主线程三者组成了生产者和消费者模式。子线程负责生产数据，主线程负责消费数据，而<strong>Handler负责将数据从子线程抛到主线程中</strong>。详细见下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d554768db7482df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler生产者消费者模型.png"></p>
<h3 id="2-Handler相关的类"><a href="#2-Handler相关的类" class="headerlink" title="2.Handler相关的类"></a>2.Handler相关的类</h3><ul>
<li>Hanlder：发送和接收消息 </li>
<li>Looper：用于轮询消息队列，一个线程只能有一个Looper </li>
<li>Message： 消息实体</li>
<li>MessageQueue： 消息队列用于存储消息和管理消息。</li>
</ul>
<h4 id="2-1-Looper的创建"><a href="#2-1-Looper的创建" class="headerlink" title="2.1 Looper的创建"></a>2.1 Looper的创建</h4><blockquote>
<p>创建Looper的方法是调用Looper.prepare() 方法或者Looper.prepareMainLooper()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadlocal保证一个线程只有一个looper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123; <span class="comment">//如果prepare()被调用两次就会抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//但Thread的map中没有looper,就创建一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span> <span class="comment">//该方法被废弃的原因是:Android帮我们调用了，自己不能调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>); <span class="comment">// 调到上述方法，创建looper</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-创建MessageQueue以及与Looper和当前线程绑定"><a href="#2-2-创建MessageQueue以及与Looper和当前线程绑定" class="headerlink" title="2.2 创建MessageQueue以及与Looper和当前线程绑定"></a>2.2 创建MessageQueue以及与Looper和当前线程绑定</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">// 创建MessageQueue</span></span><br><span class="line">    mThread = Thread.currentThread();<span class="comment">//与当前线程绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quitAllowed参数子线程传入的true，主线程传入false，代表主线程不允许销毁队列</span></span><br><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-Looper-loop-方法"><a href="#2-3-Looper-loop-方法" class="headerlink" title="2.3 Looper.loop()方法"></a>2.3 Looper.loop()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();	<span class="comment">//从threadlocal中拿到调prepare()创建的looper</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//不断从消息队列取消息。</span></span><br><span class="line">        <span class="comment">//queue.next()取消息的过程利用了epoll机制，当没有消息的时候阻塞，当有消息时，向管道写入一个字节数据，唤醒线程取消息。</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//如果队列返回null,说明quit()被调用，需要退出线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 回调抛message的Handler的dispatchMessage，最终会调到handler接收到的callback.handleMessage(msg)中或者handler重写的handleMessage(msg)中。</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//回收处理完的消息(Message采用了享元模式,防止不停的new Message导致内存抖动)</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-4-Handler的创建"><a href="#2-4-Handler的创建" class="headerlink" title="2.4 Handler的创建"></a>2.4 Handler的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="comment">//处理自己抛的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方式2 传入main looper或者子线程looper,通常传MainLooper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3 传入looper和callback,消息处理在callback中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-5-Message的创建"><a href="#2-5-Message的创建" class="headerlink" title="2.5 Message的创建"></a>2.5 Message的创建</h4><p>可以直接new Message()但是不建议这么使用，因为如果有大量的new Message()然后用完了就被回收，这样会导致内存抖动。推荐的方式是使用obtain()系列方法。Message使用了享元模式，内部维护了一个对象池(最大50个)，管理者对象的创建和销毁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next; <span class="comment">//从对象池头部取一个message</span></span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Message中有一系列obtain()方法，主要是完成handler绑定或者callback绑定工作，就不全列举了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> <span class="comment">//Message和handler绑定</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span><span class="comment">//Message与handler和Runnable绑定</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what)</span> <span class="comment">//Message与handler和事件码绑定</span></span></span><br></pre></td></tr></table></figure>


<h4 id="2-6-Message和Handhler绑定"><a href="#2-6-Message和Handhler绑定" class="headerlink" title="2.6 Message和Handhler绑定"></a>2.6 Message和Handhler绑定</h4><ul>
<li><p>方式1：通过上面创建Message时绑定</p>
</li>
<li><p>方式2：在发送消息的到时候绑定(代码如下)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>; <span class="comment">//绑定handler</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-7-Handler发送消息"><a href="#2-7-Handler发送消息" class="headerlink" title="2.7 Handler发送消息"></a>2.7 Handler发送消息</h4><p>如下图调用关系，Handler发送消息的重载方法很多，但是主要只有2种。 sendMessage(Message) sendMessage方法通过一系列重载方法的调用，sendMessage调用sendMessageDelayed，继续调用sendMessageAtTime，继续调用sendMessageAtTime，继续调用enqueueMessage，继续调用MessageQueue的enqueueMessage方法，将消息保存在消息队列中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b8890cf05af6a64f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送消息.png"></p>
<h4 id="2-8-Handler消费消息"><a href="#2-8-Handler消费消息" class="headerlink" title="2.8 Handler消费消息"></a>2.8 Handler消费消息</h4><p>当Looper取出，交给Handler的dispatchMessage进行处理</p>
<p>我们可以看到在dispatchMessage方法中，message中callback是一个Runnable对象，如果callback不为空，则直接调用callback的run方法，否则判断mCallback是否为空，mCallback在Handler构造方法中初始化，在主线程通直接通过无参的构造方法new出来的为null,所以会直接执行后面的handleMessage()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//callback在message的构造方法中初始化或者使用handler.post(Runnable)时候才不为空</span></span><br><span class="line">        handleCallback(msg); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;<span class="comment">//如果callback不为空就调用callback的run()方法</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有Runnable,就回调handler重写的handleMessage()方法。</span></span><br><span class="line">        <span class="comment">//注意，不管是否设置callback都会回调handleMessage()方法</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-难点问题"><a href="#3-难点问题" class="headerlink" title="3.难点问题"></a>3.难点问题</h3><h4 id="3-1-消息加入和取出如何保证线程安全"><a href="#3-1-消息加入和取出如何保证线程安全" class="headerlink" title="3.1 消息加入和取出如何保证线程安全"></a>3.1 消息加入和取出如何保证线程安全</h4><p>MessageQueue在消息入队的时候和取消息的时候都会对队列加锁，保证要么入队消息，要么出队消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消息入队</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//当入队的时候对消息队列加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息出队</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//循环等待消息</span></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//消息出队过程加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-2-消息机制之同步屏障"><a href="#3-2-消息机制之同步屏障" class="headerlink" title="3.2 消息机制之同步屏障"></a>3.2 消息机制之同步屏障</h4><p>通过上面分析，通常情况下Handler抛的消息会按照时间排序，然后Looper从头部开始一个一个取消息执行。但是有个需求是在一个小的时间范围内，handler抛的消息需要优先执行，那我们应该如何处理呢？例如UI需要立马重绘，而且需要优先处理这个消息，那就要用到消息同步屏障。</p>
<blockquote>
<p>MessageQueue.postSyncBarrier()    //开启同步屏障</p>
<p>MessageQueue.removeSyncBarrier() //移除同步屏障</p>
<p>Message.setAsynchronous(true)  //设置为异步消息</p>
</blockquote>
<h5 id="3-2-1-开启同步屏障"><a href="#3-2-1-开启同步屏障" class="headerlink" title="3.2.1 开启同步屏障"></a>3.2.1 开启同步屏障</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，方法调用返回一个屏障的token，到时候删除的时候会用到这个token</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="comment">//从消息池中获取Message</span></span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//就是这里！！！初始化Message对象的时候，并没有给target赋值，因此 target==null</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">             <span class="comment">//如果开启同步屏障的时间（假设记为T）T不为0，且当前的同步消息里有时间小于T，则prev也不为null</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据prev是不是为null，将 msg 按照时间顺序插入到 消息队列（链表）的合适位置</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处开启同步屏障之后，从消息池获取的Message中target==null。</p>
<h5 id="3-2-2-处理异步消息"><a href="#3-2-2-处理异步消息" class="headerlink" title="3.2.2 处理异步消息"></a>3.2.2 处理异步消息</h5><p>从下面可以看出，当消息队列开启同步屏障的时候（即标识为<code>msg.target == null</code>），消息机制在处理消息的时候，优先处理异步消息。这样，同步屏障就起到了一种过滤和优先级的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MessageQueue.java</span></span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	.....<span class="comment">//省略一些代码</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//获取系统开机到现在的时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages; <span class="comment">//当前链表的头结点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关键！！！</span></span><br><span class="line">            <span class="comment">//如果target==null，那么它就是屏障，需要循环遍历，一直往后找到第一个异步的消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next; <span class="comment">//=====重新给msg赋值，达到优先返回异步消息的作用===</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());<span class="comment">//如果有异步消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果有时间到的消息就返回，否则就等待。</span></span><br><span class="line">            &#125;</span><br><span class="line">            .....<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了同步屏障，在返回的msg中会被重新赋值，所以如果开启了同步屏障，MessageQueue会遍历队列中是否有时间到了的异步消息，如果有就重新给msg赋值让他返回出去给handler处理。</p>
<p>示意图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-26531ed2e7963895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步屏障示意图.png"></p>
<h5 id="3-2-3-同步屏障的使用场景"><a href="#3-2-3-同步屏障的使用场景" class="headerlink" title="3.2.3 同步屏障的使用场景"></a>3.2.3 同步屏障的使用场景</h5><p>在 View 更新时，draw、requestLayout、invalidate 等很多地方都调用<code>ViewRootImpl#scheduleTraversals()</code>，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//开启同步屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Choreographer.postCallback最终会调用到postCallbackDelayedInternal()，在这里面设置为异步消息并且发送到消息队列中</span></span><br><span class="line">        <span class="comment">// mTraversalRunnable中会移除同步屏障并且执行UI更新</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;PostCallback: type=&quot;</span> + callbackType</span><br><span class="line">                    + <span class="string">&quot;, action=&quot;</span> + action + <span class="string">&quot;, token=&quot;</span> + token</span><br><span class="line">                    + <span class="string">&quot;, delayMillis=&quot;</span> + delayMillis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">                msg.arg1 = callbackType;</span><br><span class="line">                <span class="comment">//将消息设置成异步消息并且发送到消息队列中，消息队列会根据target==null时取出异步消息执行</span></span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-3-同步执行消息"><a href="#3-3-同步执行消息" class="headerlink" title="3.3 同步执行消息"></a>3.3 同步执行消息</h4><h5 id="3-3-1-runWithScissors-分析"><a href="#3-3-1-runWithScissors-分析" class="headerlink" title="3.3.1 runWithScissors()分析"></a>3.3.1 runWithScissors()分析</h5><p>我们从前面的分析可以看出生产者-消费者模式其实是异步的执行操作。生产者生产好了商品向容器里面放，消费者只管从容器取就行，但是有这么一个场景，就是我生产的东西需要消费了才能继续生产下去，那么就需要考虑同步执行消息了。（可能举例不恰当）但是在framework中，WindowManagerService初始化的时候，就会出现这样的情况，WindowManagerService的初始化是放在<strong>显示子线程</strong>完成的，但是使用多线程来初始化服务虽然加快了初始化速度，但是也会出现一种情况就是某个服务没有初始化结束，导致其他服务运行异常的情况。因此系统提供了Handler.runWithScissors()这个方法来实现同步执行消息。如果任务没有执行结束，该线程不能执行其他的任务。下面我们来分析一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runWithScissors</span><span class="params">(<span class="meta">@NonNull</span> Runnable r, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="comment">// 创建一个带阻塞功能的Runnable，主要是传入待执行的任务</span></span><br><span class="line">    BlockingRunnable br = <span class="keyword">new</span> BlockingRunnable(r);</span><br><span class="line">    <span class="keyword">return</span> br.postAndWait(<span class="keyword">this</span>, timeout); <span class="comment">// 发送任务到消息队列，并且阻塞线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postAndWait</span><span class="params">(Handler handler, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!handler.post(<span class="keyword">this</span>)) &#123; <span class="comment">//发送任务到消息队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> expirationTime = SystemClock.uptimeMillis() + timeout;</span><br><span class="line">            <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait(delay); <span class="comment">//有超时时间的阻塞线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//阻塞线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BlockingRunnable的run方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mTask.run();  <span class="comment">//调用传入任务的run方法执行任务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mDone = <span class="keyword">true</span>;</span><br><span class="line">            notifyAll(); <span class="comment">//通知其他线程不再休眠</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-2-runWithScissors-使用场景"><a href="#3-3-2-runWithScissors-使用场景" class="headerlink" title="3.3.2 runWithScissors()使用场景"></a>3.3.2 runWithScissors()使用场景</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,<span class="keyword">final</span> <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="keyword">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory,Supplier&lt;Surface&gt; surfaceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用显示子线程来初始化WindowManagerService</span></span><br><span class="line">    DisplayThread.getHandler().runWithScissors(() -&gt;</span><br><span class="line">            sInstance = <span class="keyword">new</span> WindowManagerService(context, im, showBootMsgs, onlyCore, policy,atm, transactionFactory, surfaceFactory, surfaceControlFactory), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>参考文章：</strong></p>
<p><a href="https://juejin.cn/post/6844903910113705998">同步屏障</a></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>Framework</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title>SELinux介绍(一)</title>
    <url>/2021/03/15/SELinux%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-Android-中的安全增强型-Linux"><a href="#1-Android-中的安全增强型-Linux" class="headerlink" title="1.Android 中的安全增强型 Linux"></a>1.Android 中的安全增强型 Linux</h3><p>作为 Android <a href="https://source.android.com/security">安全模型</a>的一部分，Android 使用安全增强型 Linux (SELinux) 对所有进程强制执行强制访问控制 (MAC)，甚至包括以 Root/超级用户权限运行的进程（Linux 功能）。很多公司和组织都为 Android 的 <a href="https://android.googlesource.com/platform/external/selinux/">SELinux 实现</a>做出了贡献。借助 SELinux，Android 可以更好地保护和限制系统服务、控制对应用数据和系统日志的访问、降低恶意软件的影响，并保护用户免遭移动设备上的代码可能存在的缺陷的影响。</p>
<p>SELinux 按照默认拒绝的原则运行：任何未经明确允许的行为都会被拒绝。SELinux 可按两种全局模式运行：</p>
<ul>
<li>宽容模式：权限拒绝事件会被记录下来，但不会被强制执行。</li>
<li>强制模式：权限拒绝事件会被记录下来<strong>并</strong>强制执行。</li>
</ul>
<p>Android 中包含 SELinux（处于强制模式）和默认适用于整个 AOSP 的相应安全政策。在强制模式下，非法操作会被阻止，并且尝试进行的所有违规行为都会被内核记录到 <code>dmesg</code> 和 <code>logcat</code>。开发时，您应该先利用这些错误信息对软件和 SELinux 政策进行优化，再对它们进行强制执行。如需了解详情，请参阅<a href="https://source.android.com/security/selinux/implement">实现 SELinux</a>。</p>
<p>此外，SELinux 还支持基于域的宽容模式。在这种模式下，可将特定域（进程）设为宽容模式，同时使系统的其余部分处于全局强制模式。简单来说，域是安全政策中用于标识一个进程或一组进程的标签，安全政策会以相同的方式处理所有具有相同域标签的进程。借助基于域的宽容模式，可逐步将 SELinux 应用于系统中越来越多的部分，还可以为新服务制定政策（同时确保系统的其余部分处于强制模式）。</p>
<h4 id="1-1背景"><a href="#1-1背景" class="headerlink" title="1.1背景"></a>1.1背景</h4><p>Android 安全模型部分基于<a href="https://source.android.com/security/app-sandbox">应用沙盒</a>的概念。每个应用都在自己的沙盒内运行。在 Android 4.3 之前的版本中，这些沙盒是通过为每个应用创建独一无二的 Linux UID（在应用安装时创建）来定义的。Android 4.3 及更高版本使用 SELinux 进一步定义 Android 应用沙盒的边界。</p>
<p>基于 Android 4.3（宽容模式）和 Android 4.4（部分强制模式），在 Android 5.0 及更高版本中，已全面强制执行 SELinux。通过此项变更，Android 已从对有限的一组关键域（<code>installd</code>、<code>netd</code>、<code>vold</code> 和 <code>zygote</code>）强制执行 SELinux 转为对所有域（超过 60 个）强制执行 SELinux。具体而言：</p>
<ul>
<li>在 Android 5.x 及更高版本中，所有域均处于强制模式。</li>
<li><code>init</code> 以外的任何进程都不应在 <code>init</code> 域中运行。</li>
<li>出现任何常规拒绝事件（对于 <code>block_device</code>、<code>socket_device</code>、<code>default_service</code>），都表示设备需要一个特殊域。</li>
</ul>
<p>Android 6.0 通过降低我们政策的宽容度强化了系统安全，从而实现更好的用户隔离和 IOCTL 过滤、降低可从设备/系统之外访问的服务面临的威胁、进一步强化 SELinux 域，以及高度限制对 <code>/proc</code> 的访问。</p>
<p>Android 7.0 更新了 SELinux 配置，以进一步锁定应用沙盒并缩小受攻击面。此版本还将单片式 mediaserver 堆栈拆分为较小的进程，以缩小其权限范围。如需了解详情，请参阅<a href="https://android-developers.googleblog.com/2016/07/protecting-android-with-more-linux.html">利用更多的 Linux 内核防护功能保护 Android 系统</a>和<a href="https://android-developers.googleblog.com/2016/05/hardening-media-stack.html">媒体堆栈安全强化</a>。</p>
<p>Android 8.0 更新了 SELinux 以便与 <a href="https://source.android.com/devices/architecture#hidl">Treble</a> 配合使用，后者可将较低级别的供应商代码与 Android 系统框架分离开来。此版本更新了 SELinux 政策以允许设备制造商和 SOC 供应商更新自己的政策部分、构建自己的映像（<code>vendor.img</code>、<code>boot.img</code> 等），然后更新这些映像而不受平台影响，反之亦然。</p>
<p>虽然可以在设备上运行更高/更新版本的平台（框架），但反之并不成立；供应商映像 (<code>vendor.img/odm.img</code>) 的版本不能高于平台 (<code>system.img</code>) 的版本。因此，较新版平台可能会带来 SELinux 兼容性问题，因为平台 SELinux 政策的版本要比该政策的供应商 SELinux 部分更新。Android 8.0 模型提供了一种<a href="https://source.android.com/security/selinux/compatibility">保持兼容性</a>的方法，以免进行不必要的同时 OTA。</p>
<h4 id="1-2其他资源"><a href="#1-2其他资源" class="headerlink" title="1.2其他资源"></a>1.2其他资源</h4><p>如需关于构建实用 SELinux 政策的帮助，请参阅以下资源：</p>
<ul>
<li><a href="https://events.static.linuxfound.org/sites/events/files/slides/abs2014_seforandroid_smalley.pdf">Security Enhancements for Linux（针对 Linux 的安全增强功能）</a></li>
<li><a href="http://www.cs.columbia.edu/~lierranli/coms6998-7Spring2014/papers/SEAndroid-NDSS2013.pdf">Security Enhanced (SE) Android: Bringing Flexible MAC to Android（安全增强 (SE) Android：在 Android 中引入灵活 MAC）</a></li>
<li><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf">The SELinux Notebook, 4th Edition（SELinux 手册第 4 版）</a></li>
<li><a href="http://selinuxproject.org/page/ObjectClassesPerms">SELinux Object Classes and Permissions Reference（SELinux 对象类和权限参考文档）</a></li>
<li><a href="https://www.nsa.gov/resources/everyone/digital-media-center/publications/research-papers/assets/files/implementing-selinux-as-linux-security-module-report.pdf">Implementing SELinux as a Linux Security Module（将 SELinux 作为 Linux 安全模块实现）</a></li>
<li><a href="https://www.nsa.gov/resources/everyone/digital-media-center/publications/research-papers/assets/files/configuring-selinux-policy-report.pdf">Configuring the SELinux Policy（配置 SELinux 政策）</a></li>
<li><a href="https://www.gnu.org/software/m4/manual/index.html">GNU M4 - GNU Macro Processor Manual（GNU M4 - GNU 宏处理器手册）</a></li>
<li><a href="https://opensource.com/business/13/11/selinux-policy-guide">Your visual how-to guide for SELinux policy enforcement（有关强制执行 SELinux 政策的直观操作指南）</a></li>
</ul>
<h3 id="2-SELinux-概念"><a href="#2-SELinux-概念" class="headerlink" title="2.SELinux 概念"></a>2.SELinux 概念</h3><p>请查看此页中的内容，熟悉 SELinux 概念。</p>
<h4 id="2-1强制访问控制"><a href="#2-1强制访问控制" class="headerlink" title="2.1强制访问控制"></a>2.1强制访问控制</h4><p>安全增强型 Linux (SELinux) 是适用于 Linux 操作系统的强制访问控制 (MAC) 系统。作为 MAC 系统，它与 Linux 中用户非常熟悉的自主访问控制 (DAC) 系统不同。在 DAC 系统中，存在所有权的概念，即特定资源的所有者可以控制与该资源关联的访问权限。这种系统通常比较粗放，并且容易出现无意中提权的问题。MAC 系统则会在每次收到访问请求时都先咨询核心机构，再做出决定。</p>
<p>SELinux 已作为 Linux 安全模块 (LSM) 框架的一部分实现，该框架可识别各种内核对象以及对这些对象执行的敏感操作。其中每项操作要执行时，系统都会调用 LSM 钩子函数，以便根据不透明安全对象中存储的关于相应操作的信息来确定是否应允许执行相应操作。SELinux 针对这些钩子以及这些安全对象的管理提供了相应的实现，该实现可结合自己的政策来决定是否允许相应访问。</p>
<p>通过结合使用其他 Android 安全措施，Android 的访问控制政策能够大大降低遭到入侵的计算机和帐号可能蒙受的损失。Android 的自主访问控制和强制访问控制等工具可为您提供一种结构，确保您的软件仅以最低权限级别运行。这样可降低攻击造成的影响，并降低错误进程重写数据甚至是传输数据的可能性。</p>
<p>在 Android 4.3 及更高版本中，SELinux 开始为传统的自主访问控制 (DAC) 环境提供强制访问控制 (MAC) 保护功能。例如，软件通常情况下必须以 Root 用户帐号的身份运行，才能向原始块设备写入数据。在基于 DAC 的传统 Linux 环境中，如果 Root 用户遭到入侵，攻击者便可以利用该用户身份向每个原始块设备写入数据。不过，可以使用 SELinux 为这些设备添加标签，以便被分配了 Root 权限的进程可以只向相关政策中指定的设备写入数据。这样一来，该进程便无法重写特定原始块设备之外的数据和系统设置。</p>
<p>如需更多安全威胁示例以及使用 SELinux 解决安全威胁的方法，请参阅<a href="https://source.android.com/security/selinux/implement#use_cases">用例</a>。</p>
<h4 id="2-2强制执行级别"><a href="#2-2强制执行级别" class="headerlink" title="2.2强制执行级别"></a>2.2强制执行级别</h4><p>SELinux 可以在各种模式下实现：</p>
<ul>
<li>宽容模式 - 仅记录但不强制执行 SELinux 安全政策。</li>
<li>强制模式 - 强制执行并记录安全政策。如果失败，则显示为 EPERM 错误。</li>
</ul>
<p>在选择强制执行级别时只能二择其一，您的选择将决定您的政策是采取操作，还是仅允许您收集潜在的失败事件。宽容模式在实现过程中尤其有用。</p>
<h4 id="2-3标签、规则和域"><a href="#2-3标签、规则和域" class="headerlink" title="2.3标签、规则和域"></a>2.3标签、规则和域</h4><p>SELinux 依靠标签来匹配操作和政策。标签用于决定允许的事项。套接字、文件和进程在 SELinux 中都有标签。SELinux 在做决定时需参照两点：一是为这些对象分配的标签，二是定义这些对象如何交互的政策。</p>
<p>在 SELinux 中，标签采用以下形式：<code>user:role:type:mls_level</code>，其中 type 是访问决定的主要组成部分，可通过构成标签的其他组成部分进行修改。对象会映射到类，对每个类的不同访问类型由权限表示。</p>
<p>政策规则采用以下形式：<code>allow *domains* *types*:*classes* *permissions*;</code>，其中：</p>
<ul>
<li>Domain - 一个进程或一组进程的标签。也称为域类型，因为它只是指进程的类型。</li>
<li>Type - 一个对象（例如，文件、套接字）或一组对象的标签。</li>
<li>Class - 要访问的对象（例如，文件、套接字）的类型。</li>
<li>Permission - 要执行的操作（例如，读取、写入）。</li>
</ul>
<p>使用政策规则时将遵循的结构示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow appdomain app_data_file:file rw_file_perms;</span><br></pre></td></tr></table></figure>
<p>这表示所有应用域都可以读取和写入带有 <code>app_data_file</code> 标签的文件。请注意，该规则依赖于在 <code>global_macros</code> 文件中定义的宏，您还可以在 <code>te_macros</code> 文件中找到一些其他非常实用的宏。其中提供了一些适用于常见的类、权限和规则分组的宏。应尽可能使用这些宏，以便降低因相关权限被拒而导致失败的可能性。这些宏文件位于 <a href="https://android.googlesource.com/platform/system/sepolicy/">system/sepolicy</a> 目录中。在 Android 8.0 及更高版本中，它们与其他受支持的公共 sepolicy 一起位于 <code>public</code> 子目录中。</p>
<p>除了在规则中逐个列出域或类型之外，还可以通过属性引用一组域或类型。简单来说，属性是一组域或类型的名称。每个域或类型都可以与任意数量的属性相关联。当编写的规则指定了某个属性名称时，该名称会自动扩展为列出与该属性关联的所有域或类型。例如，domain 属性与所有进程域相关联，file_type 属性与所有文件类型相关联。</p>
<p>使用上述语法可以创建构成 SELinux 政策基本内容的 avc 规则。规则采用以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RULE_VARIANT SOURCE_TYPES TARGET_TYPES : CLASSES PERMISSIONS</span><br></pre></td></tr></table></figure>
<p>该规则指明了，当带有任何 source_types 标签的主体尝试对包含任何 classes 类且带有 target_types 标签的对象执行与任何 permissions 对应的操作时，应该发生什么情况。这些规则的一个最常见示例是 allow 规则，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow domain null_device:chr_file &#123; open &#125;;</span><br></pre></td></tr></table></figure>
<p>该规则允许具有与 <code>domain</code> 属性关联的任何 domain 的进程对 target_type 标签为 <code>null_device</code> 的 class <code>chr_file</code>（字符设备文件）的对象执行 permission <code>open</code> 所描述的操作。在实践中，该规则可能会扩展，包含其他权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow domain null_device:chr_file &#123; getattr open read ioctl lock append write&#125;;</span><br></pre></td></tr></table></figure>
<p>当了解到 <code>domain</code> 是分配给所有进程域的属性，并且 <code>null_device</code> 是字符设备 <code>/dev/null</code> 的标签时，该规则基本上会允许对 <code>/dev/null</code> 进行读写操作。</p>
<p>一个 domain 通常对应一个进程，而且具有与其关联的标签。</p>
<p>例如，典型的 Android 应用会在自己的进程中运行，并且具有 <code>untrusted_app</code> 标签（用于向其授予特定受限权限）。</p>
<p>系统中内置的平台应用会以单独的标签运行，并会被授予一组不同的权限。作为核心 Android 系统的一部分，系统 UID 应用以表示另一组权限的 <code>system_app</code> 标签运行。</p>
<p>在任何情况下，都不应直接允许域访问以下通用标签；而应为一个或多个对象创建一个更具体的类型：</p>
<ul>
<li><code>socket_device</code></li>
<li><code>device</code></li>
<li><code>block_device</code></li>
<li><code>default_service</code></li>
<li><code>system_data_file</code></li>
<li><code>tmpfs</code></li>
</ul>
<h3 id="3-实现-SELinux"><a href="#3-实现-SELinux" class="headerlink" title="3.实现 SELinux"></a>3.实现 SELinux</h3><p>SELinux 被设置为“默认拒绝”模式，这表示，对于在内核中存在钩子的每一次访问，都必须获得政策的明确许可。这意味着政策文件中包含规则、类型、类、权限等方面的大量信息。关于 SELinux 的完整注意事项不在本文档的讨论范围之内，现在您必须要了解的是在启动新的 Android 设备时如何编写政策规则。目前有大量关于 SELinux 的信息可供您参考。关于建议的资源，请参阅<a href="https://source.android.com/security/selinux#supporting_documentation">支持文档</a>。</p>
<h4 id="3-1关键文件"><a href="#3-1关键文件" class="headerlink" title="3.1关键文件"></a>3.1关键文件</h4><p>如需启用 SELinux，请集成<a href="https://android.googlesource.com/kernel/common/">最新的 Android 内核</a>，然后整合 <a href="https://android.googlesource.com/platform/system/sepolicy/">system/sepolicy</a> 目录中的文件。这些文件在编译后会包含 SELinux 内核安全政策，并涵盖上游 Android 操作系统。</p>
<p>通常情况下，您不能直接修改 <code>system/sepolicy</code> 文件，但您可以添加或修改自己的设备专用政策文件（位于 <code>/device/manufacturer/device-name/sepolicy</code> 目录中）。在 Android 8.0 及更高版本中，您对这些文件所做的更改只会影响供应商目录中的政策。如需详细了解 Android 8.0 及更高版本中的公共 sepolicy 分离，请参阅<a href="https://source.android.com/security/selinux/customize#android-o">在 Android 8.0 及更高版本中自定义 SEPolicy</a>。无论是哪个 Android 版本，您都仍需要修改以下文件：</p>
<h4 id="3-2政策文件"><a href="#3-2政策文件" class="headerlink" title="3.2政策文件"></a>3.2政策文件</h4><p>以 <code>*.te</code> 结尾的文件是 SELinux 政策源代码文件，用于定义域及其标签。您可能需要在 <code>/device/manufacturer/device-name/sepolicy</code> 中创建新的政策文件，但您应尽可能尝试更新现有文件。</p>
<h4 id="3-3上下文的描述文件"><a href="#3-3上下文的描述文件" class="headerlink" title="3.3上下文的描述文件"></a>3.3上下文的描述文件</h4><p>您可以在上下文的描述文件中为您的对象指定标签。</p>
<ul>
<li><code>file_contexts</code> 用于为文件分配标签，并且可供多种用户空间组件使用。在创建新政策时，请创建或更新该文件，以便为文件分配新标签。如需应用新的 <code>file_contexts</code>，请重新构建文件系统映像，或对要重新添加标签的文件运行 <code>restorecon</code>。在升级时，对 <code>file_contexts</code> 所做的更改会在升级过程中自动应用于系统和用户数据分区。此外，您还可以通过以下方式使这些更改在升级过程中自动应用于其他分区：在以允许读写的方式装载相应分区后，将 <code>restorecon_recursive</code> 调用添加到 init.board.rc 文件中。</li>
<li><code>genfs_contexts</code> 用于为不支持扩展属性的文件系统（例如，<code>proc</code> 或 <code>vfat</code>）分配标签。此配置会作为内核政策的一部分进行加载，但更改可能对内核 inode 无效。要全面应用更改，您需要重新启动设备，或卸载并重新装载文件系统。此外，通过使用 <code>context=mount</code> 选项，您还可以为装载的特定系统文件（例如 <code>vfat</code>）分配特定标签。</li>
<li><code>property_contexts</code> 用于为 Android 系统属性分配标签，以便控制哪些进程可以设置这些属性。在启动期间，<code>init</code> 进程会读取此配置。</li>
<li><code>service_contexts</code> 用于为 Android Binder 服务分配标签，以便控制哪些进程可以为相应服务添加（注册）和查找（查询）Binder 引用。在启动期间，<code>servicemanager</code> 进程会读取此配置。</li>
<li><code>seapp_contexts</code> 用于为应用进程和 <code>/data/data</code> 目录分配标签。在每次应用启动时，<code>zygote</code> 进程都会读取此配置；在启动期间，<code>installd</code> 会读取此配置。</li>
<li><code>mac_permissions.xml</code> 用于根据应用签名和应用软件包名称（后者可选）为应用分配 <code>seinfo</code> 标记。随后，分配的 <code>seinfo</code> 标记可在 <code>seapp_contexts</code> 文件中用作密钥，以便为带有该 <code>seinfo</code> 标记的所有应用分配特定标签。在启动期间，<code>system_server</code> 会读取此配置。</li>
</ul>
<h4 id="3-4-BoardConfig-mk-makefile"><a href="#3-4-BoardConfig-mk-makefile" class="headerlink" title="3.4 BoardConfig.mk makefile"></a>3.4 BoardConfig.mk makefile</h4><p>修改或添加政策文件和上下文的描述文件后，请更新您的 <code>/device/manufacturer/device-name/BoardConfig.mk</code>makefile 以引用 <code>sepolicy</code> 子目录和每个新的政策文件。如需详细了解 <code>BOARD_SEPOLICY</code> 变量，请参阅 <a href="https://android.googlesource.com/platform/system/sepolicy/+/master/README"><code>system/sepolicy/README</code> 文件</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOARD_SEPOLICY_DIRS +&#x3D; \</span><br><span class="line">        &lt;root&gt;&#x2F;device&#x2F;manufacturer&#x2F;device-name&#x2F;sepolicy</span><br><span class="line"></span><br><span class="line">BOARD_SEPOLICY_UNION +&#x3D; \</span><br><span class="line">        genfs_contexts \</span><br><span class="line">        file_contexts \</span><br><span class="line">        sepolicy.te</span><br></pre></td></tr></table></figure>
<p>重新进行构建后，您的设备会启用 SELinux。现在，您可以根据您向 Android 操作系统添加的内容自定义 SELinux 政策（如<a href="https://source.android.com/security/selinux/customize">自定义</a>中所述），也可以验证现有设置（如<a href="https://source.android.com/security/selinux/validate">验证</a>中所述）。</p>
<p>在新政策文件和 BoardConfig.mk 更新部署到位后，新政策设置会自动内置到最终的内核政策文件中。如需详细了解如何在设备上构建 sepolicy，请参阅<a href="https://source.android.com/security/selinux/build">构建 sepolicy</a>。</p>
<h4 id="3-5-实现"><a href="#3-5-实现" class="headerlink" title="3.5 实现"></a>3.5 实现</h4><p>如需开始使用 SELinux，请执行以下操作：</p>
<ol>
<li><p>在内核中启用 SELinux：<code>CONFIG_SECURITY_SELINUX=y</code></p>
</li>
<li><p>更改 kernel_cmdline 参数，以便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOARD_KERNEL_CMDLINE :&#x3D; androidboot.selinux&#x3D;permissive</span><br></pre></td></tr></table></figure>
<p>这仅适用于初始制定设备政策的情况。在拥有初始引导程序政策后，请移除此参数，以便将设备恢复强制模式，否则设备将无法通过 CTS 验证。</p>
</li>
<li><p>以宽容模式启动系统，看看在启动时会遇到哪些拒绝事件：</p>
<p>在 Ubuntu 14.04 或更高版本中，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell su -c dmesg | grep denied | audit2allow -p out&#x2F;target&#x2F;product&#x2F;BOARD&#x2F;root&#x2F;sepolicy</span><br></pre></td></tr></table></figure>
<p>在 Ubuntu 12.04 中，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull &#x2F;sys&#x2F;fs&#x2F;selinux&#x2F;policy</span><br><span class="line">adb logcat -b all | audit2allow -p policy</span><br></pre></td></tr></table></figure></li>
<li><p>评估与以下内容类似的警告的输出：<code>init: Warning! Service name needs a SELinux domain defined; please fix!</code>。如需查看相关说明和工具，请参阅<a href="https://source.android.com/security/selinux/validate">验证</a>。</p>
</li>
<li><p>标识设备以及需要添加标签的其他新文件。</p>
</li>
<li><p>为您的对象使用现有标签或新标签。查看 <code>*_contexts</code> 文件，了解之前是如何为内容添加标签的，然后根据对标签含义的了解分配一个新标签。这个标签最好是能够融入到政策中的现有标签，但有时也需要使用新标签，而且还需要提供关于访问该标签的规则。将您的标签添加到相应的上下文的描述文件中。</p>
</li>
<li><p>标识应该拥有自己的安全域的域/进程。您可能需要为每一项分别编写一个全新的政策。例如，从</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init</span><br></pre></td></tr></table></figure>
<p>衍生的所有服务都应该有自己的安全域。以下命令有助于查看保持运行的服务（不过所有服务都需要如此处理）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell su -c ps -Z | grep init</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell su -c dmesg | grep &#39;avc: &#39;</span><br></pre></td></tr></table></figure></li>
<li><p>查看 <code>init.device.rc</code> 以发现没有域类型的域。请在开发过程早期为其提供相应的域，以避免向 <code>init</code> 添加规则或将 <code>init</code> 访问权限与其自身政策中的访问权限混淆。</p>
</li>
<li><p>设置 <code>BOARD_CONFIG.mk</code> 以使用 <code>BOARD_SEPOLICY_*</code> 变量。如需详细了解如何进行此项设置，请参阅 <code>system/sepolicy</code> 中的 <a href="https://android.googlesource.com/platform/system/sepolicy/+/master/README">README</a>。</p>
</li>
<li><p>检查 init.device.rc 和 fstab.device 文件，确保每一次使用 <code>mount</code> 都对应一个添加了适当标签的文件系统，或者指定了 <code>context= mount</code> 选项。</p>
</li>
<li><p>查看每个拒绝事件，并创建 SELinux 政策来妥善处理每个拒绝事件。请参阅<a href="https://source.android.com/security/selinux/customize">自定义</a>中的示例。</p>
</li>
</ol>
<p>建议从 AOSP 中的政策入手，然后在这些政策的基础上创建自己的自定义政策。要详细了解政策策略以及其中一些步骤，请参阅<a href="https://source.android.com/security/selinux/device-policy">编写 SELinux 政策</a>。</p>
<h4 id="3-6-用例"><a href="#3-6-用例" class="headerlink" title="3.6 用例"></a>3.6 用例</h4><p>下面列举了一些在开发软件以及制定关联的 SELinux 政策时需要注意的具体漏洞：</p>
<p><strong>符号链接</strong> - 由于符号链接以文件形式显示，因此系统通常将其作为文件进行读取，而这可能会导致漏洞。例如，某些特权组件（例如 <code>init</code>）会更改某些文件的权限，有时会使之极度开放。</p>
<p>这样一来，攻击者便可以将这些文件替换成指向其控制的代码的符号链接，从而重写任意文件。但如果您知道自己的应用绝不会遍历符号链接，则可以通过 SELinux 来禁止您的应用遍历符号链接。</p>
<p><strong>系统文件</strong> - 以应该只有系统服务器可以修改的一系列系统文件为例。由于 <code>netd</code>、<code>init</code> 和 <code>vold</code> 是以 Root 身份运行的，因此它们也可以访问这些系统文件。这样一来，如果 <code>netd</code> 遭到入侵，这些文件乃至系统服务器本身都可能遭到入侵。</p>
<p>借助 SELinux，您可以将这些文件标识为系统服务器数据文件。这样一来，系统服务器就是唯一对这些文件具有读写权限的域。即使 <code>netd</code> 遭到入侵，它也无法将域切换到系统服务器域并访问这些系统文件，就算它是以 Root 身份运行的也是如此。</p>
<p><strong>应用数据</strong> - 另一个示例是必须以 Root 身份运行但不应获得应用数据访问权限的一系列函数。这一项非常有用，因为它可以做出广泛的声明，例如禁止与应用数据无关的特定域访问互联网。</p>
<p><strong>setattr</strong> - 对于 <code>chmod</code> 和 <code>chown</code> 等命令，您可以标识关联域可以在哪些文件中进行 <code>setattr</code> 操作。这样一来，便可以禁止对这些文件之外的任何文件进行这类更改，即使以 Root 身份进行也不例外。因此，应用可以对带 <code>app_data_files</code> 标签的文件运行 <code>chmod</code> 和 <code>chown</code>，但不能对带 <code>shell_data_files</code> 或 <code>system_data_files</code> 标签的文件运行这些命令。</p>
]]></content>
      <categories>
        <category>Android Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SeLinux</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(八) -- Java内存模型</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%85%AB-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="1-计算机原理"><a href="#1-计算机原理" class="headerlink" title="1. 计算机原理"></a>1. 计算机原理</h4><p>​    Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java1.5版本对其进行了重构，现在的Java仍沿用了Java1.5的版本。</p>
<p>根据《Jeff Dean在Google全体工程大会的报告》我们可以看到</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1d49798d5a18fbd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机执行不同操作耗时.png"></p>
<p>计算机在做一些我们平时的基本操作时，需要的响应时间是不一样的。</p>
<h4 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2.  Java内存模型"></a>2.  Java内存模型</h4><p>​    从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个<strong>私有</strong>的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4bc74c29ba73c70a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JMM模型.png"></p>
<h5 id="2-1-可见性"><a href="#2-1-可见性" class="headerlink" title="2.1 可见性"></a>2.1 可见性</h5><p>​    可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>​    由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。</p>
<p>​    要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。</p>
<h5 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h5><p>​    原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>​    我们都知道CPU资源的分配都是以线程为单位的,并且是分时调用,操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。而任务的切换大多数是在时间片段结束以后,</p>
<p>​    那么线程切换为什么会带来bug呢？因为操作系统做任务切换，可以发生在任何一条CPU 指令执行完！注意，是 CPU 指令,而不是高级语言里的一条语句。比如count++，在java里就是一句话，但高级语言里一条语句往往需要多条 CPU 指令完成。其实count++包含了三个CPU指令！</p>
<h4 id="3-volatile详解"><a href="#3-volatile详解" class="headerlink" title="3.volatile详解"></a>3.volatile详解</h4><h5 id="3-1-volatile特性"><a href="#3-1-volatile特性" class="headerlink" title="3.1 volatile特性"></a>3.1 volatile特性</h5><p>​    可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>​    原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。例如：volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2。</p>
<p>​    抑制重排序：<strong>有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。</p>
<p>​    指令重排序：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<h5 id="3-2-volatile的实现原理"><a href="#3-2-volatile的实现原理" class="headerlink" title="3.2 volatile的实现原理"></a>3.2 volatile的实现原理</h5><p>​    为了探究Volatile的底层实现原理，我们需要先将java代码编程成字节码，然后通过java工具看汇编代码就可以知道底层原理。下面来看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap -c 文件名 或者AndroidStudio的ASM插件看字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;clinit&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">8</span> L0</span><br><span class="line">    ICONST_0</span><br><span class="line">    <span class="comment">// 下面这行字节码无论是否使用volatile修饰，都是一样的</span></span><br><span class="line">    PUTSTATIC com/example/threadtest/volatilesynchronized/TestVolatile.i : I</span><br><span class="line">    RETURN</span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后继续往下探索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly TestVolatile &gt; 1.txt</span><br></pre></td></tr></table></figure>
<p>查看汇编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Line 2521:   0x000000000356fecc: lock cmpxchg qword ptr [rdx],rdi</span><br><span class="line">Line 2528:   0x000000000356feed: lock cmpxchg qword ptr [rdx],rdi</span><br><span class="line">Line 2534:   0x000000000356ff0b: lock add dword ptr [rsp],0h ;*putstatic</span><br><span class="line">Line 2538:   0x000000000356ff1a: lock cmpxchg qword ptr [rdx],rsi</span><br><span class="line">Line 2816:   0x0000000003570338: lock cmpxchg qword ptr [rdi],rsi</span><br><span class="line">Line 2941:   0x0000000003570479: lock cmpxchg qword ptr [rsi],rdi</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<p>汇编指令中会有很多加“lock”前缀的指令。</p>
<p>加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。我们发现，volatile变量在字节码级别没有任何区别，在汇编级别使用了lock指令前缀。</p>
<blockquote>
<p>lock是一个指令前缀，Intel的手册上对其的解释是：</p>
<p> Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (turns the instruction into an atomic instruction). In a multiprocessor environment, the LOCK# signal insures that the processor has exclusive use of any shared memory while the signal is asserted.</p>
</blockquote>
<p>​    简单理解也就是说，lock后就是一个原子操作。原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>​    当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。</p>
<p>​    乍一看是不是感觉和Java的synchronized锁。但volatile底层使用多核处理器实现的lock指令，更底层，消耗代价更小。</p>
<p>​    <strong>因此有人将Java的synchronized看作重量级的锁，而volatile看作轻量级的锁 并不是全无道理。</strong></p>
<p>​    lock前缀指令其实就相当于一个内存屏障。内存屏障是一组CPU处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。</p>
<p>​    编译器和执行器 可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。</p>
<p>​    <strong>内存屏障另一个作用是强制更新一次不同CPU的缓存。</strong>例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪个CPU执行的。这正是volatile实现内存可见性的基础。</p>
<h4 id="3-3-synchronized的实现原理"><a href="#3-3-synchronized的实现原理" class="headerlink" title="3.3 synchronized的实现原理"></a>3.3 synchronized的实现原理</h4><p>​    Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>对同步块</strong>，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ......</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">    MONITORENTER      <span class="comment">// 同步块开始</span></span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 15 L0</span></span><br><span class="line"><span class="function">    GETSTATIC com/example/threadtest/volatilesynchronized/Test.i : I</span></span><br><span class="line"><span class="function">    ICONST_1</span></span><br><span class="line"><span class="function">    IADD</span></span><br><span class="line"><span class="function">    PUTSTATIC com/example/threadtest/volatilesynchronized/Test.i : I</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LINENUMBER 16 L5</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    MONITOREXIT   <span class="comment">// 同步块结束</span></span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    GOTO L6</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> 	 ......</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>对同步方法</strong>，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了<strong>ACC_SYNCHRONIZED</strong>标示符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// access flags 0x1    没有synchronized修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">a</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// access flags 0x21   synchronized修饰</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title">b</span><span class="params">()</span>V</span></span><br></pre></td></tr></table></figure>


<p>​    JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<p>​    synchronized使用的锁信息是存放在Java对象头里面。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c41b9e1044e9b947.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象头.png"></p>
<p>​    具体位置是对象头里面的MarkWord，MarkWord里默认数据是存储对象的HashCode等信息，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c78ecc4cb3e78dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="markword位定义.png"></p>
<p>​    但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-1fc34498389dd8f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="锁状态.png"></p>
<h4 id="3-4-各种锁"><a href="#3-4-各种锁" class="headerlink" title="3.4 各种锁"></a>3.4 各种锁</h4><p><strong>3.4.1.1 自旋锁 (轻量级锁)</strong></p>
<p>​    自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p><strong>3.4.1.2 自旋锁的优缺点</strong></p>
<p>​    自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。</p>
<p>​    但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功。</p>
<p><strong>3.4.1.3 自旋锁时间阈值</strong></p>
<p>​    JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁</p>
<p>，<strong>适应性自旋锁</strong>意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p>
<p>​    JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制</p>
<p><strong>3.4.2.1 偏向锁</strong></p>
<p>​    研究人员经过大量统计，发现一把锁总是被同一线程竞争拿到，所以就引入偏向锁概念，当在进行CAS自旋拿锁之前，先判断自己是不是在竞争这把锁，如果是就直接执行。</p>
<p>​    偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），<strong>这种情况下，就会给线程加一个偏向锁</strong>。 如果在运行过程中，<strong>遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</strong>它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</p>
<p><strong>偏向锁获取过程：</strong></p>
<ul>
<li><p>第一步，访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</p>
</li>
<li><p>第二步，如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</p>
</li>
<li><p>第三步，如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</p>
</li>
<li><p>第四步，如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</p>
</li>
<li><p>第五步，执行同步代码。</p>
</li>
</ul>
<p><strong>偏向锁的释放：</strong></p>
<p>​    偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p><strong>偏向锁的适用场景</strong></p>
<p>​    始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； </p>
<p>​    在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</p>
<p><strong>jvm开启/关闭偏向锁</strong></p>
<p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</p>
<p>关闭偏向锁：-XX:-UseBiasedLocking</p>
<p><strong>3.4.3 轻量级锁</strong></p>
<p>​    轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p>
<p><strong>轻量级锁的加锁过程：</strong></p>
<p>​    在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p>
<p>​    拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</p>
<ul>
<li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态</p>
</li>
<li><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，<strong>当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁</strong>，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
</li>
</ul>
<p><strong>3.4.4 不同锁之间的区别</strong></p>
<p>​    JVM虚拟机对synchronized关键字的优化引入了自适应性CAS锁、偏向锁和轻量级锁机制。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-06ca275216327a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对synchronized用不同锁的优化.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结(六) -- 阻塞队列和线程池</title>
    <url>/2021/01/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93-%E5%85%AD-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="1-阻塞队列"><a href="#1-阻塞队列" class="headerlink" title="1. 阻塞队列"></a>1. 阻塞队列</h3><ul>
<li><p><strong>队列</strong>：是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。<br>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p>
</li>
<li><p><strong>阻塞队列</strong>是支持阻塞插入和支持阻塞移除的队列：</p>
<p>阻塞的插入：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>阻塞的移除：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>
</li>
</ul>
<h3 id="2-阻塞队列的用途"><a href="#2-阻塞队列的用途" class="headerlink" title="2. 阻塞队列的用途"></a>2. 阻塞队列的用途</h3><ul>
<li>阻塞队列常用于<strong>生产者和消费者</strong>的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</li>
</ul>
<h4 id="2-1-为什么有生产者消费者模式"><a href="#2-1-为什么有生产者消费者模式" class="headerlink" title="2.1 为什么有生产者消费者模式"></a>2.1 为什么有生产者消费者模式</h4><ul>
<li>在并发编程中，为了平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度，因此生产者消费者模式就有了用武之地。</li>
<li>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。</li>
</ul>
<p>​    <strong>因此就需要将生产者和消费者隔离开，并且用一个容器将产品装好。生产者生产好产品就把产品放入容器，消费者需要的时候就从容器中拿。</strong> 而这个容器就可以用队列来实现。然而有容器为空和满的两种情况导致生产者在容器满的时候无法放入队列，消费者当容器为空的时候无法从队列获取产品。所以阻塞队列就应运而生。</p>
<h4 id="2-2-阻塞队列接口-BlockingQueue"><a href="#2-2-阻塞队列接口-BlockingQueue" class="headerlink" title="2.2 阻塞队列接口(BlockingQueue)"></a>2.2 阻塞队列接口(BlockingQueue)</h4><p>​    下面看看BlockingQueue中定义的方法区别</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(E)</td>
<td>offer(E)</td>
<td>put(E)</td>
<td>offer(E, time, unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(E, time, unit)</td>
</tr>
<tr>
<td>检查队列方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li><p>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</p>
</li>
<li><p>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</p>
</li>
<li><p>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</p>
</li>
<li><p>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p>
</li>
</ul>
<h4 id="2-3-有哪些阻塞队列"><a href="#2-3-有哪些阻塞队列" class="headerlink" title="2.3 有哪些阻塞队列"></a>2.3 有哪些阻塞队列</h4><ul>
<li><p>ArrayBlockingQueue：一个由数组结构组成的<strong>有界</strong>阻塞队列。</p>
<p>是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列。在操作队列的时候使用同一把<strong>显示锁</strong>。</p>
</li>
<li><p>LinkedBlockingQueue：一个由链表结构组成的<strong>有界</strong>阻塞队列。</p>
<p>是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。在操作队列的时候使用三把锁实现：lock全局锁、放入时队列不满锁notFull和取出时队列不为空锁notEmpty。</p>
</li>
<li><p>PriorityBlockingQueue：一个支持优先级排序的<strong>无界</strong>阻塞队列。</p>
<p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
</li>
<li><p>DelayQueue：一个使用优先级队列实现的<strong>无界</strong>阻塞队列。</p>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p>
</li>
<li><p>SynchronousQueue：一个<strong>不存储元素</strong>的阻塞队列。</p>
<p>SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。主要可以解决生产者消费者隔离问题。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
</li>
</ul>
<ul>
<li>LinkedTransferQueue：一个由链表结构组成的<strong>无界</strong>阻塞队列。<ul>
<li><strong>(1) transfer方法</strong><pre><code>  如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。
</code></pre>
</li>
<li><strong>(2) tryTransfer方法</strong><br>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是<strong>tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</strong></li>
</ul>
</li>
</ul>
<ul>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p>
</li>
</ul>
<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h3><h4 id="3-1-使用线程池的好处"><a href="#3-1-使用线程池的好处" class="headerlink" title="3.1 使用线程池的好处"></a>3.1 使用线程池的好处</h4><ul>
<li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。有时候任务执行的时间还远小于线程创建和销毁的时间。</p>
</li>
<li><p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
</li>
</ul>
<h4 id="3-2-线程池相关的类"><a href="#3-2-线程池相关的类" class="headerlink" title="3.2 线程池相关的类"></a>3.2 线程池相关的类</h4><ul>
<li><p>Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</p>
</li>
<li><p>ExecutorService接口继承了Executor，在其上做了一些shutdown()、submit()的扩展，可以说是真正的线程池接口；</p>
</li>
<li><p>AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法；</p>
</li>
<li><p>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。</p>
</li>
<li><p>ScheduledExecutorService接口继承了ExecutorService接口，提供了带”周期执行”功能ExecutorService；</p>
</li>
<li><p>ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bce5aa17de1ecc42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池类关系图.png"></p>
<h4 id="3-3-线程池的创建各个参数含义"><a href="#3-3-线程池的创建各个参数含义" class="headerlink" title="3.3 线程池的创建各个参数含义"></a>3.3 线程池的创建各个参数含义</h4><blockquote>
<p>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, /*核心线程数，最大线程数*/</p>
<p>​    long keepAliveTime, TimeUnit unit,  /*空闲线程存活时间 */</p>
<p>​    BlockingQueue<Runnable> workQueue, /*阻塞队列 */</Runnable></p>
<p>   ThreadFactory threadFactory,  /*线程工厂 */</p>
<p>   RejectedExecutionHandler handler)  /*线程池拒绝策略处理器 */</p>
</blockquote>
<p>从构造方法可以看出创建线程池有五类7个参数可以配置，下面来一一阐述一下</p>
<h5 id="3-3-1-corePoolSize"><a href="#3-3-1-corePoolSize" class="headerlink" title="3.3.1 corePoolSize"></a>3.3.1 corePoolSize</h5><p>​    线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；</p>
<p>​    如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p>
<p>​    如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<h5 id="3-3-2-maximumPoolSize"><a href="#3-3-2-maximumPoolSize" class="headerlink" title="3.3.2 maximumPoolSize"></a>3.3.2 maximumPoolSize</h5><p>​    线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p>
<h5 id="3-3-3-keepAliveTime"><a href="#3-3-3-keepAliveTime" class="headerlink" title="3.3.3 keepAliveTime"></a>3.3.3 keepAliveTime</h5><p>​    线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p>
<h5 id="3-3-4-TimeUnit"><a href="#3-3-4-TimeUnit" class="headerlink" title="3.3.4 TimeUnit"></a>3.3.4 TimeUnit</h5><p>keepAliveTime的时间单位</p>
<h5 id="3-3-5-workQueue"><a href="#3-3-5-workQueue" class="headerlink" title="3.3.5 workQueue"></a>3.3.5 workQueue</h5><p>​    workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。</p>
<p>​    一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响。</p>
<ul>
<li>(1)当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li>
<li>(2)由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li>
<li>(3)由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li>
<li>(4)更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</li>
</ul>
<h5 id="3-3-6-threadFactory"><a href="#3-3-6-threadFactory" class="headerlink" title="3.3.6 threadFactory"></a>3.3.6 threadFactory</h5><p>​    创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。</p>
<p>​    Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</p>
<h5 id="3-3-7-RejectedExecutionHandler"><a href="#3-3-7-RejectedExecutionHandler" class="headerlink" title="3.3.7 RejectedExecutionHandler"></a>3.3.7 RejectedExecutionHandler</h5><p>​    线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<ul>
<li>(1) AbortPolicy：直接抛出异常，默认策略；</li>
<li>(2) CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>(3) DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>(4) DiscardPolicy：直接丢弃任务；</li>
</ul>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h4 id="3-4-线程池工作机制"><a href="#3-4-线程池工作机制" class="headerlink" title="3.4 线程池工作机制"></a>3.4 线程池工作机制</h4><ul>
<li><p>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p>
</li>
<li><p>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p>
</li>
<li><p>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</p>
</li>
<li><p>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-3a556b66a0620b99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池工作机制.png"></p>
<h4 id="3-5-提交任务"><a href="#3-5-提交任务" class="headerlink" title="3.5 提交任务"></a>3.5 提交任务</h4><h5 id="3-5-1-execute"><a href="#3-5-1-execute" class="headerlink" title="3.5.1 execute()"></a>3.5.1 execute()</h5><pre><code> execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。
</code></pre>
<h5 id="3-5-2-submit"><a href="#3-5-2-submit" class="headerlink" title="3.5.2 submit()"></a>3.5.2 submit()</h5><p>​    submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h4 id="3-6-关闭线程池"><a href="#3-6-关闭线程池" class="headerlink" title="3.6 关闭线程池"></a>3.6 关闭线程池</h4><p>​    可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断<strong>所有没有正在执行任务的线程</strong>。</p>
<p>​    只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);	<span class="comment">// 将线程池状态设置成SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers();    <span class="comment">// 中断空闲线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(STOP);	<span class="comment">// 将线程池状态设置成STOP</span></span><br><span class="line">            interruptWorkers();		<span class="comment">// 中断所有线程</span></span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-7-如何合理配置线程池"><a href="#3-7-如何合理配置线程池" class="headerlink" title="3.7 如何合理配置线程池"></a>3.7 如何合理配置线程池</h4><p>​    要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。</li>
<li>任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>
<p>​    <strong>针对CPU密集型任务</strong>应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。(可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数)</p>
<p>​    <strong>针对混合型的任务</strong>，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。</p>
<p>​    <strong>针对优先级不同的任务</strong>可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行</p>
<p>​    <strong>执行时间</strong>不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行</p>
<p><strong>测试用例代码见： <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程并发总结录(一) -- 线程进程基础</title>
    <url>/2021/01/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93%E5%BD%95(%E4%B8%80)%20--%20%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><blockquote>
<p><strong>进程概念</strong>：进程是程序运行资源分配的最小单位</p>
<blockquote>
<p>进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO 等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。</p>
</blockquote>
<p><strong>线程概念</strong>：线程是CPU 调度的最小单位,必须依赖于进程而存在</p>
<blockquote>
<p>线程是进程的一个实体,是CPU 调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</blockquote>
</blockquote>
<h3 id="CPU-核心数和线程数的关系"><a href="#CPU-核心数和线程数的关系" class="headerlink" title="CPU 核心数和线程数的关系"></a>CPU 核心数和线程数的关系</h3><blockquote>
<p><strong>多核心</strong>:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP 是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU 同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理<br><strong>多线程</strong>: Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。<br><strong>核心数、线程数</strong>:目前主流CPU 都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1 对应关系,也就是说四核CPU 一般拥有四个线程。但Intel 引入超线程技术后,使核心数与线程数形成1:2 的关系</p>
</blockquote>
<h3 id="CPU时间片轮转机制-RR-调度"><a href="#CPU时间片轮转机制-RR-调度" class="headerlink" title="CPU时间片轮转机制(RR 调度)"></a>CPU时间片轮转机制(RR 调度)</h3><p>​    时间片轮转法（Round-Robin，RR）主要用于分时系统中的进程调度。为了实现轮转调度，系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在 CPU 上运行一个时间片的时间。时间片是一个小的时间单位，通常为 10~100ms 数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把 CPU 分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。<br>​    </p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>​    采用此算法的系统，其程序就绪队列往往按进程到达的时间来排序。进程调度程序总是选择就绪队列中的第一个进程，也就是说按照先来先服务原则调度，但一旦进程占用<a href="https://link.hacpai.com/forward?goto=https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA">处理机</a>则仅使用一个时间片。在使用先一个时间片后，进程还没有完成其运行，它必须释放出处理机给下一个就绪的进程，而被抢占的进程返回到就绪队列的末尾重新排队等待再次运行。</p>
<p>处理器同一个时间只能处理一个任务。处理器在处理多任务的时候，就要看请求的时间顺序，如果时间一致，就要进行预测。挑到一个任务后，需要若干步骤才能做完，这些步骤中有些需要处理器参与，有些不需要（如磁盘控制器的存储过程）。不需要处理器处理的时候，这部分时间就要分配给其他的进程。原来的进程就要处于等待的时间段上。经过周密分配时间，宏观上就象是多个任务一起运行一样，但微观上是有先后的，就是时间片轮换。</p>
<h4 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h4><p>​    时间片轮转算法的基本思想是，系统将所有的就绪进程按先来先服务算法的原则，排成一个队列，每次调度时，系统把<a href="https://link.hacpai.com/forward?goto=https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA">处理机</a>分配给队列首进程，并让其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序根据这个请求停止该进程的运行，将它送到就绪队列的末尾，再把处理机分给就绪队列中新的队列首进程，同时让它也执行一个时间片。</p>
<h4 id="时间片设置多少合适"><a href="#时间片设置多少合适" class="headerlink" title="时间片设置多少合适"></a>时间片设置多少合适</h4><p>​    从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms 有用的工作之后,CPU 将花费5ms 来进行进程切换。CPU 时间的20%被浪费在了管理开销上了。<br>​    为了提高CPU 效率,我们可以将时间片设为500ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10 个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s 才获得运行机会。多数用户无法忍受一条简短命令要5 才能做出响应。<br>​    结论总结如下: 时间片设得太短会导致过多的进程切换,降低了CPU 效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms 通常是一个比较合理的折衷。</p>
<h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>​    **并发: **指应用能够交替执行不同的任务,比如单CPU 核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.<br>​    <strong>并行:</strong> 指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行<br>​    **两者区别: **一个是交替执行,一个是同时执行.</p>
<h3 id="多线程程序需要注意事项"><a href="#多线程程序需要注意事项" class="headerlink" title="多线程程序需要注意事项"></a>多线程程序需要注意事项</h3><h4 id="线程之间的安全性"><a href="#线程之间的安全性" class="headerlink" title="线程之间的安全性"></a>线程之间的安全性</h4><p>​    在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。</p>
<h4 id="线程之间的死锁"><a href="#线程之间的死锁" class="headerlink" title="线程之间的死锁"></a>线程之间的死锁</h4><p>​    为了解决线程之间的安全性引入了Java 的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。</p>
<h4 id="线程太多了会将服务器资源耗尽形成死机当机"><a href="#线程太多了会将服务器资源耗尽形成死机当机" class="headerlink" title="线程太多了会将服务器资源耗尽形成死机当机"></a>线程太多了会将服务器资源耗尽形成死机当机</h4><p>​    线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机。</p>
<p>​    针对多线程程序可能耗尽资源的问题，在我们的程序中应该使用线程池来管理线程、使用数据库连接池来管理数据库连接，用对象池来管理对象，防止对象经常创建和回收导致内存抖动。</p>
<h3 id="Java程序与生俱来就是多线程程序"><a href="#Java程序与生俱来就是多线程程序" class="headerlink" title="Java程序与生俱来就是多线程程序"></a>Java程序与生俱来就是多线程程序</h3><p>​    写一个最简单的demo，看看java虚拟机会为这个demo开辟多少个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Java虚拟机线程管理接口</span></span><br><span class="line">		ThreadMXBean tBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">		ThreadInfo[] threadInfos = tBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo info:threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;thread id:[&quot;</span> + info.getThreadId() </span><br><span class="line">			+ <span class="string">&quot;]; thread name:[&quot;</span> + info.getThreadName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">thread id:[<span class="number">5</span>]; thread name:[Attach Listener]  <span class="comment">//内存dump，线程dump，类信息统计，获取系统属性等</span></span><br><span class="line">thread id:[<span class="number">4</span>]; thread name:[Signal Dispatcher]<span class="comment">//分发处理发送给JVM 信号的线程</span></span><br><span class="line">thread id:[<span class="number">3</span>]; thread name:[Finalizer]         <span class="comment">//调用对象finalize 方法的线程</span></span><br><span class="line">thread id:[<span class="number">2</span>]; thread name:[Reference Handler] <span class="comment">//清除Reference 的线程</span></span><br><span class="line">thread id:[<span class="number">1</span>]; thread name:[main]		       <span class="comment">//主程序，用户程序入口</span></span><br></pre></td></tr></table></figure>


<h3 id="线程的启动和中止"><a href="#线程的启动和中止" class="headerlink" title="线程的启动和中止"></a>线程的启动和中止</h3><h4 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h4><p>​    线程的启动方式有两种：1.继承Thread类并且实现run方法的方式；2.实现Runnable接口的方式</p>
<h5 id="继承Thread类并且实现run方法的方式"><a href="#继承Thread类并且实现run方法的方式" class="headerlink" title="继承Thread类并且实现run方法的方式"></a>继承Thread类并且实现run方法的方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摘自java.lang.Thread</span></span><br><span class="line">	There are two ways to create a <span class="keyword">new</span> thread of execution. One is to declare a <span class="class"><span class="keyword">class</span> <span class="title">to</span> <span class="title">be</span> <span class="title">a</span> <span class="title">subclass</span> <span class="title">of</span> &lt;<span class="title">code</span>&gt;<span class="title">Thread</span>&lt;/<span class="title">code</span>&gt;. <span class="title">This</span> <span class="title">subclass</span> <span class="title">should</span> <span class="title">override</span> <span class="title">the</span> &lt;<span class="title">code</span>&gt;<span class="title">run</span>&lt;/<span class="title">code</span>&gt; <span class="title">method</span> <span class="title">of</span> <span class="title">class</span> &lt;<span class="title">code</span>&gt;<span class="title">Thread</span>&lt;/<span class="title">code</span>&gt;. <span class="title">An</span> <span class="title">instance</span> <span class="title">of</span> <span class="title">the</span> <span class="title">subclass</span> <span class="title">can</span> <span class="title">then</span> <span class="title">be</span> <span class="title">allocated</span> <span class="title">and</span> <span class="title">started</span>. </span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class"> <span class="title">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line"></span><br><span class="line">    PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>


<h5 id="实现Runnable的方法"><a href="#实现Runnable的方法" class="headerlink" title="实现Runnable的方法"></a>实现Runnable的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	The other way to create a thread is to declare a <span class="class"><span class="keyword">class</span> <span class="keyword">implements</span> <span class="title">the</span> &lt;<span class="title">code</span>&gt;<span class="title">run</span>&lt;/<span class="title">code</span>&gt; <span class="title">method</span>. <span class="title">An</span> <span class="title">instance</span> <span class="title">of</span> <span class="title">the</span> <span class="title">class</span> <span class="title">can</span> <span class="title">then</span> <span class="title">be</span> <span class="title">allocated</span>, <span class="title">passed</span> <span class="title">as</span> <span class="title">an</span> <span class="title">argument</span> <span class="title">when</span> <span class="title">creating</span> &lt;<span class="title">code</span>&gt;<span class="title">Thread</span>&lt;/<span class="title">code</span>&gt;, <span class="title">and</span> <span class="title">started</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> minPrime;        </span><br><span class="line">   PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">      <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>


<h5 id="Thread-和Runnable-的区别"><a href="#Thread-和Runnable-的区别" class="headerlink" title="Thread 和Runnable 的区别"></a>Thread 和Runnable 的区别</h5><p>​    Thread 是Java 里对线程的唯一抽象，Runnable 只是对任务（业务逻辑）的抽象。Thread 可以接受任意一个Runnable 的实例并执行。</p>
<h4 id="线程的中止"><a href="#线程的中止" class="headerlink" title="线程的中止"></a>线程的中止</h4><p>​    线程的中止有两种可能，要么是run()方法执行完毕，要么是程序人为中止执行。</p>
<p>​    这里重点讨论程序人为中止的手段。从Thread类中，可以发现中止线程执行的方法有 <strong>suspend()、resume()和stop()<strong>，但是这些方法都是过时的，也是官方不建议使用的，因为使用以上三种方法来</strong>暴力</strong>停止线程执行，可能会造成死锁的问题。以suspend()为例，当调用了suspend()之后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。stop()和resume()原理是一样的，可能会导致程序死锁，严重会导致自己或者其他程序ANR。所以考虑到这种严重的副作用，官方不建议使用以上三种方法停止线程执行任务。</p>
<p>​    那么如何比较优雅地中止线程呢？</p>
<p>​    因为<strong>JDK中的线程是协作式的，而不是抢占式的</strong>，否则线程发起了中断，线程可以不理会此中断。所以配合使用**interrupt()和isInterrupted()**来中断线程执行。interrupt()方法只是将中断标志位置位了，而不是强行中止线程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>那么正确的使用方法如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//和谐停止标志位</span></span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;running ! isInterrupt stats = &quot;</span> + isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; exit ! isInterrupt stats = &quot;</span> + isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    UserThread userThread = <span class="keyword">new</span> UserThread();</span><br><span class="line">    userThread.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//通知要中断，但是如果还有在执行的任务，不会真正结束</span></span><br><span class="line">    userThread.interrupt();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="我们可以自定义标志位来管理线程么？"><a href="#我们可以自定义标志位来管理线程么？" class="headerlink" title="我们可以自定义标志位来管理线程么？"></a>我们可以自定义标志位来管理线程么？</h4><p>​    不建议自定义一个取消标志位来中止线程的运行。因为run 方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，</p>
<ul>
<li><p>一、一般的阻塞方法，如sleep 等本身就支持中断的检查，</p>
</li>
<li><p>二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。</p>
<p>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait 等），则线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛InterruptedException 异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。</p>
</li>
</ul>
<h3 id="关于线程的其他点点滴滴"><a href="#关于线程的其他点点滴滴" class="headerlink" title="关于线程的其他点点滴滴"></a>关于线程的其他点点滴滴</h3><h4 id="run-和start-关系"><a href="#run-和start-关系" class="headerlink" title="run()和start()关系"></a>run()和start()关系</h4><p>​    Thread 类是Java 里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new 出一个Thread 的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。start()方法让一个线程进入就绪队列等待分配cpu，分到cpu 后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。而run 方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。</p>
<h4 id="Thread中的其他方法"><a href="#Thread中的其他方法" class="headerlink" title="Thread中的其他方法"></a>Thread中的其他方法</h4><h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><p>​    使当前线程让出CPU 占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield 方法。所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。</p>
<h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><p>​    (1) 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B 中调用了线程A 的Join()方法，直到线程A 执行完毕后，才会继续执行线程B。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadJoinTest threadJoinTest1 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        ThreadJoinTest threadJoinTest2 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        ThreadJoinTest threadJoinTest3 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        threadJoinTest1.start();</span><br><span class="line">        threadJoinTest1.join();</span><br><span class="line">		threadJoinTest2.start();</span><br><span class="line">        threadJoinTest2.join();</span><br><span class="line">        threadJoinTest3.start();</span><br><span class="line">        threadJoinTest3.join();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上事例把异步执行的事情，变成都在主线程执行的同步事件了，虽然这样做就相当于不开线程，主要是为了演示合并成串行执行。</p>
<p>​    (2) 从另一个角度上讲，join()可以让某个子线程执行完毕之后在执行主线程的代码。相当于“阻塞”主线程，等子线程执行完成之后，在执行主线程代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadJoinTest threadJoinTest1 = <span class="keyword">new</span> ThreadJoinTest(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    threadJoinTest1.start();</span><br><span class="line">    threadJoinTest1.join(); <span class="comment">// 当join()执行完之后才能执行以下代码。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;我只能在join()执行完成之后才能执行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程的生命周期以及基本状态"><a href="#线程的生命周期以及基本状态" class="headerlink" title="线程的生命周期以及基本状态"></a>线程的生命周期以及基本状态</h5><p><strong>线程生命周期</strong></p>
<p>​    关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-3e8a770cf40eae95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程状态切换.png"></p>
<p><strong>线程的基本状态</strong></p>
<p><strong>新建状态（New）：</strong>当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();</p>
<p><strong>就绪状态（Runnable）：</strong>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
<p><strong>运行状态（Running）：</strong>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就   绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
<p><strong>阻塞状态（Blocked）：</strong>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<p>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>
<p>2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
<p>3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
<p><strong>死亡状态（Dead）：</strong>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>​    在Java 线程中，通过一个整型成员变量priority 来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p>
<p>​    设置线程优先级时，针对<strong>频繁阻塞（休眠或者I/O 操作）</strong>的线程需要设置较高优先级，而<strong>偏重计算（需要较多CPU 时间或者偏运算）</strong>的线程则设置较低的优先级，确保处理器不会被独占。</p>
<h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>​    Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java 虚拟机中存在Daemon 线程的时候，当主线程退出之后，守护线程也会跟着退出。比如垃圾回收线程就是Daemon 线程，但是在Java 虚拟机退出时Daemon 线程中的finally 块并不一定会执行。在构建Daemon 线程时，不能依靠finally 块中的内容来确保执行关闭或清理资源的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;-----&gt;&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//如果该线程是守护线程，那么main线程执行完毕之后，守护线程一起结束</span></span><br><span class="line">    <span class="comment">//如果不是守护线程，Main线程会等待该线程执行结束后结束。</span></span><br><span class="line">    <span class="comment">//如果是守护线程，子线程大于main的时间，main执行完了就结束，不管子线程。</span></span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置3000 6000观察守护线程内打印情况可以看出守护线程的生命周期</span></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>测试用例代码见： <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:oujie123/UnderstandingOfThread.git</strong></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6/3059054?utm_source=hacpai.com">CPU时间片轮转机制</a></p>
<p><a href="https://www.cnblogs.com/lwbqqyumidi/p/3804883.html">线程基础</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程并发</tag>
      </tags>
  </entry>
  <entry>
    <title>容器与函数谓词</title>
    <url>/2021/06/13/%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%93%E8%AF%8D/</url>
    <content><![CDATA[<p>STL 是“Standard Template Library”的缩写，中文译为“标准模板库”。</p>
<h4 id="1-Vector"><a href="#1-Vector" class="headerlink" title="1. Vector"></a>1. Vector</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 引入 vector 容器的支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;标准模板库&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vector2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 指定10的空间大小</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vector3</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 有了10个值了 每个值都是0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector4.begin() 迭代器 插入到前面</span></span><br><span class="line">    <span class="comment">// vector4.end() 迭代器 插入到后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">40</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">60</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">80</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">100</span>);</span><br><span class="line">    vector4.insert(vector4.begin(), <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前：vector4.front():&quot;</span> &lt;&lt; vector4.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    vector4.front() = <span class="number">99</span>; <span class="comment">// 默认修改第一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后：vector4.front():&quot;</span> &lt;&lt; vector4.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前：vector4.back():&quot;</span> &lt;&lt; vector4.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    vector4.back() = <span class="number">777</span>; <span class="comment">// 默认修改最后</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后：vector4.back():&quot;</span> &lt;&lt; vector4.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    vector4.erase(vector4.begin()); <span class="comment">// 移除第一个元素（内部：通过迭代器的位置 进行移除）  删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环打印，默认 从大到小输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector4.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;item:&quot;</span> &lt;&lt; vector4[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KT的类型推到  相当于 C++ auto</span></span><br><span class="line">    <span class="comment">/*var a = 10;</span></span><br><span class="line"><span class="comment">    var b = 30.4f;</span></span><br><span class="line"><span class="comment">    var c = &quot;&quot;;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器 循环遍历</span></span><br><span class="line">    <span class="comment">// auto Kotlin自带类型推到</span></span><br><span class="line">    <span class="comment">// for (vector&lt;int&gt;::iterator iteratorVar = vector4.begin(); iteratorVar != vector4.end(); iteratorVar++) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iteratorVar = vector4.begin(); iteratorVar != vector4.end(); iteratorVar++) &#123;</span><br><span class="line">        <span class="comment">// 迭代器 当中指针操作  iteratorVar++</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;迭代器：&quot;</span> &lt;&lt; *iteratorVar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈（注意：stack无法指定那个位置去压栈）</span></span><br><span class="line">    stackVar.push(<span class="number">30</span>);</span><br><span class="line">    stackVar.push(<span class="number">60</span>);</span><br><span class="line">    stackVar.push(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请问那个元素，在最上面（看图）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [] 角标是不行的，内部没有重载此运算符</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; stackVar.size(); ++i) &#123;</span></span><br><span class="line"><span class="comment">        // cout &lt;&lt; stackVar[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        // cout &lt;&lt; stackVar.at() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 他根本就没有迭代器</span></span><br><span class="line">    <span class="comment">// 开发者 自己组装 迭代器 遍历</span></span><br><span class="line">    <span class="comment">/*for (stack&lt;int&gt;::iterator; i &lt; ; ++i) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慎用，为什么？ 元素被弹完了</span></span><br><span class="line">    <span class="comment">// 这种方式是可以的，手枪把子弹全部打完【会把元素清空】</span></span><br><span class="line">    <span class="keyword">while</span> (!stackVar.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = stackVar.top(); <span class="comment">// top == 获取栈顶的元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;获取栈顶的元素：&quot;</span> &lt;&lt; top &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 永远拿 90</span></span><br><span class="line"></span><br><span class="line">        stackVar.pop(); <span class="comment">// 把栈顶的元素 弹出去  【删除】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int top = stackVar.top();</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; top &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; // 队列支持（内部：基本上 链表 、 数组 ）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器 + 数据结构</span></span><br><span class="line"><span class="comment">// 音视频： 压缩格式音频数据（push） 保存       pop消费最前面的 音频格式数据 获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queueVar;</span><br><span class="line"></span><br><span class="line">    queueVar.push(<span class="number">20</span>);</span><br><span class="line">    queueVar.push(<span class="number">40</span>);</span><br><span class="line">    queueVar.push(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个元素是谁 20  FIFO 原则</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前： queueVar.front():&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    queueVar.front() = <span class="number">88</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后： queueVar.front():&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改前： queueVar.back():&quot;</span> &lt;&lt; queueVar.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    queueVar.back() = <span class="number">88</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 修改后： queueVar.back():&quot;</span> &lt;&lt; queueVar.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到 角标</span></span><br><span class="line">    <span class="comment">/*for (int i = 0; i &lt; 9; ++i) &#123;</span></span><br><span class="line"><span class="comment">        queueVar[i];</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 他根本就没有迭代器</span></span><br><span class="line">    <span class="comment">/*for (queue&lt;int&gt;::iterator; i &lt; ; ++i) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慎用，为什么？ 前面的元素全部被消费完了</span></span><br><span class="line">    <span class="keyword">while</span> (!queueVar.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;while1:&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        queueVar.pop(); <span class="comment">// 把前面的元素 给消费掉  【删除】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处队列中元素已经被清空了</span></span><br><span class="line">    <span class="keyword">while</span> (!queueVar.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;while2:&quot;</span> &lt;&lt; queueVar.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        queueVar.pop(); <span class="comment">// 把前面的元素 给消费掉  【删除】</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-优先级队列"><a href="#4-优先级队列" class="headerlink" title="4. 优先级队列"></a>4. 优先级队列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// priority_queue 内部对我们前面的vector 有一定的封装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque 跟 queue  有什么区别啊   双端队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 优先级队列，默认做了 从大到小 60 50 40 ...</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;int&gt; priorityQueue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式代码： vector&lt;int&gt;, less&lt;int&gt;  </span></span><br><span class="line">    <span class="comment">// priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; priorityQueue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// less  </span></span><br><span class="line">    <span class="comment">// less&lt;int&gt; return __x &lt; __y;  上一个元素和当前元素 比较，返回ture false  从大到小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// less return __x &lt; __y;  // 从大到小</span></span><br><span class="line">    <span class="comment">// greater return __x &gt; __y; // 从小到大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个参数：他内部需要vector，你就给他</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span> ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; priorityQueue;</span><br><span class="line">    <span class="comment">// priority_queue&lt;int ,vector&lt;int&gt;, greater&lt;int&gt;&gt; priorityQueue;</span></span><br><span class="line"></span><br><span class="line">    priorityQueue.push(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">20</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">30</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">40</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">50</span>);</span><br><span class="line">    priorityQueue.push(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; priorityQueue.top() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环代码</span></span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;while1:&quot;</span> &lt;&lt; priorityQueue.top() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 一直是60</span></span><br><span class="line">        priorityQueue.pop(); <span class="comment">// 最前面的元素消费掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-List容器"><a href="#5-List容器" class="headerlink" title="5. List容器"></a>5. List容器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java：ArrayList采用Object[]数组，   C++的list 内部：采用链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt; // list容器的支持</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; listVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    listVar.push_front(<span class="number">50</span>); <span class="comment">// 插入到前面   明确</span></span><br><span class="line">    listVar.push_back(<span class="number">60</span>); <span class="comment">// 插入到后面</span></span><br><span class="line">    listVar.insert(listVar.begin(), <span class="number">70</span>); <span class="comment">// 插入到前面  灵活</span></span><br><span class="line">    listVar.insert(listVar.end(), <span class="number">80</span>); <span class="comment">// 插入到后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改操作</span></span><br><span class="line">    listVar.back() = <span class="number">88</span>;</span><br><span class="line">    listVar.front() = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    listVar.erase(listVar.begin()); <span class="comment">// 删除最前面的 55</span></span><br><span class="line">    listVar.erase(listVar.end()); <span class="comment">// 删除最后面的 88</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 迭代器</span></span><br><span class="line">    <span class="comment">// 不用通过角标去访问，也不能修改   遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = listVar.begin(); it != listVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-set容器"><a href="#6-set容器" class="headerlink" title="6. set容器"></a>6. set容器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set（内部：红黑树结构），会对你存入的数据进行排序，但是绝对不允许元素相同</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, less&lt;<span class="keyword">int</span>&gt;&gt; setVar; <span class="comment">//  __x &lt; __y 从大到小，默认情况下 就是 less</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加参数，不需要用迭代器，也不需要指定位置</span></span><br><span class="line">    setVar.insert(<span class="number">1</span>);</span><br><span class="line">    setVar.insert(<span class="number">3</span>);</span><br><span class="line">    setVar.insert(<span class="number">2</span>);</span><br><span class="line">    setVar.insert(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复插入，并不会报错  std::pair&lt;iterator, bool&gt;</span></span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>, less&lt;<span class="keyword">int</span>&gt;&gt;::iterator, <span class="keyword">bool</span>&gt; res = setVar.insert(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.first 获取第一个元素 迭代器   当前迭代器   最后一个位置</span></span><br><span class="line">    <span class="comment">// res.second 获取第二个元素 bool</span></span><br><span class="line">    <span class="keyword">bool</span> insert_success = res.second;</span><br><span class="line">    <span class="keyword">if</span> (insert_success) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;恭喜你，插入成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入成功后，我用第一个元素遍历</span></span><br><span class="line">        <span class="keyword">for</span> (; res.first != setVar.end(); res.first ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *res.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;哎，插入失败..&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部遍历  auto 自动推到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = setVar.begin(); it != setVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="7-函数谓词"><a href="#7-函数谓词" class="headerlink" title="7. 函数谓词"></a>7. 函数谓词</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set（内部：红黑树结构），会对你存入的数据自动进行排序，但是绝对不允许元素相同</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> id) : name(name), id(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 都是一些常规的 谓词  不能满足功能， 模仿C++源码的谓词 自定义谓词 解决这个问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++缔造者写的这个源码 没有对象比较的功能 【系统源码谓词 做不到对象比较功能】</span></span><br><span class="line"><span class="comment">// bool operator()(const _Tp&amp; __x, const _Tp&amp; __y) const &#123; return __x &lt; __y; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们就自定义这个功能  【自定义谓词 没有达到谓词的标准】</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doCompareAction</span><span class="params">(<span class="keyword">const</span> Person&amp; person1, <span class="keyword">const</span> Person&amp; person2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person1.id &lt; person2.id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doCompareAction2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Person&amp; __x, <span class="keyword">const</span> Person&amp; __y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.id &lt; __y.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class doCompareAction3也是可以的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doCompareAction3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Person&amp; __x, <span class="keyword">const</span> Person&amp; __y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.id &gt; __y.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认是 less  return 对象1 &lt; 对象2;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;Person, doCompareAction2&gt; setVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set&lt;Person, doCompareAction3&gt; setVar;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span> <span class="params">(<span class="string">&quot;Snake&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span> <span class="params">(<span class="string">&quot;kevin&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span> <span class="params">(<span class="string">&quot;Jack&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把构建的对象 插入到 set 容器里面去</span></span><br><span class="line">    setVar.insert(p1);</span><br><span class="line">    setVar.insert(p2);</span><br><span class="line">    setVar.insert(p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name string  ---  c_str() ----&gt;   char *</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person&gt;::iterator it = setVar.begin(); it != setVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;name.c_str() &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; it-&gt;id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-Map-与-multimap"><a href="#8-Map-与-multimap" class="headerlink" title="8. Map 与 multimap"></a>8. Map 与 multimap</h4><ul>
<li>map中insert()插入之后会对key进行排序，key不能重复，如果采用覆盖的方式插入值，使用<code>arr[]</code>方式</li>
<li>multimap中key可以重复</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：map会对key进行排序，默认 key不能重复</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 添加数据</span></span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    mapVar.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&quot;一&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    mapVar.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;二&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种方式</span></span><br><span class="line">    mapVar.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">3</span>, <span class="string">&quot;三&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面三种方式 key不能重复</span></span><br><span class="line">    <span class="comment">// 思考：既然会对key进行排序，那么key是不能重复的（会插入失败）</span></span><br><span class="line">    mapVar.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">&quot;三3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种方式:key可以重复，相当于覆盖    mapVar[key]=Value</span></span><br><span class="line">    mapVar[<span class="number">4</span>] = <span class="string">&quot;四&quot;</span>;</span><br><span class="line">    mapVar[<span class="number">4</span>] = <span class="string">&quot;肆&quot;</span>; <span class="comment">// 第四种方式覆盖/替换（常用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  typedef typename _Rep_type::iterator		 iterator;  之前常规的迭代器</span></span><br><span class="line"><span class="comment">        typedef typename _Rep_type::const_iterator	 const_iterator;  只读的，只能读，不能修改 的迭代器</span></span><br><span class="line"><span class="comment">        typedef typename _Rep_type::reverse_iterator	 reverse_iterator;  倒序打印的迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环打印，迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mapVar.begin() ; it != mapVar.end() ; it ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it-&gt;second.c_str() &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Jack想知道，怎么判断插入成功、失败</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; result = mapVar.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">6</span>, <span class="string">&quot;66三san&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (result.second) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;插入失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我想知道插入后的 数据</span></span><br><span class="line">    <span class="keyword">for</span> (result.first == mapVar.begin(); result.first != mapVar.end() ; result.first++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result.first-&gt;first &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; result.first-&gt;second &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找，操作</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; ::iterator findResult = mapVar.find(<span class="number">3</span>); <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">if</span> (findResult != mapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;恭喜，找到了&quot;</span> &lt;&lt; findResult-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; findResult-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不恭喜，没找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multimap 主要使用他的分组特性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.key可以重复， 2.key重复的数据可以分组,  3.key会排序，  4.value不会排序</span></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; multimapVar;</span><br><span class="line"></span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;十个1&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;十个2&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;十个3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&quot;三十1&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&quot;三十3&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&quot;三十2&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;二十1&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;二十2&quot;</span>));</span><br><span class="line">    multimapVar.insert(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="string">&quot;二十3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iteratorVar = multimapVar.begin(); iteratorVar != multimapVar.end() ; iteratorVar ++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iteratorVar-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; iteratorVar-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 核心功能是分组</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你要查询的key，为int类型:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iteratorVar = multimapVar.find(result);</span><br><span class="line">    <span class="keyword">while</span> (iteratorVar != multimapVar.end()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iteratorVar-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; iteratorVar-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iteratorVar-&gt;first != result) &#123;</span><br><span class="line">            <span class="keyword">break</span>;; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 严谨性</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorVar == multimapVar.end()) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 循环结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处写匹配到的逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要自己做逻辑控制，不然死循环了</span></span><br><span class="line">        iteratorVar++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="9-一元谓词（仿函数）"><a href="#9-一元谓词（仿函数）" class="headerlink" title="9. 一元谓词（仿函数）"></a>9. 一元谓词（仿函数）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt; &#x2F;&#x2F; STL包</span><br><span class="line">#include &lt;algorithm&gt; &#x2F;&#x2F; 算法包</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 谓词相当于仿函数</span><br><span class="line">&#x2F;&#x2F; 通常叫法叫仿函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO 第一版: 为什么叫仿函数 （空谓词 一元谓词 二元谓词 三元谓词）</span><br><span class="line">class ComPareObject &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; void operator()(int id) &#123;&#125; 一元谓词</span><br><span class="line">    &#x2F;&#x2F; void operator()(int id,string name) &#123;&#125; 二元谓词</span><br><span class="line">    void operator()() &#123; &#x2F;&#x2F; 重装了括号运算符</span><br><span class="line">        cout &lt;&lt; &quot;仿函数&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 普通函数</span><br><span class="line">void fun2() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ComPareObject fun1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 非常像函数的调用，很像函数 &#x3D; （仿函数）</span><br><span class="line">    fun1();</span><br><span class="line"></span><br><span class="line">    fun2();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="10-引入算法包"><a href="#10-引入算法包" class="headerlink" title="10. 引入算法包"></a>10. 引入算法包</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // STL包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我如何阅读C++源码，来写我们的仿函数</span></span><br><span class="line"><span class="comment">// 明明白白的仿函数（一元谓词==一元函数对象）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">showActionObj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;自定义仿函数&quot;</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简洁方式（回调函数、一元谓词      但是不能称为 仿函数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAction</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;自定义 一元谓词&quot;</span> &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setVar;</span><br><span class="line"></span><br><span class="line">    setVar.insert(<span class="number">10</span>);</span><br><span class="line">    setVar.insert(<span class="number">20</span>);</span><br><span class="line">    setVar.insert(<span class="number">30</span>);</span><br><span class="line">    setVar.insert(<span class="number">40</span>);</span><br><span class="line">    setVar.insert(<span class="number">50</span>);</span><br><span class="line">    setVar.insert(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用一元谓词，注意：有括号</span></span><br><span class="line">    <span class="comment">// for_each(setVar.begin(), setVar.end(), showActionObj());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    for_each(setVar.begin(), setVar.end(), showAction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="11-仿函数"><a href="#11-仿函数" class="headerlink" title="11. 仿函数"></a>11. 仿函数</h4><p>回调函数扩展性不高，一般用于简单逻辑，写法也比较简单；仿函数扩展性更强，写法稍微复杂一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // STL包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数 (功能够简单)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAction</span><span class="params">(<span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一元谓词&quot;</span> &lt;&lt; __first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数(扩展性强) C++内置源码使用仿函数频率高，扩展性强</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">showActionObj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> _count() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;本次输出次数是:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;count &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> __first)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;仿函数&quot;</span> &lt;&lt; __first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 理解：类型传递</span></span><br><span class="line">    <span class="comment">// set&lt;int, showActionObj&gt; setVar; 这样写的语法是OK的，不能加括号</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setVar;</span><br><span class="line"></span><br><span class="line">    setVar.insert(<span class="number">10</span>);</span><br><span class="line">    setVar.insert(<span class="number">20</span>);</span><br><span class="line">    setVar.insert(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第一种方式</span></span><br><span class="line">    for_each(setVar.begin(), setVar.end(), showAction);</span><br><span class="line">    <span class="comment">// 请你统计打印次数？ 答：做不到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 第二种方式</span></span><br><span class="line">    <span class="comment">// 此处s相当于showActionObj()</span></span><br><span class="line">    showActionObj s; <span class="comment">// 理解：值传递</span></span><br><span class="line">    <span class="comment">// for_each第三个参数传入s,会拷贝一个副本，运算结束需要接收回来。</span></span><br><span class="line">    s = for_each(setVar.begin(), setVar.end(), s); <span class="comment">// 传入进去的s是新的副本，我们外面的s是旧地址</span></span><br><span class="line">    <span class="comment">// 请你统计打印次数？ 答：OK</span></span><br><span class="line">    s._count();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="12-对象生命周期"><a href="#12-对象生命周期" class="headerlink" title="12. 对象生命周期"></a>12. 对象生命周期</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // set 存入对象 奔溃（set会自动排序，对象没法排序，所以奔溃）  解决方案：自定义仿函数解决</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  // 存入对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name) : name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;person) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = person.name; <span class="comment">// 浅拷贝</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person拷贝构造函数执行了...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person析构函数执行了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Java：把对象存入 添加到 集合</span></span><br><span class="line">    <span class="comment">// C++: 调用拷贝构造函数，存进去的是另一个新的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; vectorVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// person 被main函数弹栈 析构一次</span></span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Jack&quot;</span>)</span></span>; <span class="comment">// 2  Jack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 里面的insert函数弹栈 析构一次</span></span><br><span class="line">    vectorVar.insert(vectorVar.begin(), person); <span class="comment">// 外面的person是旧地址，到insert函数里面的person就是新地址（拷贝构造函数 一次）</span></span><br><span class="line"></span><br><span class="line">    person.setName(<span class="string">&quot;Kevin&quot;</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// newPerson 被main函数弹栈 析构一次</span></span><br><span class="line">    Person newPerson =</span><br><span class="line">            vectorVar.front(); <span class="comment">// front里面的person是旧地址， 外面的newPerson就是新地址（拷贝构造函数 一次）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;newPerson:&quot;</span> &lt;&lt; newPerson.getName().c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3次析构函数   两次拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// main弹栈</span></span><br></pre></td></tr></table></figure>


<h4 id="13-预定义函数"><a href="#13-预定义函数" class="headerlink" title="13. 预定义函数"></a>13. 预定义函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; // STL包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // 算法包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &quot;Jack&quot; + &quot;AAAA&quot; // 运算符重载</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++已经提供了 预定义函数  plus,minus,multiplies,divides,modulus ...</span></span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; add_func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = add_func(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    plus&lt;<span class="built_in">string</span>&gt; add_func2;</span><br><span class="line">    <span class="built_in">string</span> r2 = add_func2(<span class="string">&quot;AAAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    plus&lt;<span class="keyword">float</span>&gt; add_func3;</span><br><span class="line">    <span class="keyword">float</span> r3 = add_func3(<span class="number">4354.45f</span>, <span class="number">34.3f</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="14-手写预定义函数"><a href="#14-手写预定义函数" class="headerlink" title="14. 手写预定义函数"></a>14. 手写预定义函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt; &#x2F;&#x2F; STL包</span><br><span class="line">#include &lt;algorithm&gt; &#x2F;&#x2F; 算法包</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename Arg1, typename Arg2, typename Result&gt;</span><br><span class="line">struct binary_function</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 第一个参数类型 是底一个参数的类型</span><br><span class="line">    typedef Arg1 	first_argument_type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;econd_argument_type是第二个参数的类型</span><br><span class="line">    typedef Arg2 	second_argument_type;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @c result_type是返回类型</span><br><span class="line">    typedef Result 	result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO 对象 + 对象</span><br><span class="line">&#x2F;&#x2F; 1.运算符重载</span><br><span class="line">&#x2F;&#x2F; 2.对象+对象 自己去写仿函数</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct plus_d &#x2F;*: public binary_function&lt;T, T, T&gt;*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    T operator() (const T &amp; x, const T &amp; y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    plus_d&lt;int&gt; add_func;</span><br><span class="line">    int r &#x3D; add_func(1, 1);</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    plus_d&lt;string&gt; add_func2;</span><br><span class="line">    string r2 &#x3D; add_func2(&quot;AAAA&quot;, &quot;BBB&quot;);</span><br><span class="line">    cout &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    plus_d&lt;float&gt; add_func3;</span><br><span class="line">    float r3 &#x3D; add_func3(4354.45f, 34.3f);</span><br><span class="line">    cout &lt;&lt; r3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>对Java对象的深入认识(三)</title>
    <url>/2021/01/27/%E5%AF%B9Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E8%AE%A4%E8%AF%86-%E4%B8%89/</url>
    <content><![CDATA[<h4 id="1-Java对象"><a href="#1-Java对象" class="headerlink" title="1. Java对象"></a>1. Java对象</h4><h5 id="1-1-Java对象的组成"><a href="#1-1-Java对象的组成" class="headerlink" title="1.1 Java对象的组成"></a>1.1 Java对象的组成</h5><p>​    在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<ul>
<li><p><strong>对象头</strong>包括两部分信息: 对象自身的运行时数据和类型指针</p>
<ul>
<li><p>运行时数据包含哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<a href="https://www.jianshu.com/p/28cd41100193">《多线程并发总结(八)–Java内存模型》3.3小节有讲到线程运行的不同状态mark word的不同值</a></p>
</li>
<li><p>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>如果对象是一个java数组，那么在对象头中还有一块用于记录数组长度的数据。</p>
</li>
</ul>
</li>
<li><p><strong>对齐填充</strong>不是必然存在的，因为虚拟机在创建对象分配内存的时候，都是分配8个字节的整数倍，如果对象大小不是8字节的整数倍，就需要填充占位符来使内存对齐。</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-9a5225534e9ab151.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象组成.png"></p>
<p>​    </p>
<h5 id="1-2-对象的创建"><a href="#1-2-对象的创建" class="headerlink" title="1.2 对象的创建"></a>1.2 对象的创建</h5><p>​    当虚拟机遇到一条new指令时，首先检查是否被类加载器加载，如果没有，那必须先执行相应的类加载过程。</p>
<p>类加载就是把class加载到JVM的运行时数据区的过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5f9c2441823230b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象创建.png"></p>
<p><strong>1.2.1 检查加载</strong></p>
<p>​    检查这个指令的参数是否能在常量池中定位到一个类的符号引用（<strong>符号引用</strong> <strong>：</strong>符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。</p>
<p><strong>1.2.2 分配内存</strong></p>
<p>​    虚拟机会为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从运行时数据区的堆中划分出来。</p>
<ul>
<li><strong>指针碰撞的方式：</strong>对于规整的内存区域使用指针碰撞的形式分配内存，在内存已使用和未使用的区域之间存放一个指示器，需要分配内存时，直接在该指针后分配指定大小的空间即可。</li>
<li><strong>空闲列表：</strong>对于不规整的内存区域使用空闲列表的方式分配内存。虚拟机会维护一张列表(相当于空闲内存索引)，表中标记哪些内存已经被分配，哪些没有，当需要分配内存时，只需要在表中找到符合需求大小的位置分配即可，然后更新列表。</li>
</ul>
<p>(1) 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</p>
<p>(2) 在虚拟机中创建对象的操作是非常频繁的，仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p><strong>如何保证在创建对象过程中的线程安全呢？</strong></p>
<p><strong>CAS机制：</strong>虚拟机采用CAS失败重试的方式保证更新操作的原子性；</p>
<p><strong>分配缓存：</strong>在Eden区分配一块缓存区的方式创建对象，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），此操作有点像Threadlocal。可使用-XX:+UseTLAB来启动此选项。</p>
<p><strong>1.2.3 内存空间初始化</strong></p>
<p>​    虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>1.2.4 设置对象头</strong></p>
<p>​    虚拟机会对对象头进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes在Java hotspot VM内部表示为类元数据）、对象的哈希码、对象的GC分代年龄等信息。</p>
<p><strong>1.2.5 对象初始化</strong></p>
<p>​    调用对象的构造方法，按照程序员的意愿初始化对象。</p>
<h5 id="1-3-对对象的访问方式"><a href="#1-3-对对象的访问方式" class="headerlink" title="1.3 对对象的访问方式"></a>1.3 对对象的访问方式</h5><p>​    当对象创建出来之后，Java程序需要通过栈上引用的方式对堆上的具体对象进行操作。目前主流的访问方式有使用句柄和直接指针两种。</p>
<ul>
<li><p><strong>句柄：</strong>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
</li>
<li><p><strong>直接指针：</strong>如果使用直接指针访问， reference中存储的直接就是对象地址。</p>
</li>
</ul>
<p><strong>1.3.1 两种对象访问方式的区别</strong></p>
<p>​    使用<strong>句柄</strong>来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾回收时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>​    使用<strong>直接指针</strong>访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
<p>  对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问。<a href="https://www.jianshu.com/p/71ed22f0fab5">《可视化JVM理解运行时数据区》中可以看到验证过程</a></p>
<h5 id="1-4-对象的存活判断"><a href="#1-4-对象的存活判断" class="headerlink" title="1.4 对象的存活判断"></a>1.4 对象的存活判断</h5><p>​    在运行时数据区的堆中几乎保存着所有的对象实例，当内存不够的时候，垃圾回收器会根据对象实例的“存活”，对实例进行回收。根据不同的虚拟机，判断方式有所不同，主流的有两种方式：<strong>引用计数法和可达性分析法</strong></p>
<p><strong>1.4.1 引用计数法</strong></p>
<p>​    在对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效时，计数器减1。如果计数器为0就可以回收对象，但是这种方式存在循环引用导致对象无法被回收的情况，需要引入其他机制来保证循环引用对象的回收。</p>
<p><strong>1.4.2 可达性分析</strong></p>
<p><strong>1.4.2.1 对实例对象的回收</strong></p>
<p>​    垃圾回收器从一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，称此对象不可达。</p>
<p>​    可以被作为“GC Roots”的对象有以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性。</li>
<li>方法区中常量。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
<li>JVM的内部引用（class对象、异常对象NullPointException、OutofMemoryError，系统类加载器）。</li>
<li>所有被同步锁(synchronized关键字)持有的对象。</li>
<li>JVM内部的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
<li>JVM实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代时）</li>
</ul>
<p>以上是通过可达性分析对<strong>实例对象</strong>的回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object instance =<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//占据内存，便于判断分析GC</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">50</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    GcTest objectA = <span class="keyword">new</span> GcTest();<span class="comment">//objectA 会放入局部变量表作为GCRoots</span></span><br><span class="line">    GcTest objectB = <span class="keyword">new</span> GcTest();<span class="comment">//objectB 会放入局部变量表作为GCRoots</span></span><br><span class="line">    <span class="comment">//相互引用</span></span><br><span class="line">    objectA.instance = objectB;</span><br><span class="line">    objectB.instance = objectA;</span><br><span class="line">    <span class="comment">//切断可达</span></span><br><span class="line">    objectA =<span class="keyword">null</span>;</span><br><span class="line">    objectB =<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//强制垃圾回收</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：虚拟机对objectA和objectB引用的对象进行回收</span></span><br><span class="line">[GC (System.gc())  106345K-&gt;52064K(251392K), <span class="number">0.0011209</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  52064K-&gt;708<span class="title">K</span><span class="params">(251392K)</span>, 0.0054685 secs]</span></span><br></pre></td></tr></table></figure>


<p><strong>1.4.2.2 对Class对象的回收</strong></p>
<p>​    要想对<strong>方法区中的Class对象</strong>进行回收，条件就比较苛刻了：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
<li>参数控制：-Xnoclassgc  禁止垃圾回收器对Class对象的回收。</li>
</ul>
<h4 id="2-对象的引用方式"><a href="#2-对象的引用方式" class="headerlink" title="2. 对象的引用方式"></a>2. 对象的引用方式</h4><h5 id="2-1-强引用"><a href="#2-1-强引用" class="headerlink" title="2.1 强引用"></a>2.1 强引用</h5><p>​    Object obj = new Object() ，引用通过new关键字创建的对象都属于强引用。在任何情况下，只要有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。</p>
<h5 id="2-2-软引用"><a href="#2-2-软引用" class="headerlink" title="2.2 软引用"></a>2.2 软引用</h5><p>​    通过SoftReference<GcTest> test = new SoftReference&lt;&gt;(objectA);创建软引用对象，软引用对象只有当系统发生OOM之前才会被回收。</GcTest></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虚拟机参数:-Xms10m  -Xmx10m -XX:+PrintGC    配置10M堆内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student jackOu = <span class="keyword">new</span> Student(<span class="string">&quot;JackOu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        SoftReference&lt;Student&gt; soft = <span class="keyword">new</span> SoftReference&lt;&gt;(jackOu); <span class="comment">// 创建软引用对象</span></span><br><span class="line">        jackOu = <span class="keyword">null</span>;<span class="comment">//切掉强引用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Gc前，我还在?  -&gt;&quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;Gc后，我还在?  -&gt;&quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 制造oom</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我还活着么？ -&gt;&quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;OOM了，我还活着么？-&gt; &quot;</span> + (soft.get() != <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Gc前，我还在?  -&gt;<span class="keyword">true</span></span><br><span class="line">[GC (System.gc())  844K-&gt;804K(9728K), <span class="number">0.0005400</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  804K-&gt;697<span class="title">K</span><span class="params">(9728K)</span>, 0.0138756 secs]</span></span><br><span class="line"><span class="function">Gc后，我还在?  -&gt;<span class="keyword">true</span>   <span class="comment">//GC后没被回收</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span>	<span class="comment">// 打印了4次，说明OOM之前没被回收</span></span></span><br><span class="line"><span class="function">我还活着么？ -&gt;<span class="keyword">true</span>	<span class="comment">// 第5次内存分配失败发生OOM就被回收了</span></span></span><br><span class="line"><span class="function">[<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  7002K-&gt;7033<span class="title">K</span><span class="params">(9728K)</span>, 0.0021776 secs]</span></span><br><span class="line"><span class="function">[Full <span class="title">GC</span> <span class="params">(Ergonomics)</span>  7033K-&gt;6874<span class="title">K</span><span class="params">(9728K)</span>, 0.0065646 secs]</span></span><br><span class="line"><span class="function">[<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  6874K-&gt;6874<span class="title">K</span><span class="params">(9728K)</span>, 0.0003435 secs]</span></span><br><span class="line"><span class="function">[Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span>  6874K-&gt;6856<span class="title">K</span><span class="params">(9728K)</span>, 0.0084790 secs]</span></span><br><span class="line"><span class="function">OOM了，我还活着么？-&gt; <span class="keyword">false</span>  <span class="comment">// OOM之后被回收</span></span></span><br></pre></td></tr></table></figure>


<h5 id="2-3-弱引用"><a href="#2-3-弱引用" class="headerlink" title="2.3 弱引用"></a>2.3 弱引用</h5><p>​    通过WeakReference<GcTest> test = new WeakReference&lt;&gt;(objectA);创建弱引用对象，弱引用对象从程度比软引用更低，弱引用对象只能活到下一次GC之前，不管内存足不足GC的过程中就会被回收。</GcTest></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student jackOu = <span class="keyword">new</span> Student(<span class="string">&quot;JackOu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    WeakReference&lt;Student&gt; weak = <span class="keyword">new</span> WeakReference&lt;&gt;(jackOu);</span><br><span class="line">    jackOu = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;GC前，我还活着么？ -&gt;&quot;</span> + (weak.get() != <span class="keyword">null</span>));</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">&quot;GC前，我还活着么？ -&gt;&quot;</span> + (weak.get() != <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">GC前，我还活着么？ -&gt;<span class="keyword">true</span></span><br><span class="line">[GC (System.gc())  3945K-&gt;896K(251392K), <span class="number">0.0008463</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  896K-&gt;706<span class="title">K</span><span class="params">(251392K)</span>, 0.0040099 secs]</span></span><br><span class="line"><span class="function">GC前，我还活着么？ -&gt;<span class="keyword">false</span>  <span class="comment">//gc之后对象被回收了</span></span></span><br></pre></td></tr></table></figure>


<h5 id="2-4-虚引用"><a href="#2-4-虚引用" class="headerlink" title="2.4 虚引用"></a>2.4 虚引用</h5><p>程度最弱，随时可能被回收，垃圾回收的时候收到一个通知，就是为了监控垃圾回收器是否正常工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;String&gt;();</span><br><span class="line">    PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Hello World!&quot;</span>), queue);</span><br><span class="line">    System.out.println(pr.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">null</span>   <span class="comment">//一创建出来就被回收了</span></span><br></pre></td></tr></table></figure>


<h4 id="3-对象分配原则"><a href="#3-对象分配原则" class="headerlink" title="3. 对象分配原则"></a>3. 对象分配原则</h4><p>​    JVM创建对象会满足以下几个原则：</p>
<ul>
<li>对象优先在Eden区分配</li>
<li>空间分配担保原则</li>
<li>大对象直接进入老年代</li>
<li>长期存活对象进入老年代</li>
<li>动态对象年龄判定</li>
</ul>
<p>其中JVM对创建对象也做了一些优化：<strong>栈中创建对象和在堆中使用TLAB技术创建对象</strong></p>
<p><strong>3.1.1 栈上创建对象</strong></p>
<p>​    Java几乎所有对象都在堆中分配，但是也有例外，可以在栈中分配的可能。如果对象没有逃逸，就会在栈中分配。</p>
<p>​    <strong>逃逸分析的原理：</strong>分析对象动态作用域，当一个对象在方法中定义后，它可能被外部方法所引用，比如：调用参数传递到其他方法中，这种称之为<strong>方法逃逸</strong>，甚至还有可能被外部线程访问到，例如：赋值给其他线程中访问的变量，这个称之为<strong>线程逃逸</strong>。</p>
<p>​    从不逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度。</p>
<p>​    <strong>总结：不逃逸的对象在栈中分配，逃逸的对象(方法逃逸和线程逃逸)在堆中分配。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-fa82c50a2f68eb21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象分配原则.png"></p>
<p><strong>3.1.2 验证栈中分配优势</strong></p>
<p>​    从测试代码中可以看到myObject对象的创建是在allocate()方法中，在其他地方没有引用，所以myObject没有发送逃逸，如果JVM开启逃逸分析的话，JVM会在栈中创建myObject对象。<br>​    如果是逃逸分析出来的对象可以在栈上分配的话，那么该对象的生命周期就跟随线程了，就不需要垃圾回收，如果是频繁的调用此方法则可以得到很大的性能提高。如果没有开启逃逸分析，对象都在堆上分配，会频繁触发垃圾回收（垃圾回收会影响系统性能），导致代码运行慢。<br>​    在虚拟机中默认是开启了栈上分配内存优化的，即默认开启了逃逸分析的，那么我们来验证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -XX:-DoEscapeAnalysis 关闭逃逸分析</span></span><br><span class="line"><span class="comment">// -XX:+DoEscapeAnalysis 开启逃逸分析</span></span><br><span class="line"><span class="comment">// -XX:+PrintGC  打印GC日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;<span class="comment">//5千万的对象，为什么不会垃圾回收</span></span><br><span class="line">            allocate();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">600000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">()</span> </span>&#123;<span class="comment">//满足逃逸分析（不会逃逸出方法）</span></span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject(<span class="number">2020</span>, <span class="number">2020.6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line">        MyObject(<span class="keyword">int</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[GC (Allocation Failure)  65536K-&gt;952K(251392K), <span class="number">0.0006760</span> secs]</span><br><span class="line">[GC (Allocation Failure)  66488K-&gt;888K(251392K), <span class="number">0.0007227</span> secs]</span><br><span class="line">[GC (Allocation Failure)  66424K-&gt;904K(251392K), <span class="number">0.0006020</span> secs]</span><br><span class="line">[GC (Allocation Failure)  66440K-&gt;920K(316928K), <span class="number">0.0007311</span> secs]</span><br><span class="line">[GC (Allocation Failure)  131992K-&gt;920K(316928K), <span class="number">0.0007891</span> secs]</span><br><span class="line">[GC (Allocation Failure)  131992K-&gt;936K(438272K), <span class="number">0.0006538</span> secs]</span><br><span class="line">[GC (Allocation Failure)  263080K-&gt;775K(438272K), <span class="number">0.0016288</span> secs]</span><br><span class="line">[GC (Allocation Failure)  262919K-&gt;775K(700928K), <span class="number">0.0002895</span> secs]</span><br><span class="line"><span class="number">232</span> ms</span><br><span class="line"><span class="comment">//关闭逃逸分析,对象分配耗时：232 ms ！ 发生了8次gc</span></span><br><span class="line">    </span><br><span class="line"><span class="number">6</span> ms</span><br><span class="line"><span class="comment">//开启逃逸分析,对象分配耗时：6ms！没有发生gc</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h5 id="3-2-对象优先在Eden区分配"><a href="#3-2-对象优先在Eden区分配" class="headerlink" title="3.2 对象优先在Eden区分配"></a>3.2 对象优先在Eden区分配</h5><p>​    从上图中可以看到，在堆中分配的情况，如果满足TLAB条件，就在Eden的TLAB区分配，如果不满足，也不是大对象，就Eden区非TLAB区分配。</p>
<p>​    当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。</p>
<h5 id="3-3-大对象直接进入老年代"><a href="#3-3-大对象直接进入老年代" class="headerlink" title="3.3 大对象直接进入老年代"></a>3.3 大对象直接进入老年代</h5><p>​    最典型的大对象是很长的字符串以及数组。这样做的目的：1.避免大量内存复制；2.避免提前进行垃圾回收，明明内存有空间进行分配。</p>
<h5 id="3-4-长期存活对象进入老年区"><a href="#3-4-长期存活对象进入老年区" class="headerlink" title="3.4 长期存活对象进入老年区"></a>3.4 长期存活对象进入老年区</h5><p>​    如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor(from区或者to区)容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(并发的垃圾回收器默认为15),CMS是6时，就会被晋升到老年代中。</p>
<h5 id="3-5-对象年龄动态判定"><a href="#3-5-对象年龄动态判定" class="headerlink" title="3.5 对象年龄动态判定"></a>3.5 对象年龄动态判定</h5><p>​    为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p>
<h5 id="3-6-空间分配担保"><a href="#3-6-空间分配担保" class="headerlink" title="3.6 空间分配担保"></a>3.6 空间分配担保</h5><p>​    在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>权限管理分析--Android Runtime Permission</title>
    <url>/2021/06/02/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-Android-Runtime-Permission/</url>
    <content><![CDATA[<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><h5 id="1-1-Android6-0以前系统"><a href="#1-1-Android6-0以前系统" class="headerlink" title="1.1 Android6.0以前系统"></a>1.1 Android6.0以前系统</h5><p>结合以前G2项目Android系统版本是4.4(Android 6.0以前)，权限系统只会在安装的时候询问一次(安装时权限)，用户可以选择性的授予应用相关权限。一旦授权，除非卸载应用重新安装，被授权的权限不能撤销。</p>
<h5 id="1-2-Android6-0及以后系统"><a href="#1-2-Android6-0及以后系统" class="headerlink" title="1.2 Android6.0及以后系统"></a>1.2 Android6.0及以后系统</h5><p>Android 6.0 及更高版本中的 Android 应用权限模式需要危险权限的 Android 应用从安装时权限模式转移至运行时权限模式，用户可以在程序运行时授予/撤销危险权限。</p>
<p><strong>因此，关于应用权限管理，针对4.4以前的系统，我们可以在PackageInstaller安装应用的时候，针对项目的权限管理策略，对被安装应用进行授权或撤销；针对Android6.0及以后的系统版本，可以启动一个系统服务，动态的修改应用权限</strong></p>
<h4 id="2-运行时权限"><a href="#2-运行时权限" class="headerlink" title="2.运行时权限"></a>2.运行时权限</h4><h5 id="2-1-权限分类"><a href="#2-1-权限分类" class="headerlink" title="2.1 权限分类"></a>2.1 权限分类</h5><p>Android权限分级具体体现是在PermissionInfo类中<code>protectionLevel</code>成员变量来定义权限的级别。</p>
<p>Android把应用权限分为四类：Normal, Dangerous, Signature, SigatureOrSystem。</p>
<ul>
<li>Normal Permission指的是那些 app获取它所在的sandbox(每个进程都有独立的一个沙箱)以外的数据和资源所对应的权限，这些权限一般不会对用户的隐私信息造成风险. 比如，设置时区的权限（SET_TIME_ZONE）。对于此类权限，app申请后系统会自动赋予。</li>
<li>Dangerous Permission指的是那些可能对用户的隐私信息造成风险，或者可能影响用户数据的行为权限。比如读取用户的联系人。对于Dangerous Permission，app必须显示的获取用户的允许才可以正常使用。Runtime Permission机制针对的即是此类 dangerous permission。</li>
<li>Signature permission：权限请求者只有使用和[权限声明者]相同的证书来签名的情况下，才可以使用的权限。如果证书匹配，系统会自动赋予这些权限，不需要通知或请求用户。</li>
<li>SignatureOrSystem: SDK版本23之前叫“signature|privileged”，该类权限除了上述的 Signature Permission以外，还包括那些只赋予Android System Image内的应用的权限。Android并不建议app使用这类，因为Signature Permission已经能满足大部分的需求，不管这些app是否是build在System Image里。</li>
</ul>
<h5 id="2-2-特殊权限"><a href="#2-2-特殊权限" class="headerlink" title="2.2 特殊权限"></a>2.2 特殊权限</h5><p>上面说明了permission 中属性android:protectionLevel 使用意义，其中存在一些特殊的权限，这些权限比较敏感，在使用的时候必须特殊处理。SYSTEM_ALERT_WINDOW和WRITE_SETTINGS就是此类比较敏感的权限。</p>
<p>例如 WRITE_SETTINGS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;permission android:name=<span class="string">&quot;android.permission.WRITE_SETTINGS&quot;</span></span><br><span class="line">    android:label=<span class="string">&quot;@string/permlab_writeSettings&quot;</span></span><br><span class="line">    android:description=<span class="string">&quot;@string/permdesc_writeSettings&quot;</span></span><br><span class="line">    android:protectionLevel=<span class="string">&quot;signature|preinstalled|appop|pre23&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>官方解释如下：</p>
<blockquote>
<p>​    Note: If the app targets API level 23 or higher, the app user must explicitly grant this<br>permission to the app through a permission management screen.<br>​    The app requests the user’s approval by sending an intent with action ACTION_MANAGE_WRITE_ SETTINGS.<br>​    The app can check whether it has this authorization by calling Settings.System.canWrite().</p>
</blockquote>
<h5 id="2-3-危险权限"><a href="#2-3-危险权限" class="headerlink" title="2.3 危险权限"></a>2.3 危险权限</h5><p>Android 6.0 及更高版本要求危险权限必须使用运行时权限模式。危险权限是具有更高风险的权限（例如READ_CALENDAR），此类权限允许寻求授权的应用访问用户私人数据或获取可对用户造成不利影响的设备控制权。要查看危险权限列表，请运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pm list permissions -g -d</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msmnile_gvmq:&#x2F; $ pm list permissions -g -d</span><br><span class="line">pm list permissions -g -d</span><br><span class="line">Dangerous Permissions:</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CONTACTS</span><br><span class="line">  permission:android.permission.WRITE_CONTACTS</span><br><span class="line">  permission:android.permission.GET_ACCOUNTS</span><br><span class="line">  permission:android.permission.READ_CONTACTS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.PHONE</span><br><span class="line">  permission:android.permission.ANSWER_PHONE_CALLS</span><br><span class="line">  permission:android.permission.READ_PHONE_NUMBERS</span><br><span class="line">  permission:android.permission.READ_PHONE_STATE</span><br><span class="line">  permission:android.permission.CALL_PHONE</span><br><span class="line">  permission:android.permission.ACCEPT_HANDOVER</span><br><span class="line">  permission:android.permission.USE_SIP</span><br><span class="line">  permission:com.android.voicemail.permission.ADD_VOICEMAIL</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CALENDAR</span><br><span class="line">  permission:android.permission.READ_CALENDAR</span><br><span class="line">  permission:android.permission.WRITE_CALENDAR</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CALL_LOG</span><br><span class="line">  permission:android.permission.READ_CALL_LOG</span><br><span class="line">  permission:android.permission.WRITE_CALL_LOG</span><br><span class="line">  permission:android.permission.PROCESS_OUTGOING_CALLS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CAMERA</span><br><span class="line">  permission:android.permission.CAMERA</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SENSORS</span><br><span class="line">  permission:android.permission.BODY_SENSORS</span><br><span class="line"></span><br><span class="line">group:android.car.permission-group.CAR_MONITORING</span><br><span class="line">  permission:android.car.permission.CAR_ENERGY</span><br><span class="line"></span><br><span class="line">group:android.permission-group.LOCATION</span><br><span class="line">  permission:android.permission.ACCESS_FINE_LOCATION</span><br><span class="line">  permission:android.car.permission.CAR_SPEED</span><br><span class="line">  permission:android.permission.ACCESS_COARSE_LOCATION</span><br><span class="line"></span><br><span class="line">group:android.permission-group.STORAGE</span><br><span class="line">  permission:android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">  permission:android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line"></span><br><span class="line">group:android.permission-group.MICROPHONE</span><br><span class="line">  permission:android.permission.RECORD_AUDIO</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SMS</span><br><span class="line">  permission:android.permission.READ_SMS</span><br><span class="line">  permission:android.permission.RECEIVE_WAP_PUSH</span><br><span class="line">  permission:android.permission.RECEIVE_MMS</span><br><span class="line">  permission:android.permission.RECEIVE_SMS</span><br><span class="line">  permission:android.permission.SEND_SMS</span><br><span class="line">  permission:android.permission.READ_CELL_BROADCASTS</span><br><span class="line"></span><br><span class="line">ungrouped:</span><br><span class="line">  permission:org.codeaurora.permission.POWER_OFF_ALARM</span><br></pre></td></tr></table></figure>


<h5 id="2-4-权限组"><a href="#2-4-权限组" class="headerlink" title="2.4 权限组"></a>2.4 权限组</h5><p>所有危险的 Android 系统权限都属于权限组。如果设备运行的是 Android 6.0（API 级别 23），并且应用的 targetSdkVersion 是 23 或更高版本，则当用户请求危险权限时系统会发生以下行为：</p>
<ul>
<li><p>如果应用请求其清单中列出的危险权限，而应用目前在权限组中没有任何权限，则系统会向用户显示一个对话框，描述应用要访问的权限组。对话框不描述该组内的具体权限。例如，如果应用请求 READ_CONTACTS 权限，系统对话框只说明该应用需要访问设备的联系信息。如果用户批准，系统将向应用授予其请求的权限。</p>
</li>
<li><p>如果应用请求其清单中列出的危险权限，而应用在同一权限组中已有另一项危险权限，则系统会立即授予该权限，而无需与用户进行任何交互。例如，如果某应用已经请求并且被授予了 READ_CONTACTS 权限，然后它又请WRITE_CONTACTS，系统将立即授予该权限。</p>
</li>
</ul>
<p>任何权限都可属于一个权限组，包括正常权限和应用定义的权限。但权限组仅当权限危险时才影响用户体验。可以忽略正常权限的权限组。</p>
<h5 id="2-5-权限校验方法"><a href="#2-5-权限校验方法" class="headerlink" title="2.5 权限校验方法"></a>2.5 权限校验方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查某个 uid 和 pid是否有permission</span></span><br><span class="line"><span class="comment">//如果返回PackageManager#PERMISSION_GRANTED，说明该权限已经被allowed</span></span><br><span class="line"><span class="comment">//如果返回PackageManager#PERMISSION_DENIED，说明该权限不被allowed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同checkPermission，这里提供给当前进程调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkCallingPermission</span><span class="params">(String permission)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同checkPermission，这里跟checkCallingPermission区别是，不需要判断调用者是否是当前进程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkCallingOrSelfPermission</span><span class="params">(String permission)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同checkPermission，主要是当返回不是PackageManager.PERMISSION_GRANTED会抛出SecurityException</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforcePermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同enforcePermission</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforceCallingPermission</span><span class="params">(String permission, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同enforcePermission</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforceCallingOrSelfPermission</span><span class="params">(String permission, String message)</span></span></span><br></pre></td></tr></table></figure>


<h5 id="2-6-permission-flags"><a href="#2-6-permission-flags" class="headerlink" title="2.6 permission flags"></a>2.6 permission flags</h5><ul>
<li>PackageManager.FLAG_PERMISSION_USER_SET: 权限被用户设置，应用还可以在runtime 的时候request</li>
<li>PackageManager.FLAG_PERMISSION_USER_FIXED：权限被用户设置，但是应用不能再request此权限（用户勾选了“never ask again”）。</li>
<li>PackageManager.FLAG_PERMISSION_POLICY_FIXED：device policy设定的权限，用户和app都不能修改。</li>
<li>PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE：如果permission被标记了这个flag，那么表示，app升级后被deny的permission，会依然是deny的状态。这个flag会在下面的情况中用到。适用于L以前版本的app,安装得到M的device上，如果它的dangerous permission被撤销了，比如通过settings里面的permission管理撤销或者device policy中设定，那么该APP升级到适用于M新的permission模式后，那么升级后这个permission依然是撤销的状态。也就是dangerous permission如果在升级之前被撤销过，升级后依然是撤销的状态。</li>
<li>PackageManager.FLAG_PERMISSION_SYSTEM_FIXED： 系统app获得的自动授权的permission。</li>
<li>PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT：  默认的系统基本功能app获得的自动授权的permission.</li>
<li>PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED：在app 运行之前必须要进行permission review</li>
</ul>
<h5 id="2-7-授权-撤销权限"><a href="#2-7-授权-撤销权限" class="headerlink" title="2.7 授权/撤销权限"></a>2.7 授权/撤销权限</h5><p>在PackageManager中提供了两个方法来给某个应用赋予/撤销某些权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许权限</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	grantRuntimePermission(packageName, name, userId, <span class="keyword">false</span> <span class="comment">/* Only if not fixed by policy */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销权限</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revokeRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	revokeRuntimePermission(packageName, name, userId, <span class="keyword">false</span> <span class="comment">/* Only if not fixed by policy */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-GrantPermissionsActivity授权界面"><a href="#3-GrantPermissionsActivity授权界面" class="headerlink" title="3. GrantPermissionsActivity授权界面"></a>3. GrantPermissionsActivity授权界面</h4><p>该界面是Android 6.0之后对Runtime Permission控制，与用户的交互界面。</p>
<p>GrantPermissionsActivity的注册信息如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在包安装管理器 packages/apps/PackageInstaller/AndroidManifest.xml</span></span><br><span class="line">&lt;activity android:name=<span class="string">&quot;.permission.ui.GrantPermissionsActivity&quot;</span></span><br><span class="line">	android:configChanges=<span class="string">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br><span class="line">    android:excludeFromRecents=<span class="string">&quot;true&quot;</span></span><br><span class="line">    android:theme=<span class="string">&quot;@style/GrantPermissions&quot;</span></span><br><span class="line">    android:visibleToInstantApps=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        &lt;intent-filter android:priority=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot;</span> /&gt;</span><br><span class="line">            &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>


<p>在Activity.java基类中请求权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(<span class="meta">@NonNull</span> String[] permissions, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;requestCode should be &gt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Can request only one set of permissions at a time&quot;</span>);</span><br><span class="line">        <span class="comment">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class="line">        onRequestPermissionsResult(requestCode, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在PackageManager中去构建intent，主要是pm能够拿到action和intent的包名</span></span><br><span class="line">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class="line">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line">    mHasCurrentPermissionsRequest = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">buildRequestPermissionsIntent</span><span class="params">(<span class="meta">@NonNull</span> String[] permissions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(permissions)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;permission cannot be null or empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// GrantPermissionsActivity的action</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(ACTION_REQUEST_PERMISSIONS);</span><br><span class="line">    <span class="comment">// 声请的权限</span></span><br><span class="line">    intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);</span><br><span class="line">    <span class="comment">// GrantPermissionsActivity所在的包，即PackageInstaller</span></span><br><span class="line">    intent.setPackage(getPermissionControllerPackageName());</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，当某个应用的Activity需要申请权限，都会走到PackageInstaller的GrantPermissionsActivity 里来和用户交互申请权限。</p>
<h5 id="3-1-GrantPermissionsActivity-交互过程"><a href="#3-1-GrantPermissionsActivity-交互过程" class="headerlink" title="3.1 GrantPermissionsActivity 交互过程"></a>3.1 GrantPermissionsActivity 交互过程</h5><p>该Activity主要偏向UI逻辑控制，有以下几个部分：</p>
<p>1.mRequestedPermissions</p>
<p>这个是通过intent 的extra 传过来的，extra 的name 是PackageManager.EXTRA_REQUEST_PERMISSIONS_ NAMES</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mRequestedPermissions = getIntent().getStringArrayExtra(PackageManager. EXTRA_REQUEST_PERMISSIONS_NAMES);</span><br></pre></td></tr></table></figure>


<p>2、GrantPermissionsViewHandlerImpl<br>这个是用来更新activity UI的重要类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mViewHandler = <span class="keyword">new</span> com.android.packageinstaller.permission.ui.handheld</span><br><span class="line">            .GrantPermissionsViewHandlerImpl(<span class="keyword">this</span>, getCallingPackage())</span><br><span class="line">            .setResultListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>


<p>3、setContentView(mViewHandler.createView());</p>
<p>acitivity 将GrantPermissionsViewHandlerImpl 中的createView 出来的View 显示出来。</p>
<p>4、mAppPermissions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mAppPermissions = <span class="keyword">new</span> AppPermissions(<span class="keyword">this</span>, callingPackageInfo, <span class="keyword">null</span>, <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	setResultAndFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个AppPermissions 其实就是单个应用所拥有的所有的group permission 的统计，详细看<br>private final ArrayList<AppPermissionGroup> mGroups = new ArrayList&lt;&gt;();</AppPermissionGroup></p>
<p>5、showNextPermissionGroupGrantRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mViewHandler.updateUi(groupState.mGroup.getName(), groupCount, currentIndex,</span><br><span class="line">	Icon.createWithResource(resources, icon), message,</span><br><span class="line">	groupState.mGroup.isUserSet());</span><br></pre></td></tr></table></figure>


<p>6、点击界面按钮</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.permission_allow_button:</span><br><span class="line">            <span class="keyword">if</span> (mResultListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view.performAccessibilityAction(</span><br><span class="line">                        AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS, <span class="keyword">null</span>);</span><br><span class="line">                mResultListener.onPermissionGrantResult(mGroupName, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.permission_deny_button:</span><br><span class="line">            mAllowButton.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (mResultListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view.performAccessibilityAction(</span><br><span class="line">                        AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS, <span class="keyword">null</span>);</span><br><span class="line">                mResultListener.onPermissionGrantResult(mGroupName, <span class="keyword">false</span>,</span><br><span class="line">                        AppPermissionGroup.isStrictOpEnable() ? <span class="keyword">false</span> : mShowDonNotAsk</span><br><span class="line">                                &amp;&amp; mDoNotAskCheckbox.isChecked());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.permission_more_info_button:</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_PACKAGE_NAME, mAppPackageName);</span><br><span class="line">            intent.putExtra(ManagePermissionsActivity.EXTRA_ALL_PERMISSIONS, <span class="keyword">true</span>);</span><br><span class="line">            mActivity.startActivity(intent);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.do_not_ask_checkbox:</span><br><span class="line">            mAllowButton.setEnabled(!mDoNotAskCheckbox.isChecked());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>7、onPermissionGrantResult</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPermissionGrantResult</span><span class="params">(String name, <span class="keyword">boolean</span> granted, <span class="keyword">boolean</span> doNotAskAgain)</span> </span>&#123;</span><br><span class="line">    GroupState groupState = mRequestGrantPermissionGroups.get(name);</span><br><span class="line">    <span class="keyword">if</span> (groupState.mGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (granted) &#123;</span><br><span class="line">            groupState.mGroup.grantRuntimePermissions(doNotAskAgain,</span><br><span class="line">                    groupState.affectedPermissions);</span><br><span class="line">            groupState.mState = GroupState.STATE_ALLOWED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!AppPermissionGroup.isStrictOpEnable()) &#123;</span><br><span class="line">                groupState.mGroup.revokeRuntimePermissions(doNotAskAgain,</span><br><span class="line">                        groupState.affectedPermissions);</span><br><span class="line">            &#125;</span><br><span class="line">            groupState.mState = GroupState.STATE_DENIED;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> numRequestedPermissions = mRequestedPermissions.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRequestedPermissions; i++) &#123;</span><br><span class="line">                String permission = mRequestedPermissions[i];</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (groupState.mGroup.hasPermission(permission)) &#123;</span><br><span class="line">                    EventLogger.logPermissionDenied(<span class="keyword">this</span>, permission,</span><br><span class="line">                            mAppPermissions.getPackageInfo().packageName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        updateGrantResults(groupState.mGroup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!showNextPermissionGroupGrantRequest()) &#123;</span><br><span class="line">        setResultAndFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的callback 是从GrantPermissionsViewHandlerImpl 回来，确定执行grant 还是revoke。</p>
<h4 id="4-grantRuntimePermission-授权流程"><a href="#4-grantRuntimePermission-授权流程" class="headerlink" title="4.grantRuntimePermission 授权流程"></a>4.grantRuntimePermission 授权流程</h4><p>在PackageManager提供了grantRuntimePermission给某个应用授权。该API是@SystemApi，需要有平台签名的应用才能调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission(android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(<span class="meta">@NonNull</span> String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="meta">@NonNull</span> String permissionName, <span class="meta">@NonNull</span> UserHandle user)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最终会调到PKMS中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">   grantRuntimePermission(packageName, name, userId, <span class="keyword">false</span> <span class="comment">/* Only if not fixed by policy */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(String packageName, String name, <span class="keyword">final</span> <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> overridePolicy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) &#123;<span class="comment">//确认user id存在</span></span><br><span class="line">        Log.e(TAG, <span class="string">&quot;No such user:&quot;</span> + userId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();<span class="comment">//确定调用端app 的uid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要app端注册GRANT_RUNTIME_PERMISSIONS 权限，不然会抛出exception</span></span><br><span class="line">    mContext.enforceCallingOrSelfPermission(</span><br><span class="line">        android.Manifest.permission.GRANT_RUNTIME_PERMISSIONS,</span><br><span class="line">        <span class="string">&quot;grantRuntimePermission&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要INTERACT_ACROSS_USERS_FULL 权限，也会抛出exception</span></span><br><span class="line">    enforceCrossUserPermission(callingUid, userId,</span><br><span class="line">                               <span class="keyword">true</span> <span class="comment">/* requireFullPermission */</span>, <span class="keyword">true</span> <span class="comment">/* checkShell */</span>,</span><br><span class="line">                               <span class="string">&quot;grantRuntimePermission&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">final</span> PackageSetting ps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">// //packageName 正确性</span></span><br><span class="line">        <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(packageName);</span><br><span class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown package: &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//permission name 正确性</span></span><br><span class="line">        <span class="keyword">final</span> BasePermission bp = mSettings.mPermissions.get(name);</span><br><span class="line">        <span class="keyword">if</span> (bp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown permission: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取ps，可以从里面拿到PermissionsState</span></span><br><span class="line">        ps = (PackageSetting) pkg.mExtras;</span><br><span class="line">        <span class="keyword">if</span> (ps == <span class="keyword">null</span></span><br><span class="line">            || filterAppAccessLPr(ps, callingUid, userId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown package: &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        enforceDeclaredAsUsedAndRuntimeOrDevelopmentPermission(pkg, bp);</span><br><span class="line">        <span class="comment">//app将该permission 注册到AndroidManifest中</span></span><br><span class="line">        <span class="comment">//并且该permission 是Runtime 或者是development permission</span></span><br><span class="line">        <span class="comment">// If a permission review is required for legacy apps we represent</span></span><br><span class="line">        <span class="comment">// their permissions as always granted runtime ones since we need</span></span><br><span class="line">        <span class="comment">// to keep the review required permission flag per user while an</span></span><br><span class="line">        <span class="comment">// install permission&#x27;s state is shared across all users.</span></span><br><span class="line">        <span class="keyword">if</span> (mPermissionReviewRequired <span class="comment">//对于legacy apps不做处理</span></span><br><span class="line">            &amp;&amp; pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M</span><br><span class="line">            &amp;&amp; bp.isRuntime()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uid = UserHandle.getUid(userId, pkg.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PermissionsState permissionsState = ps.getPermissionsState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = permissionsState.getPermissionFlags(name, userId);</span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Cannot grant system fixed permission &quot;</span></span><br><span class="line">                                        + name + <span class="string">&quot; for package &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!overridePolicy &amp;&amp; (flags &amp; PackageManager.FLAG_PERMISSION_POLICY_FIXED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Cannot grant policy fixed permission &quot;</span></span><br><span class="line">                                        + name + <span class="string">&quot; for package &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bp.isDevelopment()) &#123;</span><br><span class="line">            <span class="comment">// Development permissions must be handled specially, since they are not</span></span><br><span class="line">            <span class="comment">// normal runtime permissions.  For now they apply to all users.</span></span><br><span class="line">            <span class="keyword">if</span> (permissionsState.grantInstallPermission(bp) !=</span><br><span class="line">                PermissionsState.PERMISSION_OPERATION_FAILURE) &#123;</span><br><span class="line">                scheduleWriteSettingsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ps.getInstantApp(userId) &amp;&amp; !bp.isInstant()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Cannot grant non-ephemeral permission&quot;</span></span><br><span class="line">                                        + name + <span class="string">&quot; for package &quot;</span> + packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkg.applicationInfo.targetSdkVersion &lt; Build.VERSION_CODES.M) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Cannot grant runtime permission to a legacy app&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对当前用户授权</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> result = permissionsState.grantRuntimePermission(bp, userId);</span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">            <span class="keyword">case</span> PermissionsState.PERMISSION_OPERATION_FAILURE: &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> PermissionsState.PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> appId = UserHandle.getAppId(pkg.applicationInfo.uid);</span><br><span class="line">                mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        killUid(appId, userId, KILL_APP_REASON_GIDS_CHANGED);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bp.isRuntime()) &#123;</span><br><span class="line">            logPermissionGranted(mContext, name, packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mOnPermissionChangeListeners.onPermissionsChanged(uid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not critical if that is lost - app has to request again.</span></span><br><span class="line">        mSettings.writeRuntimePermissionsForUserLPr(userId, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only need to do this if user is initialized. Otherwise it&#x27;s a new user</span></span><br><span class="line">    <span class="comment">// and there are no processes running as the user yet and there&#x27;s no need</span></span><br><span class="line">    <span class="comment">// to make an expensive call to remount processes for the changed permissions.</span></span><br><span class="line">    <span class="keyword">if</span> (READ_EXTERNAL_STORAGE.equals(name)</span><br><span class="line">        || WRITE_EXTERNAL_STORAGE.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sUserManager.isInitialized(userId)) &#123;</span><br><span class="line">                StorageManagerInternal storageManagerInternal = LocalServices.getService(</span><br><span class="line">                    StorageManagerInternal.class);</span><br><span class="line">                storageManagerInternal.onExternalStoragePolicyChanged(uid, packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要注意 3 个地方：</p>
<p>1、permissionsState.grantRuntimePermission(bp, userId);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">grantRuntimePermission</span><span class="params">(BasePermission permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceValidUserId(userId);</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;<span class="comment">//这个操作不能针对所有用户，只能针对当前用户</span></span><br><span class="line">    	<span class="keyword">return</span> PERMISSION_OPERATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grantPermission(permission, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">grantPermission</span><span class="params">(BasePermission permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasPermission(permission.name, userId)) &#123;<span class="comment">//确认是否已经grant</span></span><br><span class="line">        <span class="keyword">return</span> PERMISSION_OPERATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasGids = !ArrayUtils.isEmpty(permission.computeGids(userId));</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] oldGids = hasGids ? computeGids(userId) : NO_GIDS;</span><br><span class="line"></span><br><span class="line">    PermissionData permissionData = ensurePermissionData(permission);</span><br><span class="line">	<span class="comment">//这里就是终点，修改PermissionData 中PermissionState 的 mGranted属性</span></span><br><span class="line">    <span class="keyword">if</span> (!permissionData.grant(userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> PERMISSION_OPERATION_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasGids) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] newGids = computeGids(userId);</span><br><span class="line">        <span class="keyword">if</span> (oldGids.length != newGids.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> PERMISSION_OPERATION_SUCCESS_GIDS_CHANGED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PERMISSION_OPERATION_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2、mOnPermissionChangeListeners.onPermissionsChanged(uid);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleOnPermissionsChanged</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mPermissionListeners.beginBroadcast();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            IOnPermissionsChangeListener callback = mPermissionListeners</span><br><span class="line">                    .getBroadcastItem(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                callback.onPermissionsChanged(uid);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Permission listener is dead&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mPermissionListeners.finishBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给客户端注册I OnPermissionsChangeListener 的callback 用，提示grant 成功。</p>
<p>3、mSettings.writeRuntimePermissionsForUserLPr(userId, false);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRuntimePermissionsForUserLPr</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">boolean</span> sync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sync) &#123;</span><br><span class="line">        mRuntimePermissionsPersistence.writePermissionsForUserSyncLPr(userId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRuntimePermissionsPersistence.writePermissionsForUserAsyncLPr(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writePermissionsForUserAsyncLPr</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mWriteScheduled.get(userId)) &#123;</span><br><span class="line">        mHandler.removeMessages(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If enough time passed, write without holding off anymore.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> lastNotWrittenMutationTimeMillis = mLastNotWrittenMutationTimesMillis</span><br><span class="line">                .get(userId);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLastNotWrittenMutationMillis = currentTimeMillis</span><br><span class="line">                - lastNotWrittenMutationTimeMillis;</span><br><span class="line">        <span class="keyword">if</span> (timeSinceLastNotWrittenMutationMillis &gt;= MAX_WRITE_PERMISSIONS_DELAY_MILLIS) &#123;</span><br><span class="line">            mHandler.obtainMessage(userId).sendToTarget();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hold off a bit more as settings are frequently changing.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> maxDelayMillis = Math.max(lastNotWrittenMutationTimeMillis</span><br><span class="line">                + MAX_WRITE_PERMISSIONS_DELAY_MILLIS - currentTimeMillis, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> writeDelayMillis = Math.min(WRITE_PERMISSIONS_DELAY_MILLIS,</span><br><span class="line">                maxDelayMillis);</span><br><span class="line"></span><br><span class="line">        Message message = mHandler.obtainMessage(userId);</span><br><span class="line">        mHandler.sendMessageDelayed(message, writeDelayMillis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLastNotWrittenMutationTimesMillis.put(userId, currentTimeMillis);</span><br><span class="line">        Message message = mHandler.obtainMessage(userId);</span><br><span class="line">        mHandler.sendMessageDelayed(message, WRITE_PERMISSIONS_DELAY_MILLIS);</span><br><span class="line">        mWriteScheduled.put(userId, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要异步处理，首先确认mWriteScheduled 是否在处理userId，如果没有就添加进去，200ms 后发出消息开始处理；如果已经在处理，计算出最合适的delay 处理，可以看出系统给定的一次操作最长是2秒。</p>
<p>最后会在mHandler 中的handleMessage 中处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = message.what;</span><br><span class="line">    Runnable callback = (Runnable) message.obj;</span><br><span class="line">    <span class="comment">// 写各个应用的运行时权限到文件中</span></span><br><span class="line">    writePermissionsSync(userId);</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">  	  callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>writePermissionsSync方法中从permissionsForPackage和permissionsForSharedUser 中将各个应用运行时权限获取出来，调用writePermissions()将对应的runtime permission 存放在runtime-permissions.xml 中，主要就是将之前保存的PermissionStates中的mGranted属性和mFlags属性存放在这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writePermissions</span><span class="params">(XmlSerializer serializer,</span></span></span><br><span class="line"><span class="function"><span class="params">	List&lt;PermissionState&gt; permissionStates)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (PermissionState permissionState : permissionStates) &#123;</span><br><span class="line">        serializer.startTag(<span class="keyword">null</span>, TAG_ITEM);</span><br><span class="line">        serializer.attribute(<span class="keyword">null</span>, ATTR_NAME,permissionState.getName());</span><br><span class="line">        serializer.attribute(<span class="keyword">null</span>, ATTR_GRANTED,</span><br><span class="line">                String.valueOf(permissionState.isGranted()));</span><br><span class="line">        serializer.attribute(<span class="keyword">null</span>, ATTR_FLAGS,</span><br><span class="line">                Integer.toHexString(permissionState.getFlags()));</span><br><span class="line">        serializer.endTag(<span class="keyword">null</span>, TAG_ITEM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的xml 如下（详见/data/system/users/0/runtime-permissions.xml）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&#x27;1.0&#x27;</span> encoding=<span class="string">&#x27;UTF-8&#x27;</span> standalone=<span class="string">&#x27;yes&#x27;</span> ?&gt;</span><br><span class="line">&lt;runtime-permissions fingerprint=<span class="string">&quot;qti/msmnile_gvmq/msmnile_gvmq:9/PQ1A.190105.004/jieou05250205:userdebug/test-keys&quot;</span>&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.android.car.messenger&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_SMS&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.SEND_SMS&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_CONTACTS&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.appservice.weather&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.android.car.trust&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.app.settings&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.app.music&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">  &lt;pkg name=<span class="string">&quot;com.ts.app.raido&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">  &lt;/pkg&gt;</span><br><span class="line">    </span><br><span class="line">.......</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>权限管理分析--AppOps对Normal Permission控制</title>
    <url>/2021/06/03/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90-AppOps%E5%AF%B9Normal-Permission%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h4 id="1-App-ops作用"><a href="#1-App-ops作用" class="headerlink" title="1.App-ops作用"></a>1.App-ops作用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * App-ops are used for two purposes: Access control and tracking.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;App-ops cover a wide variety of functionality from helping with runtime permissions access</span></span><br><span class="line"><span class="comment"> * control and tracking to battery consumption tracking.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h2&gt;Access control&lt;/h2&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;App-ops can either be controlled for each uid or for each package. Which one is used depends</span></span><br><span class="line"><span class="comment"> * on the API provider maintaining this app-op. For any security or privacy related app-op the</span></span><br><span class="line"><span class="comment"> * provider needs to control the app-op for per uid as all security and privacy is based on uid in</span></span><br><span class="line"><span class="comment"> * Android.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To control access the app-op can be set to a mode to:</span></span><br><span class="line"><span class="comment"> * &lt;dl&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_DEFAULT&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Default behavior, might differ from app-op or app-op</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_ALLOWED&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Allow the access</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_IGNORED&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Don&#x27;t allow the access, i.e. don&#x27;t perform the requested action or return no or dummy</span></span><br><span class="line"><span class="comment"> *     data</span></span><br><span class="line"><span class="comment"> *     &lt;dt&gt;&#123;<span class="doctag">@link</span> #MODE_ERRORED&#125;</span></span><br><span class="line"><span class="comment"> *     &lt;dd&gt;Throw a &#123;<span class="doctag">@link</span> SecurityException&#125; on access. This can be suppressed by using a</span></span><br><span class="line"><span class="comment"> *     &#123;<span class="doctag">@code</span> ...noThrow&#125; method to check the mode</span></span><br><span class="line"><span class="comment"> * &lt;/dl&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>从AppOpsManager注解可以看出，App-Ops主要用于权限控制和追述一些重要事件。</p>
<p>App-Ops可以对每一个uid或者每一个应用程序进行操作权限控制，此接入控制可以被设置成一下四种模式：</p>
<ul>
<li>MODE_DEFAULT：默认行为，用于区分不同app-op</li>
<li>MODE_ALLOWED: 运行操作</li>
<li>MODE_IGNORED:  不允许操作。不执行请求操作，或者返回空或者虚拟数据</li>
<li>MODE_ERRORED：此操作发生之后，抛SecurityException异常。</li>
</ul>
<p>每个平台会给每一个运行时权限定义一个app-op，用于追述和运行异常操作。如果运行时权限被拒绝，系统将抛SecurityException异常，但是如果权限被授予并且app op是MODE_IGNORED，那么调用者将获得虚拟数据。</p>
<p>如果被平台定义的App-ops被覆盖，app-op权限将被设置成MODE_DEFAULT，如果希望将app-ops设置成MODE_ALLOWED或者MODE_IGNORED，都需要校验之后再赋值。</p>
<h4 id="2-AppopsService分析"><a href="#2-AppopsService分析" class="headerlink" title="2.AppopsService分析"></a>2.AppopsService分析</h4><h5 id="2-1-AppopsService启动和数据结构分析"><a href="#2-1-AppopsService启动和数据结构分析" class="headerlink" title="2.1 AppopsService启动和数据结构分析"></a>2.1 AppopsService启动和数据结构分析</h5><p>AppOpsService的启动是再ActivityManagerService中启动的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data/system/appops.xml文件</span></span><br><span class="line">mAppOpsService = <span class="keyword">new</span> AppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">&quot;appops.xml&quot;</span>), mHandler);</span><br><span class="line"></span><br><span class="line">mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">new</span> IAppOpsCallback.Stub() &#123;</span><br><span class="line">         <span class="meta">@Override</span> </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opChanged</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAppOpsService.checkOperation(op, uid, packageName)</span><br><span class="line">                         != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                     runInBackgroundDisabled(uid);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AppOpsService</span><span class="params">(File storagePath, Handler handler)</span> </span>&#123;</span><br><span class="line">    mFile = <span class="keyword">new</span> AtomicFile(storagePath);</span><br><span class="line">    mHandler = handler;</span><br><span class="line">    readState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AppOpsService初始化的时候，通过readState()去读取data/system/appops.xml文件把他保存在内存中。</p>
<p>appops.xml文件大致如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-ops</span> <span class="attr">v</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">pkg</span> <span class="attr">n</span>=<span class="string">&quot;com.ts.appservice.settings&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uid</span> <span class="attr">n</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">p</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;59&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129003446&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;60&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129003446&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uid</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">pkg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pkg</span> <span class="attr">n</span>=<span class="string">&quot;com.ts.appservice.mediacenterservice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uid</span> <span class="attr">n</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">p</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;59&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622128997408&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;60&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622128997408&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pkg</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">pkg</span> <span class="attr">n</span>=<span class="string">&quot;com.iflytek.autofly.systemserver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uid</span> <span class="attr">n</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">p</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;2&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1577845829783&quot;</span> <span class="attr">d</span>=<span class="string">&quot;182727&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;41&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006431&quot;</span> <span class="attr">d</span>=<span class="string">&quot;9182935&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;42&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006431&quot;</span> <span class="attr">d</span>=<span class="string">&quot;9182935&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;59&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006246&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;60&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1622129006246&quot;</span> <span class="attr">pu</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">op</span> <span class="attr">n</span>=<span class="string">&quot;76&quot;</span> <span class="attr">tp</span>=<span class="string">&quot;1577837011354&quot;</span> <span class="attr">d</span>=<span class="string">&quot;9001156&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pkg</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">app-ops</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最外层用app-ops标签，里面包裹了<pkg>，再里面包裹了<uid>，最里面包裹各式各样不同的操作。每个uid可能存在于多个包中。</uid></pkg></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mFile) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//1 打开文件</span></span><br><span class="line">                FileInputStream stream;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stream = mFile.openRead();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">&quot;No existing app ops &quot;</span> + mFile.getBaseFile() + <span class="string">&quot;; starting empty&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                mUidStates.clear();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">                    parser.setInput(stream, StandardCharsets.UTF_8.name());</span><br><span class="line">                    <span class="keyword">int</span> type;</span><br><span class="line">                    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                            &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;no start tag found&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">                    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String tagName = parser.getName();</span><br><span class="line">                        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;pkg&quot;</span>)) &#123;</span><br><span class="line">                            <span class="comment">//2 解析package数据</span></span><br><span class="line">                            readPackage(parser);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;uid&quot;</span>)) &#123;</span><br><span class="line">                            <span class="comment">//3解析uid数据</span></span><br><span class="line">                            readUidOps(parser);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;app-ops&gt;: &quot;</span></span><br><span class="line">                                    + parser.getName());</span><br><span class="line">                            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed parsing &quot;</span> + e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                        mUidStates.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        stream.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法中主要关注<code>readPackage(parser)</code>和<code>readUidOps(parser)</code>函数，先看看readUidOps(parser)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readUidOps</span><span class="params">(XmlPullParser parser)</span> <span class="keyword">throws</span> NumberFormatException,</span></span><br><span class="line"><span class="function">XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1 读取n节点，也就是name 代表uid</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> uid = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>));</span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="comment">//2 下面读取uid下面的节点</span></span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">           &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tagName = parser.getName();</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;op&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//3 解析op节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> code = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>));</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> mode = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;m&quot;</span>));</span><br><span class="line">            <span class="comment">// 创建UidState并且放入mUidStates集合中</span></span><br><span class="line">            UidState uidState = getUidStateLocked(uid, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (uidState.opModes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                uidState.opModes = <span class="keyword">new</span> SparseIntArray();</span><br><span class="line">            &#125;</span><br><span class="line">            uidState.opModes.put(code, mode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4 未知节点直接跳过</span></span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;uid-ops&gt;: &quot;</span></span><br><span class="line">                   + parser.getName());</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是创建一个UidState。然后创建opModes，之后将code和mode关系保存在opModes中。</p>
<p>然后再分析一下<code>readPackage(parser)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readPackage</span><span class="params">(XmlPullParser parser)</span> <span class="keyword">throws</span> NumberFormatException,</span></span><br><span class="line"><span class="function">           XmlPullParserException, IOException </span>&#123;</span><br><span class="line">       <span class="comment">//1 n代表name ,也就是包名</span></span><br><span class="line">       String pkgName = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">       <span class="keyword">int</span> type;</span><br><span class="line">       <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">               &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String tagName = parser.getName();</span><br><span class="line">           <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;uid&quot;</span>)) &#123;</span><br><span class="line">               <span class="comment">//2 解析uid相关数据，这里是uid在pkg内的情况</span></span><br><span class="line">               readUid(parser, pkgName);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;pkg&gt;: &quot;</span></span><br><span class="line">                       + parser.getName());</span><br><span class="line">               XmlUtils.skipCurrentTag(parser);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从上面看解释pkg只是解析package name,然后解析uid的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readUid</span><span class="params">(XmlPullParser parser, String pkgName)</span> <span class="keyword">throws</span> NumberFormatException,</span></span><br><span class="line"><span class="function">XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1 n代表uid</span></span><br><span class="line">    <span class="keyword">int</span> uid = Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>));</span><br><span class="line">    <span class="comment">//2 p代表是否预装在/system/priv-app/下</span></span><br><span class="line">    String isPrivilegedString = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;p&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> isPrivileged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//3 如果xml里面没有写这个pkg是否是priv-app就使用PMS查询，最终确定isPrivileged变量</span></span><br><span class="line">    <span class="keyword">if</span> (isPrivilegedString == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IPackageManager packageManager = ActivityThread.getPackageManager();</span><br><span class="line">            <span class="keyword">if</span> (packageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ApplicationInfo appInfo = ActivityThread.getPackageManager()</span><br><span class="line">                    .getApplicationInfo(pkgName, <span class="number">0</span>, UserHandle.getUserId(uid));</span><br><span class="line">                <span class="keyword">if</span> (appInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    isPrivileged = (appInfo.privateFlags</span><br><span class="line">                                    &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Could not load data, don&#x27;t add to cache so it will be loaded later.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Could not contact PackageManager&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isPrivileged = Boolean.parseBoolean(isPrivilegedString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">           &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4解析op标签</span></span><br><span class="line">        String tagName = parser.getName();</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;op&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//5 创建op数据结构，这里可以看到op包含的数据结构有uid,包名，name,我们在xml中看到op的name全都是数字，从Integer.parseInt来看也是这么实现的</span></span><br><span class="line">            Op op = <span class="keyword">new</span> Op(uid, pkgName, Integer.parseInt(parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;n&quot;</span>)));</span><br><span class="line">            String mode = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">            <span class="comment">//6 设置op的mode</span></span><br><span class="line">            <span class="keyword">if</span> (mode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.mode = Integer.parseInt(mode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//7 设置时间</span></span><br><span class="line">            String time = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (time != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.time = Long.parseLong(time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//8 获取拒绝时间</span></span><br><span class="line">            time = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (time != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.rejectTime = Long.parseLong(time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9 获取间隔</span></span><br><span class="line">            String dur = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (dur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.duration = Integer.parseInt(dur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//10代理uid</span></span><br><span class="line">            String proxyUid = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;pu&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyUid != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.proxyUid = Integer.parseInt(proxyUid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//11 代理报名</span></span><br><span class="line">            String proxyPackageName = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;pp&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyPackageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                op.proxyPackageName = proxyPackageName;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//12 这里和readUidOps函数是一样的，创建UidState和pkgOps集合</span></span><br><span class="line">            UidState uidState = getUidStateLocked(uid, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (uidState.pkgOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">                uidState.pkgOps = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//13 创建Ops数据结构，添加到uidState</span></span><br><span class="line">            Ops ops = uidState.pkgOps.get(pkgName);</span><br><span class="line">            <span class="keyword">if</span> (ops == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ops = <span class="keyword">new</span> Ops(pkgName, uidState, isPrivileged);</span><br><span class="line">                uidState.pkgOps.put(pkgName, ops);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//14添加Op到ops中</span></span><br><span class="line">            ops.put(op.op, op);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Unknown element under &lt;pkg&gt;: &quot;</span></span><br><span class="line">                   + parser.getName());</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看出Ops数据结构分为三层：</p>
<p>1 SparseArray mUidStates　用于存放uid和对应的uid下的状态，用UidState变量代表<br>2 UidState,一个uid对应一个UidState，然而一个uid可以对应多个package， 每个package下面都有一个Ops代表一组操作<br>3 每个Ops下又有多个op<br>另外每个UidState下还有一组opModes，分别保存code和mode的对应管理。</p>
<p>到这里就分析完成了解析，和数据结构的组织。　我们来线下AppOps如何检查权限。</p>
<h5 id="2-2-Appops权限校验"><a href="#2-2-Appops权限校验" class="headerlink" title="2.2 Appops权限校验"></a>2.2 Appops权限校验</h5><p>我们以AppOpsManager类的checkOp和checkOpNoThrow为例子说明AppOps的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOp</span><span class="params">(String op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkOp(strOpToOp(op), uid, packageName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOp</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mode = mService.checkOperation(op, uid, packageName);</span><br><span class="line">        <span class="keyword">if</span> (mode == MODE_ERRORED) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(buildSecurityExceptionMsg(op, uid, packageName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOpNoThrow</span><span class="params">(String op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> checkOpNoThrow(strOpToOp(op), uid, packageName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOpNoThrow</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mService.checkOperation(op, uid, packageName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法的区别在于，如果mode是MODE_ERRORED抛不抛异常。</p>
<p>当我们看到strOpToOp(op)似乎就可以猜到是把一个字符串转为从一个整形，就是转化成op code，似乎瞬间明白op标签的n是数字的原因了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strOpToOp</span><span class="params">(String op)</span> </span>&#123;</span><br><span class="line">   Integer val = sOpStrToOp.get(op);</span><br><span class="line">   <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown operation string: &quot;</span> + op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;_NUM_OP; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (sOpToString[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">       sOpStrToOp.put(sOpToString[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] sOpToString = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">    OPSTR_COARSE_LOCATION,</span><br><span class="line">    OPSTR_FINE_LOCATION,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AppOpsManager中有op的名字对应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> No operation specified. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_NONE = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> Access to coarse location information. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_COARSE_LOCATION = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> Access to fine location information. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_FINE_LOCATION = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> Causing GPS to run. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_GPS = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_VIBRATE = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ_CONTACTS = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE_CONTACTS = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ_CALL_LOG = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE_CALL_LOG = <span class="number">7</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ_CALENDAR = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE_CALENDAR = <span class="number">9</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WIFI_SCAN = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_POST_NOTIFICATION = <span class="number">11</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_NEIGHBORING_CELLS = <span class="number">12</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CALL_PHONE = <span class="number">13</span>;</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>sOpStrToOp是使用sOpToString所维护的字符串作为key,数组下标作为value去维护关系，所以这里的code就是数组下表，看来要加AppOps还要注意和google的兼容性。其实都是使用AppOpsService的checkOperation函数来检查的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkOperation</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1 检查uid是否具有UPDATE_APP_OPS_STATS权限</span></span><br><span class="line">        verifyIncomingUid(uid);</span><br><span class="line">        <span class="comment">//2 检查code是否合理</span></span><br><span class="line">        verifyIncomingOp(code);</span><br><span class="line">        <span class="comment">//3 根据uid和包名获取包名</span></span><br><span class="line">        String resolvedPackageName = resolvePackageName(uid, packageName);</span><br><span class="line">        <span class="keyword">if</span> (resolvedPackageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AppOpsManager.MODE_IGNORED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//4 检查user多用户相关的权限</span></span><br><span class="line">            <span class="keyword">if</span> (isOpRestrictedLocked(uid, code, resolvedPackageName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> AppOpsManager.MODE_IGNORED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5 根据code转换为op code,这里又进行了一个转换的操作</span></span><br><span class="line">            code = AppOpsManager.opToSwitch(code);</span><br><span class="line">            <span class="comment">//6 获取UidState</span></span><br><span class="line">            UidState uidState = getUidStateLocked(uid, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (uidState != <span class="keyword">null</span> &amp;&amp; uidState.opModes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//7 检查opModes下维护的code权限</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> uidMode = uidState.opModes.get(code);</span><br><span class="line">                <span class="keyword">if</span> (uidMode != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> uidMode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//8 获取pkg下的Op</span></span><br><span class="line">            Op op = getOpLocked(code, uid, resolvedPackageName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//9 op不存在使用默认规则</span></span><br><span class="line">                <span class="keyword">return</span> AppOpsManager.opToDefaultMode(code);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//9op 存在返回op下的mode</span></span><br><span class="line">            <span class="keyword">return</span> op.mode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">opToSwitch</span><span class="params">(<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sOpToSwitch[op];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sOpToSwitch = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">            OP_COARSE_LOCATION,</span><br><span class="line">            OP_COARSE_LOCATION,</span><br><span class="line">            OP_COARSE_LOCATION,</span><br><span class="line">            OP_VIBRATE,</span><br><span class="line">            OP_READ_CONTACTS,</span><br><span class="line">            OP_WRITE_CONTACTS,</span><br><span class="line">            OP_READ_CALL_LOG,</span><br><span class="line">            OP_WRITE_CALL_LOG,</span><br><span class="line">            OP_READ_CALENDAR,</span><br><span class="line">            OP_WRITE_CALENDAR,</span><br><span class="line">   　　　　　....</span><br><span class="line">   　　　　　&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android.os.Process.java</span></span><br><span class="line"><span class="comment">// UID定义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the root UID.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ROOT_UID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID under which system code runs.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYSTEM_UID = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID under which the telephony code runs.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PHONE_UID = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID for the user shell.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHELL_UID = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID for the log group.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOG_UID = <span class="number">1007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the UID/GID for the WIFI supplicant process.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WIFI_UID = <span class="number">1010</span>;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines the start of a range of UIDs (and GIDs), going from this</span></span><br><span class="line"><span class="comment">* number to &#123;<span class="doctag">@link</span> #LAST_APPLICATION_UID&#125; that are reserved for assigning</span></span><br><span class="line"><span class="comment">* to applications.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_UID = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Last of application-specific UIDs starting at</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #FIRST_APPLICATION_UID&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_UID = <span class="number">19999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* First uid used for fully isolated sandboxed processes (with no permissions of their own)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_ISOLATED_UID = <span class="number">99000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Last uid used for fully isolated sandboxed processes (with no permissions of their own)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_ISOLATED_UID = <span class="number">99999</span>;</span><br></pre></td></tr></table></figure>
<p>函数很简单，使用注释中的九个步骤去判断op code对应的授权模式。　<br>1,2,3 三个步骤都是检查参数和调用者的合理性，这里需要说明的是如果resolvedPackageName不存在的时候返回AppOpsManager.MODE_IGNORED，看来这就是一种op对应的mode,这里对mode做一下说明</p>
<blockquote>
<p>//1 操作允许<br>public static final int MODE_ALLOWED = 0;<br>//操作不允许，但是checkOp不会抛出安全异常，表示忽略<br>public static final int MODE_IGNORED = 1;<br>//3 表示操作不允许，checkOp操作会抛出安全异常<br>public static final int MODE_ERRORED = 2;<br>//4　默认行为，可能进一步检查权限<br>public static final int MODE_DEFAULT = 3;</p>
</blockquote>
<p>步骤４检查多用户相关的授权，我们先放一下再来分析<br>步骤５根据code转换为op code,这里又进行了一个转换的操作,对于这里的转换，注释里面说的比较清楚，就是多个code可能对应同一个op code,所以这里要进行一次转换。大多数时候code都是和opcode相同的。　<br>步骤７　首先检查uid下的opModes，我们在分析读取appops.xml文件的时候，有时候一个uid标签是不在pkg内部的，这种uid标签下申明的mode,优先级要高于pkg下的op,所以在这里先去判断uid的op code 对应的mode.<br>步骤８　则是当uid下的规则不存在，继而检查pkg下的op<br>步骤９是如果没有指定规则，则采用默认规则，opToDefaultMode函数也是使用查表的方式确定默认规则，表则AppOpsManager类的sOpDefaultMode变量中维护。</p>
<h5 id="2-3-AppOpsManager下一个方法"><a href="#2-3-AppOpsManager下一个方法" class="headerlink" title="2.3 AppOpsManager下一个方法"></a>2.3 AppOpsManager下一个方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkPackage</span><span class="params">(<span class="keyword">int</span> uid, String packageName)</span> </span></span><br></pre></td></tr></table></figure>
<p>这个方法会在uid下创建对应的uidState和一个Ops返回给用户，创建成功返回说明uid和packagename是对应的上的，返回AppOpsManager.MODE_ALLOWED，否则返回AppOpsManager.MODE_ERRORED</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noteOp</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span></span></span><br></pre></td></tr></table></figure>
<p>noteOp 函数比checkOp函数额外多出的功能就是会创建对应的op,另外会更新一些op操作的时间用于统计信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startOp</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span></span><br></pre></td></tr></table></figure>
<p>表示一个长时间运行的操作，比noteOp增加了一个统计信息，放在一个叫starting的集合里可以dump到，调用finishOp结束操作。</p>
<h5 id="2-4-多用户检测"><a href="#2-4-多用户检测" class="headerlink" title="2.4 多用户检测"></a>2.4 多用户检测</h5><p>AppOps的另外一个功能是针对多用户的授权检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRestriction</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">boolean</span> restricted, IBinder token, <span class="keyword">int</span> userHandle, String[] exceptionPackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 不是针对自己进程的首先规则，要检查MANAGE_APP_OPS_RESTRICTIONS权限</span></span><br><span class="line">    <span class="keyword">if</span> (Binder.getCallingPid() != Process.myPid()) &#123;</span><br><span class="line">    	mContext.enforcePermission(Manifest.permission.MANAGE_APP_OPS_RESTRICTIONS,</span><br><span class="line">    		Binder.getCallingPid(), Binder.getCallingUid(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 跨用户的调用检查INTERACT_ACROSS_USERS_FULL　权限</span></span><br><span class="line">    <span class="keyword">if</span> (userHandle != UserHandle.getCallingUserId()) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (mContext.checkCallingOrSelfPermission(Manifest.permission</span><br><span class="line">    		.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">    		&amp;&amp; mContext.checkCallingOrSelfPermission(Manifest.permission</span><br><span class="line">    		.INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Need INTERACT_ACROSS_USERS_FULL or&quot;</span></span><br><span class="line">    		+ <span class="string">&quot; INTERACT_ACROSS_USERS to interact cross user &quot;</span>);</span><br><span class="line">   		 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 检查code合理性</span></span><br><span class="line">    verifyIncomingOp(code);</span><br><span class="line">    Preconditions.checkNotNull(token);</span><br><span class="line">    setUserRestrictionNoCheck(code, restricted, token, userHandle, exceptionPackages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了一系列检查后进入setUserRestrictionNoCheck真正的创先相应的受限规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUserRestrictionNoCheck</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">boolean</span> restricted, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> userHandle, String[] exceptionPackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> notifyChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1 获取token所对应的ClientRestrictionState，这代表一个用户应用进程，用户应用进程会发布一些针对某些user的限制</span></span><br><span class="line">    <span class="keyword">synchronized</span> (AppOpsService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        ClientRestrictionState restrictionState = mOpUserRestrictions.get(token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (restrictionState == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                restrictionState = <span class="keyword">new</span> ClientRestrictionState(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2 不存在的情况创建，放入mOpUserRestrictions集合</span></span><br><span class="line">            mOpUserRestrictions.put(token, restrictionState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3给userHandle添加一个受限规则，其中code为op,restricted为是否收到限制，真为是，exceptionPackages</span></span><br><span class="line">        <span class="comment">//是指白名单的包，这些包属于userHandle这个用户。</span></span><br><span class="line">        <span class="keyword">if</span> (restrictionState.setRestriction(code, restricted, exceptionPackages, userHandle)) &#123;</span><br><span class="line">            notifyChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4　没有任何授权需要创建，直接销毁</span></span><br><span class="line">        <span class="keyword">if</span> (restrictionState.isDefault()) &#123;</span><br><span class="line">            mOpUserRestrictions.remove(token);</span><br><span class="line">            restrictionState.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (notifyChange) &#123;</span><br><span class="line">        <span class="comment">//5 通知监听者</span></span><br><span class="line">        notifyWatchersOfChange(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setRestriction</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">boolean</span> restricted,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] excludedPackages, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//1 创建user数据结构，维护每个user的授权情况</span></span><br><span class="line">    <span class="keyword">if</span> (perUserRestrictions == <span class="keyword">null</span> &amp;&amp; restricted) &#123;</span><br><span class="line">        perUserRestrictions = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (perUserRestrictions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] userRestrictions = perUserRestrictions.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (userRestrictions == <span class="keyword">null</span> &amp;&amp; restricted) &#123;</span><br><span class="line">            <span class="comment">//２创建每种权限的受限情况</span></span><br><span class="line">            userRestrictions = <span class="keyword">new</span> <span class="keyword">boolean</span>[AppOpsManager._NUM_OP];</span><br><span class="line">            perUserRestrictions.put(userId, userRestrictions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3 如果设置完成后，对所有op的操作都是不受限制的，则清除该限制的数据结构</span></span><br><span class="line">        <span class="keyword">if</span> (userRestrictions != <span class="keyword">null</span> &amp;&amp; userRestrictions[code] != restricted) &#123;</span><br><span class="line">            userRestrictions[code] = restricted;</span><br><span class="line">            <span class="keyword">if</span> (!restricted &amp;&amp; isDefault(userRestrictions)) &#123;</span><br><span class="line">                perUserRestrictions.remove(userId);</span><br><span class="line">                userRestrictions = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 创建excludedPackages相关信息</span></span><br><span class="line">        <span class="keyword">if</span> (userRestrictions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> noExcludedPackages = ArrayUtils.isEmpty(excludedPackages);</span><br><span class="line">            <span class="keyword">if</span> (perUserExcludedPackages == <span class="keyword">null</span> &amp;&amp; !noExcludedPackages) &#123;</span><br><span class="line">                perUserExcludedPackages = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (perUserExcludedPackages != <span class="keyword">null</span> &amp;&amp; !Arrays.equals(excludedPackages,</span><br><span class="line">                    perUserExcludedPackages.get(userId))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (noExcludedPackages) &#123;</span><br><span class="line">                    perUserExcludedPackages.remove(userId);</span><br><span class="line">                    <span class="keyword">if</span> (perUserExcludedPackages.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        perUserExcludedPackages = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    perUserExcludedPackages.put(userId, excludedPackages);</span><br><span class="line">                &#125;</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个api的作用就是限制一个user去做某件事情。</p>
<h5 id="2-4-限制用户操作例子"><a href="#2-4-限制用户操作例子" class="headerlink" title="2.4 限制用户操作例子"></a>2.4 限制用户操作例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverlayTouchActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mToken = <span class="keyword">new</span> Binder();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        setOverlayAllowed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        setOverlayAllowed(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOverlayAllowed</span><span class="params">(<span class="keyword">boolean</span> allowed)</span> </span>&#123;</span><br><span class="line">        AppOpsManager appOpsManager = getSystemService(AppOpsManager.class);</span><br><span class="line">        <span class="keyword">if</span> (appOpsManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            appOpsManager.setUserRestriction(AppOpsManager.OP_SYSTEM_ALERT_WINDOW,</span><br><span class="line">                    !allowed, mToken);</span><br><span class="line">            appOpsManager.setUserRestriction(AppOpsManager.OP_TOAST_WINDOW,</span><br><span class="line">                    !allowed, mToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入OverlayTouchActivity这个页面时候就不允许这个用户弹出window，除非弹框来自Privileged的包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOpRestrictedLocked</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> code, String packageName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> userHandle = UserHandle.getUserId(uid);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> restrictionSetCount = mOpUserRestrictions.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; restrictionSetCount; i++) &#123;</span><br><span class="line">        <span class="comment">// For each client, check that the given op is not restricted, or that the given</span></span><br><span class="line">        <span class="comment">// package is exempt from the restriction.</span></span><br><span class="line">        ClientRestrictionState restrictionState = mOpUserRestrictions.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (restrictionState.hasRestriction(code, packageName, userHandle)) &#123;</span><br><span class="line">            <span class="comment">// opAllowSystemBypassRestriction检查一些op code是否对Privileged开放</span></span><br><span class="line">            <span class="keyword">if</span> (AppOpsManager.opAllowSystemBypassRestriction(code)) &#123;</span><br><span class="line">                <span class="comment">// If we are the system, bypass user restrictions for certain codes</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    Ops ops = getOpsRawLocked(uid, packageName, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> ((ops != <span class="keyword">null</span>) &amp;&amp; ops.isPrivileged) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>网络管理(ConnectivityService)</title>
    <url>/2021/04/08/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86-ConnectivityService/</url>
    <content><![CDATA[<h3 id="1-网络管理概览"><a href="#1-网络管理概览" class="headerlink" title="1.网络管理概览"></a>1.网络管理概览</h3><p>​    Android中提供的数据业务方式有几种：移动数据网络，WIFI，热点，网线等。这些数据业务本身可以独立使用，但是同一时刻，只能使用其中的一种数据业务方式。管理这些数据业务方式的使用由ConnectivityService，NetworkFactory，NetworkAgent，NetworkMonitor等来完成，ConnectivityService处于核心调度位置。</p>
<p>​    在公司项目中,引入了Tbox和车内以太网。这两类网络上网的方式主要替代原生的移动数据网络和以太网。</p>
<p>​    ConnectivityService主要和以下四个模块交互来完成网络管理：</p>
<ul>
<li>网络有效性检测（NetworkMonitor） </li>
<li>网络评分机制（NetworkFactory） </li>
<li>路由配置信息的获取（NetworkAgent） </li>
<li>网络物理端口的设置（Netd）</li>
</ul>
<p><strong>Android网络管理架构如下图所示</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f4b58a927db33e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android网络管理.png"></p>
<p>当Android数据业务服务可用时，会将自己(NetworkFactory和NetworkAgent)注册到ConnectivityService中统一管理，ConnectivityService通过ping网络来检查网络的有效性(AOSP中的网址是墙外的网址，极有可能ping不通，因此项目中应该修改此网址，否则可能会导致期望的网络得不到上网权限)，进而影响到各个数据业务方式的评分值，ConnectivityService通过这些评分值来决定以哪个数据业务方式连接网络。决定好数据业务方式后，把这些路由配置信息设置到网络物理设备中。这样我们的手机就可以正常上网了。</p>
<h3 id="2-各个服务的初始化"><a href="#2-各个服务的初始化" class="headerlink" title="2.各个服务的初始化"></a>2.各个服务的初始化</h3><h4 id="2-1-1-ConnectivityService的初始化"><a href="#2-1-1-ConnectivityService的初始化" class="headerlink" title="2.1.1 ConnectivityService的初始化"></a>2.1.1 ConnectivityService的初始化</h4><p>ConnectivityService属于系统服务，在SystemServer中被启动。</p>
<p>SystemServer启动系统核心服务分为三个阶段:</p>
<ul>
<li>启动引导服务，包含AMS PMS DMS PKMS等</li>
<li>启动核心服务：DropBox，Battery,UsageStats,WebViewUpdate等</li>
<li>启动其他服务：InputManagerService，WindowManagerService，ConnectivityService等</li>
</ul>
<p>咱们的主角ConnectivityService就是在其他服务中被启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 设置时区</span></span><br><span class="line">        String timezoneProperty =  SystemProperties.get(<span class="string">&quot;persist.sys.timezone&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Timezone not set; setting to GMT.&quot;</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.timezone&quot;</span>, <span class="string">&quot;GMT&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 设置语言，国家等等</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.get(<span class="string">&quot;persist.sys.language&quot;</span>).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.locale&quot;</span>, languageTag);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.language&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.country&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">&quot;persist.sys.localevar&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Here we go!</span></span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Entered the Android system server!&quot;</span>);</span><br><span class="line">        ......</span><br><span class="line">		<span class="comment">//此处省略部分主要干了清理更多内存出来为初始化服务做准备，设置后台任务，增加binder最大线程等</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">        android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize native services.</span></span><br><span class="line">        System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the system context.</span></span><br><span class="line">        <span class="comment">//创建android上下文</span></span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the system service manager.</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">        <span class="comment">//开始启动服务了   ,这个方法是启动引导服务 例如AMS PMS DMS PKMS</span></span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        <span class="comment">//启动核心服务：DropBox，Battery,UsageStats,WebViewUpdate</span></span><br><span class="line">        startCoreServices();</span><br><span class="line">        <span class="comment">//启动其他服务</span></span><br><span class="line">        startOtherServices();</span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    <span class="comment">//systemServer一直循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Context context = mSystemContext;</span><br><span class="line">        VibratorService vibrator = <span class="keyword">null</span>;</span><br><span class="line">        IStorageManager storageManager = <span class="keyword">null</span>;</span><br><span class="line">        NetworkManagementService networkManagement = <span class="keyword">null</span>;</span><br><span class="line">        NetworkStatsService networkStats = <span class="keyword">null</span>;</span><br><span class="line">        NetworkPolicyManagerService networkPolicy = <span class="keyword">null</span>;</span><br><span class="line">        ConnectivityService connectivity = <span class="keyword">null</span>;</span><br><span class="line">        NetworkScoreService networkScore = <span class="keyword">null</span>;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化NetworkManagementService</span></span><br><span class="line">        <span class="keyword">if</span> (!disableNetwork) &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartNetworkManagementService&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                networkManagement = NetworkManagementService.create(context);</span><br><span class="line">                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">&quot;starting NetworkManagement Service&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            traceEnd();</span><br><span class="line">        &#125;</span><br><span class="line">   		 ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化NetworkStatsService</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartNetworkStatsService&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            networkStats = NetworkStatsService.create(context, networkManagement);</span><br><span class="line">            ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;starting NetworkStats Service&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 初始化NetworkPolicyManagerService</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartNetworkPolicyManagerService&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            networkPolicy = <span class="keyword">new</span> NetworkPolicyManagerService(context,</span><br><span class="line">                              mActivityManagerService, networkStats, networkManagement);</span><br><span class="line">            ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;starting NetworkPolicy Service&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">            </span><br><span class="line">    	<span class="comment">// 初始化ConnectivityService</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartConnectivityService&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectivity = <span class="keyword">new</span> ConnectivityService(</span><br><span class="line">                context, networkManagement, networkStats, networkPolicy);</span><br><span class="line">            ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);</span><br><span class="line">            networkStats.bindConnectivityManager(connectivity);</span><br><span class="line">            networkPolicy.bindConnectivityManager(connectivity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;starting Connectivity Service&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化ConnectivityService的时候传入networkManagement，networkStats，networkPolicy。</p>
<h4 id="2-1-2-获取其他服务的接口"><a href="#2-1-2-获取其他服务的接口" class="headerlink" title="2.1.2 获取其他服务的接口"></a>2.1.2 获取其他服务的接口</h4><p>ConnectivityService构造方法中接收交互服务的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mNetd = checkNotNull(netManager, <span class="string">&quot;missing INetworkManagementService&quot;</span>);</span><br><span class="line">mStatsService = checkNotNull(statsService, <span class="string">&quot;missing INetworkStatsService&quot;</span>);</span><br><span class="line">mPolicyManager = checkNotNull(policyManager, <span class="string">&quot;missing INetworkPolicyManager&quot;</span>);</span><br><span class="line">mPolicyManagerInternal = checkNotNull(</span><br><span class="line">LocalServices.getService(NetworkPolicyManagerInternal.class),</span><br><span class="line"><span class="string">&quot;missing NetworkPolicyManagerInternal&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建mTethering</span></span><br><span class="line">mTethering = <span class="keyword">new</span> Tethering(mContext, mNetd, statsService, mPolicyManager,</span><br><span class="line">IoThread.get().getLooper(), <span class="keyword">new</span> MockableSystemProperties());</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册其他必要的监听和广播，以便接收变化信息和通知变化信息。</span></span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_STARTED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_STOPPED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_ADDED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_REMOVED);</span><br><span class="line">intentFilter.addAction(Intent.ACTION_USER_UNLOCKED);</span><br><span class="line">mContext.registerReceiverAsUser(</span><br><span class="line">    mUserIntentReceiver, UserHandle.ALL, intentFilter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">mContext.registerReceiverAsUser(mUserPresentReceiver, UserHandle.SYSTEM,</span><br><span class="line">    <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_PRESENT), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向netd注册mTethering</span></span><br><span class="line">mNetd.registerObserver(mTethering);</span><br><span class="line">mNetd.registerObserver(mDataActivityObserver);</span><br></pre></td></tr></table></figure>


<h4 id="2-2-NetworkFactory的初始化"><a href="#2-2-NetworkFactory的初始化" class="headerlink" title="2.2  NetworkFactory的初始化"></a>2.2  NetworkFactory的初始化</h4><p>NetworkFactory负责构建新增网络默认评分，网络类型，网络能力。为了车机启动起来就能按照网络评分机制来选择网络，ConnectivityService服务起来之后，就不断收集外部注册进来的网络(本文用Tbox注册网络和wifi注册网络来叙述)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-44f70a21b2d72c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NetworkFactory初始化.png"></p>
<p>当管理Tbox的service起来之后，通过获取usb0(tbox通过usb0与车机通信)配置信息(usb0;12,13,14,15;ip=2.2.2.1/24 gateway=2.2.2.2 dns=116.116.116.116,8.8.8.8;0;70)。然后解析配置信息，解析获取网卡信息之后，创建一个NetworkFactory最后调用register()方法，将该网卡注册到ConnectivityService中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NetworkFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.log(<span class="string">&quot;Registering NetworkFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mMessenger == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">this</span>);</span><br><span class="line">        ConnectivityManager.from(<span class="keyword">this</span>.mContext).registerNetworkFactory(<span class="keyword">this</span>.mMessenger, </span><br><span class="line">                                                                       <span class="keyword">this</span>.LOG_TAG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConnectivityService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerNetworkFactory</span><span class="params">(Messenger messenger, String name)</span> </span>&#123;</span><br><span class="line">    enforceConnectivityInternalPermission();</span><br><span class="line">    NetworkFactoryInfo nfi = <span class="keyword">new</span> NetworkFactoryInfo(name, messenger, <span class="keyword">new</span> AsyncChannel());</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_FACTORY, nfi));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理EVENT_REGISTER_NETWORK_FACTORY</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRegisterNetworkFactory</span><span class="params">(NetworkFactoryInfo nfi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) log(<span class="string">&quot;Got NetworkFactory Messenger for &quot;</span> + nfi.name);</span><br><span class="line">    mNetworkFactoryInfos.put(nfi.messenger, nfi);</span><br><span class="line">    <span class="comment">//通过asyncChannel通知Networkfactory操作成功</span></span><br><span class="line">    <span class="comment">//注意，在异步回复Networkfactory的时候，asyncChannel会处理CMD_CHANNEL_HALF_CONNECTED来通知创建NetworkAgent</span></span><br><span class="line">    nfi.asyncChannel.connect(mContext, mTrackerHandler, nfi.messenger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-3-NetworkAgent的初始化"><a href="#2-3-NetworkAgent的初始化" class="headerlink" title="2.3 NetworkAgent的初始化"></a>2.3 NetworkAgent的初始化</h4><p>NetworkAgent是一个网络代理，它里面保存了一些路由的配置信息，比如NetworkInfo，LinkProperties，NetworkCapabilities等。NetworkAgent的初始化都是在路由配置信息获取成功之后。比如打开数据开关，打开wifi开关等操作之后。</p>
<p>注：<br>NetworkInfo 描述一个给定类型的网络接口的状态方面的信息，包括网络连接状态、网络类型、网络可连接性、是否漫游等信息<br>LinkProperties 描述一个网络连接属性信息（包含网络地址、网关、DNS、HTTP代理等属性信息<br>NetworkCapabilities 描述一个网络连接能力方面的信息，包括带宽、延迟等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理CMD_CHANNEL_HALF_CONNECTED </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">maybeHandleAsyncChannelMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">         <span class="keyword">case</span> AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: &#123;</span><br><span class="line">             <span class="comment">// 向NetworkFactory发送路由配置成功了，可以创建NetworkAgent代理了。</span></span><br><span class="line">             handleAsyncChannelHalfConnect(msg);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        ......</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleAsyncChannelHalfConnect</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    AsyncChannel ac = (AsyncChannel) msg.obj;</span><br><span class="line">    <span class="keyword">if</span> (mNetworkFactoryInfos.containsKey(msg.replyTo)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;NetworkFactory connected&quot;</span>);</span><br><span class="line">            <span class="comment">// A network factory has connected.  Send it all current NetworkRequests.</span></span><br><span class="line">            <span class="keyword">for</span> (NetworkRequestInfo nri : mNetworkRequests.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nri.request.isListen()) <span class="keyword">continue</span>;</span><br><span class="line">                NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);</span><br><span class="line">                <span class="comment">// 向NetworkFactory发送CMD_REQUEST_NETWORK请求处理</span></span><br><span class="line">                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK,</span><br><span class="line">                               (nai != <span class="keyword">null</span> ? nai.getCurrentScore() : <span class="number">0</span>), <span class="number">0</span>, nri.request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loge(<span class="string">&quot;Error connecting NetworkFactory&quot;</span>);</span><br><span class="line">            mNetworkFactoryInfos.remove(msg.obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NetworkFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_REQUEST_NETWORK: &#123;</span><br><span class="line">            handleAddRequest((NetworkRequest) msg.obj, msg.arg1, msg.arg2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当路由信息配置成功之后，ConnectivityService会通知NetworkFactory创建NetworkAgent。在handleAddRequest方法中会调用evalRequest根据评分，网络能力等来判断是否需要创建代理。</p>
<p><strong>调用链路：</strong>handleAddRequest() –&gt; evalRequest() –&gt;  needNetworkFor() –&gt;  NetworkFactory.startNetwork()–&gt; ExtNetworkFactory.startNetwork() –&gt; mayStartIpManager() –&gt; startIpManager() –&gt;  new NetworkAgent()</p>
<h4 id="2-4-NetworkMonitor的初始化"><a href="#2-4-NetworkMonitor的初始化" class="headerlink" title="2.4 NetworkMonitor的初始化"></a>2.4 NetworkMonitor的初始化</h4><p>NetworkMonitor主要是检测网络有效性的，通过Http封装类去ping一个网站，根据ping网站的结果来影响评分值。因此，它的初始化是在NetworkAgent初始化之后，必须要获取到路由配置信息NetworkAgent后才会去初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建NetworkAgent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkAgent</span><span class="params">(Looper looper, Context context, String logTag, NetworkInfo ni, NetworkCapabilities nc, LinkProperties lp, <span class="keyword">int</span> score, NetworkMisc misc)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 向ConnectivityService中注册NetworkAgent</span></span><br><span class="line">    <span class="keyword">this</span>.netId = cm.registerNetworkAgent(<span class="keyword">new</span> Messenger(<span class="keyword">this</span>), <span class="keyword">new</span> NetworkInfo(ni), <span class="keyword">new</span> LinkProperties(lp), <span class="keyword">new</span> NetworkCapabilities(nc), score, misc);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerNetworkAgent</span><span class="params">(Messenger messenger, NetworkInfo networkInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            LinkProperties linkProperties, NetworkCapabilities networkCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> currentScore, NetworkMisc networkMisc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  构建NetworkAgentInfo，在NetworkAgentInfo中构建NetworkMonitor</span></span><br><span class="line">    <span class="keyword">final</span> NetworkAgentInfo nai = <span class="keyword">new</span> NetworkAgentInfo(messenger, <span class="keyword">new</span> AsyncChannel(),</span><br><span class="line">          <span class="keyword">new</span> Network(reserveNetId()), <span class="keyword">new</span> NetworkInfo(networkInfo), <span class="keyword">new</span> LinkProperties(</span><br><span class="line">linkProperties), <span class="keyword">new</span> NetworkCapabilities(networkCapabilities), currentScore,mContext, mTrackerHandler, <span class="keyword">new</span> NetworkMisc(networkMisc), mDefaultRequest, <span class="keyword">this</span>);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-网络有效性检测（NetworkMonitor）"><a href="#3-网络有效性检测（NetworkMonitor）" class="headerlink" title="3. 网络有效性检测（NetworkMonitor）"></a>3. 网络有效性检测（NetworkMonitor）</h3><p>NetworkMonitor是一个状态机。负责检测网络有效性，也就是ping网络的过程。ping网络过程中产生的几种状态如下：</p>
<ul>
<li>DefaultState 默认状态 </li>
<li>EvaluatingState 验证状态 </li>
<li>ValidatedState 验证通过状态 </li>
<li>LingeringState 休闲状态，表示网络的验证位是真实的，并且曾经是满足特定NetworkRequest的最高得分网络，但是此时另一个网络满足了NetworkRequest的更高分数，在断开连接前的一段时间前，该网络被“固定”为休闲状态。 </li>
<li>CaptivePortalState 强制门户状态 </li>
<li>MaybeNotifyState 可能通知状态，表示用户可能已被通知需要登录。 在退出该状态时，应该小心清除通知。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-54dfaf5e8c873a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NetworkMonitor状态机.png"></p>
<p>以正常的ping网站过程为例，DefaultState为默认状态，NetworkMonitor接收到CMD_NETWORK_CONNECTED事件消息后，先由DefaultState状态处理，然后由EvaluatingState处理，最后交给ValidatedState处理。</p>
<p>从NetworkMonitor的初始化，到ping网站的过程，到ping网站的结果影响评分值。这个过程的时序图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-07f4f715a1ef8978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NetworkMonitor初始化流程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handles a network appearing or improving its score.</span></span><br><span class="line"><span class="comment">// - Evaluates all current NetworkRequests that can be</span></span><br><span class="line"><span class="comment">//   satisfied by newNetwork, and reassigns to newNetwork</span></span><br><span class="line"><span class="comment">//   any such requests for which newNetwork is the best.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - Lingers any validated Networks that as a result are no longer</span></span><br><span class="line"><span class="comment">//   needed. A network is needed if it is the best network for</span></span><br><span class="line"><span class="comment">//   one or more NetworkRequests, or if it is a VPN.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - Tears down newNetwork if it just became validated</span></span><br><span class="line"><span class="comment">//   but turns out to be unneeded.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - If reapUnvalidatedNetworks==REAP, tears down unvalidated</span></span><br><span class="line"><span class="comment">//   networks that have no chance (i.e. even if validated)</span></span><br><span class="line"><span class="comment">//   of becoming the highest scoring network.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.新的NetworkAgentInfo出来，要重新评估所有的NetworkRequests，如果这个网络是最好的网络，会将这些NetworkRequests reassigns到这个新网络， 比如数据网络连接的情况下，wifi连接成功且网络判通成功，这时候一些网络请求的NetworkRequests 要reassigns 到wifi的NetworkAgentInfo</span></span><br><span class="line"><span class="comment">//  2.Lingers任何一个不再需要的validated Networks，理解 “不再需要”，wifi连接的情况下，data网络正常是会linger的，但是如果此时有一个或多个NetworkRequest的指定的transportType为NetworkCapabilities.TRANSPORT_CELLULAR 此时不会linger这个数据网络，另外这个网络是VPN.也不会被linger</span></span><br><span class="line"><span class="comment">//  3.如果一个不需要的网络，就是被linger的网络，会执行Tears down newNetwork ，导致networkagent调用unwanted()方法 网络interface 都会被关闭（可以通过ifconfig 中消失掉来验证）</span></span><br><span class="line"><span class="comment">//  4.reapUnvalidatedNetworks 最后一个网络会传REAP，导致网络被tear down</span></span><br><span class="line">rematchNetworkAndRequests(NetworkAgentInfo newNetwork,</span><br><span class="line">        ReapUnvalidatedNetworks reapUnvalidatedNetworks, <span class="keyword">long</span> now)</span><br></pre></td></tr></table></figure>
<p>当网络状态变化，网络信息变化都会调用到rematchNetworkAndRequests方法中，最后会根据状态机状态，send不同类型的message，NetworkMonitor收到message之后进行相应的处理。</p>
<p>以收到CMD_NETWORK_CONNECTED为例，当monitor收到CMD_NETWORK_CONNECTED消息的时候，会将状态机切换到EvaluatingState状态，在EvaluatingState的enter()方法中发送CMD_REEVALUATE消息。在processMessage()中处理该消息。最后会调用到isCaptivePortal();中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isCaptivePortal会根据http或者https请求发起HttpURLConnection()</span></span><br><span class="line">CaptivePortalProbeResult probeResult = isCaptivePortal();</span><br><span class="line"><span class="comment">//根据不同的ping结果，做相应处理</span></span><br><span class="line"><span class="keyword">if</span> (probeResult.isSuccessful()) &#123;</span><br><span class="line">    transitionTo(mValidatedState);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (probeResult.isPortal()) &#123;</span><br><span class="line">    mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED,</span><br><span class="line">               NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));</span><br><span class="line">    mLastPortalProbeResult = probeResult;</span><br><span class="line">    transitionTo(mCaptivePortalState);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Message msg = obtainMessage(CMD_REEVALUATE, ++mReevaluateToken, <span class="number">0</span>);</span><br><span class="line">    sendMessageDelayed(msg, mReevaluateDelayMs);</span><br><span class="line">    logNetworkEvent(NetworkEvent.NETWORK_VALIDATION_FAILED);</span><br><span class="line">    mConnectivityServiceHandler.sendMessage(obtainMessage(</span><br><span class="line">        EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId,</span><br><span class="line">        probeResult.redirectUrl));</span><br><span class="line">    <span class="keyword">if</span> (mAttempts &gt;= BLAME_FOR_EVALUATION_ATTEMPTS) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t continue to blame UID forever.</span></span><br><span class="line">        TrafficStats.clearThreadStatsUid();</span><br><span class="line">    &#125;</span><br><span class="line">    mReevaluateDelayMs *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mReevaluateDelayMs &gt; MAX_REEVALUATE_DELAY_MS) &#123;</span><br><span class="line">        mReevaluateDelayMs = MAX_REEVALUATE_DELAY_MS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据ping网络的结果来执行不同的操作： </p>
<ul>
<li><strong>ping网络成功</strong>，如果收到的响应码是204，将状态机切换到ValidatedState。当状态机切换到ValidatedState之后，在enter()方法中会发送消息EVENT_NETWORK_TESTED。当ConnectivityService收到EVENT_NETWORK_TESTED之后，调用updateCapabilities()更新网卡能力和重新评估这个网络是否对于所有请求是最优的；如果当前能ping通的网络评分和以前的评分不一致，调用sendUpdatedScoreToFactories()更新评分。</li>
<li><strong>ping网络失败</strong>，网络返回200~399，转到CaptivePortalState状态处理。 </li>
<li><strong>ping网络失败</strong>，不是204，也不是200~399，则发送CMD_REEVALUATE消息，重新触发ping网络的动作。第一次失败，8s后重新ping网络，第二次失败，16s后重新ping网络，时间依次倍增，最长的时间间隔为10分钟。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">maybeHandleNetworkMonitorMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">case</span> NetworkMonitor.EVENT_NETWORK_TESTED: &#123;</span><br><span class="line">        <span class="keyword">final</span> NetworkAgentInfo nai;</span><br><span class="line">        <span class="keyword">synchronized</span> (mNetworkForNetId) &#123;</span><br><span class="line">            nai = mNetworkForNetId.get(msg.arg2);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">            <span class="keyword">if</span> (valid != nai.lastValidated) &#123;</span><br><span class="line">                <span class="comment">// 更新评分</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> oldScore = nai.getCurrentScore();</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 更新网络接口能力</span></span><br><span class="line">                updateCapabilities(oldScore, nai, nai.networkCapabilities);</span><br><span class="line">                <span class="comment">// 更新评分到网络工厂</span></span><br><span class="line">                <span class="keyword">if</span> (oldScore != nai.getCurrentScore()) sendUpdatedScoreToFactories(nai);</span><br><span class="line">            &#125;</span><br><span class="line">           .....</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ping网络的状态会保存到NetworkAgentInfo中，而后续所有的评分值都会调用NetworkAgentInfo的getCurrentScore()方法来获取，getCurrentScore()方法会根据当前ping网络的状态重新计算评分值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCurrentScore</span><span class="params">(<span class="keyword">boolean</span> pretendValidated)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是用户指定的网络，直接给100分</span></span><br><span class="line">	<span class="keyword">if</span> (networkMisc.explicitlySelected &amp;&amp; (networkMisc.acceptUnvalidated || 						pretendValidated)) &#123;</span><br><span class="line">		<span class="keyword">return</span> MAXIMUM_NETWORK_SCORE; <span class="comment">//100</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> score = currentScore;</span><br><span class="line">    <span class="comment">// 如果ping失败了就扣40分，如果ping网络成功，则评分值不变。</span></span><br><span class="line">    <span class="keyword">if</span> (!lastValidated &amp;&amp; !pretendValidated &amp;&amp; !ignoreWifiUnvalidationPenalty()) &#123;</span><br><span class="line">   		score -= UNVALIDATED_SCORE_PENALTY; <span class="comment">// -40</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (score &lt; <span class="number">0</span>) score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-网络评分机制"><a href="#3-网络评分机制" class="headerlink" title="3.网络评分机制"></a>3.网络评分机制</h3><p>NetworkFactory的存在意义就是为了帮助ConnectivityService进行评分的管理。一般在NetworkFactory在初始化时，设置固定的评分值，作为评判的标准。<br>NetworkAgent作为一个代理信息的抽象，在其初始化时，也设置了固定的评分值，不过，这个评分值会根据当前的网络情况的不同而变化，其最后的评分值会和NetworkFactory中的固定评分值进行比较，从而筛选出最优网络。</p>
<p>项目中可能涉及的网络源如下：WifiNetworkFactory，TelephonyNetwork，EthernetNetwork，PhoneSwitcher，Tbox。</p>
<p>这些工厂在初始化的时候，会将默认评分注册到ConnectivityService中</p>
<table>
<thead>
<tr>
<th></th>
<th>NetworkFactory初始化</th>
<th>NetworkAgent初始化</th>
<th>NetworkMonitor中ping网络</th>
<th>disconnect</th>
</tr>
</thead>
<tbody><tr>
<td>TelephonyNetwork</td>
<td>50</td>
<td>50</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>Tbox</td>
<td>50</td>
<td>50</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>Wifi</td>
<td>60</td>
<td>60</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>EthernetNetwork</td>
<td>69</td>
<td>69</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
<tr>
<td>PhoneSwitcher</td>
<td>101</td>
<td>101</td>
<td>成功：+0 失败：-40 用户指定：+100</td>
<td>0</td>
</tr>
</tbody></table>
<p>各种数据业务类型的评分标准，除了其基础评分值不同之外，其他的评判标准都一样。其评分值的变化，主要有以下几种情况：<br>一．代理信息获取结束后，会参与ping网络的过程，如果ping网络成功，那么NetworkAgent中的评分值不变。如果ping网络失败，那么NetworkAgent中的评分值-40。如果用户指定了某种网络类型作为连接方式，那么NetworkAgent重的评分值+100。<br>二．如果NetworkAgent和ConnectivityService的AsyncChannel通道断开，需要设置其评分值为0，好让其他的评分高的网络类型连接。</p>
<p><strong>NetworkFactory中的评分标准：</strong></p>
<p>NetworkFactory中维持了基础的评分分值mScore，mScore只有在 NetworkFactory对象创建的时候才会赋值。因网络环境的变化导致需要重新进行网络评估时，使用基础评分分值与传进来的NetworkRequestInfo中的分值进行比较。</p>
<ul>
<li>如果当前的NetworkRequestInfo没有requested过，且当前的分值score比基础分值mScore小，说明当前的NetworkRequestInfo为最优网络，调用needNetworkFor()连接网络。</li>
<li>如果当前的NetworkRequestInfo已经requested过，且当前的分值score比基础分值mScore大，说明当前的NetworkRequestInfo已经不是最优网络了，有个更优的网络可用连接，此时应该调用releaseNetworkFor()释放掉此类网络连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evalRequest</span><span class="params">(NetworkRequestInfo n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;evalRequest request = &quot;</span> + n.request + <span class="string">&quot; with requested = &quot;</span> + n.requested);</span><br><span class="line">    <span class="keyword">if</span> (n.requested == <span class="keyword">false</span> &amp;&amp; n.score &lt; mScore &amp;&amp;</span><br><span class="line">            n.request.networkCapabilities.satisfiedByNetworkCapabilities(</span><br><span class="line">            mCapabilityFilter) &amp;&amp; acceptRequest(n.request, n.score)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;  needNetworkFor&quot;</span>);</span><br><span class="line">        needNetworkFor(n.request, n.score);</span><br><span class="line">        n.requested = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.requested == <span class="keyword">true</span> &amp;&amp;</span><br><span class="line">            (n.score &gt; mScore || n.request.networkCapabilities.satisfiedByNetworkCapabilities(</span><br><span class="line">            mCapabilityFilter) == <span class="keyword">false</span> || acceptRequest(n.request, n.score) == <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;  releaseNetworkFor&quot;</span>);</span><br><span class="line">        releaseNetworkFor(n.request);</span><br><span class="line">        n.requested = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (VDBG) log(<span class="string">&quot;  done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>触发评分的过程：</strong></p>
<p>1.NetworkFactory与ConnectivityService通过AsyncChannel建立连接的时候，初始化评分，并参与了第一次的评分过程。如果此时还没有ping网络的话，其传进来的评分值为基础评分值，以上代码会执行else逻辑。 </p>
<p>2.调用sendUpdatedScoreToFactories()方法触发了评分过程<br>在ping网络过程中，会触发多次评分过程。在NetworkMonitor的多个状态中，都有向ConnectivityService发起EVENT_NETWORK_TESTED事件消息更新评分</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>网络管理</tag>
        <tag>ConnectivityService</tag>
      </tags>
  </entry>
  <entry>
    <title>调查ADB突然异常问题</title>
    <url>/2021/07/27/%E8%B0%83%E6%9F%A5ADB%E7%AA%81%E7%84%B6%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1. 问题现象"></a>1. 问题现象</h4><p>​    adb用着用着就不好使了，然后出现黑屏，伴随着有时候串口也不好使。</p>
<h4 id="2-应急补救措施"><a href="#2-应急补救措施" class="headerlink" title="2.应急补救措施"></a>2.应急补救措施</h4><p>​    测试同学如果遇到adb用着用着突然不好使了，请使用如下手顺首先恢复串口或者adb口好使，然后取一下相关日志给到开发。<br>![adb突然不好使应急措施]<img src="https://upload-images.jianshu.io/upload_images/13838098-835ec93a64822a64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="adb突然不好使应急措施.png"></p>
<h4 id="3-问题调查"><a href="#3-问题调查" class="headerlink" title="3.问题调查"></a>3.问题调查</h4><p>​    经过上面手顺发现是</p>
<ul>
<li>有一台车机是adbd服务挂掉了，通过<code>start adbd</code>重启adb服务之后就可以恢复正常使用了。导出tombstone文件，分析问题发生原因。</li>
<li>有一台车是adb口的模式属性值被设置成host模式。</li>
</ul>
<p>​    </p>
<h5 id="3-1-查看tombstone日志"><a href="#3-1-查看tombstone日志" class="headerlink" title="3.1 查看tombstone日志"></a>3.1 查看tombstone日志</h5><p>为什么看tombstone日志呢，因为logcat中着实看不出什么问题来。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">Build fingerprint: <span class="string">&#x27;qti/msmnile_gvmq/msmnile_gvmq:9/PQ1A.190105.004/root07251158:userdebug/test-keys&#x27;</span></span><br><span class="line">Revision: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">ABI: <span class="string">&#x27;arm64&#x27;</span></span><br><span class="line">pid: <span class="number">6911</span>, tid: <span class="number">6911</span>, name: cockpit.settings  &gt;&gt;&gt; com.gxatek.cockpit.settings &lt;&lt;&lt;</span><br><span class="line">signal <span class="number">11</span> (SIGSEGV), code <span class="number">1</span> (SEGV_MAPERR), fault addr <span class="number">0x19</span></span><br><span class="line">Cause: <span class="keyword">null</span> pointer dereference    <span class="comment">// 空指针异常</span></span><br><span class="line">    x0  <span class="number">00000000000003e7</span>  x1  0000000000000018  x2  <span class="number">0000000000000000</span>  x3  <span class="number">0000000000000001</span></span><br><span class="line">    x4  <span class="number">0000000000000000</span>  x5  0000007ff5c5b180  x6  64636e4c3c04ff3c  x7  <span class="number">0000000000000000</span></span><br><span class="line">    x8  <span class="number">00000000000003e7</span>  x9  0000000000007ffe  x10 <span class="number">0000000000000000</span>  x11 0000007258614c00</span><br><span class="line">    x12 <span class="number">0000000000000000</span>  x13 <span class="number">0000000000000001</span>  x14 0000007ff5c5af94  x15 <span class="number">0000000000000000</span></span><br><span class="line">    x16 <span class="number">0000007257e48080</span>  x17 <span class="number">0000007257e40880</span>  x18 <span class="number">0000000000000000</span>  x19 0000007ff5c5b018</span><br><span class="line">    x20 0000007240f83d08  x21 0000007ff5c5afd0  x22 0000007258614c00  x23 00000000000010ef</span><br><span class="line">    x24 <span class="number">0000007257e40900</span>  x25 0000007ff5c5afd8  x26 <span class="number">00000000000003e7</span>  x27 0000007ff5c5af98</span><br><span class="line">    x28 0000007257f31048  x29 0000007ff5c5ae40</span><br><span class="line">    sp  0000007ff5c5ae00  lr  0000007257e408d0  pc  <span class="number">0000007257e48094</span></span><br><span class="line"></span><br><span class="line">backtrace:</span><br><span class="line">    #00 pc 000000000054b094  /system/lib64/libart.so (ExecuteMterpImpl+30740)</span><br><span class="line">    <span class="comment">// NestedScrollingChildHelper报空指针</span></span><br><span class="line">    #01 pc 00000000000f1d08  /system/framework/oat/arm64/ui-framework.vdex (android.support.v4.view.NestedScrollingChildHelper.isNestedScrollingEnabled)</span><br><span class="line">    #02 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #03 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #04 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #05 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #06 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #07 pc 000000000012dd58  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (android.support.v7.widget.RecyclerView.setNestedScrollingEnabled+8)</span><br><span class="line">    #08 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #09 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #10 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #11 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #12 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #13 pc 000000000012b302  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (android.support.v7.widget.RecyclerView.&lt;init&gt;+674)</span><br><span class="line">    #14 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #15 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #16 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #17 pc 0000000000525a50  /system/lib64/libart.so (MterpInvokeDirect+296)</span><br><span class="line">    #18 pc 0000000000547114  /system/lib64/libart.so (ExecuteMterpImpl+14484)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 在CarplayFragment中inflate创建Fragment布局</span></span><br><span class="line">    #41 pc 000000000017300c  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.fragment.internet.CarplayFragment.onCreateView+8)</span><br><span class="line">    #42 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #43 pc 0000000000514fa4  /system/lib64/libart.so (artQuickToInterpreterBridge+1020)</span><br><span class="line">    #44 pc 000000000055dafc  /system/lib64/libart.so (art_quick_to_interpreter_bridge+92)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 懒加载机制加载fragment</span></span><br><span class="line">    #68 pc 000000000015a276  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.adapter.FragmentAdapter.finishUpdate+8)</span><br><span class="line">    #69 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #70 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #71 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #72 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #73 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #74 pc 000000000015e11c  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.custom.NoPreloadViewPager.populate+436)</span><br><span class="line">    #75 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #76 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #77 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #78 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">    #79 pc 000000000054ad94  /system/lib64/libart.so (ExecuteMterpImpl+29972)</span><br><span class="line">    #80 pc 000000000015e410  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.view.custom.NoPreloadViewPager.setCurrentItemInternal+184)</span><br><span class="line">    #81 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #82 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #83 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #84 pc 0000000000527754  /system/lib64/libart.so (MterpInvokeVirtualQuick+584)</span><br><span class="line">        </span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 点击item，切换到fragment</span></span><br><span class="line">   #98 pc 000000000013e91e  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.MainActivity.switchToFragment+16)</span><br><span class="line">    #99 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #100 pc 0000000000258ab4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToInterpreterBridge(art::Thread*, art::CodeItemDataAccessor const&amp;, art::ShadowFrame*, art::JValue*)+216)</span><br><span class="line">    #101 pc 00000000002792a0  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+940)</span><br><span class="line">    #102 pc 0000000000525a50  /system/lib64/libart.so (MterpInvokeDirect+296)</span><br><span class="line">    #103 pc 0000000000547114  /system/lib64/libart.so (ExecuteMterpImpl+14484)</span><br><span class="line">    #104 pc 000000000013e4ae  /system/app/CarSettingHMI/oat/arm64/CarSettingHMI.vdex (com.gxatek.cockpit.settings.MainActivity.onClick+94)</span><br><span class="line">    #105 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #106 pc 0000000000514fa4  /system/lib64/libart.so (artQuickToInterpreterBridge+1020)</span><br><span class="line">    #107 pc 000000000055dafc  /system/lib64/libart.so (art_quick_to_interpreter_bridge+92)</span><br><span class="line">    #108 pc 0000000000c7dee4  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.view.View.performClick+148)</span><br><span class="line">    #109 pc 0000000000554988  /system/lib64/libart.so (art_quick_invoke_stub+584)</span><br><span class="line">    #110 pc 00000000000cf6c8  /system/lib64/libart.so (art::ArtMethod::Invoke(art::Thread*, unsigned int*, unsigned int, art::JValue*, char const*)+200)</span><br><span class="line">    #111 pc 000000000027f2b4  /system/lib64/libart.so (art::interpreter::ArtInterpreterToCompiledCodeBridge(art::Thread*, art::ArtMethod*, art::ShadowFrame*, unsigned short, art::JValue*)+344)</span><br><span class="line">    #112 pc 00000000002792bc  /system/lib64/libart.so (bool art::interpreter::DoCall&lt;false, false&gt;(art::ArtMethod*, art::Thread*, art::ShadowFrame&amp;, art::Instruction const*, unsigned short, art::JValue*)+968)</span><br><span class="line">    #113 pc 0000000000524da8  /system/lib64/libart.so (MterpInvokeSuper+1420)</span><br><span class="line">    #114 pc 0000000000547094  /system/lib64/libart.so (ExecuteMterpImpl+14356)</span><br><span class="line">    #115 pc 0000000000d5aa92  /system/framework/boot-framework.vdex (android.widget.CompoundButton.performClick+6)</span><br><span class="line">    #116 pc 0000000000252fc0  /system/lib64/libart.so (_ZN3art11interpreterL7ExecuteEPNS_6ThreadERKNS_20CodeItemDataAccessorERNS_11ShadowFrameENS_6JValueEb.llvm.2118865428+488)</span><br><span class="line">    #117 pc 0000000000514fa4  /system/lib64/libart.so (artQuickToInterpreterBridge+1020)</span><br><span class="line">    #118 pc 000000000055dafc  /system/lib64/libart.so (art_quick_to_interpreter_bridge+92)</span><br><span class="line">    #119 pc 0000000000b83484  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.view.View$PerformClick.run+84)</span><br><span class="line">    #120 pc 0000000000aacccc  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.os.Handler.dispatchMessage+76)</span><br><span class="line">    #121 pc 0000000000aafe30  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.os.Looper.loop+1264)</span><br><span class="line">    #122 pc 000000000087c378  /system/framework/arm64/boot-framework.oat (offset 0x3ce000) (android.app.ActivityThread.main+664)        </span><br></pre></td></tr></table></figure>
<p><strong>从调用栈分析调度过程如下：</strong></p>
<ol>
<li>用户点击CarSettingHMI的界面某个item(最终调查到时carplayfragment)切换Fragment</li>
<li>懒加载加载carplayfragment</li>
<li>在递归加载RecycleView中子item的时候，NestedScrollingChildHelper处获得的时空指针</li>
</ol>
<h5 id="3-2-反编译CarSettingHMI-apk跟踪代码"><a href="#3-2-反编译CarSettingHMI-apk跟踪代码" class="headerlink" title="3.2 反编译CarSettingHMI.apk跟踪代码"></a>3.2 反编译CarSettingHMI.apk跟踪代码</h5><p>从CarplayFragment开始看，当然也可以从更早时机开始看，但是前面都是正常的，就直接接近真相便捷一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CarplayFragment.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater paramLayoutInflater, ViewGroup paramViewGroup, Bundle paramBundle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paramLayoutInflater.inflate(<span class="number">2131361842</span>, paramViewGroup, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当加载CarplayFragment的时候，系统回调onCreateView取加载布局文件。<strong>此处无异常代码</strong>，继续跟踪</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RecyclerView.setNestedScrollingEnabled</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNestedScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> paramBoolean)</span></span>&#123;</span><br><span class="line">    getScrollingChildHelper().setNestedScrollingEnabled(paramBoolean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着setNestedScrollingEnabled()就是真相，前面的ScrollingChildHelper是null，然后调用报空指针异常。继续跟进。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NestedScrollingChildHelper <span class="title">getScrollingChildHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mScrollingChildHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">this</span>.mScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mScrollingChildHelper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处看也是常规构建对象的方法，感觉也没有错，除了加锁可以防止，但是这个android.support.v7.widget支持包，是错也不应该我先发现，所有还是先从自身原因着手。</p>
<p>现在问题原因是找到了，就是：getScrollingChildHelper()返回了一个空对象，导致空指针异常。</p>
<h5 id="3-3-猜测问题原因"><a href="#3-3-猜测问题原因" class="headerlink" title="3.3 猜测问题原因"></a>3.3 猜测问题原因</h5><p>感觉调查到上面在不改支持库的前提下就没辙了。不过细心看tombstone日志，发现调用栈是CarSettingHMI.vdex 中的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#01 pc 00000000000f1d08  &#x2F;system&#x2F;framework&#x2F;oat&#x2F;arm64&#x2F;ui-framework.vdex (android.support.v4.view.NestedScrollingChildHelper.isNestedScrollingEnabled)</span><br><span class="line">   ......</span><br><span class="line">   #07 pc 000000000012dd58  &#x2F;system&#x2F;app&#x2F;CarSettingHMI&#x2F;oat&#x2F;arm64&#x2F;CarSettingHMI.vdex (android.support.v7.widget.RecyclerView.setNestedScrollingEnabled+8)</span><br></pre></td></tr></table></figure>
<p>可以看到是ui-framework.vdex和CarSettingHMI.vdex，让我不由想到之前遇到过的System-UI应用方法调用的内存地址错位的问题。</p>
<p>于是顺着经验，开始验证猜想，首先点击设置<code>系统设置应用</code>的carplayfragment界面，现象：<strong>必崩</strong>；删掉包含CarSettingHMI.vdex和CarSettingHMI.odex的oat目录，然后在点击carplayfragment界面，就好使了。</p>
<h5 id="3-4-临时解决办法"><a href="#3-4-临时解决办法" class="headerlink" title="3.4 临时解决办法"></a>3.4 临时解决办法</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">++ b/Feiyu/CarSettingHMI/Android.mk</span><br><span class="line">@@ -17,6 +17,7 @@ LOCAL_SRC_FILES := <span class="variable">$(LOCAL_MODULE)</span>.apk</span><br><span class="line"> LOCAL_MODULE_CLASS := APPS</span><br><span class="line"> LOCAL_MODULE_SUFFIX := <span class="variable">$(COMMON_ANDROID_PACKAGE_SUFFIX)</span></span><br><span class="line"> LOCAL_CERTIFICATE := platform</span><br><span class="line">+LOCAL_DEX_PREOPT := false</span><br></pre></td></tr></table></figure>
<p>取消优化项，在系统编译的时候，取消CarSettingHMI的优化项，让系统不生成CarSettingHMI.odex和CarSettingHMI.vdex文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">临时解决办法手顺：</span><br><span class="line">1、通过串口线进入Android系统</span><br><span class="line">   输入指令：dtach -a &#x2F;tmp&#x2F;android</span><br><span class="line">2、通过串口打开ADB：先通过串口进入Android系统，再输入以下指令：</span><br><span class="line">   echo peripheral &gt; &#x2F;sys&#x2F;devices&#x2F;platform&#x2F;soc&#x2F;ee080200.usb-phy&#x2F;role</span><br><span class="line">3、getprop persist.vendor.usb.mode   查看是否是host，是host执行步骤4即可</span><br><span class="line">4、setprop persist.vendor.usb.mode adb</span><br><span class="line">5、&#x2F;data&#x2F;tombstones    &#x2F;data&#x2F;system&#x2F;dropbox    &#x2F;log</span><br></pre></td></tr></table></figure>


<p><strong>3.5 终极解决办法</strong></p>
<p>建立maven仓库，或者artifactory仓库，让应用在Android Studio编译的时候，始终是最新的ui-framework和car-framework。然后在打开各个应用的预编译优化项。</p>
<h4 id="4-回溯问题"><a href="#4-回溯问题" class="headerlink" title="4.回溯问题"></a>4.回溯问题</h4><p>上面一顿操作猛如虎，但是还没有回答为什么ADB口用着用着一会儿就用不了。</p>
<p>其实系统设置里面有个工程模式，工程模式里面有个usb口模式切换。当系统设置崩溃之后，再启动起来，usb口的模式自动切回模式的模式了。usb口默认模式是：host模式。</p>
<p>当工程模式崩溃之后，可以通过如下指令查看usb的模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getprop persist.vendor.usb.mode</span><br><span class="line">setprop persist.vendor.usb.mode host</span><br><span class="line">setprop persist.vendor.usb.mode adb</span><br></pre></td></tr></table></figure>




<p><strong>参考文档：</strong></p>
<p><a href="https://www.cnblogs.com/CoderTian/p/5980426.html">1. Android Tombstone 分析</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>ADB无法使用</tag>
      </tags>
  </entry>
  <entry>
    <title>调查应用无辜被kill问题</title>
    <url>/2021/07/29/%E8%B0%83%E6%9F%A5%E5%BA%94%E7%94%A8%E6%97%A0%E8%BE%9C%E8%A2%ABkill%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>​    VPA应用经常崩溃，从日志中看com.iflytek.autofly.avatar 进程经常被kill。</p>
<h4 id="2-问题定位"><a href="#2-问题定位" class="headerlink" title="2.问题定位"></a>2.问题定位</h4><h5 id="2-1-搜索AndroidRuntime"><a href="#2-1-搜索AndroidRuntime" class="headerlink" title="2.1 搜索AndroidRuntime"></a>2.1 搜索<code>AndroidRuntime</code></h5><p>查看进程有没有被系统杀死，从log中看到,系统杀死的是<code>com.gxa.service.btcall</code>，并不是我们希望的<code>com.iflytek.autofly.avatar</code>应用，因此此线索结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">E AndroidRuntime: Process: com.gxa.service.btcall, PID: <span class="number">16399</span></span><br><span class="line">E AndroidRuntime: java.lang.RuntimeException: Unable to create service com.gxa.service.btcall.BtCallService: java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">&#x27;boolean ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager.registerCallback(ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager$BluetoothPhoneBookCallBack)&#x27;</span> on a <span class="keyword">null</span> object reference</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3582</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.access$<span class="number">1300</span>(ActivityThread.java:<span class="number">200</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">1672</span>)</span><br><span class="line">E AndroidRuntime: 	at android.os.Handler.dispatchMessage(Handler.java:<span class="number">106</span>)</span><br><span class="line">E AndroidRuntime: 	at android.os.Looper.loop(Looper.java:<span class="number">193</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6718</span>)</span><br><span class="line">E AndroidRuntime: 	at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">E AndroidRuntime: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">493</span>)</span><br><span class="line">E AndroidRuntime: 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">858</span>)</span><br><span class="line">E AndroidRuntime: Caused by: java.lang.NullPointerException: Attempt to invoke virtual method <span class="string">&#x27;boolean ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager.registerCallback(ts.car.bluetooth.sdk.phone.BluetoothPhoneBookManager$BluetoothPhoneBookCallBack)&#x27;</span> on a <span class="keyword">null</span> object reference</span><br><span class="line">E AndroidRuntime: 	at com.gxa.service.btcall.model.adapter.BtPhoneAdapter.init(BtPhoneAdapter.java:<span class="number">282</span>)</span><br><span class="line">E AndroidRuntime: 	at com.gxa.service.btcall.model.adapter.BtPhoneAdapter.&lt;init&gt;(BtPhoneAdapter.java:<span class="number">249</span>)</span><br><span class="line">E AndroidRuntime: 	at com.gxa.service.btcall.BtCallService.onCreate(BtCallService.java:<span class="number">101</span>)</span><br><span class="line">E AndroidRuntime: 	at android.app.ActivityThread.handleCreateService(ActivityThread.java:<span class="number">3570</span>)</span><br><span class="line">E AndroidRuntime: 	... <span class="number">8</span> more</span><br></pre></td></tr></table></figure>


<h5 id="2-2-直接搜索com-iflytek-autofly-avatar"><a href="#2-2-直接搜索com-iflytek-autofly-avatar" class="headerlink" title="2.2 直接搜索com.iflytek.autofly.avatar"></a>2.2 直接搜索<code>com.iflytek.autofly.avatar</code></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Line <span class="number">13098</span>: <span class="number">07</span>-<span class="number">28</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">06.089</span>   <span class="number">782</span> <span class="number">17518</span> I am_kill : [<span class="number">0</span>,<span class="number">28090</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]</span><br><span class="line">Line <span class="number">13098</span>: <span class="number">07</span>-<span class="number">28</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">06.089</span>   <span class="number">782</span> <span class="number">17518</span> I am_kill : [<span class="number">0</span>,<span class="number">28090</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]</span><br></pre></td></tr></table></figure>
<p>从日志中看到我们关注的应用确实有被kill的足迹。然后顺腾摸瓜，搜索“782”,看看这个进程是为什么kill VPA进程。</p>
<h5 id="2-3-搜索782"><a href="#2-3-搜索782" class="headerlink" title="2.3 搜索782"></a>2.3 搜索782</h5><p>从一堆日志中根本看不出有什么被杀原因的线索，“单纯”被杀了。继续回到<code>com.iflytek.autofly.avatar</code>的日志中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一行日志非常关键，可以看到com.iflytek.autofly.avatar被3186强制停止了！！</span></span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Force stopping com.iflytek.autofly.avatar appid=<span class="number">1000</span> user=<span class="number">0</span>: from pid <span class="number">3186</span></span><br><span class="line"><span class="comment">// 被停止的oom_adj值为200说明内存暂时也还不高，因此暂时排除com.iflytek.autofly.avatar因为内存问题被kill的可能</span></span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Killing <span class="number">2211</span>:com.iflytek.autofly.avatar/<span class="number">1000</span> (adj <span class="number">200</span>): stop com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I am_kill : [<span class="number">0</span>,<span class="number">2211</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]xxxxxxxxxx com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Force stopping com.iflytek.autofly.avatar appid=<span class="number">1000</span> user=<span class="number">0</span>: from pid <span class="number">3186</span></span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Killing <span class="number">2211</span>:com.iflytek.autofly.avatar/<span class="number">1000</span> (adj <span class="number">200</span>): stop com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">782</span> <span class="number">15478</span> I am_kill : [<span class="number">0</span>,<span class="number">2211</span>,com.iflytek.autofly.avatar,<span class="number">200</span>,stop com.iflytek.autofly.avatar]</span><br></pre></td></tr></table></figure>


<h5 id="2-4-搜索”3186”查看这个进程干了什么"><a href="#2-4-搜索”3186”查看这个进程干了什么" class="headerlink" title="2.4 搜索”3186”查看这个进程干了什么"></a>2.4 搜索”3186”查看这个进程干了什么</h5><p>从<code>3186</code>可以看到很多重要信息，如下信息显示这个进程会去做内存检查，当前可用内存：51687837696，已用内存419430400，发起超过400M警告</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: MSG_CHECK_DATA_MEMORY</span><br><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: requestCheckDataAvailableMemorySize</span><br><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: checkDataAvailableMemorySize is <span class="number">51687837696</span> check memorySize is <span class="number">419430400</span></span><br><span class="line"><span class="number">3186</span>  <span class="number">3245</span> I procmonitor: <span class="meta">@DeviceStorageMonitor</span>@: MSG_DATA_MEMORY_MORE_400M</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">782</span> <span class="number">15478</span> I ActivityManager: Force stopping com.iflytek.autofly.avatar appid=<span class="number">1000</span> user=<span class="number">0</span>: from pid <span class="number">3186</span></span><br><span class="line"><span class="number">3186</span>  <span class="number">3218</span> D procmonitor: <span class="meta">@ActivityProcManager</span>@: onProcessDied pid=<span class="number">2211</span> uid=<span class="number">1000</span></span><br><span class="line"><span class="comment">// 从这句话可以看出com.iflytek.autofly.avatar被杀了</span></span><br><span class="line"><span class="number">3186</span>  <span class="number">3246</span> D procmonitor: <span class="meta">@ActivityProcManager</span>@: runLimitLogic kill packagename = com.iflytek.autofly.avatar</span><br><span class="line"><span class="number">3186</span>  <span class="number">3246</span> D procmonitor: <span class="meta">@ConfigManager</span>@: <span class="function">getWhiteLists <span class="title">called</span><span class="params">()</span> isInitFalg</span>=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>真相即将浮现，查看procmonitor是哪个服务输出的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jieou<span class="meta">@gxatek</span>-fw-no:/work/jieou/gxa_code/lagvm_p/LINUX/android/vendor/gxatek/proprietary$ grep -nr <span class="string">&quot;procmonitor&quot;</span></span><br><span class="line">CarProcManager/ProcManagementService/service/src/main/java/com/gxa/car/procmanagement/utils/LogUtils.java:<span class="number">27</span>:    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;procmonitor&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在源码中grep到日志是ProcManagementService发出的，于是开始分析这个服务到底是干了什么。</p>
<h4 id="3-ProcManagementService源码分析"><a href="#3-ProcManagementService源码分析" class="headerlink" title="3.ProcManagementService源码分析"></a>3.ProcManagementService源码分析</h4><h5 id="3-1-服务架构如下"><a href="#3-1-服务架构如下" class="headerlink" title="3.1 服务架构如下"></a>3.1 服务架构如下</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-7c74847778ed3cb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ProcManagerService.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcManagementService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;onCreate()&quot;</span>);</span><br><span class="line">        mProcManagementImpl = <span class="keyword">new</span> ProcManagementImpl(<span class="keyword">this</span>.getApplicationContext());</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正实现在<code>ProcManagementImpl</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProcManagementImpl</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">// 1.一键清理manager</span></span><br><span class="line">    mCleanProcManager = <span class="keyword">new</span> CleanProcManager(mContext);</span><br><span class="line">    <span class="comment">// 2.内存管理monitor</span></span><br><span class="line">    mDeviceStorageMonitor = <span class="keyword">new</span> DeviceStorageMonitor(mContext);</span><br><span class="line">    mDeviceStorageMonitor.init();</span><br><span class="line">    <span class="comment">// 3.界面管理manager</span></span><br><span class="line">    mActivityProcManager = <span class="keyword">new</span> ActivityProcManager(mContext.getApplicationContext());</span><br><span class="line">    mAsyncHandlerThread = <span class="keyword">new</span> HandlerThread(THREAD_NAME);</span><br><span class="line">    mAsyncHandlerThread.start();</span><br><span class="line">    mAsyncHandler = <span class="keyword">new</span> Handler(mAsyncHandlerThread.getLooper()) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        	asyncHandleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 4.初始化Handler，解析配置文件</span></span><br><span class="line">    mAsyncHandler.sendEmptyMessageDelayed(ID_INIT, DELAY_TIME_500);</span><br><span class="line">    <span class="comment">// 5.注册清理app内存和清理后台app内存广播</span></span><br><span class="line">    registerDebugReceiver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>从构造方法中可以看出，ProcManagement主要会做五个事情，其中我们主要分析1，2，3，5步。</p>
<h5 id="3-2-CleanProcManager"><a href="#3-2-CleanProcManager" class="headerlink" title="3.2 CleanProcManager"></a>3.2 CleanProcManager</h5><p>CleanProcManager主要是提供接口供设置应用使用，设置可以一键kill非白名单后台应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CleanProcManager.java</span></span><br><span class="line"><span class="comment">// kill非白名单应用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBackgroundProcessByWhiteList</span><span class="params">(List&lt;String&gt; whiteList)</span> </span>&#123;</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;killBackgroundProcessByWhiteList&quot;</span>);</span><br><span class="line">        MemoryInfo beforeInfo = <span class="keyword">new</span> MemoryInfo();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAms.getMemoryInfo(beforeInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;getMemoryInfo exception=&quot;</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;RecentTaskInfo&gt; runningAppList = filterAppInfoByWhiteList(getRecentTask(), whiteList);</span><br><span class="line">        <span class="keyword">if</span> (runningAppList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RecentTaskInfo info : runningAppList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    LogUtils.logd(TAG, <span class="string">&quot;runningAppList:&quot;</span> + info.realActivity.getPackageName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//KillProcess</span></span><br><span class="line">                String packageName = info.realActivity.getPackageName();</span><br><span class="line">                <span class="keyword">if</span> (packageName.contains(<span class="string">&quot;launcher&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;killProcess:&quot;</span> + info.realActivity.getPackageName());</span><br><span class="line">                <span class="comment">// mAm.killBackgroundProcesses(info.realActivity.getPackageName());</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mAms.removeTask(info.persistentId);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                    LogUtils.loge(TAG, <span class="string">&quot;killBackgroundProcessByWhiteList ex=&quot;</span> + ex.toString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemoryInfo afterInfo = <span class="keyword">new</span> MemoryInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAms.getMemoryInfo(afterInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;getMemoryInfo exception=&quot;</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mem = afterInfo.availMem - beforeInfo.availMem;</span><br><span class="line">        String freeMem = Formatter.formatFileSize(mContext, mem);</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;FreeMem=&quot;</span> + freeMem);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CleanProcManager.java</span></span><br><span class="line"><span class="comment">// 清理应用内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteCacheByWhiteList</span><span class="params">(List&lt;String&gt; whiteList)</span> </span>&#123;</span><br><span class="line">        LogUtils.logd(TAG, <span class="string">&quot;deleteCacheByWhiteList&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (mAppDataObserver == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAppDataObserver = <span class="keyword">new</span> AppDataObserver();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ApplicationInfo&gt; installApps = getInstallApplications();</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; installApps.size(); i++) &#123;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;getInstallApplications-&gt;&quot;</span> + installApps.get(i).packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ApplicationInfo&gt; runningAppList = filterAppInfoByWhiteList(installApps, whiteList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runningAppList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ApplicationInfo info : runningAppList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    LogUtils.logd(TAG, <span class="string">&quot;runningAppList-&gt;&quot;</span> + info.processName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (info.packageName.contains(<span class="string">&quot;launcher&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;deleteApplicationCacheFiles-&gt;&quot;</span> + info.processName);</span><br><span class="line">                mPm.deleteApplicationCacheFiles(info.processName, mAppDataObserver);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-DeviceStorageMonitor"><a href="#3-3-DeviceStorageMonitor" class="headerlink" title="3.3 DeviceStorageMonitor"></a>3.3 DeviceStorageMonitor</h5><p>在DeviceStorageMonitor主要是判断每个应用在data分区的数据大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        requestCheckDataAvailableMemorySize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkDataAvailableMemorySize(MEMORY_SIZE_FOR_400M)) &#123;</span><br><span class="line">            mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_MORE_400M);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkDataAvailableMemorySize(MEMORY_SIZE_FOR_200M)) &#123;</span><br><span class="line">                mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_MORE_200M);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkDataAvailableMemorySize(MEMORY_SIZE_FOR_100M)) &#123;</span><br><span class="line">                    mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_MORE_100M);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mStorageMonitorHandler.sendEmptyMessage(MSG_DATA_MEMORY_LESS_100M);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_CHECK_DATA_MEMORY:</span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_CHECK_DATA_MEMORY&quot;</span>);</span><br><span class="line">        checkMemory();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_MORE_400M:</span><br><span class="line">        <span class="comment">// 当还大于400M，不处理</span></span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_MORE_400M&quot;</span>);</span><br><span class="line">        mLowStorageSpace = <span class="keyword">false</span>;</span><br><span class="line">   	 <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_MORE_200M:</span><br><span class="line">        <span class="comment">// 当小于200M，弹出toast</span></span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_MORE_200M&quot;</span>);</span><br><span class="line">        mLowStorageSpace = <span class="keyword">false</span>;</span><br><span class="line">        CarToast.makeText(mContext, R.string.system_basic_recovery_and_remove_app_text,</span><br><span class="line">        TOAST_SHOW_LONG_TIME).show();</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_MORE_100M:</span><br><span class="line">        <span class="comment">// 当小于100M，弹出警告框</span></span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_MORE_100M&quot;</span>);</span><br><span class="line">        mLowStorageSpace = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (has3rdApp()) &#123;</span><br><span class="line">       		showStorageWarningView();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			showMasterCleanDialog();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理log日志</span></span><br><span class="line">        clearLogFiles();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_DATA_MEMORY_LESS_100M:</span><br><span class="line">        LogUtils.logi(TAG, <span class="string">&quot;MSG_DATA_MEMORY_LESS_100M&quot;</span>);</span><br><span class="line">        <span class="comment">// 低内存标志位置位</span></span><br><span class="line">        mLowStorageSpace = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 弹出清理提示框</span></span><br><span class="line">        showMasterCleanDialog();</span><br><span class="line">       	<span class="comment">// 删除temp目录</span></span><br><span class="line">        deletePlaceHolderFile();</span><br><span class="line">        <span class="comment">// 清理log日志</span></span><br><span class="line">        clearLogFiles();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-4-ActivityProcManager"><a href="#3-4-ActivityProcManager" class="headerlink" title="3.4 ActivityProcManager"></a>3.4 ActivityProcManager</h5><p>这里着重介绍ActivityProcManager类，因为出现该问题的原因就是这个manager导致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityProcManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mMonitorHandlerThread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">        mMonitorHandlerThread.start();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(mMonitorHandlerThread.getLooper()) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 判断是否杀掉进程的逻辑</span></span><br><span class="line">                myHandleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    	<span class="comment">// 进程观察者</span></span><br><span class="line">        mProcessObserver = <span class="keyword">new</span> ProcessObserver();</span><br><span class="line">        mAm = ActivityManager.getService();</span><br><span class="line">        <span class="comment">// monitor activity change.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAm.registerProcessObserver(mProcessObserver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;cannot register activity monitoring&quot;</span> + Log.getStackTraceString(ex));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先来看一下信号输入，进程观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessObserver</span> <span class="keyword">extends</span> <span class="title">IProcessObserver</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onForegroundActivitiesChanged</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid, <span class="keyword">boolean</span> foregroundActivities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            LogUtils.logd(TAG, <span class="string">&quot;onForegroundActivitiesChanged,pid=&quot;</span> + pid + <span class="string">&quot; uid=&quot;</span> + uid</span><br><span class="line">                + <span class="string">&quot; foregroundActivities=&quot;</span> + foregroundActivities);</span><br><span class="line">        &#125;</span><br><span class="line">        String packageName = getPackageNameByPidUid(pid, uid);</span><br><span class="line">        <span class="keyword">if</span> (foregroundActivities) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="comment">// 如果是前台activity，做一个标记</span></span><br><span class="line">                mCurrentActivityInfo = <span class="keyword">new</span> LastActivityInfo(pid, uid, packageName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是忽略列表中的应用，直接返回，(应用返回home或者systemui)不做记录</span></span><br><span class="line">        <span class="keyword">if</span> (checkIsIgnorePackage(packageName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果切换界面的进程号是一样的，不做判断</span></span><br><span class="line">        <span class="keyword">if</span> (mLastActivityInfo != <span class="keyword">null</span> &amp;&amp; mLastActivityInfo.mPid == pid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="comment">// 记录上一次界面的进程号和包名</span></span><br><span class="line">            mLastActivityInfo = <span class="keyword">new</span> LastActivityInfo(pid, uid, packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            LogUtils.logd(TAG, <span class="string">&quot;mLastActivityInfo = &quot;</span> + mLastActivityInfo.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知检查activity界面</span></span><br><span class="line">        notifyForegroundActivitiesChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessDied</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyForegroundActivitiesChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LogUtils.loge(TAG, <span class="string">&quot;notifyForegroundActivitiesChanged handler is null!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check interval time</span></span><br><span class="line">    	<span class="comment">// 每10秒触发一次界面检查：ID_CHECK_RUN_LIMIT</span></span><br><span class="line">        <span class="keyword">long</span> curTime = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">if</span> ((curTime - mLastRunLimitLogicTime) &gt;= MINIMUM_RUNNING_INTERVAL) &#123;</span><br><span class="line">            mHandler.removeMessages(ID_CHECK_RUN_LIMIT);</span><br><span class="line">            mHandler.sendEmptyMessage(ID_CHECK_RUN_LIMIT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHandler.removeMessages(ID_CHECK_RUN_LIMIT);</span><br><span class="line">            <span class="keyword">long</span> delay = MINIMUM_RUNNING_INTERVAL - (curTime - mLastRunLimitLogicTime);</span><br><span class="line">            mHandler.sendEmptyMessageDelayed(ID_CHECK_RUN_LIMIT, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id = msg.what;</span><br><span class="line">        <span class="keyword">if</span> (id == ID_CHECK_RUN_LIMIT) &#123;</span><br><span class="line">            runLimitLogic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runLimitLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFeaturesEnable) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="comment">// 获取当前activity栈</span></span><br><span class="line">        List&lt;RecentTaskInfo&gt; infos = getRecentTask();</span><br><span class="line">        <span class="keyword">if</span> (infos == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (RecentTaskInfo info : infos) &#123;</span><br><span class="line">            String packageName = info.realActivity.getPackageName();</span><br><span class="line">            <span class="comment">// 校验当前activity是否是前台activity</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsCurrentActiveTask(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 校验是否是白名单应用</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsWhiteList(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 校验是否是音乐应用在后台播放</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsAudioInBackground(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 校验是否跳过两级界面</span></span><br><span class="line">            <span class="keyword">if</span> (checkIsLastRecord(packageName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果以上都是false，杀掉进程</span></span><br><span class="line">                Method method = Class.forName(ACTIVITY_MANAGER_NAME)</span><br><span class="line">                                .getMethod(FORCE_STOP_PACKAGE, String.class);</span><br><span class="line">                method.invoke((ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE), packageName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;forceStopPackage ex=&quot;</span> + Log.getStackTraceString(ex));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                LogUtils.logd(TAG, <span class="string">&quot;runLimitLogic kill packagename = &quot;</span> + packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update record time</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            mLastRunLimitLogicTime = SystemClock.elapsedRealtime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ok，我们找到问题了，<code>com.iflytek.autofly.avatar</code>不是白名单应用，界面跳过两级以上，被procmanger杀死了。</p>
<h5 id="3-5-问题解决"><a href="#3-5-问题解决" class="headerlink" title="3.5 问题解决"></a>3.5 问题解决</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在procmanager/proc_management_cfg.xml中加入应用白名单 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">proc_configs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">white_lists</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.app.launcher<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.appservice.procmanagement<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.systemui<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.gxa.app.settings<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.android.systemui<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">white_lists</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">black_lists</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>demo.test.package<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">black_lists</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">proc_configs</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="4-问题回溯"><a href="#4-问题回溯" class="headerlink" title="4.问题回溯"></a>4.问题回溯</h4><p>车机系统在基于原生AMS的oom_adj内存管理机制的基础上，另外建立了一套进程管理机制来保证车机在有限的资源中，优先级高的应用进程能够获得更多存活机会。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>kill</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理详解</title>
    <url>/2021/04/23/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h4><p><strong>1.1 定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活 中常见的中介。</p>
<p><strong>1.2 目的：</strong></p>
<ul>
<li><p>(1) 通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性；可以实现客户端和服务端解耦，方便替换真实实现的对象。（例如某项目使用了Volley网络请求，现在项目有一个特殊需求，要换成okhttp网络请求框架，使用代理模式可以很容易替换）</p>
</li>
<li><p>(2) 通过代理对象对访问进行控制；(例如在正在执行代理行为前后添加更多控制行为)</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e57ebe022ee1b88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静态代理.png"></p>
<p><strong>1.3 角色介绍：</strong></p>
<ul>
<li>抽象角色：指代理角色和真实角色对外提供的公共方法，一般为一个接口 </li>
<li>真实角色：需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业 务逻辑在此。 </li>
<li>代理角色：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。将统一的流程控制都放到代理角色中处理！</li>
</ul>
<p><strong>1.4 使用样例代码：</strong></p>
<p>以下是代理接口，该接口定义保存订单功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以下是真实实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下单成功，订单号： 66666666&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">66666666</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以下是代理类，代理持有真实实现类的对象，可以流程进行控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyOrder</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真实的订单服务</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService = <span class="keyword">new</span> OutOrderServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOrderTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在真实操作之前，还可以对订单进行控制，演示上叙目的2</span></span><br><span class="line">        <span class="comment">// 例如：可以在用户下单之后，给订单打上标签</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开始海外下订单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setOrderTag();</span><br><span class="line">        <span class="keyword">return</span> orderService.saveOrder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h4><p><strong>2.1 定义：</strong>通过反射机制，在运行时创建代理类</p>
<p><strong>2.2 使用：</strong></p>
<p>创建代理类，持有真实实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(OrderService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke --&gt;&quot;</span>);</span><br><span class="line">        method.invoke(service, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke --&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用动态代理调用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建真实实现类</span></span><br><span class="line">    OrderService service = <span class="keyword">new</span> OutOrderServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将真实实现类交给ProxyHandler</span></span><br><span class="line">    OrderService proxy = (OrderService)Proxy.newProxyInstance(</span><br><span class="line">        	service.getClass().getClassLoader(),</span><br><span class="line">            service.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> ProxyHandler(service));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过代理调用到真实实现的方法</span></span><br><span class="line">    proxy.saveOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>2.3 动态代理原理：</strong></p>
<ul>
<li>通过用户实现的InvocationHandler接口，获得真实处理事件的对象（相当于Proxy加了个传入真实实现对象监听）；</li>
<li>通过newProxyInstance传入的ClassLoader和一组Interface来创建动态代理类；</li>
<li>通过反射获取动态代理类的构造方法，其构造函数的参数就是用户实现的InvocationHandler接口类；</li>
<li>通过构造函数创建动态代理类实例。</li>
</ul>
<p>==============================<strong>生成动态代理类</strong>=============================================</p>
<p>下面我们详细来看一下Proxy是如何生成代理对象的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从classloader中遍历接口，并且调用generateProxy()生成Class对象</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指定的InvocationHandler来调用生成class对象的构造方法</span></span><br><span class="line">    <span class="comment">// 参数constructorParams就是指定的InvocationHandler，也就是传入自定义实现InvocationHandler的类</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来看一下是如何生成这个Class对象的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 接口数不能超过65535，即单个dex里面的方法数不能超过65535个</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定接口的代理类已经存在于缓存中，则不用新创建，直接从缓存中取即可；</span></span><br><span class="line">    <span class="comment">// 如果缓存中没有指定代理对象，则通过ProxyClassFactory来创建一个代理对象。</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面来看一下<strong>ProxyClassFactory</strong>是如何创建代理对象的。(在Proxy中有一个ProxyClassFactory静态内部类)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//校验类加载器中加载的接口是否是定义的接口</span></span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验加载的类是否是接口</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验接口是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// 新生成类的包名</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录非公共代理接口的包，以便在同一个包中定义代理类。验证所有非公共代理接口是否在同一个包中。</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if no non-public proxy interfaces, use the default package.</span></span><br><span class="line">        proxyPkg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 收集接口中所有方法</span></span><br><span class="line">        List&lt;Method&gt; methods = getMethods(interfaces);</span><br><span class="line">        Collections.sort(methods, ORDER_BY_SIGNATURE_AND_SUBTYPE);</span><br><span class="line">        validateReturnTypes(methods);</span><br><span class="line">        List&lt;Class&lt;?&gt;[]&gt; exceptions = deduplicateAndGetExceptions(methods);</span><br><span class="line"></span><br><span class="line">        Method[] methodsArray = methods.toArray(<span class="keyword">new</span> Method[methods.size()]);</span><br><span class="line">        Class&lt;?&gt;[][] exceptionsArray = exceptions.toArray(<span class="keyword">new</span> Class&lt;?&gt;[exceptions.size()][]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 敲定生成类的类名</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用generateProxy()生成class类</span></span><br><span class="line">        <span class="keyword">return</span> generateProxy(proxyName, interfaces, loader, methodsArray,</span><br><span class="line">                exceptionsArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后通过调用native的generateProxy()方法生成class类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; generateProxy(String name, Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                             ClassLoader loader, Method[] methods,</span><br><span class="line">                                             Class&lt;?&gt;[][] exceptions);</span><br><span class="line"><span class="comment">// END Android-changed: How proxies are generated.</span></span><br></pre></td></tr></table></figure>


<p>在Android中生成class类是在navite中生成的。在java中最终是调用ProxyGenerator.generateProxyClass()生成byte数组，最后调用defineClass0()将byte数组转化成class类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="comment">// 真正用来生成代理类字节码文件的方法在这里</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">        <span class="comment">// 保存代理类的字节码文件</span></span><br><span class="line">        <span class="keyword">if</span>(saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        <span class="keyword">if</span>(var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar), <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                            Files.createDirectories(var3, <span class="keyword">new</span> FileAttribute[<span class="number">0</span>]);</span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + <span class="string">&quot;.class&quot;</span>, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;I/O exception saving generated file: &quot;</span> + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>生成代理类字节码文件的generateClassFile方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">//下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中(proxyMethod)</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">//获得接口中所有方法并添加到代理方法中</span></span><br><span class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">        List var12;</span><br><span class="line">        <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List)var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var15;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成代理类的构造函数</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line">            var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List)var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                    <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>, <span class="number">10</span>));</span><br><span class="line">                    <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;unexpected I/O Exception&quot;</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.methods.size() &gt; <span class="string">&#x27;\uffff&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method limit exceeded&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.fields.size() &gt; <span class="string">&#x27;\uffff&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;field limit exceeded&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(<span class="string">&quot;java/lang/reflect/Proxy&quot;</span>);</span><br><span class="line">            var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line">            ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                var14.writeShort(<span class="number">49</span>);</span><br><span class="line">                <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">&quot;java/lang/reflect/Proxy&quot;</span>));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">                Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">                <span class="keyword">int</span> var18 = var17.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;unexpected I/O Exception&quot;</span>, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用generateClassFile()之后，就会生成class类的byte数组。</p>
<p><strong>为了验证这个结论</strong>，写一个demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String name = OrderService.class.getName() + <span class="string">&quot;$Proxy0&quot;</span>;</span><br><span class="line">        <span class="comment">//生成代理指定接口的Class数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = ProxyGenerator.generateProxyClass(name, <span class="keyword">new</span> Class[]&#123;OrderService.class&#125;);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\gz04766\\Desktop\\&quot;</span> + name + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们分析清楚了Proxy是如何生成代理class类的。</p>
<p>================================<strong>如何完成动态调用</strong>========================================</p>
<p>当通过反射调用构造方法的时候，将用户实现的InvocationHandler传给Proxy。在生成的类中，通过反射拿到接口定义的Method方法。最后通过父类的中的InvocationHandler的invoke方法，最终调入到自定义的InvocationHandler中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span>$<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderService$Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过父类的中的InvocationHandler的invoke方法，最终调入到自定义的InvocationHandler中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">saveOrder</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过反射拿到接口定义的Method方法</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.gac.oj.OrderService&quot;</span>).getMethod(<span class="string">&quot;saveOrder&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>编译集成ffmpeg</title>
    <url>/2021/07/12/%E7%BC%96%E8%AF%91%E9%9B%86%E6%88%90ffmpeg/</url>
    <content><![CDATA[<h4 id="1-下载ffmpeg"><a href="#1-下载ffmpeg" class="headerlink" title="1.下载ffmpeg"></a>1.下载ffmpeg</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://www.ffmpeg.org/releases/ffmpeg-4.0.2.tar.bz2</span><br><span class="line">tar -xjf ffmpeg-4.0.2.tar.bz2</span><br></pre></td></tr></table></figure>


<h4 id="2-编译选项说明"><a href="#2-编译选项说明" class="headerlink" title="2.编译选项说明"></a>2.编译选项说明</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存选项到本地</span></span><br><span class="line">./configure --help -&gt; ffmpeg_help.txt</span><br><span class="line"></span><br><span class="line">Help options: </span><br><span class="line">–help print this message # 帮助选项 </span><br><span class="line">–quiet Suppress showing informative output # 信息输出显示 </span><br><span class="line">–list-decoders show all available decoders # 可用解码器 </span><br><span class="line">–list-encoders show all available encoders # 可用编码器 </span><br><span class="line">–list-hwaccels show all available hardware accelerators # 可用硬件编解码器 </span><br><span class="line">–list-demuxers show all available demuxers # 可用解复用 </span><br><span class="line">–list-muxers show all available muxers # 可用复用器 </span><br><span class="line">–list-parsers show all available parsers # 可用解析器 </span><br><span class="line">–list-protocols show all available protocols # 可用协议 </span><br><span class="line">–list-bsfs show all available bitstream filters # 可用比特流过滤器 </span><br><span class="line">–list-indevs show all available input devices # 可用输入设备 </span><br><span class="line">–list-outdevs show all available output devices # 可用输出设备 </span><br><span class="line">–list-filters show all available filters # 可用过滤器 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">一般选项</span> </span><br><span class="line">Standard options: </span><br><span class="line">–logfile=FILE log tests and output to FILE [config.log] # 生成指定的log文件 </span><br><span class="line">–disable-logging do not log configure debug information # 禁止调试信息 </span><br><span class="line">–fatal-warnings fail if any configure warning is generated # 任何警告则失败 </span><br><span class="line">–prefix=PREFIX install in PREFIX [$prefix_default] # 安装目录 </span><br><span class="line">–bindir=DIR install binaries in DIR [PREFIX/bin] # exe和dll安装目录 </span><br><span class="line">–datadir=DIR install data files in DIR [PREFIX/share/ffmpeg] # 数据安装目录 </span><br><span class="line">–docdir=DIR install documentation in DIR [PREFIX/share/doc/ffmpeg]# 文档安装目录 –libdir=DIR install libs in DIR [PREFIX/lib] # 静态库安装目录 </span><br><span class="line">–shlibdir=DIR install shared libs in DIR [LIBDIR] # 共享库安装目录 </span><br><span class="line">–incdir=DIR install includes in DIR [PREFIX/include] # 头文件安装目录 </span><br><span class="line">–mandir=DIR install man page in DIR [PREFIX/share/man] # 帮助文档安装目录 </span><br><span class="line">–pkgconfigdir=DIR install pkg-config files in DIR [LIBDIR/pkgconfig] # pkg- config安装目录 </span><br><span class="line">–enable-rpath use rpath to allow installing libraries in paths # 调用程序所用目录 not part of the dynamic linker search path </span><br><span class="line">use rpath when linking programs (USE WITH CARE) </span><br><span class="line">–install-name-dir=DIR Darwin directory name for installed targets </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 许可选项</span> </span><br><span class="line">Licensing options: </span><br><span class="line">–enable-gpl allow use of GPL code, the resulting libs # 允许使用GPL </span><br><span class="line">and binaries will be under GPL [no] </span><br><span class="line">–enable-version3 upgrade (L)GPL to version 3 [no] # 更新GPL版本 </span><br><span class="line">–enable-nonfree allow use of nonfree code, the resulting libs # 允许使用非免费程序 and binaries will be unredistributable [no] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置选项</span> </span><br><span class="line">Configuration options: </span><br><span class="line">–disable-static do not build static libraries [no] # 禁止静态库 </span><br><span class="line">–enable-shared build shared libraries [no] # 启用共享库 </span><br><span class="line">–enable-small optimize for size instead of speed # 启用最小尺寸而非速度</span><br><span class="line">–disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary) # 禁用实时的CPU效率检测 </span><br><span class="line">–enable-gray enable full grayscale support (slower color) # 启用灰度(颜色、空间转换) –disable-swscale-alpha disable alpha channel support in swscale # 禁用swscale中的 透明度 </span><br><span class="line">–disable-all disable building components, libraries and programs # 禁用所有，包括组 件、库、程序 </span><br><span class="line">–enable-raise-major increase major version numbers in sonames [no] # 提升版本号 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 项目选项</span> </span><br><span class="line">Program options: </span><br><span class="line">–disable-programs do not build command line programs # 禁止生成所有exe </span><br><span class="line">–disable-ffmpeg disable ffmpeg build # 禁止生成ffmpeg.exe </span><br><span class="line">–disable-ffplay disable ffplay build # 禁止生成ffplay.exe </span><br><span class="line">–disable-ffprobe disable ffprobe build # 禁止生成ffprobe.exe </span><br><span class="line">–disable-ffserver disable ffserver build # 禁止生成ffserver.exe </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文档选项</span> </span><br><span class="line">Documentation options: </span><br><span class="line">–disable-doc do not build documentation # 禁止生成doc文件 </span><br><span class="line">–disable-htmlpages do not build HTML documentation pages # 禁止生成HTML文档页 </span><br><span class="line">–disable-manpages do not build man documentation pages # 禁止生成帮助文档页 </span><br><span class="line">–disable-podpages do not build POD documentation pages # 禁止生成POD文档页 </span><br><span class="line">–disable-txtpages do not build text documentation pages # 禁止生成txt文档页 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 组件选项</span> </span><br><span class="line">Component options: </span><br><span class="line">–disable-avdevice disable libavdevice build # 禁止libavdevice构造 </span><br><span class="line">–disable-avcodec disable libavcodec build # 禁止libavcodec构造 </span><br><span class="line">–disable-avformat disable libavformat build # 禁止libavformat构造 </span><br><span class="line">–disable-swresample disable libswresample build # 禁止libswresample构造 </span><br><span class="line">–disable-swscale disable libswscale build # 禁止libswscale构造 </span><br><span class="line">–disable-postproc disable libpostproc build # 禁止libpostproc构造 </span><br><span class="line">–disable-avfilter disable libavfilter build # 禁止libavfilter构造 </span><br><span class="line">–enable-avresample enable libavresample build [no] # 允许libavresample构造 </span><br><span class="line">–disable-pthreads disable pthreads [autodetect] # 禁止pthread构造 </span><br><span class="line">–disable-w32threads disable Win32 threads [autodetect] # 禁止使用win32线程 </span><br><span class="line">–disable-os2threads disable OS/2 threads [autodetect] # 禁止使用OS/2线程 </span><br><span class="line">–disable-network disable network support [no] # 禁止网络支持 </span><br><span class="line">–disable-dct disable DCT code # 禁止DCT代码 </span><br><span class="line">–disable-dwt disable DWT code # 禁止DWT代码 </span><br><span class="line">–disable-error-resilience disable error resilience code # 禁止纠错 </span><br><span class="line">–disable-lsp disable LSP code # 禁止行同步脉冲 </span><br><span class="line">–disable-lzo disable LZO decoder code # 禁止LZO压缩编码 </span><br><span class="line">–disable-mdct disable MDCT code # 禁止修正离散余弦变换 </span><br><span class="line">–disable-rdft disable RDFT code # 禁止实数离散傅里叶变换 </span><br><span class="line">–disable-fft disable FFT code # 禁止快速傅氏变换算法 </span><br><span class="line">–disable-faan disable floating point AAN (I)DCT code # 禁止AAN DCT变换 </span><br><span class="line">–disable-pixelutils disable pixel utils in libavutil # 禁用avutil中的像素单元 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单个组件选项</span> </span><br><span class="line">Individual component options: </span><br><span class="line">–disable-everything disable all components listed below # 禁用下面已列出的全部组件 –disable-encoder=NAME disable encoder NAME # 禁用指定的编码器 </span><br><span class="line">–enable-encoder=NAME enable encoder NAME # 启用指定的编码器 </span><br><span class="line">–disable-encoders disable all encoders # 禁用所有的编码器 </span><br><span class="line">–disable-decoder=NAME disable decoder NAME # 禁用指定的解码器 </span><br><span class="line">–enable-decoder=NAME enable decoder NAME # 启用指定的解码器</span><br><span class="line">–disable-decoders disable all decoders # 禁用所有的解码器 </span><br><span class="line">–disable-hwaccel=NAME disable hwaccel NAME # 禁用指定的硬件加速 </span><br><span class="line">–enable-hwaccel=NAME enable hwaccel NAME # 启用指定的硬件加速 </span><br><span class="line">–disable-hwaccels disable all hwaccels # 禁用全部的硬件加速 </span><br><span class="line">–disable-muxer=NAME disable muxer NAME # 禁用指定的混合器 </span><br><span class="line">–enable-muxer=NAME enable muxer NAME # 启用指定的混合器 </span><br><span class="line">–disable-muxers disable all muxers # 禁用所有的混合器 </span><br><span class="line">–disable-demuxer=NAME disable demuxer NAME # 禁用指定的解复用器 </span><br><span class="line">–enable-demuxer=NAME enable demuxer NAME # 启用指定的解复用器 </span><br><span class="line">–disable-demuxers disable all demuxers # 禁用所有的解复用器 </span><br><span class="line">–enable-parser=NAME enable parser NAME # 启用指定的分析器 </span><br><span class="line">–disable-parser=NAME disable parser NAME # 禁用指定的分析器 </span><br><span class="line">–disable-parsers disable all parsers # 禁用所有的分析器 </span><br><span class="line">–enable-bsf=NAME enable bitstream filter NAME # 启用指定的流过滤器 </span><br><span class="line">–disable-bsf=NAME disable bitstream filter NAME # 禁用指定的流过滤器 </span><br><span class="line">–disable-bsfs disable all bitstream filters # 禁用所有的流过滤器 </span><br><span class="line">–enable-protocol=NAME enable protocol NAME # 启用指定的协议 </span><br><span class="line">–disable-protocol=NAME disable protocol NAME # 禁用指定的协议 </span><br><span class="line">–disable-protocols disable all protocols # 禁用所有的协议 </span><br><span class="line">–enable-indev=NAME enable input device NAME # 启用指定的输入设备 </span><br><span class="line">–disable-indev=NAME disable input device NAME # 禁用指定的输入设备 </span><br><span class="line">–disable-indevs disable input devices # 禁用输入设备 </span><br><span class="line">–enable-outdev=NAME enable output device NAME # 启用指定的输出设备 </span><br><span class="line">–disable-outdev=NAME disable output device NAME# 禁用指定的输出设备 </span><br><span class="line">–disable-outdevs disable output devices # 禁用输出设备 </span><br><span class="line">–disable-devices disable all devices # 禁用所有设备 </span><br><span class="line">–enable-filter=NAME enable filter NAME # 启用指定的过滤器 </span><br><span class="line">–disable-filter=NAME disable filter NAME # 禁用指定的过滤器 </span><br><span class="line">–disable-filters disable all filters # 禁用所有的过滤器 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加依赖库支持</span> </span><br><span class="line">External library support: </span><br><span class="line">Using any of the following switches will allow FFmpeg to link to the corresponding external library. All the components depending on that library will become enabled, if all their other dependencies are met and they are not explicitly disabled. E.g. –enable-libwavpack will enable linking to libwavpack and allow the libwavpack encoder to be built, unless it is specifically disabled with  –disable-encoder=libwavpack.</span><br><span class="line">Note that only the system libraries are auto-detected. All the other external libraries must be explicitly enabled. </span><br><span class="line">Also note that the following help text describes the purpose of the libraries themselves, not all their features will necessarily be usable by FFmpeg. </span><br><span class="line">–enable-avisynth enable reading of AviSynth script files [no] # 启用读取AVISynth脚 本文件 </span><br><span class="line">–disable-bzlib disable bzlib [autodetect] # 启用bzlib </span><br><span class="line">–enable-chromaprint enable audio fingerprinting with chromaprint [no] # 启用音频指 纹技术 </span><br><span class="line">–enable-frei0r enable frei0r video filtering [no] # 启用frei0r视频筛选 </span><br><span class="line">–enable-gcrypt enable gcrypt, needed for rtmp(t)e support # 启用加密 </span><br><span class="line">if openssl, librtmp or gmp is not used [no] </span><br><span class="line">–enable-gmp enable gmp, needed for rtmp(t)e support # 启用gmp </span><br><span class="line">if openssl or librtmp is not used [no] </span><br><span class="line">–enable-gnutls enable gnutls, needed for https support # 启用gnutls </span><br><span class="line">if openssl is not used [no]</span><br><span class="line">–disable-iconv disable iconv [autodetect] # 禁用iconv </span><br><span class="line">–enable-jni enable JNI support [no] # 启用JNI支持 </span><br><span class="line">–enable-ladspa enable LADSPA audio filtering [no] # 启用LADSPA音频过滤 </span><br><span class="line">–enable-libass enable libass subtitles rendering, # 启用libass </span><br><span class="line">needed for subtitles and ass filter [no] </span><br><span class="line">–enable-libbluray enable BluRay reading using libbluray [no] # 启用libbluray </span><br><span class="line">–enable-libbs2b enable bs2b DSP library [no] # 启用bs2b DSP库 </span><br><span class="line">–enable-libcaca enable textual display using libcaca [no] # 启用libcaca用于文本显示 –enable-libcelt enable CELT decoding via libcelt [no] # 启用CEKT解码 </span><br><span class="line">–enable-libcdio enable audio CD grabbing with libcdio [no] # 通过libcdio启用音频CD –enable-libdc1394 enable IIDC-1394 grabbing using libdc1394 # 启用libdc1394 </span><br><span class="line">and libraw1394 [no] </span><br><span class="line">–enable-libfdk-aac enable AAC de/encoding via libfdk-aac [no] # 启用libfdk-aac解 码/编码 </span><br><span class="line">–enable-libflite enable flite (voice synthesis) support via libflite [no] # 启用 libflite </span><br><span class="line">–enable-libfontconfig enable libfontconfig, useful for drawtext filter [no] # 启 用libfontconfig </span><br><span class="line">–enable-libfreetype enable libfreetype, needed for drawtext filter [no]# 启用 libfreetype </span><br><span class="line">–enable-libfribidi enable libfribidi, improves drawtext filter [no] # 启用 libfribidi，改善绘画过滤 </span><br><span class="line">–enable-libgme enable Game Music Emu via libgme [no] # 启用libgme </span><br><span class="line">–enable-libgsm enable GSM de/encoding via libgsm [no] # 启用libgsm做GSM编/解码 </span><br><span class="line">–enable-libiec61883 enable iec61883 via libiec61883 [no] # 启用libiec61883 </span><br><span class="line">–enable-libilbc enable iLBC de/encoding via libilbc [no] # 启用libilbc做iLBC编/解码 –enable-libkvazaar enable HEVC encoding via libkvazaar [no] # 启用libkvazaar做HEVC 编码 </span><br><span class="line">–enable-libmodplug enable ModPlug via libmodplug [no] # 启用ModPlug通过libmodplug –enable-libmp3lame enable MP3 encoding via libmp3lame [no] # 启用MP3编码通过 </span><br><span class="line">libmp3lame </span><br><span class="line">–enable-libnut enable NUT (de)muxing via libnut, # 启用NUT解复用通过libnut </span><br><span class="line">native (de)muxer exists [no] </span><br><span class="line">–enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no] # 启用ARN-NB解/编码 </span><br><span class="line">–enable-libopencore-amrwb enable AMR-WB decoding via libopencore-amrwb [no] # 启 用ARM-WB解码 </span><br><span class="line">–enable-libopencv enable video filtering via libopencv [no] # 启用视频过滤通过 opencv </span><br><span class="line">–enable-libopenh264 enable H.264 encoding via OpenH264 [no] # 启用H.264编码 </span><br><span class="line">–enable-libopenjpeg enable JPEG 2000 de/encoding via OpenJPEG [no] # 启用JPEG编解 码 </span><br><span class="line">–enable-libopenmpt enable decoding tracked files via libopenmpt [no] # 启用解码文件 通过libopenmpt </span><br><span class="line">–enable-libopus enable Opus de/encoding via libopus [no] # 启用Oplus编解码 </span><br><span class="line">–enable-libpulse enable Pulseaudio input via libpulse [no] # 启用Pulse输入 </span><br><span class="line">–enable-librubberband enable rubberband needed for rubberband filter [no] # 启用 rubberband </span><br><span class="line">–enable-librtmp enable RTMP[E] support via librtmp [no] # 启用RTMP支持通过librtmp –enable-libschroedinger enable Dirac de/encoding via libschroedinger [no] # 启用 Dirac编解码通过libschroedinger </span><br><span class="line">–enable-libshine enable fixed-point MP3 encoding via libshine [no] # 启用libshine 固定MP3点 </span><br><span class="line">–enable-libsmbclient enable Samba protocol via libsmbclient [no] # 启用Samba协议 –enable-libsnappy enable Snappy compression, needed for hap encoding [no] # 启用 Snappy压缩 </span><br><span class="line">–enable-libsoxr enable Include libsoxr resampling [no] # 启用libsoxr采样 </span><br><span class="line">–enable-libspeex enable Speex de/encoding via libspeex [no] # 启用Speex编解码</span><br><span class="line">–enable-libssh enable SFTP protocol via libssh [no] # 启用SFTP协议 </span><br><span class="line">–enable-libtesseract enable Tesseract, needed for ocr filter [no] # 启用Tesseract –enable-libtheora enable Theora encoding via libtheora [no] # 启用Theora编码 </span><br><span class="line">–enable-libtwolame enable MP2 encoding via libtwolame [no] # 启用MP2编码 </span><br><span class="line">–enable-libv4l2 enable libv4l2/v4l-utils [no] # 启用libv412 </span><br><span class="line">–enable-libvidstab enable video stabilization using vid.stab [no] # 启用 libvidstab </span><br><span class="line">–enable-libvo-amrwbenc enable AMR-WB encoding via libvo-amrwbenc [no] # 启用AMR- WB </span><br><span class="line">–enable-libvorbis enable Vorbis en/decoding via libvorbis, # 启用Vorbis编解码 native implementation exists [no] </span><br><span class="line">–enable-libvpx enable VP8 and VP9 de/encoding via libvpx [no] # 启用VP8/VP9编解码 –enable-libwavpack enable wavpack encoding via libwavpack [no] # 启用wavpack编码 –enable-libwebp enable WebP encoding via libwebp [no] # 启用WbebP编码 </span><br><span class="line">–enable-libx264 enable H.264 encoding via x264 [no] # 启用H.264编码 </span><br><span class="line">–enable-libx265 enable HEVC encoding via x265 [no] # 启用HEVC编码 </span><br><span class="line">–enable-libxavs enable AVS encoding via xavs [no] # 启用AVS编码 </span><br><span class="line">–enable-libxcb enable X11 grabbing using XCB [autodetect] # 启用X11 </span><br><span class="line">–enable-libxcb-shm enable X11 grabbing shm communication [autodetect] # 启用X11 –enable-libxcb-xfixes enable X11 grabbing mouse rendering [autodetect] # 启用X11 –enable-libxcb-shape enable X11 grabbing shape rendering [autodetect] # 启用X11 –enable-libxvid enable Xvid encoding via xvidcore, # 启用Xvid编码 </span><br><span class="line">native MPEG-4/Xvid encoder exists [no] </span><br><span class="line">–enable-libzimg enable z.lib, needed for zscale filter [no] # 启用z.lib </span><br><span class="line">–enable-libzmq enable message passing via libzmq [no] # 启用消息传递通过libzmq </span><br><span class="line">–enable-libzvbi enable teletext support via libzvbi [no] # 启用文本支持 </span><br><span class="line">–disable-lzma disable lzma [autodetect] # 禁用lzma </span><br><span class="line">–enable-decklink enable Blackmagic DeckLink I/O support [no] # 启用阻塞IO支持 </span><br><span class="line">–enable-mediacodec enable Android MediaCodec support [no] # 启用安卓MediaCodec支持 –enable-netcdf enable NetCDF, needed for sofalizer filter [no] # 启用NetCDF </span><br><span class="line">–enable-openal enable OpenAL 1.1 capture support [no] # 启用OpenAL1.1采集支持 </span><br><span class="line">–enable-opencl enable OpenCL code # 启用OpenCL代码 </span><br><span class="line">–enable-opengl enable OpenGL rendering [no] # 启用OpenGL </span><br><span class="line">–enable-openssl enable openssl, needed for https support # 启用openssl，需支持https if gnutls is not used [no] </span><br><span class="line">–disable-schannel disable SChannel SSP, needed for TLS support on # 启用SSP Windows if openssl and gnutls are not used [autodetect] </span><br><span class="line">–disable-sdl2 disable sdl2 [autodetect] # 禁用sdl2 </span><br><span class="line">–disable-securetransport disable Secure Transport, needed for TLS support # 禁用安 全传输 </span><br><span class="line">on OSX if openssl and gnutls are not used [autodetect] </span><br><span class="line">–disable-xlib disable xlib [autodetect] # 禁用xlib </span><br><span class="line">–disable-zlib disable zlib [autodetect] # 禁用zlib </span><br><span class="line">The following libraries provide various hardware acceleration features: </span><br><span class="line">–disable-audiotoolbox disable Apple AudioToolbox code [autodetect] # 禁用苹果音频工 具箱 </span><br><span class="line">–disable-cuda disable dynamically linked Nvidia CUDA code [autodetect] # 禁用CUDA 编程 </span><br><span class="line">–disable-cuvid disable Nvidia CUVID support [autodetect] # 启用Nvidia CUVID </span><br><span class="line">–disable-d3d11va disable Microsoft Direct3D 11 video acceleration code </span><br><span class="line">[autodetect] # 禁用微软Direct3D 11视频加速 </span><br><span class="line">–disable-dxva2 disable Microsoft DirectX 9 video acceleration code [autodetect] # 禁用微软錎irectX视频加速 </span><br><span class="line">–enable-libmfx enable Intel MediaSDK (AKA Quick Sync Video) code via libmfx [no] # 启用Intel音频SDk </span><br><span class="line">–enable-libnpp enable Nvidia Performance Primitives-based code [no] # 启用Nvidia性 能代码</span><br><span class="line">–enable-mmal enable Broadcom Multi-Media Abstraction Layer (Raspberry Pi) via MMAL [no] # 启用网络多媒体结构层 </span><br><span class="line">–disable-nvenc disable Nvidia video encoding code [autodetect] # 禁用Nvidia视频编码 –enable-omx enable OpenMAX IL code [no] # 启用OpenMAX IL代码 </span><br><span class="line">–enable-omx-rpi enable OpenMAX IL code for Raspberry Pi [no] # 启用OpenMAX IL代码 –disable-vaapi disable Video Acceleration API (mainly Unix/Intel) code </span><br><span class="line">[autodetect] # 禁用视频加速API </span><br><span class="line">–disable-vda disable Apple Video Decode Acceleration code [autodetect] # 禁用苹果 视频解码加速代码 </span><br><span class="line">–disable-vdpau disable Nvidia Video Decode and Presentation API for Unix code </span><br><span class="line">[autodetect] # 禁用Nvidia视频编码和表达API </span><br><span class="line">–disable-videotoolbox disable VideoToolbox code [autodetect] # 禁用视频工具箱代码 编译工具选项 </span><br><span class="line">Toolchain options: </span><br><span class="line">–arch=ARCH select architecture [$arch] # 选择架构 </span><br><span class="line">–cpu=CPU select the minimum required CPU (affects instruction selection, may crash on older CPUs) # 选择CPU </span><br><span class="line">–cross-prefix=PREFIX use PREFIX for compilation tools [$cross_prefix] # 交叉编译工 具目录 </span><br><span class="line">–progs-suffix=SUFFIX program name suffix [] # 程序后缀名 </span><br><span class="line">–enable-cross-compile assume a cross-compiler is used # 启用交叉编译 </span><br><span class="line">–sysroot=PATH root of cross-build tree # 交叉编译根目录 </span><br><span class="line">–sysinclude=PATH location of cross-build system headers # 交叉编译头文件目录 </span><br><span class="line">–target-os=OS compiler targets OS [$target_os] # 交叉编译的目标系统 </span><br><span class="line">–target-exec=CMD command to run executables on target # 交叉编译启动程序命令 </span><br><span class="line">–target-path=DIR path to view of build directory on target # 交叉编译的安装目录 </span><br><span class="line">–target-samples=DIR path to samples directory on target # 交叉编译samples存放目录 –tempprefix=PATH force fixed dir/prefix instead of mktemp for checks # 交叉编译的 temp目录 </span><br><span class="line">–toolchain=NAME set tool defaults according to NAME # 编译工具 </span><br><span class="line">–nm=NM use nm tool NM [$nm_default] </span><br><span class="line">–ar=AR use archive tool AR [$ar_default] </span><br><span class="line">–as=AS use assembler AS [$as_default] </span><br><span class="line">–ln_s=LN_S use symbolic link tool LN_S [$ln_s_default] </span><br><span class="line">–strip=STRIP use strip tool STRIP [$strip_default] </span><br><span class="line">–windres=WINDRES use windows resource compiler WINDRES [$windre_default] </span><br><span class="line">–yasmexe=EXE use yasm-compatible assembler EXE [$yasmexe_default]# 使用yasm编译 –cc=CC use C compiler CC [$cc_default] # 使用gcc编译 </span><br><span class="line">–cxx=CXX use C compiler CXX [$cxx_default] # 使用g++编译 </span><br><span class="line">–objcc=OCC use ObjC compiler OCC [$cc_default] # 使用object C编译工具occ编译 </span><br><span class="line">–dep-cc=DEPCC use dependency generator DEPCC [$cc_default] # 使用依赖生成DEPCC </span><br><span class="line">–ld=LD use linker LD [$ld_default] # 使用连接LD </span><br><span class="line">–pkg-config=PKGCONFIG use pkg-config tool PKGCONFIG [$pkg_config_default] # 使用 pkg-config工具 </span><br><span class="line">–pkg-config-flags=FLAGS pass additional flags to pkgconf [] # 传递额外标志到pkg- config </span><br><span class="line">–ranlib=RANLIB use ranlib RANLIB [$ranlib_default] # 使用RANLIB </span><br><span class="line">–doxygen=DOXYGEN use DOXYGEN to generate API doc [$doxygen_default] # 生成doxygen 文档 </span><br><span class="line">–host-cc=HOSTCC use host C compiler HOSTCC # 使用HOST c编译 </span><br><span class="line">–host-cflags=HCFLAGS use HCFLAGS when compiling for host # 使用HCFLAGS </span><br><span class="line">–host-cppflags=HCPPFLAGS use HCPPFLAGS when compiling for host # 使用HCPPFLAGSS –host-ld=HOSTLD use host linker HOSTLD # 使用host连接器 </span><br><span class="line">–host-ldflags=HLDFLAGS use HLDFLAGS when linking for host # 使用HLDFLAGS </span><br><span class="line">–host-libs=HLIBS use libs HLIBS when linking for host # 使用HLIBS </span><br><span class="line">–host-os=OS compiler host OS [$target_os] # 编译主机系统 </span><br><span class="line">–extra-cflags=ECFLAGS add ECFLAGS to CFLAGS [$CFLAGS] # 添加ECFLAGS到CFLAGS</span><br><span class="line">–extra-cxxflags=ECFLAGS add ECFLAGS to CXXFLAGS [$CXXFLAGS] # 添加ECFLAGS到 CXXFLAGS </span><br><span class="line">–extra-objcflags=FLAGS add FLAGS to OBJCFLAGS [$CFLAGS] # 添加FLAGS到OBJCFLAGS –extra-ldflags=ELDFLAGS add ELDFLAGS to LDFLAGS [\$LDFLAGS] # 添加ELDFLAGS到 LDFLAGS </span><br><span class="line">–extra-ldexeflags=ELDFLAGS add ELDFLAGS to LDEXEFLAGS [\$LDEXEFLAGS] # 添加 ELDFLAGS到LDEXEFLAGS </span><br><span class="line">–extra-ldlibflags=ELDFLAGS add ELDFLAGS to LDLIBFLAGS [\$LDLIBFLAGS] # 添加 ELDFLAGS到LDLIBFLAGS </span><br><span class="line">–extra-libs=ELIBS add ELIBS [\$ELIBS] # 添加ELIBS </span><br><span class="line">–extra-version=STRING version string suffix [] # 添加版本 </span><br><span class="line">–optflags=OPTFLAGS override optimization-related compiler flags # 重写优化编译标志 –build-suffix=SUFFIX library name suffix [] # 添加库名字路径 </span><br><span class="line">–enable-pic build position-independent code # 添加位置独立代码 </span><br><span class="line">–enable-thumb compile for Thumb instruction set # 编译錞humb指令集 </span><br><span class="line">–enable-lto use link-time optimization # 使用连接时优化 </span><br><span class="line">–env=”ENV=override” override the environment variables # 重写环境变量 </span><br><span class="line">高级选项 </span><br><span class="line">Advanced options (experts only): </span><br><span class="line">–malloc-prefix=PREFIX prefix malloc and related names with PREFIX # 申请路径 </span><br><span class="line">–custom-allocator=NAME use a supported custom allocator # 申请名字 </span><br><span class="line">–disable-symver disable symbol versioning # 禁用symver </span><br><span class="line">–enable-hardcoded-tables use hardcoded tables instead of runtime generation # 启 用硬件编码表 </span><br><span class="line">–disable-safe-bitstream-reader # 禁用安全流阅读器 </span><br><span class="line">disable buffer boundary checking in bitreaders </span><br><span class="line">(faster, but may crash) </span><br><span class="line">–sws-max-filter-size=N the max filter size swscale uses </span><br><span class="line"><span class="meta">[$</span><span class="bash">sws_max_filter_size_default] <span class="comment"># 最大过滤器大小N</span></span> </span><br><span class="line">优化选项 </span><br><span class="line">Optimization options (experts only): </span><br><span class="line">–disable-asm disable all assembly optimizations # 禁用全部汇编程序优化 </span><br><span class="line">–disable-altivec disable AltiVec optimizations # 禁用邋AltiVec优化 </span><br><span class="line">–disable-vsx disable VSX optimizations # 急用VSX优化 </span><br><span class="line">–disable-power8 disable POWER8 optimizations # 禁用power8优化 </span><br><span class="line">–disable-amd3dnow disable 3DNow! optimizations # 禁用3D Now!优化 </span><br><span class="line">–disable-amd3dnowext disable 3DNow! extended optimizations # 禁用3D Now!扩展优化 –disable-mmx disable MMX optimizations # 禁用MMX优化 </span><br><span class="line">–disable-mmxext disable MMXEXT optimizations # 禁用MMXEXT优化 </span><br><span class="line">–disable-sse disable SSE optimizations # 禁用SSE优化 </span><br><span class="line">–disable-sse2 disable SSE2 optimizations # 禁用SSE2优化 </span><br><span class="line">–disable-sse3 disable SSE3 optimizations # 禁用SSE3优化 </span><br><span class="line">–disable-ssse3 disable SSSE3 optimizations # 禁用SSSE3优化 </span><br><span class="line">–disable-sse4 disable SSE4 optimizations # 禁用SSE4优化 </span><br><span class="line">–disable-sse42 disable SSE4.2 optimizations # 禁用SSE4.2优化 </span><br><span class="line">–disable-avx disable AVX optimizations # 禁用AVX优化 </span><br><span class="line">–disable-xop disable XOP optimizations # 禁用XOP优化 </span><br><span class="line">–disable-fma3 disable FMA3 optimizations # 禁用FMA3优化 </span><br><span class="line">–disable-fma4 disable FMA4 optimizations # 禁用FMA4优化 </span><br><span class="line">–disable-avx2 disable AVX2 optimizations # 禁用AVX2优化 </span><br><span class="line">–disable-aesni disable AESNI optimizations # 禁用AESNI优化 </span><br><span class="line">–disable-armv5te disable armv5te optimizations # 禁用armv5te优化 </span><br><span class="line">–disable-armv6 disable armv6 optimizations # 禁用armv6优化 </span><br><span class="line">–disable-armv6t2 disable armv6t2 optimizations # 禁用armv6t2优化 </span><br><span class="line">–disable-vfp disable VFP optimizations # 禁用VFP优化 </span><br><span class="line">–disable-neon disable NEON optimizations # 禁用NEON优化</span><br><span class="line">–disable-inline-asm disable use of inline assembly # 禁用内部组合优化 </span><br><span class="line">–disable-yasm disable use of nasm/yasm assembly # 禁用nasm/yasm组合 </span><br><span class="line">–disable-mipsdsp disable MIPS DSP ASE R1 optimizations # 禁用MIPS DSP ASE R1优化 –disable-mipsdspr2 disable MIPS DSP ASE R2 optimizations # 禁用MIPS DSP ASE R2优化 –disable-msa disable MSA optimizations # 禁用MSA优化 </span><br><span class="line">–disable-mipsfpu disable floating point MIPS optimizations # 禁用浮点MIPS优化 </span><br><span class="line">–disable-mmi disable Loongson SIMD optimizations # 禁用长SIMD优化 </span><br><span class="line">–disable-fast-unaligned consider unaligned accesses slow # 禁用快速非对齐，非对齐速度 慢 </span><br><span class="line">开发选项 </span><br><span class="line">Developer options (useful when working on FFmpeg itself): </span><br><span class="line">–disable-debug disable debugging symbols # 禁用调试符号 </span><br><span class="line">–enable-debug=LEVEL set the debug level [$debuglevel] # 禁用调试等级 </span><br><span class="line">–disable-optimizations disable compiler optimizations # 禁用编译器优化 </span><br><span class="line">–enable-extra-warnings enable more compiler warnings # 启用编译器警告 </span><br><span class="line">–disable-stripping disable stripping of executables and shared libraries # 禁用可 执行程序剥脱共享库 </span><br><span class="line">–assert-level=level 0(default), 1 or 2, amount of assertion testing, # 启用段保护等 级 </span><br><span class="line">2 causes a slowdown at runtime. </span><br><span class="line">–enable-memory-poisoning fill heap uninitialized allocated space with arbitrary data # 启用内存填充，用任意数填充 </span><br><span class="line">–valgrind=VALGRIND run “make fate” tests through valgrind to detect memory # 启用 内存检测 </span><br><span class="line">leaks and errors, using the specified valgrind binary. </span><br><span class="line">Cannot be combined with –target-exec </span><br><span class="line">–enable-ftrapv Trap arithmetic overflows # 启用算术运算溢出 </span><br><span class="line">–samples=PATH location of test samples for FATE, if not set use # 指定测试示例位置 \$FATE_SAMPLES at make invocation time. </span><br><span class="line">–enable-neon-clobber-test check NEON registers for clobbering (should be # 启用 neon clobber测试 </span><br><span class="line">used only for debugging purposes) </span><br><span class="line">–enable-xmm-clobber-test check XMM registers for clobbering (Win64-only; # 启用 xmm clobber测试 </span><br><span class="line">should be used only for debugging purposes) </span><br><span class="line">–enable-random randomly enable/disable components # 启用组件随机开启或关闭 </span><br><span class="line">–disable-random # 禁用组件随机开启或关闭 </span><br><span class="line">–enable-random=LIST randomly enable/disable specific components or # 启用随机列表 –disable-random=LIST component groups. LIST is a comma-separated list # 禁用随机列 表 </span><br><span class="line">of NAME[:PROB] entries where NAME is a component </span><br><span class="line">(group) and PROB the probability associated with </span><br><span class="line">NAME (default 0.5). </span><br><span class="line">–random-seed=VALUE seed value for –enable/disable-random # 启用随机种子值 </span><br><span class="line">–disable-valgrind-backtrace do not print a backtrace under Valgrind </span><br><span class="line">(only applies to –disable-optimizations builds) # 禁用valgrind内存分析追踪</span><br></pre></td></tr></table></figure>


<h4 id="3-FFMPEG各模块简述"><a href="#3-FFMPEG各模块简述" class="headerlink" title="3.FFMPEG各模块简述"></a>3.FFMPEG各模块简述</h4><blockquote>
<p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了领先的 音/视频编码库libavcodec等。<br>libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取 音视频帧等功能；<br>libavcodec：用于各种类型声音/图像编解码；<br>libavutil：包含一些公共的工具函数；<br>libswscale：用于视频场景比例缩放、色彩映射转换；<br>libpostproc：用于后期效果处理；</p>
</blockquote>
<h4 id="4-编译ffmpeg"><a href="#4-编译ffmpeg" class="headerlink" title="4.编译ffmpeg"></a>4.编译ffmpeg</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --disable-x86asm</span><br></pre></td></tr></table></figure>


<p>编译成功后的脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先定义一个NDK目录的变量 NDK_ROOT</span></span><br><span class="line">NDK_ROOT=/home/jackou/tools/android-ndk-r17c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此变量执行ndk中的交叉编译gcc所在目录</span></span><br><span class="line">TOOLCHAIN=$NDK_ROOT/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从as的 externalNativeBuild/xxx/build.ninja，  反正下面的配置，可以压制警告的意思</span></span><br><span class="line"><span class="meta">#</span><span class="bash">FLAGS=<span class="string">&quot;-isystem <span class="variable">$NDK_ROOT</span>/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=arm64-v8a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fPIC&quot;</span></span></span><br><span class="line"></span><br><span class="line">FLAGS=&quot;-isystem $NDK_ROOT/sysroot/usr/include/aarch64-linux-android -D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -march=armv8-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 -fPIC&quot;</span><br><span class="line"></span><br><span class="line">INCLUDES=&quot; -isystem $NDK_ROOT/sources/android/support/include&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.定义编译后，所存放的目录</span></span><br><span class="line">PREFIX=./android/arm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.--enable-small 优化大小 非常重要，必须优化才行的哦</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.--disable-programs 不编译ffmpeg程序（命令行工具），我们是需要获取静态、动态库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.--disable-avdevice 关闭avdevice模块，此模块在android中无用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.--disable-encoders 关闭所有编码器（播放不需要编码）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.--disable-muxers 关闭所有复用器（封装器），不需要生成mp4这样的文件，所有关闭</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7.--disable-filters 关闭所有滤镜</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8.--enable-cross-compile 开启交叉编译（ffmpeg是跨平台的，注意：并不是所有库都有这么happy的选项）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9.--cross-prefix 看右边的值就知道是干嘛的，gcc的前缀..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.disable-shared / enable-static 这个不写也可以，默认就是这样的，（代表关闭动态库，开启静态库）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 11.--sysroot 寻找NDK所有的库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 12.--extra-cflags 会传给gcc的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13.--arch  --target-os</span> </span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/aarch64-linux-android- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-21/arch-arm64 \</span><br><span class="line">--extra-cflags=&quot;$FLAGS $INCLUDES&quot; \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot&quot; \</span><br><span class="line">--arch=aarch64 \</span><br><span class="line">--extra-libs=-lgcc \</span><br><span class="line">--target-os=android</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>


<p>导入AS中Cmakelist编译脚本</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB allCpp *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        SHARED</span><br><span class="line">        <span class="variable">$&#123;allCpp&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_library</span>(</span><br><span class="line">        log-lib</span><br><span class="line">        log)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入FFmpeg的头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入FFmpeg的库文件，设置内部的方式引入，指定库的目录是 -L  指定具体的库-l</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        native-lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 具体的库文件，链接到总库</span></span><br><span class="line">        <span class="comment"># 这样写会报错，有坑</span></span><br><span class="line">        <span class="comment"># avcodec avfilter avformat avutil swresample swscale</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先把有依赖的库，先依赖进来</span></span><br><span class="line">        avformat avcodec avfilter avutil swresample swscale</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="5-Makefile构建系统"><a href="#5-Makefile构建系统" class="headerlink" title="5.Makefile构建系统"></a>5.Makefile构建系统</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里面能够决定编译 Login.c Test.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.源文件在的位置。宏函数 my-dir 返回当前目录（包含 Android.mk 文件本身的目录）的路径。</span></span><br><span class="line"><span class="comment"># LOCAL_PATH 其实就是Android.mk文件本身的目录的路径</span></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(info &quot;LOCAL_PATH:======== $&#123;LOCAL_PATH&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.清理</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO 预编译库的引入 == 提前编译好的库</span></span><br><span class="line">LOCAL_MODULE := getndk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定静态库</span></span><br><span class="line"><span class="comment"># LOCAL_SRC_FILES := libgetndk.a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定动态库</span></span><br><span class="line">LOCAL_SRC_FILES := libgetndk.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译静态库的Makeifle脚本</span></span><br><span class="line"><span class="comment"># include $(PREBUILT_STATIC_LIBRARY)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译共享库的Makeifle脚本</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(PREBUILT_SHARED_LIBRARY)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引入其他makefile文件。CLEAR_VARS 变量指向特殊 GNU Makefile，可为您清除许多 LOCAL_XXX 变量</span></span><br><span class="line"><span class="comment">#不会清理 LOCAL_PATH 变量</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"><span class="comment"># TODO end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.指定库名字  apk/lib/libMyLoginJar.so  == 总库</span></span><br><span class="line"><span class="comment">#存储您要构建的模块的名称 每个模块名称必须唯一，且不含任何空格</span></span><br><span class="line"><span class="comment">#如果模块名称的开头已是 lib，则构建系统不会附加额外的前缀 lib；而是按原样采用模块名称，并添加 .so 扩展名。</span></span><br><span class="line">LOCAL_MODULE := MyLoginJar</span><br><span class="line"></span><br><span class="line"><span class="comment">#包含要构建到模块中的 C 和/或 C++ 源文件列表 以空格分开</span></span><br><span class="line">LOCAL_SRC_FILES := Login.c \</span><br><span class="line">Test.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO 开始链接进来</span></span><br><span class="line"><span class="comment"># 静态库的链接</span></span><br><span class="line"><span class="comment"># LOCAL_STATIC_LIBRARIES := getndk</span></span><br><span class="line"><span class="comment"># 动态库链接</span></span><br><span class="line">LOCAL_SHARED_LIBRARIES := getndk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 log</span></span><br><span class="line"><span class="comment">#LOCAL_LDLIBS := -llog</span></span><br><span class="line"><span class="comment"># 链接数学库和log库</span></span><br><span class="line">LOCAL_LDLIBS  := -lm -llog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.动态库</span></span><br><span class="line"><span class="comment">#构建动态库BUILD_SHARED_LIBRARY 最后生成总动态库  ---&gt; apk/lib/armeabi-v7a/libMyLoginJar.so</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br><span class="line"><span class="comment"># 静态库</span></span><br><span class="line"><span class="comment"># include $(BUILD_STATIC_LIBRARY)</span></span><br></pre></td></tr></table></figure>


<h4 id="6-Cmake构建工程"><a href="#6-Cmake构建工程" class="headerlink" title="6.Cmake构建工程"></a>6.Cmake构建工程</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;ndk28_cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量导入 cpp c源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/*.cpp <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/*.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个库（动态库SHARED，静态库STATIC）</span></span><br><span class="line"><span class="keyword">add_library</span>(native-lib <span class="comment"># 库的名字 ---&gt; libnative-lib.so</span></span><br><span class="line">             SHARED  <span class="comment"># 动态库</span></span><br><span class="line">            <span class="comment"># cpp的源文件：把cpp源文件编译成 libnative-lib.so 库</span></span><br><span class="line">             <span class="variable">$&#123;SOURCE&#125;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 预编译库（已经有了 xxx.so / xxx.a）的导入方式</span></span><br><span class="line"><span class="comment"># TODO 方式一：推荐的方式</span></span><br><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment"># 第一步：导入fmod头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cpp/inc&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：导入库文件 （方式一）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_SOURCE_DIR&#125;/jniLibsaaa/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 第三步链接到总库中去</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmod <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmodL <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO 方式二：以前更多使用的方式</span></span><br><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment"># 第一步：导入fmod头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cpp/inc&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：导入库文件 （方式二）</span></span><br><span class="line"><span class="keyword">add_library</span>(fmod SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmod PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmod.so)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(fmodL SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmodL PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmodL.so)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步链接到总库中去</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmod <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmodL <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br><span class="line"><span class="comment">#]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 判断静态库还是动态库 (静态库会直接Copy到总库，动态库则不会)</span></span><br><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 下面代码不参与 判断 start</span></span><br><span class="line"><span class="comment"># 第一步：导入fmod头文件</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cpp/inc&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：导入库文件 （方式二）</span></span><br><span class="line"><span class="keyword">add_library</span>(fmod SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmod PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmod.so)</span><br><span class="line"><span class="keyword">add_library</span>(fmodL SHARED IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(fmodL PROPERTIES</span><br><span class="line">        IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libfmodL.so)</span><br><span class="line"><span class="comment"># &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 上面代码不参与 判断 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## OFF=0=false    ON=1=true</span></span><br><span class="line"><span class="comment"># set(isSTATIC OFF)</span></span><br><span class="line"><span class="keyword">set</span>(isSTATIC <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;isSTATIC&#125;</span>)</span><br><span class="line">    <span class="comment"># 导入静态库</span></span><br><span class="line">    <span class="keyword">add_library</span>(getndk STATIC IMPORTED)</span><br><span class="line">    <span class="comment"># 开始真正导入 静态库   System.loadLibrary(&quot;getndk&quot;); // 如果是动态库，这里需要加载，否则注释</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(getndk PROPERTIES IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/libgetndk.a)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;isSTATIC == static&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>(<span class="variable">$&#123;isSTATIC&#125;</span>)</span><br><span class="line">    <span class="comment"># 导入动态库</span></span><br><span class="line">    <span class="keyword">add_library</span>(getndk SHARED IMPORTED)</span><br><span class="line">    <span class="comment"># 开始真正导入 动态库  System.loadLibrary(&quot;getndk&quot;); // 如果是动态库，这里需要加载，否则注释</span></span><br><span class="line">    <span class="keyword">set_target_properties</span>(getndk PROPERTIES</span><br><span class="line">            IMPORTED_LOCATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/jniLibsaaa/<span class="variable">$&#123;CMAKE_ANDROID_ARCH_ABI&#125;</span>/libgetndk.so)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;isSTATIC == shared&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>(<span class="variable">$&#123;isSTATIC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        getndk <span class="comment"># TODO 具体的库 链接到 libnative-lib.so里面去【这个库，有可能是静态库，有可能是动态库】</span></span><br><span class="line">        fmod <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        fmodL <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rtmp的时候，就全盘采用 源码构建方式</span></span><br><span class="line"><span class="comment"># TODO &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 依赖源码的方式（已经有了 xxxc / xxx.c / xxx.c ...）的导入方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#引入get子目录下的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/libget)</span><br><span class="line"></span><br><span class="line"><span class="comment">#引入count子目录下的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cpp/libcount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># native-lib是我们的总库</span></span><br><span class="line">        native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">        log <span class="comment"># 自动寻找  # 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        get <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        count <span class="comment"># 具体的库 链接到 libnative-lib.so里面去</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure>


<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 子目录下的cmakelist</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        count</span><br><span class="line">        SHARED <span class="comment"># 最终生成 libcount.so</span></span><br><span class="line">        <span class="variable">$&#123;SOURCE&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>.<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE *.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        get</span><br><span class="line">        STATIC <span class="comment"># 最终生成 libget.a</span></span><br><span class="line">        <span class="variable">$&#123;SOURCE&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旧版本日志输出到output.txt中，新版本输出到/.cxx/cmake/debug/armeabi-v7a/metadata_generation_stderr.txt或者cmake_server_log.txt中</span></span><br><span class="line"><span class="comment"># (无) = 重要消息；</span></span><br><span class="line"><span class="comment"># STATUS = 非重要消息；</span></span><br><span class="line"><span class="comment"># WARNING = CMake 警告, 会继续执行；</span></span><br><span class="line"><span class="comment"># AUTHOR_WARNING = CMake 警告 (dev), 会继续执行；</span></span><br><span class="line"><span class="comment"># SEND_ERROR = CMake 错误, 继续执行，但是会跳过生成的步骤；</span></span><br><span class="line"><span class="comment"># FATAL_ERROR = CMake 错误, 终止所有处理过程；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;this print message!&quot;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="7-Cmake变量"><a href="#7-Cmake变量" class="headerlink" title="7. Cmake变量"></a>7. Cmake变量</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#申明变量</span></span><br><span class="line"><span class="keyword">set</span>(var jack)</span><br><span class="line">messgae(STATUS <span class="variable">$&#123;var&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CMake中所有变量都是string类型。可以使用set()和unset()命令来声明或移除一个变量 </span></span><br><span class="line"><span class="comment"># 移除变量 </span></span><br><span class="line"><span class="keyword">unset</span>(var) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;my_var = $&#123;var&#125;&quot;</span>) <span class="comment"># 会取不到值，因为被移除了 </span></span><br><span class="line"><span class="comment"># TODO CMake列表（lists） </span></span><br><span class="line"><span class="comment"># 声明列表：set(列表名    值1 值2 ... 值N) 或    set(列表名    &quot;值1;值2;...;值N&quot;) </span></span><br><span class="line"><span class="keyword">set</span>(list_var <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="comment"># 字符串列表呢？    CMake中所有变量都是string类型 </span></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line"><span class="keyword">set</span>(list_var2 <span class="string">&quot;1;2;3;4;5&quot;</span>) <span class="comment"># 字符串列表呢？         CMake中所有变量都是string类型 message(&quot;list_var = $&#123;list_var&#125;&quot;) </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;list_var2 = $&#123;list_var2&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake流程控制-条件命令 </span></span><br><span class="line"><span class="comment"># true(1，ON，YES，TRUE，Y，非0的值) </span></span><br><span class="line"><span class="comment"># false(0，OFF，NO，FALSE，N，IGNORE，NOTFOUND) </span></span><br><span class="line"><span class="keyword">set</span>(if_tap <span class="keyword">OFF</span>) <span class="comment"># 定义一个变量if_tap，值为false </span></span><br><span class="line"><span class="keyword">set</span>(elseif_tap <span class="keyword">ON</span>) <span class="comment"># 定义一个变量elseif_tap，值为ture </span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;if_tap&#125;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;if&quot;</span>) </span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$&#123;elseif_tap&#125;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;elseif&quot;</span>) </span><br><span class="line"><span class="keyword">else</span>(<span class="variable">$&#123;if_tap&#125;</span>) <span class="comment"># 可以不加入    $&#123;if_tap&#125; </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;else&quot;</span>) </span><br><span class="line"><span class="comment"># endif($&#123;if_tap&#125;) # 结束if </span></span><br><span class="line"><span class="keyword">endif</span>() <span class="comment"># 结束if 可以不加 </span></span><br><span class="line"><span class="comment"># 注意：elseif和else部分是可选的，也可以有多个elseif部分，缩进和空格对语句解析没有影响</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake流程控制-循环命令 </span></span><br><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;&quot;</span>) </span><br><span class="line"><span class="comment">#  a STREQUAL &quot;xxx&quot;（a等不等xxx，不等于） </span></span><br><span class="line"><span class="comment">#  NOT == ! </span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">NOT</span> a <span class="keyword">STREQUAL</span> <span class="string">&quot;xxx&quot;</span>) </span><br><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;$&#123;a&#125;x&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;a = $&#123;a&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endwhile</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># break()命令可以跳出整个循环 </span></span><br><span class="line"><span class="comment"># continue()可以继续当前循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;1item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item) <span class="comment"># 结束for</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">2</span>) <span class="comment"># RANGE 默认从0开始，    所以是：0 1 2 </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;2item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">1</span> <span class="number">6</span> <span class="number">2</span>) <span class="comment">#  1 3 5 每次跳级2 </span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;3item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(list_va3 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment"># 列表 </span></span><br><span class="line"><span class="comment"># foreach(item IN LISTS $&#123;list_va3&#125;) 没有报错，没有循环 </span></span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS list_va3) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;4item = $&#123;item&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="comment"># TODO CMake自定义函数         Shell的函数很类似 </span></span><br><span class="line"><span class="comment">#[[ </span></span><br><span class="line">ARGC：表示传入参数的个数 </span><br><span class="line">ARGV0：表示第一个参数，ARGV1、ARGV2以此类推即可 </span><br><span class="line">ARGV：表示所有参数 </span><br><span class="line"><span class="comment">#]] </span></span><br><span class="line"><span class="keyword">function</span>(num_method n1 n2 n3) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;call num_method method&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;n1 = $&#123;n1&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;n2 = $&#123;n2&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;n3 = $&#123;n3&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;ARGC = $&#123;ARGC&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;arg1 = $&#123;ARGV0&#125; arg2 = $&#123;ARGV1&#125; arg3 = $&#123;ARGV2&#125;&quot;</span>) <span class="keyword">message</span>(<span class="string">&quot;all args = $&#123;ARGV&#125;&quot;</span>) </span><br><span class="line"><span class="keyword">endfunction</span>(num_method) </span><br><span class="line">num_method(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment"># 调用num_method函数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide源码分析</title>
    <url>/2021/04/29/Glide%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="1-Glide总览"><a href="#1-Glide总览" class="headerlink" title="1. Glide总览"></a>1. Glide总览</h3><p>Glide图片加载框架从总体来看采用三段论来让用户轻松加载图片。</p>
<ul>
<li>with()方法主要通过创建一个空白的Fragment盖在展示的页面上，感知展示页面的生命周期，来动态调整Glide内部请求等业务。详细参见<a href="https://www.jianshu.com/p/f42a2c00c9d1">Glide源码分析-生命周期管理</a></li>
<li>load()方法完成通用请求的构建</li>
<li>into()方法主要维护这运行队列和等待队列，当生命周期改变的时候，动态清除一些不必要加载的请求。同时还维护着活动缓存和内存缓存，多级缓存有利于节约资源和加载效率，最后如果没有缓存就采用网络请求的方式加载请求的内容。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b1a128a4e99cfd2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide总览.png"></p>
<h3 id="2-with"><a href="#2-with" class="headerlink" title="2. with()"></a>2. with()</h3><p>with()方法的详细分析可以参见上一篇Glide的叙述：<a href="https://www.jianshu.com/p/f42a2c00c9d1">Glide源码分析-生命周期管理</a>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7f361758e40a09a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide_with.png"></p>
<p>总体来讲，with()方法中发生了如下事情：</p>
<ul>
<li>Glide类:主要做一些 init 工作，比如缓存，线程池，复用池的构建等等。</li>
<li>RequestManagerRetriever类：主要是获得一个 <code>RequestManager</code> 请求管理类，然后绑定一个 Fragment</li>
<li>SupportRequestManagerFragment 类:用于管理请求的生命周期。</li>
<li>RequestManager:主要用于对请求的管理封装。</li>
</ul>
<h3 id="3-load"><a href="#3-load" class="headerlink" title="3. load()"></a>3. load()</h3><p>load()流程其实不是很复杂，主要做了通用资源类型的设置选项和启动负载，在RequestBuilder 中完成。流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f3aa2776268cc9e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Glide_with_load.png"></p>
<p>RequestBuilder : 这是一个通用请求构建类，可以处理通用资源类型的设置选项和启动负载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ModelTypes</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">Drawable</span>&gt;&gt; </span>&#123;</span><br><span class="line">      </span><br><span class="line">  .....</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里调用 Drawable 图片加载请求器为其加载</span></span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@CheckResult</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(uri);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@CheckResult</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asDrawable().load(file);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">  &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilder</span>&lt;<span class="title">TranscodeType</span>&gt; <span class="keyword">extends</span> <span class="title">BaseRequestOptions</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">TranscodeType</span>&gt;&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">ModelTypes</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">TranscodeType</span>&gt;&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 描述加载的数据源-这里可以看做是我们传递进来的 http://xxxx.png</span></span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> Object model;</span><br><span class="line">  <span class="comment">// 描述这个请求是否已经添加了加载的数据源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isModelSet;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    isModelSet = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// model是我们需要加载的数据源，可能为null，为了保证model一定被赋值，此处引进isModelSet来保证。</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.model = model;</span><br><span class="line">      isModelSet = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里 RequestBuilder 就构建好了， RequestBuilder构建出来，接下来就是重头戏into()。</p>
<h3 id="4-into"><a href="#4-into" class="headerlink" title="4.into()"></a>4.into()</h3><p>into()是所有流程中最最复杂的方法，有60多个步骤，此处我们分成几个环节来一一分析流程。</p>
<p>分析之前，我们脑子中一定记住从最初是状态开始翻代码，最初始状态就是：<strong>拿到了url，各级缓存都没有资源，需要从网上下载资源，然后加载到控件中。</strong></p>
<p><strong>into()整体流程图</strong><a href="https://github.com/oujie123/Glide">在Glide工程中src目录中</a>。</p>
<h4 id="4-1-确定控件大小"><a href="#4-1-确定控件大小" class="headerlink" title="4.1 确定控件大小"></a>4.1 确定控件大小</h4><p>我们从网上加载的inputstram不可能是下载多少就加载多少，这样内存可能爆掉，或者效率很低，我们应该按需加载，控件多大，我们就将图片压缩到多大加载。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e2e80706f9f2534b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="确定控件大小.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  Preconditions.checkNotNull(view);</span><br><span class="line">  <span class="comment">// 根据 ImageView 布局中的 scaleType 来重构 requestOptions</span></span><br><span class="line">  BaseRequestOptions&lt;?&gt; requestOptions = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果在 xml ImageView 节点中 没有设置 scaleType 那么默认在构造函数中进行了初始化为   mScaleType = ScaleType.FIT_CENTER;  </span></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">     .....</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        <span class="comment">//这里用到了克隆（原型设计模式），选择一个&quot;居中合适&quot;显示的方案</span></span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用 into 重载函数，创建一个 ViewTarget</span></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">    	<span class="comment">//调用 buildImageViewTarget 构建一个 ImageView 类型的 Target(Bitmap/Drawable)</span></span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      requestOptions,</span><br><span class="line">      Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就两大步：</p>
<p>   第一步：先拿到当前 ImageView getScaleType 类型的属性，然后重新 clone 一个进行配置；</p>
<p>   第二步：调用 into 重载继续构建；</p>
<p>先来看下 glideContext.buildImageViewTarget 是怎么构建出来 ImageViewTarget 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> &lt;X&gt; <span class="function">ViewTarget&lt;ImageView, X&gt; <span class="title">buildImageViewTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@NonNull</span> ImageView imageView, <span class="meta">@NonNull</span> Class&lt;X&gt; transcodeClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用 工厂模式 根据 transcodeClass 生成出一个对应的 ImageViewTarget</span></span><br><span class="line">  <span class="keyword">return</span> imageViewTargetFactory.buildTarget(imageView, transcodeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTargetFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> &lt;Z&gt; <span class="function">ViewTarget&lt;ImageView, Z&gt; <span class="title">buildTarget</span><span class="params">(<span class="meta">@NonNull</span> ImageView view,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果目标的编码类型属于 Bitmap 那么就创建一个 Bitmap 类型的 ImageViewTarget</span></span><br><span class="line">    <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">    <span class="comment">////如果目标的编码类型属于 Drawable 那么就创建一个 Drawable 类型的 ImageViewTarget</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (ViewTarget&lt;ImageView, Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">&quot;Unhandled class: &quot;</span> + clazz + <span class="string">&quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 生产 Target 的时候注意一下，只要调用了  <code>asBitmap</code> 才会执行生产 BitmapImageViewTarget ,所以这里我们关注 Drawable 类型就行了，我们就先简单看看这个 target 内部怎么实现的，因为最后当拿到请求资源之后，会在target中设置资源到view中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableImageViewTarget</span> <span class="keyword">extends</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Drawable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view, <span class="keyword">boolean</span> waitForLayout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view, waitForLayout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Drawable resource)</span> </span>&#123;</span><br><span class="line">    view.setImageDrawable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以知道 DrawableImageViewTarget 继承的是 ImageViewTarget 重写的 setResource 函数，实现了显示 Drawable 图片的逻辑。</p>
<p>回到主流程，into()重载方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Y target,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">      BaseRequestOptions&lt;?&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="comment">//这里的 isModelSet 是在 load 的时候赋值为 true 的，所以不会抛异常，确保了信息源一定被设置。</span></span><br><span class="line">    <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You must call #load() before calling #into()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//为这个 http://xxx.png 生成一个 Glide request 请求</span></span><br><span class="line">    Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line">		<span class="comment">//相当于拿到上一个请求</span></span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line">    <span class="comment">//下面的几行说明是否与上一个请求冲突，一般不用管 直接看下面 else 判断</span></span><br><span class="line">    <span class="comment">// 如果两个请求参数和大小相同，就不用再请求了，直接返回。此if中也会判断前一个请求是否在请求中等状态，此处我们不用关心，第一次加载图片不会进入此if语句。</span></span><br><span class="line">    <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">      request.recycle();</span><br><span class="line">      <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">        previous.begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果是一个新请求，先清理掉目标请求管理</span></span><br><span class="line">    requestManager.clear(target);</span><br><span class="line">    <span class="comment">//重新为目标设置一个 Glide request 请求</span></span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    <span class="comment">//最后是调用 RequestManager 的 track 来执行目标的 Glide request 请求</span></span><br><span class="line">    requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>以上核心就两个点：</p>
<p>​    第一点：为 target buildRequest 构建一个 Glide request 请求； </p>
<p>​    第二点：将构建出来的 Request 交于 RequestManager 来执行；</p>
<p>我们先简单的来看下怎么构建的 Request：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">buildRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildRequestRecursive(</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      <span class="comment">/*parentCoordinator=*/</span> <span class="keyword">null</span>,</span><br><span class="line">      transitionOptions,</span><br><span class="line">      requestOptions.getPriority(),</span><br><span class="line">      requestOptions.getOverrideWidth(),</span><br><span class="line">      requestOptions.getOverrideHeight(),</span><br><span class="line">      requestOptions,</span><br><span class="line">      callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Request <span class="title">obtainRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Target&lt;TranscodeType&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestListener&lt;TranscodeType&gt; targetListener,</span></span></span><br><span class="line"><span class="function"><span class="params">    BaseRequestOptions&lt;?&gt; requestOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    RequestCoordinator requestCoordinator,</span></span></span><br><span class="line"><span class="function"><span class="params">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> overrideHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SingleRequest.obtain(</span><br><span class="line">      context,</span><br><span class="line">      glideContext,</span><br><span class="line">      model,</span><br><span class="line">      transcodeClass,</span><br><span class="line">      requestOptions,</span><br><span class="line">      overrideWidth,</span><br><span class="line">      overrideHeight,</span><br><span class="line">      priority,</span><br><span class="line">      target,</span><br><span class="line">      targetListener,</span><br><span class="line">      requestListeners,</span><br><span class="line">      requestCoordinator,</span><br><span class="line">      glideContext.getEngine(),</span><br><span class="line">      transitionOptions.getTransitionFactory(),</span><br><span class="line">      callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们发现是 <code>SingleRequest.obtain</code> 来为我们构建的 Request 请求对象，开始只是初始化一些配置属性。</p>
<p>继续回到上面看request的track()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里对当前 class 加了一个同步锁避免线程引起的安全性  </span></span><br><span class="line"> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(<span class="meta">@NonNull</span> Target&lt;?&gt; target, <span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//添加一个目标任务  </span></span><br><span class="line">  	targetTracker.track(target);</span><br><span class="line">  	<span class="comment">//执行 Glide request</span></span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(<span class="meta">@NonNull</span> Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加一个请求</span></span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="comment">//是否暂停</span></span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">      <span class="comment">//没有暂停，开始调用 Request begin 执行</span></span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果调用了 暂停，清理请求</span></span><br><span class="line">      request.clear();</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑是先为 <code>requests</code> 添加一个请求，看看是否是停止状态，如果不是就调用 <code>request.begin();</code>执行。</p>
<p>这里的 <code>Request</code> 是一个接口，通过之前我们讲到 <code>buildRequest</code> 函数可知  <code>Request</code>  的实现类是  <code>SingleRequest</code> 我们就直接看它的 <code>begin</code> 函数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   assertNotCallingCallbacks();</span><br><span class="line">   stateVerifier.throwIfRecycled();</span><br><span class="line">   startTime = LogTime.getLogTime();</span><br><span class="line">   <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">//检查外部调用的尺寸是否有效</span></span><br><span class="line">     <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">       width = overrideWidth;</span><br><span class="line">       height = overrideHeight;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//失败的回调</span></span><br><span class="line">     <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">     onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">&quot;Received null model&quot;</span>), logLevel);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot restart a running request&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">     <span class="comment">//表示资源准备好了</span></span><br><span class="line">     onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   status = Status.WAITING_FOR_SIZE;</span><br><span class="line">   <span class="comment">//这里表示大小已经准备好了</span></span><br><span class="line">   <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">     <span class="comment">// 需要加载的尺寸已经测量好了，接下里就开始加载引擎。</span></span><br><span class="line">     onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     target.getSize(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">//这里是刚刚开始执行的回调，相当于显示开始的进度</span></span><br><span class="line">   <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">       &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">     target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">     logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">      loadStatus =</span><br><span class="line">          engine.load(</span><br><span class="line">              glideContext,</span><br><span class="line">              model,</span><br><span class="line">              requestOptions.getSignature(),</span><br><span class="line">              <span class="keyword">this</span>.width,</span><br><span class="line">              <span class="keyword">this</span>.height,</span><br><span class="line">              requestOptions.getResourceClass(),</span><br><span class="line">              transcodeClass,</span><br><span class="line">              priority,</span><br><span class="line">              requestOptions.getDiskCacheStrategy(),</span><br><span class="line">              requestOptions.getTransformations(),</span><br><span class="line">              requestOptions.isTransformationRequired(),</span><br><span class="line">              requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">              requestOptions.getOptions(),</span><br><span class="line">              requestOptions.isMemoryCacheable(),</span><br><span class="line">              requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">              requestOptions.getUseAnimationPool(),</span><br><span class="line">              requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">              <span class="keyword">this</span>,</span><br><span class="line">              callbackExecutor);</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-2-从不同缓存中搜寻资源"><a href="#4-2-从不同缓存中搜寻资源" class="headerlink" title="4.2 从不同缓存中搜寻资源"></a>4.2 从不同缓存中搜寻资源</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-0644fe6707e53fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="从不同缓存中获取资源过程.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      GlideContext glideContext,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object model,</span></span></span><br><span class="line"><span class="function"><span class="params">      Key signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;R&gt; transcodeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      DiskCacheStrategy diskCacheStrategy,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isTransformationRequired,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span></span></span><br><span class="line"><span class="function"><span class="params">      Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> isMemoryCacheable,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useAnimationPool,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> onlyRetrieveFromCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResourceCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">      Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到缓存或者请求的 key</span></span><br><span class="line">    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">		<span class="comment">//根据 key 拿到活动缓存中的资源</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="comment">//如果 ActiveResources 活动缓存中有就回调出去</span></span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从 LruResourceCache 中找寻这个资源 </span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果内存缓存 Lru 中资源存在回调出去</span></span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------- 走到这里说明活动缓存 跟内存 缓存都没有找到 -----------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据 Key 看看缓存中是否正在执行</span></span><br><span class="line">    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果正在执行，把数据回调出去</span></span><br><span class="line">      current.addCallback(cb, callbackExecutor);</span><br><span class="line">      <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">&quot;Added to existing load&quot;</span>, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------   走到这里说明是一个新的任务  ---------------</span></span><br><span class="line">    <span class="comment">// --------------   构建新的请求任务  ---------------</span></span><br><span class="line">    EngineJob&lt;R&gt; engineJob =</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line">		<span class="comment">//把当前需要执行的 key 添加进缓存</span></span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">		<span class="comment">//执行任务的回调</span></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="comment">//开始执行。</span></span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>engine.load</code> 这个函数里面的逻辑，我们可以总结3点：</p>
<ol>
<li><p>先构建请求或者缓存 KEY ;</p>
</li>
<li><p>根据 KEY 从内存缓存中查找对应的资源数据(ActiveResources（活动缓存，内部是一个 Map 用弱引用持有）,LruResourceCache)，如果有就回调 对应监听的 onResourceReady 表示数据准备好了。</p>
</li>
<li><p>从执行缓存中查找对应 key 的任务</p>
<ol>
<li><p>如果找到了，就说明已经正在执行了，不用重复执行。</p>
</li>
<li><p>没有找到，通过 EngineJob.start 开启一个新的请求任务执行。</p>
</li>
</ol>
</li>
</ol>
<p>为了看主线，时刻记住开始强调的，<strong>所有缓存中都没有数据！</strong>直接看 EngineJob.start </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">    <span class="comment">//拿到 Glide 执行的线程池</span></span><br><span class="line">    GlideExecutor executor = decodeJob.willDecodeFromCache()</span><br><span class="line">        ? diskCacheExecutor</span><br><span class="line">        : getActiveSourceExecutor();</span><br><span class="line">    <span class="comment">//开始执行</span></span><br><span class="line">    executor.execute(decodeJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>DecodeJob</code> 源码得知，它是实现的 <code>Runnable</code> 接口，这里 GlideExecutor 线程池开始执行，就会启动 DecodeJob 的 run 函数。</p>
<p>细心的小伙伴可以看出engineJob之后就decodeJob，不难想出，这两个任务之间一定有获取到资源的过程。而decodeJob包裹了engineJob，decodeJob是一个runnable，所以不难猜出会在线程池中网络请求资源，并且解码资源。下面我们就来看看是如何加载资源和解码的。</p>
<h4 id="4-3-寻找资源加载器"><a href="#4-3-寻找资源加载器" class="headerlink" title="4.3 寻找资源加载器"></a>4.3 寻找资源加载器</h4><p>此处不得不佩服框架考虑得的确很周全，我们需要加载资源，肯定就需要资源加载器，那么是不是只有一个加载器呢，当然不是，只有一个加载器的代码可能是我写的，哈哈哈。<strong>透露小秘密：框架会根据我们load传入的不同信息源，获取不同的资源加载器。</strong>下面我们来看一下流程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-44d8321db10c4208.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取url加载器.png"></p>
<p>上一小节结束我们可以看到包裹了engineJob的decodeJob任务会在线程池中执行，那么不难想出decodeJob的run()肯定会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 线程执行调用 run</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        GlideTrace.beginSectionFormat(<span class="string">&quot;DecodeJob#run(model=%s)&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">        DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//是否取消了当前请求</span></span><br><span class="line">          <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">            notifyFailed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//执行</span></span><br><span class="line">          runWrapped();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CallbackException e) &#123;</span><br><span class="line"></span><br><span class="line">         .....<span class="comment">//一些错误回调</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>分析runWrapped:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="comment">//获取资源状态</span></span><br><span class="line">        stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">        <span class="comment">//根据当前资源状态，获取资源执行器</span></span><br><span class="line">        currentGenerator = getNextGenerator();</span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        runGenerators();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Stage <span class="title">getNextStage</span><span class="params">(Stage current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">        <span class="comment">//如果外部调用配置了资源缓存策略，那么返回 Stage.RESOURCE_CACHE</span></span><br><span class="line">       	<span class="comment">//否则继续调用 Stage.RESOURCE_CACHE 执行。</span></span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedResource()</span><br><span class="line">            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="comment">//如果外部配置了源数据缓存，那么返回 Stage.DATA_CACHE</span></span><br><span class="line">        <span class="comment">//否则继续调用 getNextStage(Stage.DATA_CACHE)</span></span><br><span class="line">        <span class="keyword">return</span> diskCacheStrategy.decodeCachedData()</span><br><span class="line">            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="comment">//如果只能从缓存中获取数据，则直接返回 FINISHED，否则，返回SOURCE。</span></span><br><span class="line">        <span class="comment">//意思就是一个新的资源</span></span><br><span class="line">        <span class="keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;</span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> Stage.FINISHED;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unrecognized stage: &quot;</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码可以知道，我们在找资源的执行器，这里由于我们没有在外部配置缓存策略所以，直接从源数据加载，看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">      <span class="comment">//从资源缓存执行器</span></span><br><span class="line">      <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//源数据磁盘缓存执行器</span></span><br><span class="line">      <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//什么都没有配置，源数据的执行器</span></span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">case</span> FINISHED:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由于我们什么都没有配置，返回的是 <code>SourceGenerator</code> 源数据执行器。继续下面代码执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    currentThread = Thread.currentThread();</span><br><span class="line">    startFetchTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//判断是否取消，是否开始</span></span><br><span class="line">    <span class="comment">//调用 DataFetcherGenerator.startNext() 判断是否是属于开始执行的任务</span></span><br><span class="line">    <span class="keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">   </span><br><span class="line">      ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先看 <code>currentGenerator.startNext()</code> 这句代码，<code>DataFetcherGenerator</code> 是一个抽象类，那么这里执行的实现类是哪一个，可以参考下面说明：</p>
<table>
<thead>
<tr>
<th>状态标记</th>
<th>作用</th>
<th>执行器</th>
</tr>
</thead>
<tbody><tr>
<td>Stage.RESOURCE_CACHE</td>
<td>从磁盘中获取缓存的资源数据</td>
<td>ResourceCacheGenerator</td>
</tr>
<tr>
<td>Stage.DATA_CACHE</td>
<td>从磁盘中获取缓存的源数据</td>
<td>DataCacheGenerator</td>
</tr>
<tr>
<td>Stage.SOURCE</td>
<td>一次新的请求任务</td>
<td>SourceGenerator</td>
</tr>
</tbody></table>
<p>因为这里我们没有配置缓存，那么直接看 <code>SourceGenerator</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">    loadData = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">      <span class="comment">//获取一个 ModelLoad 加载器</span></span><br><span class="line">      loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">          &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//使用加载器中的 fetcher 根据优先级加载数据</span></span><br><span class="line">        loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> started;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑很简单，首先获取加载器，然后从加载器中使用fetcher来加载数据就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;LoadData&lt;?&gt;&gt; getLoadData() &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isLoadDataSet) &#123;</span><br><span class="line">     isLoadDataSet = <span class="keyword">true</span>;</span><br><span class="line">     loadData.clear(); </span><br><span class="line">     <span class="comment">//从 Glide 注册的 Model 来获取加载器（注册是在 Glide 初始化的时候通过 registry</span></span><br><span class="line">      <span class="comment">// .append()添加的）</span></span><br><span class="line">     List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = modelLoaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">       ModelLoader&lt;Object, ?&gt; modelLoader = modelLoaders.get(i);</span><br><span class="line">       LoadData&lt;?&gt; current =</span><br><span class="line">         <span class="comment">// 构建加载器。modelLoader是一个接口，需要知道是那个类的buildLoadData()来构建加载器。看看下面的分析。</span></span><br><span class="line">           modelLoader.buildLoadData(model, width, height, options);</span><br><span class="line">       <span class="comment">//如果加载器器不为空，那么添加进临时缓存</span></span><br><span class="line">       <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">         loadData.add(current);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> loadData;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>获取到加载器之后，会通过加载器中的fetcher加载数据，然后我们进入loadData()一看，fetcher是一个接口(DataFetcher<Data>)，实现类有一大堆(如下图)，我们根本没法知道到底是哪个来加载数据。</Data></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-01822f1043c41de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fetcher实现类.png"></p>
<p>此处就是框架设计巧妙的一点了，到底是怎么知道哪个fetcher呢？</p>
<p>此时我们要回到 <strong>Glide 初始的时候 通过 <code>Registry.append()</code> 添加的！！！！！！</strong> 下面我们来看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide(</span><br><span class="line">      <span class="meta">@NonNull</span> Context context,</span><br><span class="line">      <span class="meta">@NonNull</span> Engine engine,</span><br><span class="line">      <span class="meta">@NonNull</span> MemoryCache memoryCache,</span><br><span class="line">      <span class="meta">@NonNull</span> BitmapPool bitmapPool,</span><br><span class="line">      <span class="meta">@NonNull</span> ArrayPool arrayPool,</span><br><span class="line">      <span class="meta">@NonNull</span> RequestManagerRetriever requestManagerRetriever,</span><br><span class="line">      <span class="meta">@NonNull</span> ConnectivityMonitorFactory connectivityMonitorFactory,</span><br><span class="line">      <span class="keyword">int</span> logLevel,</span><br><span class="line">      <span class="meta">@NonNull</span> RequestOptionsFactory defaultRequestOptionsFactory,</span><br><span class="line">      <span class="meta">@NonNull</span> Map&lt;Class&lt;?&gt;, TransitionOptions&lt;?, ?&gt;&gt; defaultTransitionOptions,</span><br><span class="line">      <span class="meta">@NonNull</span> List&lt;RequestListener&lt;Object&gt;&gt; defaultRequestListeners,</span><br><span class="line">      <span class="keyword">boolean</span> isLoggingRequestOriginsEnabled,</span><br><span class="line">      <span class="keyword">boolean</span> isImageDecoderEnabledForBitmaps) &#123;</span><br><span class="line">	......</span><br><span class="line">    registry</span><br><span class="line">        .append(Uri.class, InputStream.class, <span class="keyword">new</span> UrlUriLoader.StreamFactory())</span><br><span class="line">        .append(URL.class, InputStream.class, <span class="keyword">new</span> UrlLoader.StreamFactory())</span><br><span class="line">        .append(Uri.class, File.class, <span class="keyword">new</span> MediaStoreFileLoader.Factory(context))</span><br><span class="line">        <span class="comment">// 我们load传入的是一个url，所以我们的fetcher就是HttpGlideUrlLoader。</span></span><br><span class="line">        .append(GlideUrl.class, InputStream.class, <span class="keyword">new</span> HttpGlideUrlLoader.Factory())</span><br><span class="line">        .append(<span class="keyword">byte</span>[].class, ByteBuffer.class, <span class="keyword">new</span> ByteArrayLoader.ByteBufferFactory())</span><br><span class="line">        .append(<span class="keyword">byte</span>[].class, InputStream.class, <span class="keyword">new</span> ByteArrayLoader.StreamFactory())</span><br><span class="line">        .append(Uri.class, Uri.class, UnitModelLoader.Factory.&lt;Uri&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.&lt;Drawable&gt;getInstance())</span><br><span class="line">        .append(Drawable.class, Drawable.class, <span class="keyword">new</span> UnitDrawableDecoder())</span><br><span class="line">        <span class="comment">/* Transcoders */</span></span><br><span class="line">        .register(Bitmap.class, BitmapDrawable.class, <span class="keyword">new</span> BitmapDrawableTranscoder(resources))</span><br><span class="line">        .register(Bitmap.class, <span class="keyword">byte</span>[].class, bitmapBytesTranscoder)</span><br><span class="line">        .register(</span><br><span class="line">            Drawable.class,</span><br><span class="line">            <span class="keyword">byte</span>[].class,</span><br><span class="line">            <span class="keyword">new</span> DrawableBytesTranscoder(</span><br><span class="line">                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))</span><br><span class="line">        .register(GifDrawable.class, <span class="keyword">byte</span>[].class, gifDrawableBytesTranscoder);</span><br><span class="line">    </span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Glide的构造方法中，我们找到了线索，registry.append()会根据我们load()传入不同类型的参数，为我们注册不同的fetcher。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 说明：load传入参数类型----加载后的资源形式--------加载器----</span></span><br><span class="line">append(GlideUrl.class, InputStream.class, <span class="keyword">new</span> HttpGlideUrlLoader.Factory())</span><br></pre></td></tr></table></figure>
<p>我们可以这么理解，我们传入的参数是URL，使用HttpGlideUrlLoader来加载，最终返回一个InputStream流。看了注册加载器之后，<strong>我们继续回到如何构建加载器的主路线上：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadData&lt;InputStream&gt;就是加载器包裹，HttpUrlFetcher就是我们要找到真正的网络资源加载器！！！！</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> GlideUrl model, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time</span></span><br><span class="line">    <span class="comment">// spent parsing urls.</span></span><br><span class="line">    GlideUrl url = model;</span><br><span class="line">    <span class="keyword">if</span> (modelCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      url = modelCache.get(model, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        modelCache.put(model, <span class="number">0</span>, <span class="number">0</span>, model);</span><br><span class="line">        url = model;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> timeout = options.get(TIMEOUT);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(url, <span class="keyword">new</span> HttpUrlFetcher(url, timeout));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此时就很清晰了，我们是通过<code>HttpUrlFetcher</code>来加载资源的，然后我们进入资源加载环节。</p>
<h4 id="4-4-加载资源"><a href="#4-4-加载资源" class="headerlink" title="4.4 加载资源"></a>4.4 加载资源</h4><p>从上一小节中，我们知道了我们传入的url是通过<code>HttpUrlFetcher</code>来加载资源。那么我们就进入<code>HttpUrlFetcher</code>的loadData()。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ecf374cbf67ca2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载资源.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//http 请求，返回一个 InputStream 输入流</span></span><br><span class="line">      InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">      <span class="comment">//将 InputStream 以回调形式回调出去</span></span><br><span class="line">      callback.onDataReady(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      callback.onLoadFailed(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InputStream <span class="title">loadDataWithRedirects</span><span class="params">(URL url, <span class="keyword">int</span> redirects, URL lastUrl,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&quot;Too many (&gt; &quot;</span> + MAXIMUM_REDIRECTS + <span class="string">&quot;) redirects!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastUrl != <span class="keyword">null</span> &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="string">&quot;In re-direct loop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        <span class="comment">// Do nothing, this is best effort.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    urlConnection = connectionFactory.build(url);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    urlConnection.setConnectTimeout(timeout);</span><br><span class="line">    urlConnection.setReadTimeout(timeout);</span><br><span class="line">    urlConnection.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">    urlConnection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    urlConnection.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">    urlConnection.connect();</span><br><span class="line"></span><br><span class="line">    stream = urlConnection.getInputStream();</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> statusCode = urlConnection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (isHttpOk(statusCode)) &#123;</span><br><span class="line">      <span class="keyword">return</span> getStreamForSuccessfulRequest(urlConnection);</span><br><span class="line">    &#125; </span><br><span class="line">    ...<span class="comment">//抛的异常我们暂时先不管</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码我们可以看出 HttpURLConnection 作为 Glide 底层成网络请求的。请求成功之后直接返回的是一个输入流，最后会通过 <code>onDataReady</code> 回调到 DecodeJob的onDataFetcherReady 函数中。</p>
<p>此时我们已经从网络上获取到资源了，现在来看是如何回调的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">      dataToCache = data;</span><br><span class="line">      cb.reschedule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,</span><br><span class="line">          loadData.fetcher.getDataSource(), originalKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会有 else 因为我们没有配置缓存,继续回调:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,</span></span></span><br><span class="line"><span class="function"><span class="params">          DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentSourceKey = sourceKey; <span class="comment">//当前返回数据的 key</span></span><br><span class="line">        <span class="keyword">this</span>.currentData = data; <span class="comment">//返回的数据</span></span><br><span class="line">        <span class="keyword">this</span>.currentFetcher = fetcher; <span class="comment">//返回的数据执行器，这里可以理解为 HttpUrlFetcher</span></span><br><span class="line">        <span class="keyword">this</span>.currentDataSource = dataSource; <span class="comment">//数据来源 url</span></span><br><span class="line">        <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">          runReason = RunReason.DECODE_DATA;</span><br><span class="line">          callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          GlideTrace.beginSection(<span class="string">&quot;DecodeJob.decodeFromRetrievedData&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//解析返回回来的数据</span></span><br><span class="line">            decodeFromRetrievedData();</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            GlideTrace.endSection();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;   </span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们的数据已经从网络上加载完成。最后通过<code>decodeFromRetrievedData()</code>方法来解析inputstream流。</p>
<h4 id="4-5-解析资源"><a href="#4-5-解析资源" class="headerlink" title="4.5 解析资源"></a>4.5 解析资源</h4><p>从上一小节，我们拿到了资源流，下面我们来看看是如何解析资源的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c3c98a0b247497c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析资源.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析返回的数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 decodeFrom 解析 数据；HttpUrlFetcher , InputStream ,  currentDataSource</span></span><br><span class="line">    resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">    e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">    throwables.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析完成后，通知下去</span></span><br><span class="line">  <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runGenerators();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromData</span><span class="params">(DataFetcher&lt;?&gt; fetcher, Data data,</span></span></span><br><span class="line"><span class="function"><span class="params">      DataSource dataSource)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">   	  ...  </span><br><span class="line">      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class="line">      ....</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromFetcher</span><span class="params">(Data data, DataSource dataSource)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前数据类的解析器 LoadPath </span></span><br><span class="line">    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">    <span class="comment">//通过 LoadPath 解析器来解析数据</span></span><br><span class="line">    <span class="keyword">return</span> runLoadPath(data, dataSource, path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> &lt;Data, ResourceType&gt; <span class="function">Resource&lt;R&gt; <span class="title">runLoadPath</span><span class="params">(Data data, DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">      LoadPath&lt;Data, ResourceType, R&gt; path)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Options options = getOptionsWithHardwareConfig(dataSource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为这里返回的是一个 InputStream 所以 这里拿到的是 InputStreamRewinder</span></span><br><span class="line">    DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将解析资源的任务转移到 Load.path 方法中</span></span><br><span class="line">      <span class="keyword">return</span> path.load(</span><br><span class="line">          rewinder, options, width, height, <span class="keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rewinder.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意上面代码，为了解析数据首先构建一个 LoadPath, 然后创建一个 InputStreamRewinder 类型的 DataRewinder, 最终将数据解析的操作放到了 LoadPath.load 方法中 ，接下来看下 LoadPath.load 方法的具体逻辑操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">load</span><span class="params">(DataRewinder&lt;Data&gt; rewinder, <span class="meta">@NonNull</span> Options options, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      listPool.release(throwables);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;Transcode&gt; <span class="title">loadWithExceptionList</span><span class="params">(DataRewinder&lt;Data&gt; rewinder,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> width, <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;Transcode&gt; result = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//遍历内部存储的 DecodePath 集合，通过他们来解析数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;</span><br><span class="line">      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里才是真正解析数据的地方</span></span><br><span class="line">        result = path.decode(rewinder, width, height, options, decodeCallback);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最终通过path.decode()根据尺寸来解析inputstream流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//调用 decodeResourec 将数据解析成中间资源</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">//解析完数据回调出去</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//转换资源为目标资源</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>看看 decodeResource 怎么解析成中间资源的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResource</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> decodeResourceWithList(rewinder, width, height, options, exceptions);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResourceWithList</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options, List&lt;Throwable&gt; exceptions)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    Resource&lt;ResourceType&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;</span><br><span class="line">      ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        DataType data = rewinder.rewindAndGet();</span><br><span class="line">        <span class="keyword">if</span> (decoder.handles(data, options)) &#123;</span><br><span class="line">          data = rewinder.rewindAndGet();</span><br><span class="line">          <span class="comment">// 调用 ResourceDecoder.decode 解析数据</span></span><br><span class="line">          result = decoder.decode(data, width, height, options);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;</span><br><span class="line">				...</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到数据解析的任务最终是通过 DecodePath 来执行的, 它内部有三大步操作</p>
<ul>
<li>第一大步：deResource 将源数据解析成资源（源数据: InputStream，  中间产物: Bitmap）</li>
<li>第二大步：调用 DecodeCallback.onResourceDecoded 处理资源</li>
<li>第三大步：调用 ResourceTranscoder.transcode 将资源转为目标资源（目标资源类型: Drawable）</li>
</ul>
<p>可以发现，通过上面的 decoder.decode 源码可知，它是一个接口，由于我们这里的源数据是 InputStream,所以，它的实现类是 <strong>StreamBitmapDecoder类</strong> ,我们就来看下 它内部的解码过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(<span class="meta">@NonNull</span> InputStream source, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use to fix the mark limit to avoid allocating buffers that fit entire images.</span></span><br><span class="line">    <span class="keyword">final</span> RecyclableBufferedInputStream bufferedStream;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ownsBufferedStream;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据请求配置来对数据进行采样压缩，获取一个 Resource&lt;Bitmap&gt; </span></span><br><span class="line">      <span class="keyword">return</span> downsampler.decode(invalidatingStream, width, height, options, callbacks);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最终是通过downsampler去根据目标的宽高，来对输入数据流进行压缩。</p>
<p>回到主线中的三大步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//第一步： 调用 decodeResourec 将数据解析成中间资源 Bitmap</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">//第二步： 解析完数据回调出去</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//第三步： 转换资源为目标资源 Bitmap to Drawable</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>解析完数据，看第二注释里面回调，最后会回调到 DecodeJob：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line">      ...  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">onResourceDecoded</span><span class="params">(<span class="meta">@NonNull</span> Resource&lt;Z&gt; decoded)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DecodeJob.<span class="keyword">this</span>.onResourceDecoded(dataSource, decoded);</span><br><span class="line">    &#125; </span><br><span class="line">      ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synthetic</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  &lt;Z&gt; <span class="function">Resource&lt;Z&gt; <span class="title">onResourceDecoded</span><span class="params">(DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Resource&lt;Z&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取资源类型</span></span><br><span class="line">    Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();</span><br><span class="line">    Transformation&lt;Z&gt; appliedTransformation = <span class="keyword">null</span>;</span><br><span class="line">    Resource&lt;Z&gt; transformed = decoded;</span><br><span class="line">    <span class="comment">//如果不是从磁盘资源中获取需要进行 transform 操作</span></span><br><span class="line">    <span class="keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;</span><br><span class="line">      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);</span><br><span class="line">      transformed = appliedTransformation.transform(glideContext, decoded, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//构建数据编码的策略</span></span><br><span class="line">    <span class="keyword">final</span> EncodeStrategy encodeStrategy;</span><br><span class="line">    <span class="keyword">final</span> ResourceEncoder&lt;Z&gt; encoder;</span><br><span class="line">    <span class="keyword">if</span> (decodeHelper.isResourceEncoderAvailable(transformed)) &#123;</span><br><span class="line">      encoder = decodeHelper.getResultEncoder(transformed);</span><br><span class="line">      encodeStrategy = encoder.getEncodeStrategy(options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      encoder = <span class="keyword">null</span>;</span><br><span class="line">      encodeStrategy = EncodeStrategy.NONE;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//根据编码策略，构建缓存 Key</span></span><br><span class="line">    Resource&lt;Z&gt; result = transformed;</span><br><span class="line">    <span class="keyword">boolean</span> isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);</span><br><span class="line">    <span class="keyword">if</span> (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,</span><br><span class="line">        encodeStrategy)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (encoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Registry.NoResultEncoderAvailableException(transformed.get().getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> Key key;</span><br><span class="line">      <span class="keyword">switch</span> (encodeStrategy) &#123;</span><br><span class="line">        <span class="keyword">case</span> SOURCE:</span><br><span class="line">          <span class="comment">//源数据 key</span></span><br><span class="line">          key = <span class="keyword">new</span> DataCacheKey(currentSourceKey, signature);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">//... 省略 成吨的代码</span></span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">//初始化编码管理者，用于提交内存缓存</span></span><br><span class="line">      LockedResource&lt;Z&gt; lockedResult = LockedResource.obtain(transformed);</span><br><span class="line">      deferredEncodeManager.init(key, encoder, lockedResult);</span><br><span class="line">      result = lockedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回转换后的 Bitmap</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此处说白了， onResourceDecoded 中, 主要是对中间资源做了如下的操作：</p>
<p>   第一步：对资源进行了转换操作。比如 Fit_Center,CenterCrop, 这些都是在请求的时候配置的；</p>
<p>   第二步：构建磁盘缓存的 key。</p>
<p>资源解析完成，已经存入磁盘，此处开始对资源继续转换。</p>
<h4 id="4-6-资源转换"><a href="#4-6-资源转换" class="headerlink" title="4.6 资源转换"></a>4.6 资源转换</h4><p>从上一节我们通过解码inputstream流得到Bitmap，然而我们显示需要将Bitmap转化成Drawable。下面我们继续接着上一小节看看资源是如何转换的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-0d88a0936eb2e188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="资源转换.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodePath</span>&lt;<span class="title">DataType</span>, <span class="title">ResourceType</span>, <span class="title">Transcode</span>&gt; </span>&#123; </span><br><span class="line">  <span class="comment">//省略成吨的代码 ...  </span></span><br><span class="line">  <span class="function">Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">    <span class="comment">//第一步： 调用 decodeResourec 将数据解析成中间资源 Bitmap</span></span><br><span class="line">    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">    <span class="comment">//第二步： 解析完数据回调出去</span></span><br><span class="line">    Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">    <span class="comment">//第三步： 转换资源为目标资源 Bitmap to Drawable</span></span><br><span class="line">    <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略成吨的代码 ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续看第三步。通过源码可知，ResourceTranscoder 是一个接口，又因为解析完的数据是 Bitmap 所以它的实现类是 BitmapDrawableTranscoder ，最后看下它的 transcode 具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapDrawableTranscoder</span> <span class="keyword">implements</span> <span class="title">ResourceTranscoder</span>&lt;<span class="title">Bitmap</span>, <span class="title">BitmapDrawable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Resource&lt;BitmapDrawable&gt; <span class="title">transcode</span><span class="params">(<span class="meta">@NonNull</span> Resource&lt;Bitmap&gt; toTranscode,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Options options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LazyBitmapDrawableResource.obtain(resources, toTranscode);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBitmapDrawableResource</span> <span class="keyword">implements</span> <span class="title">Resource</span>&lt;<span class="title">BitmapDrawable</span>&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Initializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Resources resources;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Resource&lt;Bitmap&gt; bitmapResource;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyBitmapDrawableResource <span class="title">obtain</span><span class="params">(Context context, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        (LazyBitmapDrawableResource)</span><br><span class="line">            obtain(</span><br><span class="line">                context.getResources(),</span><br><span class="line">                BitmapResource.obtain(bitmap, Glide.get(context).getBitmapPool()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyBitmapDrawableResource <span class="title">obtain</span><span class="params">(Resources resources, BitmapPool bitmapPool,Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LazyBitmapDrawableResource) obtain(resources, BitmapResource.obtain(bitmap, bitmapPool));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource&lt;BitmapDrawable&gt; <span class="title">obtain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Resources resources, <span class="meta">@Nullable</span> Resource&lt;Bitmap&gt; bitmapResource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitmapResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyBitmapDrawableResource(resources, bitmapResource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazyBitmapDrawableResource</span><span class="params">(<span class="meta">@NonNull</span> Resources resources,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@NonNull</span> Resource&lt;Bitmap&gt; bitmapResource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resources = Preconditions.checkNotNull(resources);</span><br><span class="line">    <span class="keyword">this</span>.bitmapResource = Preconditions.checkNotNull(bitmapResource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;BitmapDrawable&gt; <span class="title">getResourceClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BitmapDrawable.class;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get 方法返回了一个 BitmapDrawable 对象</span></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BitmapDrawable <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BitmapDrawable(resources, bitmapResource.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitmapResource.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bitmapResource.recycle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitmapResource <span class="keyword">instanceof</span> Initializable) &#123;</span><br><span class="line">      ((Initializable) bitmapResource).initialize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化终于完成了 ，将我们解析到的 bitmap 存放到 LazyBitmapDrawableResource 内部, 然后外界通过 get 方法就可以获取到一个 BitmapDrawable 的对象了，解析完就到了展示数据了，请看下面代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecodeJob</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">DataFetcherGenerator</span>.<span class="title">FetcherReadyCallback</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Runnable</span>,</span></span><br><span class="line"><span class="class">    <span class="title">Comparable</span>&lt;<span class="title">DecodeJob</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Poolable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解析返回的数据</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//第一步： 调用 decodeFrom 解析 数据；HttpUrlFetcher , InputStream ,  currentDataSource</span></span><br><span class="line">      resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">      e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">      throwables.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步： 解析完成后，通知下去</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runGenerators();</span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>第一步就解析完了数据， 现在第二步执行 <strong>notifyEncodeAndRelease</strong>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//通知调用层数据已经装备好了</span></span><br><span class="line">    notifyComplete(result, dataSource);</span><br><span class="line"></span><br><span class="line">    stage = Stage.ENCODE;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这里就是将资源磁盘缓存</span></span><br><span class="line">      <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">        deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//完成</span></span><br><span class="line">    onEncodeComplete();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyComplete</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    setNotifiedOrThrow();</span><br><span class="line">    <span class="comment">// 在 DecodeJob 的构建中, 我们知道这个 Callback 是 EngineJob</span></span><br><span class="line">    callback.onResourceReady(resource, dataSource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的 DecodeJob.<strong>decodeFromRetrievedData</strong> 中主要做了三个处理：</p>
<p>  第一个处理：解析返回回来的资源。</p>
<p>  第二个处理：拿到解析的资源，如果配置了本地缓存，就缓存到磁盘。</p>
<p>  第三个处理：通知上层资源准备就绪，可以使用了。</p>
<p>我们直接看 EngineJob 的 onResourceReady 回调函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.resource = resource;</span><br><span class="line">     <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">   &#125;</span><br><span class="line">   notifyCallbacksOfResult();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Synthetic</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">notifyCallbacksOfResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ResourceCallbacksAndExecutors copy;</span><br><span class="line">   Key localKey;</span><br><span class="line">   EngineResource&lt;?&gt; localResource;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     stateVerifier.throwIfRecycled();</span><br><span class="line">     <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">       resource.recycle();</span><br><span class="line">       release();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cbs.isEmpty()) &#123;</span><br><span class="line">     ... </span><br><span class="line">     &#125;</span><br><span class="line">     engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class="line">     hasResource = <span class="keyword">true</span>;</span><br><span class="line">     copy = cbs.copy();</span><br><span class="line">     incrementPendingCallbacks(copy.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     localKey = key;</span><br><span class="line">     localResource = engineResource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//回调上层 Engine 任务完成了</span></span><br><span class="line">   listener.onEngineJobComplete(<span class="keyword">this</span>, localKey, localResource);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历资源回调给 ImageViewTarget </span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">     entry.executor.execute(<span class="keyword">new</span> CallResourceReady(entry.cb));</span><br><span class="line">   &#125;</span><br><span class="line">   decrementPendingCallbacks();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面 EngineJob 的 onResourceReady 回调函数 主要做了 两个处理：</p>
<p>​    第一个处理：通知上层任务完成。 </p>
<p>​    第二个处理：回调 ImageViewTarget 用于展示数据。</p>
<p>看下 listener.onEngineJobComplete 具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onEngineJobComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      resource.setResourceListener(key, <span class="keyword">this</span>);</span><br><span class="line">			<span class="comment">//收到下游返回回来的资源，添加到活动缓存中</span></span><br><span class="line">      <span class="keyword">if</span> (resource.isCacheable()) &#123;</span><br><span class="line">        activeResources.activate(key, resource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jobs.removeIfCurrent(key, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最终通知 ImageViewTarget, 看下具体操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历资源回调给 ImageViewTarget </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">      entry.executor.execute(<span class="keyword">new</span> CallResourceReady(entry.cb));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CallResourceReady</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ResourceCallback cb;</span><br><span class="line"></span><br><span class="line">   CallResourceReady(ResourceCallback cb) &#123;</span><br><span class="line">     <span class="keyword">this</span>.cb = cb;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (EngineJob.<span class="keyword">this</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (cbs.contains(cb)) &#123;</span><br><span class="line">        ...</span><br><span class="line">         <span class="comment">//返回准备好的资源</span></span><br><span class="line">         callCallbackOnResourceReady(cb);</span><br><span class="line">         removeCallback(cb);</span><br><span class="line">       &#125;</span><br><span class="line">       decrementPendingCallbacks();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 CallResourceReady 实现 Runnable ，当 entry.executor.execute 线程池执行的时候就会调用 run ，最后我们继续跟 callCallbackOnResourceReady函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synthetic</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">callCallbackOnResourceReady</span><span class="params">(ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//回调给 SingleRequest</span></span><br><span class="line">    cb.onResourceReady(engineResource, dataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CallbackException(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleRequest onResourceReady 回调实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    loadStatus = <span class="keyword">null</span>;</span><br><span class="line">    ... 省略成吨的代码</span><br><span class="line">    Object received = resource.get();</span><br><span class="line">    <span class="keyword">if</span> (received == <span class="keyword">null</span> || !transcodeClass.isAssignableFrom(received.getClass())) &#123;</span><br><span class="line">      releaseResource(resource);</span><br><span class="line">      ... 省略成吨的代码</span><br><span class="line">      onLoadFailed(exception);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canSetResource()) &#123;</span><br><span class="line">      releaseResource(resource);</span><br><span class="line">      status = Status.COMPLETE;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当资源准备好的时候</span></span><br><span class="line">    onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">      ... 省略成吨的代码</span><br><span class="line">      anyListenerHandledUpdatingTarget |=</span><br><span class="line">          targetListener != <span class="keyword">null</span></span><br><span class="line">              &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">        Transition&lt;? <span class="keyword">super</span> R&gt; animation =</span><br><span class="line">            animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">        <span class="comment">//回调给目标 ImageViewTarget 资源准备好了</span></span><br><span class="line">        target.onResourceReady(result, animation);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//加载成功</span></span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这一步主要把准备好的资源回调给显示层!!!!!!!   终于快看到胜利的曙光了。</p>
<h4 id="4-7-显示资源"><a href="#4-7-显示资源" class="headerlink" title="4.7 显示资源"></a>4.7 显示资源</h4><p>资源终于完全准备好了，下面就是加载资源到控件上。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-e81033e60884ea86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载资源到控件上.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Z</span>&gt; <span class="keyword">extends</span> <span class="title">ViewTarget</span>&lt;<span class="title">ImageView</span>, <span class="title">Z</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Transition</span>.<span class="title">ViewAdapter</span> </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="meta">@NonNull</span> Z resource, <span class="meta">@Nullable</span> Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">      setResourceInternal(resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maybeUpdateAnimatable(resource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(<span class="meta">@Nullable</span> Z resource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用 setResource 函数，将资源显示出来</span></span><br><span class="line">    setResource(resource);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>大家还记得么？在最开始构建的时候，我们知道只有调用 asBitmap 的时候实现类是 <code>BitmapImageViewTarget</code>,在这里的测试，并没有调用这个函数，所以它的实现类是 <code>DrawableImageViewTarget</code>,具体看下它内部实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableImageViewTarget</span> <span class="keyword">extends</span> <span class="title">ImageViewTarget</span>&lt;<span class="title">Drawable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Public API.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrawableImageViewTarget</span><span class="params">(ImageView view, <span class="keyword">boolean</span> waitForLayout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(view, waitForLayout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(<span class="meta">@Nullable</span> Drawable resource)</span> </span>&#123;</span><br><span class="line">    view.setImageDrawable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看到抽象类中调用了 setResource ,子类实现并调用了 <strong>view.setImageDrawable(resource);</strong> 图片现在算是真正的显示出来了。</p>
]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>-Glide</tag>
      </tags>
  </entry>
  <entry>
    <title>解析dumpsys gfxinfo</title>
    <url>/2021/08/14/%E8%A7%A3%E6%9E%90dumpsys-gfxinfo/</url>
    <content><![CDATA[<h4 id="1-车机原始数据"><a href="#1-车机原始数据" class="headerlink" title="1.车机原始数据"></a>1.车机原始数据</h4><p>用户界面（UI）性能测试不仅可以确保app满足其功能要求，而且能够保证用户与app之间的交互是相当平滑的——以每秒60帧的速度运行，即每一帧之间间隔<code>16.6ms</code>以内就认为没有丢帧，否者就会丢帧。</p>
<p>多媒体应用一般都是UI卡顿的重灾区，因此这次我们拿聚媒体应用来试试水。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">** Graphics info <span class="keyword">for</span> pid <span class="number">2782</span> [com.iflytek.autofly.mediax] **</span><br><span class="line"></span><br><span class="line">Stats since: 168653953578ns</span><br><span class="line">Total frames rendered: <span class="number">16300</span></span><br><span class="line">Janky frames: <span class="number">4401</span> (<span class="number">27.00</span>%)</span><br><span class="line">50th percentile: 7ms</span><br><span class="line">90th percentile: 27ms</span><br><span class="line">95th percentile: 36ms</span><br><span class="line">99th percentile: 61ms</span><br><span class="line">Number Missed Vsync: <span class="number">383</span></span><br><span class="line">Number High input latency: <span class="number">5239</span></span><br><span class="line">Number Slow UI thread: <span class="number">1001</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">9</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">428</span></span><br><span class="line">Number Frame deadline missed: <span class="number">1389</span></span><br><span class="line">HISTOGRAM: 5ms=<span class="number">5635</span> 6ms=<span class="number">1499</span> 7ms=<span class="number">1203</span> 8ms=<span class="number">842</span> 9ms=<span class="number">578</span> 10ms=<span class="number">453</span> 11ms=<span class="number">408</span> 12ms=<span class="number">316</span> 13ms=<span class="number">298</span> 14ms=<span class="number">240</span> 15ms=<span class="number">240</span> 16ms=<span class="number">281</span> 17ms=<span class="number">304</span> 18ms=<span class="number">316</span> 19ms=<span class="number">330</span> 20ms=<span class="number">289</span> 21ms=<span class="number">287</span> 22ms=<span class="number">236</span> 23ms=<span class="number">195</span> 24ms=<span class="number">217</span> 25ms=<span class="number">191</span> 26ms=<span class="number">149</span> 27ms=<span class="number">164</span> 28ms=<span class="number">134</span> 29ms=<span class="number">136</span> 30ms=<span class="number">122</span> 31ms=<span class="number">100</span> 32ms=<span class="number">148</span> 34ms=<span class="number">127</span> 36ms=<span class="number">130</span> 38ms=<span class="number">108</span> 40ms=<span class="number">102</span> 42ms=<span class="number">70</span> 44ms=<span class="number">46</span> 46ms=<span class="number">41</span> 48ms=<span class="number">63</span> 53ms=<span class="number">63</span> 57ms=<span class="number">53</span> 61ms=<span class="number">50</span> 65ms=<span class="number">14</span> 69ms=<span class="number">30</span> 73ms=<span class="number">17</span> 77ms=<span class="number">21</span> 81ms=<span class="number">14</span> 85ms=<span class="number">12</span> 89ms=<span class="number">6</span> 93ms=<span class="number">4</span> 97ms=<span class="number">2</span> 101ms=<span class="number">2</span> 105ms=<span class="number">1</span> 109ms=<span class="number">3</span> 113ms=<span class="number">3</span> 117ms=<span class="number">0</span> 121ms=<span class="number">1</span> 125ms=<span class="number">1</span> 129ms=<span class="number">2</span> 133ms=<span class="number">0</span> 150ms=<span class="number">3</span> 200ms=<span class="number">0</span> 250ms=<span class="number">0</span> 300ms=<span class="number">0</span> 350ms=<span class="number">0</span> 400ms=<span class="number">0</span> 450ms=<span class="number">0</span> 500ms=<span class="number">0</span> 550ms=<span class="number">0</span> 600ms=<span class="number">0</span> 650ms=<span class="number">0</span> 700ms=<span class="number">0</span> 750ms=<span class="number">0</span> 800ms=<span class="number">0</span> 850ms=<span class="number">0</span> 900ms=<span class="number">0</span> 950ms=<span class="number">0</span> 1000ms=<span class="number">0</span> 1050ms=<span class="number">0</span> 1100ms=<span class="number">0</span> 1150ms=<span class="number">0</span> 1200ms=<span class="number">0</span> 1250ms=<span class="number">0</span> 1300ms=<span class="number">0</span> 1350ms=<span class="number">0</span> 1400ms=<span class="number">0</span> 1450ms=<span class="number">0</span> 1500ms=<span class="number">0</span> 1550ms=<span class="number">0</span> 1600ms=<span class="number">0</span> 1650ms=<span class="number">0</span> 1700ms=<span class="number">0</span> 1750ms=<span class="number">0</span> 1800ms=<span class="number">0</span> 1850ms=<span class="number">0</span> 1900ms=<span class="number">0</span> 1950ms=<span class="number">0</span> 2000ms=<span class="number">0</span> 2050ms=<span class="number">0</span> 2100ms=<span class="number">0</span> 2150ms=<span class="number">0</span> 2200ms=<span class="number">0</span> 2250ms=<span class="number">0</span> 2300ms=<span class="number">0</span> 2350ms=<span class="number">0</span> 2400ms=<span class="number">0</span> 2450ms=<span class="number">0</span> 2500ms=<span class="number">0</span> 2550ms=<span class="number">0</span> 2600ms=<span class="number">0</span> 2650ms=<span class="number">0</span> 2700ms=<span class="number">0</span> 2750ms=<span class="number">0</span> 2800ms=<span class="number">0</span> 2850ms=<span class="number">0</span> 2900ms=<span class="number">0</span> 2950ms=<span class="number">0</span> 3000ms=<span class="number">0</span> 3050ms=<span class="number">0</span> 3100ms=<span class="number">0</span> 3150ms=<span class="number">0</span> 3200ms=<span class="number">0</span> 3250ms=<span class="number">0</span> 3300ms=<span class="number">0</span> 3350ms=<span class="number">0</span> 3400ms=<span class="number">0</span> 3450ms=<span class="number">0</span> 3500ms=<span class="number">0</span> 3550ms=<span class="number">0</span> 3600ms=<span class="number">0</span> 3650ms=<span class="number">0</span> 3700ms=<span class="number">0</span> 3750ms=<span class="number">0</span> 3800ms=<span class="number">0</span> 3850ms=<span class="number">0</span> 3900ms=<span class="number">0</span> 3950ms=<span class="number">0</span> 4000ms=<span class="number">0</span> 4050ms=<span class="number">0</span> 4100ms=<span class="number">0</span> 4150ms=<span class="number">0</span> 4200ms=<span class="number">0</span> 4250ms=<span class="number">0</span> 4300ms=<span class="number">0</span> 4350ms=<span class="number">0</span> 4400ms=<span class="number">0</span> 4450ms=<span class="number">0</span> 4500ms=<span class="number">0</span> 4550ms=<span class="number">0</span> 4600ms=<span class="number">0</span> 4650ms=<span class="number">0</span> 4700ms=<span class="number">0</span> 4750ms=<span class="number">0</span> 4800ms=<span class="number">0</span> 4850ms=<span class="number">0</span> 4900ms=<span class="number">0</span> 4950ms=<span class="number">0</span></span><br><span class="line"><span class="function">Font <span class="title">Cache</span> <span class="params">(CPU)</span>:</span></span><br><span class="line"><span class="function">  Size: 735.71 kB </span></span><br><span class="line"><span class="function">  Glyph Count: 65 </span></span><br><span class="line"><span class="function">CPU Caches:</span></span><br><span class="line"><span class="function">GPU Caches:</span></span><br><span class="line"><span class="function">  Other:</span></span><br><span class="line"><span class="function">    Buffer Object: 63.00 <span class="title">KB</span> <span class="params">(<span class="number">2</span> entries)</span></span></span><br><span class="line"><span class="function">  Image:</span></span><br><span class="line"><span class="function">    Texture: 15.76 <span class="title">MB</span> <span class="params">(<span class="number">12</span> entries)</span></span></span><br><span class="line"><span class="function">  Scratch:</span></span><br><span class="line"><span class="function">    Buffer Object: 64.00 <span class="title">KB</span> <span class="params">(<span class="number">2</span> entries)</span></span></span><br><span class="line"><span class="function">    Texture: 1.00 <span class="title">MB</span> <span class="params">(<span class="number">1</span> entry)</span></span></span><br><span class="line"><span class="function">Other Caches:</span></span><br><span class="line"><span class="function">                         Current / Maximum</span></span><br><span class="line"><span class="function">  VectorDrawableAtlas    0.00 kB /   0.00 <span class="title">KB</span> <span class="params">(entries = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">  Layers Total           0.00 <span class="title">KB</span> <span class="params">(numLayers = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">Total GPU memory usage:</span></span><br><span class="line"><span class="function">  17703664 bytes, 16.88 <span class="title">MB</span> <span class="params">(<span class="number">15.88</span> MB is purgeable)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Pipeline</span>=Skia (OpenGL)</span><br><span class="line"></span><br><span class="line">Layout Cache Info:</span><br><span class="line">  Usage: <span class="number">878</span>/<span class="number">5000</span> entries</span><br><span class="line">  Hit ratio: <span class="number">72934</span>/<span class="number">73812</span> (<span class="number">0.988105</span>)</span><br><span class="line">Profile data in ms:</span><br><span class="line"></span><br><span class="line">	com.iflytek.autofly.mediax/com.iflytek.autofly.localmusic.MainActivity/android.view.ViewRootImpl<span class="meta">@bd9aa6d</span> (visibility=<span class="number">8</span>)</span><br><span class="line">Window: com.iflytek.autofly.mediax/com.iflytek.autofly.localmusic.MainActivity</span><br><span class="line">Stats since: 168661745661ns</span><br><span class="line">Total frames rendered: <span class="number">9420</span></span><br><span class="line">Janky frames: <span class="number">1831</span> (<span class="number">19.44</span>%)</span><br><span class="line">50th percentile: 7ms</span><br><span class="line">90th percentile: 26ms</span><br><span class="line">95th percentile: 34ms</span><br><span class="line">99th percentile: 57ms</span><br><span class="line">Number Missed Vsync: <span class="number">194</span></span><br><span class="line">Number High input latency: <span class="number">1991</span></span><br><span class="line">Number Slow UI thread: <span class="number">453</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">5</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">223</span></span><br><span class="line">Number Frame deadline missed: <span class="number">673</span></span><br><span class="line">HISTOGRAM: 5ms=<span class="number">3610</span> 6ms=<span class="number">985</span> 7ms=<span class="number">808</span> 8ms=<span class="number">562</span> 9ms=<span class="number">406</span> 10ms=<span class="number">291</span> 11ms=<span class="number">274</span> 12ms=<span class="number">183</span> 13ms=<span class="number">162</span> 14ms=<span class="number">131</span> 15ms=<span class="number">102</span> 16ms=<span class="number">104</span> 17ms=<span class="number">80</span> 18ms=<span class="number">89</span> 19ms=<span class="number">104</span> 20ms=<span class="number">96</span> 21ms=<span class="number">117</span> 22ms=<span class="number">100</span> 23ms=<span class="number">82</span> 24ms=<span class="number">104</span> 25ms=<span class="number">77</span> 26ms=<span class="number">73</span> 27ms=<span class="number">78</span> 28ms=<span class="number">61</span> 29ms=<span class="number">72</span> 30ms=<span class="number">61</span> 31ms=<span class="number">42</span> 32ms=<span class="number">80</span> 34ms=<span class="number">59</span> 36ms=<span class="number">60</span> 38ms=<span class="number">54</span> 40ms=<span class="number">55</span> 42ms=<span class="number">36</span> 44ms=<span class="number">25</span> 46ms=<span class="number">22</span> 48ms=<span class="number">36</span> 53ms=<span class="number">34</span> 57ms=<span class="number">35</span> 61ms=<span class="number">21</span> 65ms=<span class="number">6</span> 69ms=<span class="number">14</span> 73ms=<span class="number">3</span> 77ms=<span class="number">7</span> 81ms=<span class="number">5</span> 85ms=<span class="number">4</span> 89ms=<span class="number">1</span> 93ms=<span class="number">2</span> 97ms=<span class="number">1</span> 101ms=<span class="number">2</span> 105ms=<span class="number">0</span> 109ms=<span class="number">1</span> 113ms=<span class="number">0</span> 117ms=<span class="number">0</span> 121ms=<span class="number">0</span> 125ms=<span class="number">1</span> 129ms=<span class="number">1</span> 133ms=<span class="number">0</span> 150ms=<span class="number">1</span> 200ms=<span class="number">0</span> 250ms=<span class="number">0</span> 300ms=<span class="number">0</span> 350ms=<span class="number">0</span> 400ms=<span class="number">0</span> 450ms=<span class="number">0</span> 500ms=<span class="number">0</span> 550ms=<span class="number">0</span> 600ms=<span class="number">0</span> 650ms=<span class="number">0</span> 700ms=<span class="number">0</span> 750ms=<span class="number">0</span> 800ms=<span class="number">0</span> 850ms=<span class="number">0</span> 900ms=<span class="number">0</span> 950ms=<span class="number">0</span> 1000ms=<span class="number">0</span> 1050ms=<span class="number">0</span> 1100ms=<span class="number">0</span> 1150ms=<span class="number">0</span> 1200ms=<span class="number">0</span> 1250ms=<span class="number">0</span> 1300ms=<span class="number">0</span> 1350ms=<span class="number">0</span> 1400ms=<span class="number">0</span> 1450ms=<span class="number">0</span> 1500ms=<span class="number">0</span> 1550ms=<span class="number">0</span> 1600ms=<span class="number">0</span> 1650ms=<span class="number">0</span> 1700ms=<span class="number">0</span> 1750ms=<span class="number">0</span> 1800ms=<span class="number">0</span> 1850ms=<span class="number">0</span> 1900ms=<span class="number">0</span> 1950ms=<span class="number">0</span> 2000ms=<span class="number">0</span> 2050ms=<span class="number">0</span> 2100ms=<span class="number">0</span> 2150ms=<span class="number">0</span> 2200ms=<span class="number">0</span> 2250ms=<span class="number">0</span> 2300ms=<span class="number">0</span> 2350ms=<span class="number">0</span> 2400ms=<span class="number">0</span> 2450ms=<span class="number">0</span> 2500ms=<span class="number">0</span> 2550ms=<span class="number">0</span> 2600ms=<span class="number">0</span> 2650ms=<span class="number">0</span> 2700ms=<span class="number">0</span> 2750ms=<span class="number">0</span> 2800ms=<span class="number">0</span> 2850ms=<span class="number">0</span> 2900ms=<span class="number">0</span> 2950ms=<span class="number">0</span> 3000ms=<span class="number">0</span> 3050ms=<span class="number">0</span> 3100ms=<span class="number">0</span> 3150ms=<span class="number">0</span> 3200ms=<span class="number">0</span> 3250ms=<span class="number">0</span> 3300ms=<span class="number">0</span> 3350ms=<span class="number">0</span> 3400ms=<span class="number">0</span> 3450ms=<span class="number">0</span> 3500ms=<span class="number">0</span> 3550ms=<span class="number">0</span> 3600ms=<span class="number">0</span> 3650ms=<span class="number">0</span> 3700ms=<span class="number">0</span> 3750ms=<span class="number">0</span> 3800ms=<span class="number">0</span> 3850ms=<span class="number">0</span> 3900ms=<span class="number">0</span> 3950ms=<span class="number">0</span> 4000ms=<span class="number">0</span> 4050ms=<span class="number">0</span> 4100ms=<span class="number">0</span> 4150ms=<span class="number">0</span> 4200ms=<span class="number">0</span> 4250ms=<span class="number">0</span> 4300ms=<span class="number">0</span> 4350ms=<span class="number">0</span> 4400ms=<span class="number">0</span> 4450ms=<span class="number">0</span> 4500ms=<span class="number">0</span> 4550ms=<span class="number">0</span> 4600ms=<span class="number">0</span> 4650ms=<span class="number">0</span> 4700ms=<span class="number">0</span> 4750ms=<span class="number">0</span> 4800ms=<span class="number">0</span> 4850ms=<span class="number">0</span> 4900ms=<span class="number">0</span> 4950ms=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line"><span class="number">0</span>,<span class="number">3316999928968</span>,<span class="number">3316999928968</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">3317001414877</span>,<span class="number">3317001423627</span>,<span class="number">3317001424304</span>,<span class="number">3317001474981</span>,<span class="number">3317001537845</span>,<span class="number">3317001629877</span>,<span class="number">3317001778731</span>,<span class="number">3317003556439</span>,<span class="number">3317005974981</span>,<span class="number">292000</span>,<span class="number">129000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">3317149946849</span>,<span class="number">3317166613515</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">3317170658991</span>,<span class="number">3317170670502</span>,<span class="number">3317170742377</span>,<span class="number">3317170770866</span>,<span class="number">3317170824252</span>,<span class="number">3317173412793</span>,<span class="number">3317173569304</span>,<span class="number">3317174317064</span>,<span class="number">3317179209824</span>,<span class="number">154000</span>,<span class="number">218000</span>,</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>,<span class="number">13708316673586</span>,<span class="number">13708316673586</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13708317381173</span>,<span class="number">13708317392163</span>,<span class="number">13708317392840</span>,<span class="number">13708317425236</span>,<span class="number">13708317536225</span>,<span class="number">13708317587006</span>,<span class="number">13708317634298</span>,<span class="number">13708327112058</span>,<span class="number">13708341493725</span>,<span class="number">464000</span>,<span class="number">283000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">13709633291209</span>,<span class="number">13709649957875</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13709654350548</span>,<span class="number">13709654366068</span>,<span class="number">13709654366798</span>,<span class="number">13709654399662</span>,<span class="number">13709654863829</span>,<span class="number">13709655191850</span>,<span class="number">13709655336798</span>,<span class="number">13709661776641</span>,<span class="number">13709664536798</span>,<span class="number">1011000</span>,<span class="number">550000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">13709666630708</span>,<span class="number">13709666630708</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13709678109402</span>,<span class="number">13709678127475</span>,<span class="number">13709678128620</span>,<span class="number">13709678197214</span>,<span class="number">13709678387318</span>,<span class="number">13709678525912</span>,<span class="number">13709678730548</span>,<span class="number">13709684361225</span>,<span class="number">13709686905600</span>,<span class="number">156000</span>,<span class="number">397000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">15773249439770</span>,<span class="number">15773249439770</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">15773251623927</span>,<span class="number">15773251670490</span>,<span class="number">15773251671219</span>,<span class="number">15773251732104</span>,<span class="number">15773251848719</span>,<span class="number">15773251875125</span>,<span class="number">15773251923406</span>,<span class="number">15773256408979</span>,<span class="number">15773264913771</span>,<span class="number">1008000</span>,<span class="number">2923000</span>,</span><br><span class="line">---PROFILEDATA---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	PopupWindow:a4ff523/android.view.ViewRootImpl<span class="meta">@ae8f6a2</span> (visibility=<span class="number">8</span>)</span><br><span class="line">Window: PopupWindow:a4ff523</span><br><span class="line">Stats since: 216927875278ns</span><br><span class="line">Total frames rendered: <span class="number">718</span></span><br><span class="line">Janky frames: <span class="number">580</span> (<span class="number">80.78</span>%)</span><br><span class="line">50th percentile: 26ms</span><br><span class="line">90th percentile: 57ms</span><br><span class="line">95th percentile: 73ms</span><br><span class="line">99th percentile: 105ms</span><br><span class="line">Number Missed Vsync: <span class="number">110</span></span><br><span class="line">Number High input latency: <span class="number">275</span></span><br><span class="line">Number Slow UI thread: <span class="number">331</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">2</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">3</span></span><br><span class="line">Number Frame deadline missed: <span class="number">336</span></span><br><span class="line">HISTOGRAM: 5ms=<span class="number">12</span> 6ms=<span class="number">6</span> 7ms=<span class="number">2</span> 8ms=<span class="number">4</span> 9ms=<span class="number">1</span> 10ms=<span class="number">11</span> 11ms=<span class="number">6</span> 12ms=<span class="number">14</span> 13ms=<span class="number">24</span> 14ms=<span class="number">27</span> 15ms=<span class="number">17</span> 16ms=<span class="number">17</span> 17ms=<span class="number">18</span> 18ms=<span class="number">21</span> 19ms=<span class="number">21</span> 20ms=<span class="number">24</span> 21ms=<span class="number">25</span> 22ms=<span class="number">16</span> 23ms=<span class="number">29</span> 24ms=<span class="number">27</span> 25ms=<span class="number">27</span> 26ms=<span class="number">17</span> 27ms=<span class="number">25</span> 28ms=<span class="number">21</span> 29ms=<span class="number">15</span> 30ms=<span class="number">18</span> 31ms=<span class="number">17</span> 32ms=<span class="number">17</span> 34ms=<span class="number">21</span> 36ms=<span class="number">29</span> 38ms=<span class="number">28</span> 40ms=<span class="number">19</span> 42ms=<span class="number">19</span> 44ms=<span class="number">9</span> 46ms=<span class="number">10</span> 48ms=<span class="number">15</span> 53ms=<span class="number">14</span> 57ms=<span class="number">8</span> 61ms=<span class="number">15</span> 65ms=<span class="number">5</span> 69ms=<span class="number">9</span> 73ms=<span class="number">9</span> 77ms=<span class="number">9</span> 81ms=<span class="number">5</span> 85ms=<span class="number">3</span> 89ms=<span class="number">3</span> 93ms=<span class="number">0</span> 97ms=<span class="number">1</span> 101ms=<span class="number">0</span> 105ms=<span class="number">1</span> 109ms=<span class="number">2</span> 113ms=<span class="number">2</span> 117ms=<span class="number">0</span> 121ms=<span class="number">1</span> 125ms=<span class="number">0</span> 129ms=<span class="number">1</span> 133ms=<span class="number">0</span> 150ms=<span class="number">1</span> 200ms=<span class="number">0</span> 250ms=<span class="number">0</span> 300ms=<span class="number">0</span> 350ms=<span class="number">0</span> 400ms=<span class="number">0</span> 450ms=<span class="number">0</span> 500ms=<span class="number">0</span> 550ms=<span class="number">0</span> 600ms=<span class="number">0</span> 650ms=<span class="number">0</span> 700ms=<span class="number">0</span> 750ms=<span class="number">0</span> 800ms=<span class="number">0</span> 850ms=<span class="number">0</span> 900ms=<span class="number">0</span> 950ms=<span class="number">0</span> 1000ms=<span class="number">0</span> 1050ms=<span class="number">0</span> 1100ms=<span class="number">0</span> 1150ms=<span class="number">0</span> 1200ms=<span class="number">0</span> 1250ms=<span class="number">0</span> 1300ms=<span class="number">0</span> 1350ms=<span class="number">0</span> 1400ms=<span class="number">0</span> 1450ms=<span class="number">0</span> 1500ms=<span class="number">0</span> 1550ms=<span class="number">0</span> 1600ms=<span class="number">0</span> 1650ms=<span class="number">0</span> 1700ms=<span class="number">0</span> 1750ms=<span class="number">0</span> 1800ms=<span class="number">0</span> 1850ms=<span class="number">0</span> 1900ms=<span class="number">0</span> 1950ms=<span class="number">0</span> 2000ms=<span class="number">0</span> 2050ms=<span class="number">0</span> 2100ms=<span class="number">0</span> 2150ms=<span class="number">0</span> 2200ms=<span class="number">0</span> 2250ms=<span class="number">0</span> 2300ms=<span class="number">0</span> 2350ms=<span class="number">0</span> 2400ms=<span class="number">0</span> 2450ms=<span class="number">0</span> 2500ms=<span class="number">0</span> 2550ms=<span class="number">0</span> 2600ms=<span class="number">0</span> 2650ms=<span class="number">0</span> 2700ms=<span class="number">0</span> 2750ms=<span class="number">0</span> 2800ms=<span class="number">0</span> 2850ms=<span class="number">0</span> 2900ms=<span class="number">0</span> 2950ms=<span class="number">0</span> 3000ms=<span class="number">0</span> 3050ms=<span class="number">0</span> 3100ms=<span class="number">0</span> 3150ms=<span class="number">0</span> 3200ms=<span class="number">0</span> 3250ms=<span class="number">0</span> 3300ms=<span class="number">0</span> 3350ms=<span class="number">0</span> 3400ms=<span class="number">0</span> 3450ms=<span class="number">0</span> 3500ms=<span class="number">0</span> 3550ms=<span class="number">0</span> 3600ms=<span class="number">0</span> 3650ms=<span class="number">0</span> 3700ms=<span class="number">0</span> 3750ms=<span class="number">0</span> 3800ms=<span class="number">0</span> 3850ms=<span class="number">0</span> 3900ms=<span class="number">0</span> 3950ms=<span class="number">0</span> 4000ms=<span class="number">0</span> 4050ms=<span class="number">0</span> 4100ms=<span class="number">0</span> 4150ms=<span class="number">0</span> 4200ms=<span class="number">0</span> 4250ms=<span class="number">0</span> 4300ms=<span class="number">0</span> 4350ms=<span class="number">0</span> 4400ms=<span class="number">0</span> 4450ms=<span class="number">0</span> 4500ms=<span class="number">0</span> 4550ms=<span class="number">0</span> 4600ms=<span class="number">0</span> 4650ms=<span class="number">0</span> 4700ms=<span class="number">0</span> 4750ms=<span class="number">0</span> 4800ms=<span class="number">0</span> 4850ms=<span class="number">0</span> 4900ms=<span class="number">0</span> 4950ms=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line"><span class="number">1</span>,<span class="number">922183814197</span>,<span class="number">922183814197</span>,<span class="number">922163445000</span>,<span class="number">922171445000</span>,<span class="number">922184357353</span>,<span class="number">922185729853</span>,<span class="number">922185852144</span>,<span class="number">922189057874</span>,<span class="number">922189297457</span>,<span class="number">922190196363</span>,<span class="number">922190289332</span>,<span class="number">922192776051</span>,<span class="number">922196442144</span>,<span class="number">1815000</span>,<span class="number">193000</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">922217156051</span>,<span class="number">922250489383</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">922255031571</span>,<span class="number">922255055269</span>,<span class="number">922255798967</span>,<span class="number">922265472092</span>,<span class="number">922265566988</span>,<span class="number">922265638811</span>,<span class="number">922265692144</span>,<span class="number">922266163290</span>,<span class="number">922267312665</span>,<span class="number">66000</span>,<span class="number">101000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">924267114653</span>,<span class="number">924267114653</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">924268181571</span>,<span class="number">924268201623</span>,<span class="number">924268202664</span>,<span class="number">924268676414</span>,<span class="number">924268727091</span>,<span class="number">924268836466</span>,<span class="number">924268924800</span>,<span class="number">924269442300</span>,<span class="number">924271069852</span>,<span class="number">185000</span>,<span class="number">247000</span>,</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>,<span class="number">13088316501813</span>,<span class="number">13088316501813</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13088317970316</span>,<span class="number">13088317997503</span>,<span class="number">13088317998545</span>,<span class="number">13088318102399</span>,<span class="number">13088318257399</span>,<span class="number">13088318392139</span>,<span class="number">13088318423962</span>,<span class="number">13088322688233</span>,<span class="number">13088323788337</span>,<span class="number">1166000</span>,<span class="number">291000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">13090483121111</span>,<span class="number">13090483121111</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13090493434482</span>,<span class="number">13090493449534</span>,<span class="number">13090493450263</span>,<span class="number">13090493477346</span>,<span class="number">13090493505784</span>,<span class="number">13090493682034</span>,<span class="number">13090493714742</span>,<span class="number">13090500268284</span>,<span class="number">13090502717555</span>,<span class="number">2523000</span>,<span class="number">536000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">13092649821669</span>,<span class="number">13092649821669</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13092660657658</span>,<span class="number">13092660672606</span>,<span class="number">13092660673283</span>,<span class="number">13092660757345</span>,<span class="number">13092660785679</span>,<span class="number">13092661141564</span>,<span class="number">13092661175158</span>,<span class="number">13092663018595</span>,<span class="number">13092666056564</span>,<span class="number">401000</span>,<span class="number">803000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">13698799872395</span>,<span class="number">13698799872395</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13698800780187</span>,<span class="number">13698800795708</span>,<span class="number">13698800796489</span>,<span class="number">13698800832583</span>,<span class="number">13698800868364</span>,<span class="number">13698801056177</span>,<span class="number">13698801076073</span>,<span class="number">13698803020656</span>,<span class="number">13698804379250</span>,<span class="number">391000</span>,<span class="number">519000</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">13709633291209</span>,<span class="number">13709649957875</span>,<span class="number">9223372036854775807</span>,<span class="number">0</span>,<span class="number">13709654350548</span>,<span class="number">13709654366068</span>,<span class="number">13709654366798</span>,<span class="number">13709655434766</span>,<span class="number">13709655447787</span>,<span class="number">13709664635027</span>,<span class="number">13709664742423</span>,<span class="number">13709666301277</span>,<span class="number">13709670211173</span>,<span class="number">125000</span>,<span class="number">238000</span>,</span><br><span class="line">---PROFILEDATA---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">View hierarchy:</span><br><span class="line"></span><br><span class="line">  com.iflytek.autofly.mediax/com.iflytek.autofly.localmusic.MainActivity/android.view.ViewRootImpl<span class="meta">@bd9aa6d</span></span><br><span class="line">  <span class="number">33</span> views, <span class="number">34.29</span> kB of display lists</span><br><span class="line"></span><br><span class="line">  PopupWindow:a4ff523/android.view.ViewRootImpl<span class="meta">@ae8f6a2</span></span><br><span class="line">  <span class="number">5</span> views, <span class="number">5.20</span> kB of display lists</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total ViewRootImpl: <span class="number">2</span></span><br><span class="line">Total Views:        <span class="number">38</span></span><br><span class="line">Total DisplayList:  <span class="number">39.48</span> kB</span><br></pre></td></tr></table></figure>


<h4 id="2-分析头数据"><a href="#2-分析头数据" class="headerlink" title="2.分析头数据"></a>2.分析头数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">** Graphics info <span class="keyword">for</span> pid <span class="number">2782</span> [com.iflytek.autofly.mediax] **  <span class="comment">// 表明当前dump的为聚媒体应用界面的帧信息，pid为2782</span></span><br><span class="line"></span><br><span class="line">Stats since: 168653953578ns</span><br><span class="line">Total frames rendered: <span class="number">16300</span>   <span class="comment">//本次dump搜集了16300帧的信息</span></span><br><span class="line">Janky frames: <span class="number">4401</span> (<span class="number">27.00</span>%)  <span class="comment">// 16300帧中有4401帧的耗时超过了16ms，卡顿概率为27.00%</span></span><br><span class="line">50th percentile: 7ms</span><br><span class="line">90th percentile: 27ms</span><br><span class="line">95th percentile: 36ms</span><br><span class="line">99th percentile: 61ms</span><br><span class="line">Number Missed Vsync: <span class="number">383</span>   <span class="comment">//  垂直同步失败的帧</span></span><br><span class="line">Number High input latency: <span class="number">5239</span>  <span class="comment">// 处理input事件超时的帧数</span></span><br><span class="line">Number Slow UI thread: <span class="number">1001</span>  <span class="comment">// 因UI线程上的工作导致超时的帧数</span></span><br><span class="line">Number Slow bitmap uploads: <span class="number">9</span>   <span class="comment">// 因bitmap的加载耗时的帧数</span></span><br><span class="line">Number Slow issue draw commands: <span class="number">428</span>  <span class="comment">// 因绘制导致耗时的帧数</span></span><br><span class="line">Number Frame deadline missed: <span class="number">1389</span></span><br><span class="line">HISTOGRAM: 5ms=<span class="number">12</span> 6ms=<span class="number">6</span> 7ms=<span class="number">2</span> 8ms=<span class="number">4</span> 9ms=<span class="number">1</span> 10ms=<span class="number">11</span> 11ms=<span class="number">6</span> 12ms=<span class="number">14</span> 13ms=<span class="number">24</span> 14ms=<span class="number">27</span> 15ms=<span class="number">17</span> 16ms=<span class="number">17</span> 17ms=<span class="number">18</span> 18ms=<span class="number">21</span> 19ms=<span class="number">21</span> 20ms=<span class="number">24</span> 21ms=<span class="number">25</span> 22ms=<span class="number">16</span> 23ms=<span class="number">29</span> 24ms=<span class="number">27</span> 25ms=<span class="number">27</span> 26ms=<span class="number">17</span> 27ms=<span class="number">25</span> 28ms=<span class="number">21</span> 29ms=<span class="number">15</span> 30ms=<span class="number">18</span> 31ms=<span class="number">17</span> 32ms=<span class="number">17</span> 34ms=<span class="number">21</span> 36ms=<span class="number">29</span> 38ms=<span class="number">28</span> 40ms=<span class="number">19</span> 42ms=<span class="number">19</span> 44ms=<span class="number">9</span> 46ms=<span class="number">10</span> 48ms=<span class="number">15</span> 53ms=<span class="number">14</span> 57ms=<span class="number">8</span> 61ms=<span class="number">15</span> 65ms=<span class="number">5</span></span><br><span class="line"><span class="comment">// 直方图数据，表示耗时为0-5ms的帧数为16，耗时为5-6ms的帧数为13，同理类推。</span></span><br></pre></td></tr></table></figure>


<h4 id="3-最近120帧关键数据"><a href="#3-最近120帧关键数据" class="headerlink" title="3.最近120帧关键数据"></a>3.最近120帧关键数据</h4><p>上面分析了头数据，下面分析最近120帧中获取非常详细的帧耗时信息，因此我们可以更准确地跟踪和调试问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认打印所有应用的所有帧信息</span></span><br><span class="line">dumpsys gfxinfo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印某个应用的附近120帧信息,保存成csv好看一些</span></span><br><span class="line">dumpsys gfxinfo &lt; PACKAGE_NAME &gt; framestats &gt; E:\log\jack.csv</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line">1,922183814197,922183814197,922163445000,922171445000,922184357353,922185729853,922185852144,922189057874,922189297457,922190196363,922190289332,922192776051,922196442144,1815000,193000,</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">0,13698799872395,13698799872395,9223372036854775807,0,13698800780187,13698800795708,13698800796489,13698800832583,13698800868364,13698801056177,13698801076073,13698803020656,13698804379250,391000,519000,</span><br><span class="line">0,13709633291209,13709649957875,9223372036854775807,0,13709654350548,13709654366068,13709654366798,13709655434766,13709655447787,13709664635027,13709664742423,13709666301277,13709670211173,125000,238000,</span><br><span class="line">---PROFILEDATA---</span><br></pre></td></tr></table></figure>
<p>截取120帧详细信息如上，此输出的每一行代表app生成的一帧。每一行的列数都相同（16列），描述在生成帧的管道的每个阶段所花费的时间。</p>
<h5 id="3-1-分析framestats各字段意思"><a href="#3-1-分析framestats各字段意思" class="headerlink" title="3.1 分析framestats各字段意思"></a>3.1 分析framestats各字段意思</h5><p>下面来说明输出数据列的格式。所有时间戳都以纳秒为单位（1纳秒=1e-6毫秒）。</p>
<h5 id="3-1-1-Flags"><a href="#3-1-1-Flags" class="headerlink" title="3.1.1 Flags"></a>3.1.1 Flags</h5><p>​    如果flags为0，则此帧的<strong>总耗时时间</strong> = FRAME_COMPLETED（第14列，帧的结束时间） - INTENDED_VSYNC（第2列，帧的预期开始时间）。<br>​    如果flags不为0，则忽略该行，因为该帧的布局和绘制时间超过16ms，为异常帧。以下是可能发生的一些原因：<br>（1）窗口布局发生变化（例如app的第一帧或旋转后）；<br>（2）帧被跳过也是有可能的，在这种情况下，某些值将具有垃圾时间戳。例如，如果帧超出60fps，或者屏幕上没有任何内容变脏，则可能跳过一个帧，这不一定是app中出现问题的迹象。</p>
<h5 id="3-1-2-INTENDED-VSYNC"><a href="#3-1-2-INTENDED-VSYNC" class="headerlink" title="3.1.2 INTENDED_VSYNC"></a>3.1.2 INTENDED_VSYNC</h5><p>帧的预期开始时间。如果此值与VSYNC不同，则UI线程上发生了阻止其及时响应vsync信号的工作。</p>
<h5 id="3-1-3-Vsync"><a href="#3-1-3-Vsync" class="headerlink" title="3.1.3 Vsync"></a>3.1.3 Vsync</h5><p>花费在vsync监听器和帧绘制的时间（Choreographer frame回调，动画，View.getDrawingTime()等）。<br>要了解VSYNC的更多信息及其对app的影响，请查看<a href="https://www.youtube.com/watch?v=1iaHxmfZGGc&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=23">Understanding VSYNC</a> 视频。</p>
<p>以下结论来自上面视频所讲：如果帧率（GPU处理速度）和刷新频率不一致的时候，GPU处理速度比刷新速度快的时候，内存中下一帧数据覆盖部分上一帧数据，就会出现图像撕裂的情况。处理这种速率不一致的方式是采用双缓冲技术。</p>
<p>双缓冲技术：当GPU处理完数据之后，将数据存入后台缓冲区。然后将其拷贝到内存副缓冲区，也叫帧缓存区。当屏幕要刷新的时候，屏幕从帧缓存区获取数据显示，这样就不会出现撕裂情况，但是此时需要使用到Vsync信号。</p>
<p>当帧率高于刷新频率时，这情况是理想的。因为当屏幕需要刷新时，GPU都能将数据处理好存在帧缓存区中。因此屏幕都会刷新成功。GPU当处理完成一帧数据之后，将Vsync置位，当屏幕消耗了这帧数据，屏幕会将Vsync清空，GPU收到下一次屏幕刷新信号再继续处理下一帧数据。</p>
<p>当帧率低于刷新频率时，就会出现丢帧，屏幕显示的数据来自上一帧数据，用户就会感觉到卡顿(jank)，迟缓(lag)，打结(hitching)。</p>
<h5 id="3-1-4-OldestInputEvent"><a href="#3-1-4-OldestInputEvent" class="headerlink" title="3.1.4 OldestInputEvent"></a>3.1.4 OldestInputEvent</h5><p>输入队列中最早输入事件的时间戳。如果此帧没有输入事件，则为Long.MAX_VALUE。此值主要用于平台工作，对app开发人员的用处不大。</p>
<h5 id="3-1-5-NewestInputEvent"><a href="#3-1-5-NewestInputEvent" class="headerlink" title="3.1.5 NewestInputEvent"></a>3.1.5 NewestInputEvent</h5><p>输入队列中最后输入事件的时间戳，如果此帧没有输入事件，则为0。此值主要用于平台工作，对app开发人员的用处不大。但是，通过计算FRAME_COMPLETED - NEWEST_INPUT_EVENT的值，可以大致了解app添加的延迟时间。</p>
<h5 id="3-1-6-HandleInputStart"><a href="#3-1-6-HandleInputStart" class="headerlink" title="3.1.6 HandleInputStart"></a>3.1.6 HandleInputStart</h5><p>将输入事件分派给app的时间戳。通过计算ANIMATION_START - HANDLE_INPUT_START的值，可以测量app处理输入事件所花费的时间。<br>如果它们的时间差很高（&gt; 2ms），则表示app花费了非常长的时间处理输入事件，例如View.onTouchEvent()，这可能表示此工作需要优化，或者分发到其他线程。但是请注意，在某些情况下，例如发起新Activity或类似Activity的点击事件时，预计可接受的时间差是很大的。</p>
<h5 id="3-1-7-AnimationStart"><a href="#3-1-7-AnimationStart" class="headerlink" title="3.1.7 AnimationStart"></a>3.1.7 AnimationStart</h5><p>运行Choreographer注册动画的时间戳。<br>通过计算PERFORM_TRANVERSALS_START - ANIMATION_START的值，可以得到评估正在运行的所有动画器（ObjectAnimator，ViewPropertyAnimator和常用转换器）所花费的时间。<br>如果它们的时间差很高（&gt; 2ms），请检查您的app是否已编写了自定义动画或者设置了ObjectAnimators动画的字段，并确保它们适用于动画。<br>要了解Choreographer的更多信息，请查看 <a href="https://www.youtube.com/watch?v=Q8m9sHdyXnE">For Butter or Worse</a> 视频。</p>
<h5 id="3-1-8-PerformTraversalsStart"><a href="#3-1-8-PerformTraversalsStart" class="headerlink" title="3.1.8 PerformTraversalsStart"></a>3.1.8 PerformTraversalsStart</h5><p>计算DRAW_START - PERFORM_TRAVERSALS_START的值，可以得到完成布局和度量阶段所需的时间。（注意，在滚动或动画期间，你会希望它应该接近于零）<br>要了解有关渲染管道的度量和布局阶段的更多信息，请查看 <a href="https://www.youtube.com/watch?v=we6poP0kw6E&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=27">Invalidations, Layouts and Performance</a> 视频。</p>
<h5 id="3-1-9-DrawStart"><a href="#3-1-9-DrawStart" class="headerlink" title="3.1.9 DrawStart"></a>3.1.9 DrawStart</h5><p>performTraversals的绘制阶段开始的时间戳。这是录制任何view视图的显示列表的起点。<br>此时间与SYNC_START之间的时间是在树中所有View视图上调用View.draw()所需的时间。<br>有关绘图模型的更多信息，请查看 <a href="https://developer.android.com/guide/topics/graphics/hardware-accel.html#hardware-model">Hardware Acceleration</a> 或者 <a href="https://www.youtube.com/watch?v=we6poP0kw6E&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&index=27">Invalidations, Layouts and Performance</a> 视频。</p>
<h5 id="3-1-10-SyncQueued"><a href="#3-1-10-SyncQueued" class="headerlink" title="3.1.10 SyncQueued"></a>3.1.10 SyncQueued</h5><p>将同步请求发送到RenderThread的时间。<br>这标志着开始同步阶段的消息被发送到RenderThread的时刻。如果此时间与SYNC_START之间的时间差很长（&gt; 0.1ms左右），则表示RenderThread正忙于处理不同的帧。在内部，这用于区分执行太多工作以至于超过16ms预算的帧和由于前一帧超过16ms预算而导致被停止的帧。</p>
<h5 id="3-1-11-SyncStart"><a href="#3-1-11-SyncStart" class="headerlink" title="3.1.11 SyncStart"></a>3.1.11 SyncStart</h5><p>绘图同步阶段开始的时间。<br>如果此时间与ISSUE_DRAW_COMMANDS_START之间的时间很长（&gt; 0.4ms左右），则通常表示已绘制了许多必须上传到GPU的新位图。<br>要了解有关同步阶段的更多信息，请查看 <a href="https://www.youtube.com/watch?v=VzYkVL1n4M8&index=24&list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu">Profile GPU Rendering</a> 视频。</p>
<h5 id="3-1-12-IssueDrawCommandsStart"><a href="#3-1-12-IssueDrawCommandsStart" class="headerlink" title="3.1.12 IssueDrawCommandsStart"></a>3.1.12 IssueDrawCommandsStart</h5><p>硬件渲染器开始向GPU发出绘图命令的时间。<br>计算FRAME_COMPLETED - ISSUE_DRAW_COMMANDS_START的值，可以大致了解app生成多少GPU工作。这里会出现很多<strong>过度绘制或低效的渲染效果</strong>等问题。</p>
<h5 id="3-1-13-SwapBuffers"><a href="#3-1-13-SwapBuffers" class="headerlink" title="3.1.13 SwapBuffers"></a>3.1.13 SwapBuffers</h5><p>调用eglSwapBuffers的时间，在平台工作之外相对无用。</p>
<h5 id="3-1-14-FrameCompleted"><a href="#3-1-14-FrameCompleted" class="headerlink" title="3.1.14 FrameCompleted"></a>3.1.14 FrameCompleted</h5><p>帧的结束时间戳。可以通过执行FRAME_COMPLETED - INTENDED_VSYNC来计算在此帧上工作的总时间。</p>
<h5 id="3-1-15-DequeueBufferDuration和QueueBufferDuration"><a href="#3-1-15-DequeueBufferDuration和QueueBufferDuration" class="headerlink" title="3.1.15 DequeueBufferDuration和QueueBufferDuration"></a>3.1.15 DequeueBufferDuration和QueueBufferDuration</h5><p>SurfaceFlinger转交数据的耗时：《<a href="https://blog.csdn.net/u010164190/article/details/93638027">SurfaceFlinger中queueBuffer与dequeueBuffer作用</a>》</p>
<p>DequeueBufferDuration：renderThread交换buffer中dequeueBuffer花费的时间</p>
<p>QueueBufferDuration：renderThread queueBuffer的时间</p>
<h5 id="3-2-帧耗时数据的获取"><a href="#3-2-帧耗时数据的获取" class="headerlink" title="3.2 帧耗时数据的获取"></a>3.2 帧耗时数据的获取</h5><p>如果在开发人员选项中将配置文件Profile GPU rendering为In adb shell dumpsys gfxinfo，该命令将打印出最近120帧耗时信息，并将其分成几个不同的类别，可以直观地显示各部分的快慢。<br>与上面的framestats类似，将它粘贴到我们选择的电子表格工具，或者使用脚本进行收集和解析非常简单。下图显示了app生成的许多帧耗时的细分。</p>
<p><img src="https://img2018.cnblogs.com/blog/1375459/201811/1375459-20181128143440537-932690762.png" alt="img"><br>此结果可以通过运行gfxinfo，复制输出，将其粘贴到excel工具中，并将数据绘制为直方图获取。<br>每个垂直条代表一帧动画，它的高度表示计算动画帧所用的毫秒数。条形图的每个彩色部分代表渲染管道的不同阶段，因此您可以看到app的哪些部分可能会产生瓶颈。有关了解渲染管道以及如何对其进行优化的详细信息，请查看 <a href="https://www.youtube.com/watch?v=we6poP0kw6E&index=27&list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Invalidations Layouts and Performance</a> 视频。</p>
<p><strong>四 控制统计信息的收集</strong></p>
<p>framestats和简单的帧耗时信息都是在非常短的时间内收集数据——大约2s收集一次（一次120帧，一帧16ms，耗时约2s）。为了精确控制此时间窗口，例如，将数据限制为特定的动画，您可以重置所有计数器，并重新聚合统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt; reset</span><br></pre></td></tr></table></figure>
<p>这也可以与dumps命令一起使用，以常规节奏进行收集和重置，连续获得少于2s的帧数据。</p>
<p><strong>五 如何诊断性能问题</strong></p>
<p>dumpsys能发现问题或者判断问题的严重性，但无法定位真正的原因。如果要定位原因并找到解决它们的适当方法，强烈建议使用systrace工具。systrace工具可以打印出问题附近几秒钟的所有调用栈，以及耗时，具体分析某个方法耗时情况。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.cnblogs.com/zhengna/p/10032078.html">1.Android UI性能测试——使用 Gfxinfo 衡量性能</a></p>
<p><a href="https://www.youtube.com/watch?v=HXQhu6qfTVU">2.Rendering Performance 101</a></p>
<p><a href="https://www.youtube.com/watch?v=CaMTIgxCSqU">3.Why 60fps?</a></p>
<p><a href="https://www.youtube.com/watch?v=WH9AFhgwmDw">4.Android, UI, and the GPU</a></p>
<p><a href="https://www.youtube.com/watch?v=we6poP0kw6E">5.Invalidations, Layouts, and Performance</a></p>
<p><a href="https://developer.android.com/studio/profile/systrace.html">6.Analyzing UI Performance with Systrace</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>gfxinfo</tag>
      </tags>
  </entry>
  <entry>
    <title>解析dumpsys meminfo</title>
    <url>/2021/08/14/%E8%A7%A3%E6%9E%90dumpsys-meminfo/</url>
    <content><![CDATA[<h4 id="1-车机原始数据"><a href="#1-车机原始数据" class="headerlink" title="1.车机原始数据"></a>1.车机原始数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Applications Memory <span class="title">Usage</span> <span class="params">(in Kilobytes)</span>:</span></span><br><span class="line"><span class="function">Uptime: 17677236 Realtime: 17677236</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Total PSS by process:</span></span><br><span class="line"><span class="function">    199,233K: com.iflytek.autofly.<span class="title">mediax</span> <span class="params">(pid <span class="number">2782</span> / activities)</span></span></span><br><span class="line"><span class="function">    124,496K: <span class="title">system</span> <span class="params">(pid <span class="number">792</span>)</span></span></span><br><span class="line"><span class="function">    106,727K: com.gxa.service.<span class="title">systemui</span> <span class="params">(pid <span class="number">1513</span>)</span></span></span><br><span class="line"><span class="function">     91,710K: com.gxa.cockpit.<span class="title">hvac</span> <span class="params">(pid <span class="number">1370</span>)</span></span></span><br><span class="line"><span class="function">     41,384K: <span class="title">zygote</span> <span class="params">(pid <span class="number">361</span>)</span></span></span><br><span class="line"><span class="function">     40,611K: com.android.<span class="title">systemui</span> <span class="params">(pid <span class="number">1243</span> / activities)</span></span></span><br><span class="line"><span class="function">     37,332K: com.gxatek.cockpit.<span class="title">settings</span> <span class="params">(pid <span class="number">30089</span> / activities)</span></span></span><br><span class="line"><span class="function">     36,911K: com.gxatek.cockpit.<span class="title">msgcenter</span> <span class="params">(pid <span class="number">2469</span>)</span></span></span><br><span class="line"><span class="function">     35,512K: com.iflytek.autofly.<span class="title">avatar</span> <span class="params">(pid <span class="number">2501</span>)</span></span></span><br><span class="line"><span class="function">     24,970K: com.iflytek.<span class="title">demo</span> <span class="params">(pid <span class="number">15276</span>)</span></span></span><br><span class="line"><span class="function">     23,248K: com.gxatek.cockpit.<span class="title">miniprogram</span> <span class="params">(pid <span class="number">3481</span>)</span></span></span><br><span class="line"><span class="function">     22,704K: com.iflytek.autofly.<span class="title">systemserver</span> <span class="params">(pid <span class="number">15103</span>)</span></span></span><br><span class="line"><span class="function">     21,398K: com.gac.cloud.<span class="title">app</span> <span class="params">(pid <span class="number">2567</span>)</span></span></span><br><span class="line"><span class="function">     19,822K: com.android.webview:<span class="title">sandboxed_process0</span> <span class="params">(pid <span class="number">3027</span>)</span></span></span><br><span class="line"><span class="function">     19,732K: com.gxatek.cockpit.<span class="title">scenesengine</span> <span class="params">(pid <span class="number">3511</span>)</span></span></span><br><span class="line"><span class="function">     19,089K: com.gxa.service.<span class="title">account</span> <span class="params">(pid <span class="number">1381</span>)</span></span></span><br><span class="line"><span class="function">     18,990K: com.android.<span class="title">bluetooth</span> <span class="params">(pid <span class="number">1099</span>)</span></span></span><br><span class="line"><span class="function">     18,863K: com.gxatek.cockpit.<span class="title">screensaver</span> <span class="params">(pid <span class="number">4057</span>)</span></span></span><br><span class="line"><span class="function">     18,783K: platformservice.<span class="title">Services</span> <span class="params">(pid <span class="number">2397</span>)</span></span></span><br><span class="line"><span class="function">     18,384K: <span class="title">zygote64</span> <span class="params">(pid <span class="number">360</span>)</span></span></span><br><span class="line"><span class="function">     18,246K: <span class="title">webview_zygote</span> <span class="params">(pid <span class="number">1145</span>)</span></span></span><br><span class="line"><span class="function">     18,158K: com.android.commands.<span class="title">monkey</span> <span class="params">(pid <span class="number">30761</span>)</span></span></span><br><span class="line"><span class="function">     17,505K: <span class="title">surfaceflinger</span> <span class="params">(pid <span class="number">485</span>)</span></span></span><br><span class="line"><span class="function">     17,272K: com.android.<span class="title">car</span> <span class="params">(pid <span class="number">1772</span>)</span></span></span><br><span class="line"><span class="function">     16,549K: libweexjsb.<span class="title">so</span> <span class="params">(pid <span class="number">3533</span>)</span></span></span><br><span class="line"><span class="function">     15,683K: android.hardware.audio@2.0-<span class="title">service</span> <span class="params">(pid <span class="number">440</span>)</span></span></span><br><span class="line"><span class="function">     15,565K: com.gxa.service.<span class="title">mediacenterservice</span> <span class="params">(pid <span class="number">1552</span>)</span></span></span><br><span class="line"><span class="function">     15,563K: com.gxa.<span class="title">firewall</span> <span class="params">(pid <span class="number">1992</span> / activities)</span></span></span><br><span class="line"><span class="function">     14,053K: com.desaysv.vehiclelan.proxy@1.0-<span class="title">service</span> <span class="params">(pid <span class="number">309</span>)</span></span></span><br><span class="line"><span class="function">     13,668K: <span class="title">audioserver</span> <span class="params">(pid <span class="number">480</span>)</span></span></span><br><span class="line"><span class="function">     ......</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Total PSS by OOM adjustment:</span></span><br><span class="line"><span class="function">    405,214K: Native</span></span><br><span class="line"><span class="function">         41,384K: <span class="title">zygote</span> <span class="params">(pid <span class="number">361</span>)</span></span></span><br><span class="line"><span class="function">         24,970K: com.iflytek.<span class="title">demo</span> <span class="params">(pid <span class="number">15276</span>)</span></span></span><br><span class="line"><span class="function">         18,384K: <span class="title">zygote64</span> <span class="params">(pid <span class="number">360</span>)</span></span></span><br><span class="line"><span class="function">         18,246K: <span class="title">webview_zygote</span> <span class="params">(pid <span class="number">1145</span>)</span></span></span><br><span class="line"><span class="function">         18,158K: com.android.commands.<span class="title">monkey</span> <span class="params">(pid <span class="number">30761</span>)</span></span></span><br><span class="line"><span class="function">         17,505K: <span class="title">surfaceflinger</span> <span class="params">(pid <span class="number">485</span>)</span></span></span><br><span class="line"><span class="function">         16,549K: libweexjsb.<span class="title">so</span> <span class="params">(pid <span class="number">3533</span>)</span></span></span><br><span class="line"><span class="function">         15,683K: android.hardware.audio@2.0-<span class="title">service</span> <span class="params">(pid <span class="number">440</span>)</span></span></span><br><span class="line"><span class="function">         14,053K: com.desaysv.vehiclelan.proxy@1.0-<span class="title">service</span> <span class="params">(pid <span class="number">309</span>)</span></span></span><br><span class="line"><span class="function">         13,668K: <span class="title">audioserver</span> <span class="params">(pid <span class="number">480</span>)</span></span></span><br><span class="line"><span class="function">         10,475K: android.hardware.graphics.composer@2.2-<span class="title">service</span> <span class="params">(pid <span class="number">452</span>)</span></span></span><br><span class="line"><span class="function">          9,317K: media.<span class="title">codec</span> <span class="params">(pid <span class="number">605</span>)</span></span></span><br><span class="line"><span class="function">          8,729K: android.hardware.broadcastradio@2.0-service.<span class="title">g6</span> <span class="params">(pid <span class="number">446</span>)</span></span></span><br><span class="line"><span class="function">          7,757K: android.hardware.wifi@1.0-<span class="title">service</span> <span class="params">(pid <span class="number">463</span>)</span></span></span><br><span class="line"><span class="function">          7,662K: <span class="title">caraudioserver</span> <span class="params">(pid <span class="number">588</span>)</span></span></span><br><span class="line"><span class="function">          ......</span></span><br><span class="line"><span class="function">    124,496K: System</span></span><br><span class="line"><span class="function">        124,496K: <span class="title">system</span> <span class="params">(pid <span class="number">792</span>)</span></span></span><br><span class="line"><span class="function">    495,619K: Persistent</span></span><br><span class="line"><span class="function">        106,727K: com.gxa.service.<span class="title">systemui</span> <span class="params">(pid <span class="number">1513</span>)</span></span></span><br><span class="line"><span class="function">         40,611K: com.android.<span class="title">systemui</span> <span class="params">(pid <span class="number">1243</span> / activities)</span></span></span><br><span class="line"><span class="function">         36,911K: com.gxatek.cockpit.<span class="title">msgcenter</span> <span class="params">(pid <span class="number">2469</span>)</span></span></span><br><span class="line"><span class="function">         35,512K: com.iflytek.autofly.<span class="title">avatar</span> <span class="params">(pid <span class="number">2501</span>)</span></span></span><br><span class="line"><span class="function">         21,398K: com.gac.cloud.<span class="title">app</span> <span class="params">(pid <span class="number">2567</span>)</span></span></span><br><span class="line"><span class="function">         17,272K: com.android.<span class="title">car</span> <span class="params">(pid <span class="number">1772</span>)</span></span></span><br><span class="line"><span class="function">         15,565K: com.gxa.service.<span class="title">mediacenterservice</span> <span class="params">(pid <span class="number">1552</span>)</span></span></span><br><span class="line"><span class="function">         15,563K: com.gxa.<span class="title">firewall</span> <span class="params">(pid <span class="number">1992</span> / activities)</span></span></span><br><span class="line"><span class="function">         12,893K: com.gxa.appservice.<span class="title">caradapter</span> <span class="params">(pid <span class="number">1581</span>)</span></span></span><br><span class="line"><span class="function">         12,663K: com.android.<span class="title">phone</span> <span class="params">(pid <span class="number">9965</span>)</span></span></span><br><span class="line"><span class="function">         11,964K: com.android.car.<span class="title">hvac</span> <span class="params">(pid <span class="number">2508</span>)</span></span></span><br><span class="line"><span class="function">         11,572K: com.gxatek.cockpit.<span class="title">carlife</span> <span class="params">(pid <span class="number">2483</span>)</span></span></span><br><span class="line"><span class="function">         11,434K: com.gxa.service.<span class="title">ebcall</span> <span class="params">(pid <span class="number">1676</span>)</span></span></span><br><span class="line"><span class="function">         11,429K: com.gxa.service.<span class="title">settings</span> <span class="params">(pid <span class="number">1423</span>)</span></span></span><br><span class="line"><span class="function">         10,935K: com.desaysv.<span class="title">otaservice</span> <span class="params">(pid <span class="number">2575</span>)</span></span></span><br><span class="line"><span class="function">         ......</span></span><br><span class="line"><span class="function">     18,990K: Persistent Service</span></span><br><span class="line"><span class="function">         18,990K: com.android.<span class="title">bluetooth</span> <span class="params">(pid <span class="number">1099</span>)</span></span></span><br><span class="line"><span class="function">     12,852K: Foreground</span></span><br><span class="line"><span class="function">         12,852K: com.iflytek.autofly.<span class="title">naviselect</span> <span class="params">(pid <span class="number">15011</span> / activities)</span></span></span><br><span class="line"><span class="function">    521,294K: Visible</span></span><br><span class="line"><span class="function">        199,233K: com.iflytek.autofly.<span class="title">mediax</span> <span class="params">(pid <span class="number">2782</span> / activities)</span></span></span><br><span class="line"><span class="function">         91,710K: com.gxa.cockpit.<span class="title">hvac</span> <span class="params">(pid <span class="number">1370</span>)</span></span></span><br><span class="line"><span class="function">         22,704K: com.iflytek.autofly.<span class="title">systemserver</span> <span class="params">(pid <span class="number">15103</span>)</span></span></span><br><span class="line"><span class="function">         19,822K: com.android.webview:<span class="title">sandboxed_process0</span> <span class="params">(pid <span class="number">3027</span>)</span></span></span><br><span class="line"><span class="function">         19,089K: com.gxa.service.<span class="title">account</span> <span class="params">(pid <span class="number">1381</span>)</span></span></span><br><span class="line"><span class="function">         18,863K: com.gxatek.cockpit.<span class="title">screensaver</span> <span class="params">(pid <span class="number">4057</span>)</span></span></span><br><span class="line"><span class="function">         18,783K: platformservice.<span class="title">Services</span> <span class="params">(pid <span class="number">2397</span>)</span></span></span><br><span class="line"><span class="function">         12,914K: com.gxa.car.<span class="title">power</span> <span class="params">(pid <span class="number">1451</span>)</span></span></span><br><span class="line"><span class="function">         12,868K: com.gxa.car.<span class="title">externalkey</span> <span class="params">(pid <span class="number">1354</span>)</span></span></span><br><span class="line"><span class="function">         10,901K: com.gac.cloud.<span class="title">cert</span> <span class="params">(pid <span class="number">2718</span>)</span></span></span><br><span class="line"><span class="function">         10,798K: com.gxa.car.<span class="title">engineMode</span> <span class="params">(pid <span class="number">1405</span>)</span></span></span><br><span class="line"><span class="function">         10,590K: com.gxa.appservice.platformadapter.<span class="title">adaptermainservice</span> <span class="params">(pid <span class="number">2643</span>)</span></span></span><br><span class="line"><span class="function">         10,217K: com.gxa.service.<span class="title">ota</span> <span class="params">(pid <span class="number">2818</span>)</span></span></span><br><span class="line"><span class="function">          9,010K: com.gxa.car.<span class="title">procmanagement</span> <span class="params">(pid <span class="number">2802</span>)</span></span></span><br><span class="line"><span class="function">          8,462K: com.gxa.service.<span class="title">cluster</span> <span class="params">(pid <span class="number">1645</span>)</span></span></span><br><span class="line"><span class="function">          8,352K: com.gxa.car.<span class="title">hardkey</span> <span class="params">(pid <span class="number">2389</span>)</span></span></span><br><span class="line"><span class="function">          8,141K: android.ext.<span class="title">services</span> <span class="params">(pid <span class="number">3252</span>)</span></span></span><br><span class="line"><span class="function">          7,989K: android.ext.<span class="title">services</span> <span class="params">(pid <span class="number">3267</span>)</span></span></span><br><span class="line"><span class="function">          7,550K: com.iflytek.autofly.<span class="title">accountcenter</span> <span class="params">(pid <span class="number">3087</span>)</span></span></span><br><span class="line"><span class="function">          7,528K: android.ext.<span class="title">services</span> <span class="params">(pid <span class="number">2137</span>)</span></span></span><br><span class="line"><span class="function">          5,770K: com.gxatek.appservice.<span class="title">cluster</span> <span class="params">(pid <span class="number">3071</span>)</span></span></span><br><span class="line"><span class="function">     59,002K: Perceptible</span></span><br><span class="line"><span class="function">         23,248K: com.gxatek.cockpit.<span class="title">miniprogram</span> <span class="params">(pid <span class="number">3481</span>)</span></span></span><br><span class="line"><span class="function">         19,732K: com.gxatek.cockpit.<span class="title">scenesengine</span> <span class="params">(pid <span class="number">3511</span>)</span></span></span><br><span class="line"><span class="function">          8,066K: com.android.inputmethod.<span class="title">latin</span> <span class="params">(pid <span class="number">2109</span>)</span></span></span><br><span class="line"><span class="function">          7,956K: com.desaysv.<span class="title">ftpserver</span> <span class="params">(pid <span class="number">3620</span>)</span></span></span><br><span class="line"><span class="function">     18,531K: A Services</span></span><br><span class="line"><span class="function">          9,298K: com.iflytek.autofly.mediax:<span class="title">remote</span> <span class="params">(pid <span class="number">10360</span>)</span></span></span><br><span class="line"><span class="function">          9,233K: com.iflytek.autofly.mediax:<span class="title">remote</span> <span class="params">(pid <span class="number">10857</span>)</span></span></span><br><span class="line"><span class="function">     29,298K: B Services</span></span><br><span class="line"><span class="function">          8,706K: com.iflytek.autofly.mediax:<span class="title">remote</span> <span class="params">(pid <span class="number">3104</span>)</span></span></span><br><span class="line"><span class="function">          7,016K: android.process.<span class="title">media</span> <span class="params">(pid <span class="number">23822</span>)</span></span></span><br><span class="line"><span class="function">          5,697K: com.android.car.<span class="title">messenger</span> <span class="params">(pid <span class="number">3834</span>)</span></span></span><br><span class="line"><span class="function">          4,040K: com.qti.<span class="title">diagservices</span> <span class="params">(pid <span class="number">3707</span>)</span></span></span><br><span class="line"><span class="function">          3,839K: com.qualcomm.<span class="title">qcrilmsgtunnel</span> <span class="params">(pid <span class="number">2332</span>)</span></span></span><br><span class="line"><span class="function">     96,280K: Cached</span></span><br><span class="line"><span class="function">         37,332K: com.gxatek.cockpit.<span class="title">settings</span> <span class="params">(pid <span class="number">30089</span> / activities)</span></span></span><br><span class="line"><span class="function">          8,291K: com.iflytek.autofly.<span class="title">accountcenter</span> <span class="params">(pid <span class="number">10320</span>)</span></span></span><br><span class="line"><span class="function">          8,207K: com.iflytek.autofly.<span class="title">accountcenter</span> <span class="params">(pid <span class="number">10818</span>)</span></span></span><br><span class="line"><span class="function">          7,960K: com.google.android.car.vms.<span class="title">subscriber</span> <span class="params">(pid <span class="number">14643</span>)</span></span></span><br><span class="line"><span class="function">          5,333K: com.gxatek.appservice.<span class="title">cluster</span> <span class="params">(pid <span class="number">10803</span>)</span></span></span><br><span class="line"><span class="function">          5,074K: com.gxatek.appservice.<span class="title">cluster</span> <span class="params">(pid <span class="number">11980</span>)</span></span></span><br><span class="line"><span class="function">          4,452K: com.android.<span class="title">mtp</span> <span class="params">(pid <span class="number">31084</span>)</span></span></span><br><span class="line"><span class="function">          4,270K: com.android.<span class="title">mtp</span> <span class="params">(pid <span class="number">5760</span>)</span></span></span><br><span class="line"><span class="function">          4,192K: com.android.<span class="title">mtp</span> <span class="params">(pid <span class="number">5685</span>)</span></span></span><br><span class="line"><span class="function">          3,829K: com.android.<span class="title">externalstorage</span> <span class="params">(pid <span class="number">31047</span>)</span></span></span><br><span class="line"><span class="function">          3,674K: com.android.<span class="title">externalstorage</span> <span class="params">(pid <span class="number">5445</span>)</span></span></span><br><span class="line"><span class="function">          3,666K: com.android.<span class="title">externalstorage</span> <span class="params">(pid <span class="number">5430</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Total PSS by category:</span></span><br><span class="line"><span class="function">    645,466K: Native</span></span><br><span class="line"><span class="function">    257,284K: .so mmap</span></span><br><span class="line"><span class="function">    193,418K: .dex mmap</span></span><br><span class="line"><span class="function">    140,979K: Dalvik</span></span><br><span class="line"><span class="function">    112,332K: .art mmap</span></span><br><span class="line"><span class="function">    103,828K: Unknown</span></span><br><span class="line"><span class="function">     98,915K: .apk mmap</span></span><br><span class="line"><span class="function">     75,275K: .jar mmap</span></span><br><span class="line"><span class="function">     48,058K: Other mmap</span></span><br><span class="line"><span class="function">     42,943K: Dalvik Other</span></span><br><span class="line"><span class="function">     37,704K: .oat mmap</span></span><br><span class="line"><span class="function">     13,094K: .ttf mmap</span></span><br><span class="line"><span class="function">      7,928K: Stack</span></span><br><span class="line"><span class="function">      3,206K: Other dev</span></span><br><span class="line"><span class="function">      1,146K: Ashmem</span></span><br><span class="line"><span class="function">          0K: Cursor</span></span><br><span class="line"><span class="function">          0K: Gfx dev</span></span><br><span class="line"><span class="function">          0K: EGL mtrack</span></span><br><span class="line"><span class="function">          0K: GL mtrack</span></span><br><span class="line"><span class="function">          0K: Other mtrack</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Total RAM: 6,266,692<span class="title">K</span> <span class="params">(status normal)</span></span></span><br><span class="line"><span class="function"> Free RAM: 3,487,696<span class="title">K</span> <span class="params">(   <span class="number">96</span>,280K cached pss +   <span class="number">844</span>,924K cached kernel + <span class="number">2</span>,<span class="number">546</span>,492K free)</span></span></span><br><span class="line"><span class="function"> Used RAM: 2,162,420<span class="title">K</span> <span class="params">(<span class="number">1</span>,<span class="number">685</span>,296K used pss +   <span class="number">477</span>,124K kernel)</span></span></span><br><span class="line"><span class="function"> Lost RAM:   616,576K</span></span><br><span class="line"><span class="function">   Tuning: 512 <span class="params">(large <span class="number">512</span>)</span>, oom   322,560K, restore limit   107,520<span class="title">K</span> <span class="params">(high-end-gfx)</span></span></span><br></pre></td></tr></table></figure>


<h4 id="2-追根溯源"><a href="#2-追根溯源" class="headerlink" title="2.追根溯源"></a>2.追根溯源</h4><p>简单的查看内存信息可以使用命令：adb shell dumpsys meminfo</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android/frameworks/native/cmds/dumpsys/main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to get default service manager!&quot;</span>);</span><br><span class="line">        aerr &lt;&lt; <span class="string">&quot;dumpsys: Unable to get default service manager!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dumpsys <span class="title">dumpsys</span><span class="params">(sm.get())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dumpsys.main(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过解析参数，会调用对应servicemanager中注册的服务meminfo 的dump接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android/frameworks/base/services/core/java/com/android/server/am/ ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="keyword">true</span>,DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        <span class="comment">// 添加meminfo服务到ServiceManager中</span></span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;meminfo&quot;</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>), <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,DUMP_FLAG_PRIORITY_HIGH);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;gfxinfo&quot;</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;dbinfo&quot;</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;cpuinfo&quot;</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>),<span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;permission&quot;</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;processinfo&quot;</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Unable to find android system package&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看到AMS将各种服务通过setSystemProcess()方法注册到ServiceManager中，我们本次要分析的是meminfo，因此主要看<code>MemBinder</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">    ActivityManagerService mActivityManagerService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityDump.PriorityDumper mPriorityDumper =</span><br><span class="line">        <span class="keyword">new</span> PriorityDump.PriorityDumper() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dumpHigh</span><span class="params">(FileDescriptor fd, PrintWriter pw, String[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span> asProto)</span> </span>&#123;</span><br><span class="line">            dump(fd, pw, <span class="keyword">new</span> String[] &#123;<span class="string">&quot;-a&quot;</span>&#125;, asProto);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter pw, String[] args, <span class="keyword">boolean</span> asProto)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 最终会调到AMS的dumpApplicationMemoryUsage方法打印meminfo</span></span><br><span class="line">            mActivityManagerService.dumpApplicationMemoryUsage(</span><br><span class="line">                fd, pw, <span class="string">&quot;  &quot;</span>, args, <span class="keyword">false</span>, <span class="keyword">null</span>, asProto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    MemBinder(ActivityManagerService activityManagerService) &#123;</span><br><span class="line">        mActivityManagerService = activityManagerService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter pw, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!DumpUtils.checkDumpAndUsageStatsPermission(mActivityManagerService.mContext,</span><br><span class="line">                                                        <span class="string">&quot;meminfo&quot;</span>, pw)) <span class="keyword">return</span>;</span><br><span class="line">        PriorityDump.dump(mPriorityDumper, fd, pw, args);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，<code>dumpsys meminfo</code>最终会调到AMS的dumpApplicationMemoryUsage中，然后经过一系列对传入参数的判断，打印出第一小节的内容。</p>
<h4 id="3-解析打印内容"><a href="#3-解析打印内容" class="headerlink" title="3.解析打印内容"></a>3.解析打印内容</h4><h5 id="3-1-标题解析"><a href="#3-1-标题解析" class="headerlink" title="3.1 标题解析"></a>3.1 标题解析</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Applications Memory Usage (in Kilobytes):</span><br><span class="line">Uptime: 17677236 Realtime: 17677236</span><br><span class="line"></span><br><span class="line">Total PSS by process:</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">Total PSS by OOM adjustment:</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">Total PSS by category:</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<ul>
<li>Uptime: 表示启动到现在的时长，不包含休眠的时间，单位毫秒(ms)</li>
<li>Realtime: 表示启动到现在的时长，包含休眠的时间，单位毫秒(ms)</li>
<li>PSS:Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存），比如2个进程使用10KB的共享库，那么每个进程算5KB内存占用到PSS中。</li>
<li>Total PSS by process：这个标签下面的就是按照以PPS方式统计的，进程使用内存按多到少排列出来。</li>
<li>Total PSS by OOM adjustment:这个下面是按OOM adj值排列的，就是lowmem kill时的优先级，<strong>从高到低排列(Native最高，Cached最低)。OOM_ADJ值越小，优先级越高，越难被lowmem kill杀。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ProcessList.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uninitialized value for any major or minor adj fields</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_ADJ = -<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjustment used in certain places where we don&#x27;t know it yet.</span></span><br><span class="line"><span class="comment">// (Generally this is something that is going to be cached, but we</span></span><br><span class="line"><span class="comment">// don&#x27;t know the exact value in the cached range to assign yet.)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNKNOWN_ADJ = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process only hosting activities that are not visible,</span></span><br><span class="line"><span class="comment">// so it can be killed without any disruption.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHED_APP_MAX_ADJ = <span class="number">906</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHED_APP_MIN_ADJ = <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The B list of SERVICE_ADJ -- these are the old and decrepit</span></span><br><span class="line"><span class="comment">// services that aren&#x27;t as shiny and interesting as the ones in the A list.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_B_ADJ = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the process of the previous application that the user was in.</span></span><br><span class="line"><span class="comment">// This process is kept above other things, because it is very common to</span></span><br><span class="line"><span class="comment">// switch back to the previous app.  This is important both for recent</span></span><br><span class="line"><span class="comment">// task switch (toggling between the two top recent apps) as well as normal</span></span><br><span class="line"><span class="comment">// UI flow such as clicking on a URI in the e-mail app to view in the browser,</span></span><br><span class="line"><span class="comment">// and then pressing back to return to e-mail.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PREVIOUS_APP_ADJ = <span class="number">700</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process holding the home application -- we want to try</span></span><br><span class="line"><span class="comment">// avoiding killing it, even if it would normally be in the background,</span></span><br><span class="line"><span class="comment">// because the user interacts with it so much.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOME_APP_ADJ = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process holding an application service -- killing it will not</span></span><br><span class="line"><span class="comment">// have much of an impact as far as the user is concerned.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_ADJ = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process with a heavy-weight application.  It is in the</span></span><br><span class="line"><span class="comment">// background, but we want to try to avoid killing it.  Value set in</span></span><br><span class="line"><span class="comment">// system/rootdir/init.rc on startup.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAVY_WEIGHT_APP_ADJ = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process currently hosting a backup operation.  Killing it</span></span><br><span class="line"><span class="comment">// is not entirely fatal but is generally a bad idea.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACKUP_APP_ADJ = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process only hosting components that are perceptible to the</span></span><br><span class="line"><span class="comment">// user, and we really want to avoid killing them, but they are not</span></span><br><span class="line"><span class="comment">// immediately visible. An example is background music playback.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERCEPTIBLE_APP_ADJ = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process only hosting activities that are visible to the</span></span><br><span class="line"><span class="comment">// user, so we&#x27;d prefer they don&#x27;t disappear.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VISIBLE_APP_ADJ = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VISIBLE_APP_LAYER_MAX = PERCEPTIBLE_APP_ADJ - VISIBLE_APP_ADJ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the process running the current foreground app.  We&#x27;d really</span></span><br><span class="line"><span class="comment">// rather not kill it!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOREGROUND_APP_ADJ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a process that the system or a persistent process has bound to,</span></span><br><span class="line"><span class="comment">// and indicated it is important.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERSISTENT_SERVICE_ADJ = -<span class="number">700</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a system persistent process, such as telephony.  Definitely</span></span><br><span class="line"><span class="comment">// don&#x27;t want to kill it, but doing so is not completely fatal.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERSISTENT_PROC_ADJ = -<span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The system process runs at the default adjustment.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYSTEM_ADJ = -<span class="number">900</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Special code for native processes that are not being managed by the system (so</span></span><br><span class="line"><span class="comment">// don&#x27;t have an oom adj assigned by the system).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NATIVE_ADJ = -<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>由于在Cached标签下的进程是随时可以回收内存的缓存进程，所以该部分内存在后面会统计到Free RAM字段中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Total RAM: <span class="number">6</span>,<span class="number">266</span>,692K (status normal)</span><br><span class="line"> Free RAM: <span class="number">3</span>,<span class="number">487</span>,696K (   <span class="number">96</span>,280K cached pss +   <span class="number">844</span>,924K cached kernel + <span class="number">2</span>,<span class="number">546</span>,492K free)</span><br><span class="line"> Used RAM: <span class="number">2</span>,<span class="number">162</span>,420K (<span class="number">1</span>,<span class="number">685</span>,296K used pss +   <span class="number">477</span>,124K kernel)</span><br><span class="line"> Lost RAM:   <span class="number">616</span>,576K</span><br><span class="line">   Tuning: <span class="number">512</span> (large <span class="number">512</span>), oom   <span class="number">322</span>,560K, restore limit   <span class="number">107</span>,520K (high-end-gfx)</span><br></pre></td></tr></table></figure>


<h5 id="3-2-单个app内存分析"><a href="#3-2-单个app内存分析" class="headerlink" title="3.2 单个app内存分析"></a>3.2 单个app内存分析</h5><p>Total PSS by category:该标签下统计系统中所有进程每个类别占用内存的总和，具体每个的含义后面按app来解释。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取单个进程对应的内存信息：</span></span><br><span class="line">adb shell dumpsys meminfo &lt;pid&gt; </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">** MEMINFO in pid <span class="number">5304</span> [com.gxa.car.scene] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">  Native Heap     <span class="number">2737</span>     <span class="number">2668</span>        <span class="number">0</span>        <span class="number">0</span>     <span class="number">9728</span>     <span class="number">8103</span>     <span class="number">1624</span></span><br><span class="line">  Dalvik Heap      <span class="number">635</span>      <span class="number">576</span>        <span class="number">0</span>        <span class="number">0</span>     <span class="number">2736</span>     <span class="number">1200</span>     <span class="number">1536</span></span><br><span class="line"> Dalvik Other      <span class="number">428</span>      <span class="number">428</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">        Stack      <span class="number">252</span>      <span class="number">252</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">       Ashmem        <span class="number">5</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    Other dev       <span class="number">14</span>        <span class="number">0</span>       <span class="number">12</span>        <span class="number">0</span></span><br><span class="line">     .so mmap     <span class="number">1601</span>      <span class="number">120</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .apk mmap      <span class="number">564</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .ttf mmap       <span class="number">59</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .dex mmap     <span class="number">3987</span>        <span class="number">4</span>     <span class="number">2228</span>        <span class="number">0</span></span><br><span class="line">    .oat mmap      <span class="number">306</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .art mmap     <span class="number">4131</span>     <span class="number">3800</span>       <span class="number">88</span>        <span class="number">0</span></span><br><span class="line">   Other mmap       <span class="number">13</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">      Unknown      <span class="number">323</span>      <span class="number">288</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">        TOTAL    <span class="number">15055</span>     <span class="number">8140</span>     <span class="number">2328</span>        <span class="number">0</span>    <span class="number">12464</span>     <span class="number">9303</span>     <span class="number">3160</span></span><br><span class="line"></span><br><span class="line"> App Summary</span><br><span class="line">                       Pss(KB)</span><br><span class="line">                        ------</span><br><span class="line">           Java Heap:     <span class="number">4464</span></span><br><span class="line">         Native Heap:     <span class="number">2668</span></span><br><span class="line">                Code:     <span class="number">2352</span></span><br><span class="line">               Stack:      <span class="number">252</span></span><br><span class="line">            Graphics:        <span class="number">0</span></span><br><span class="line">       Private Other:      <span class="number">732</span></span><br><span class="line">              System:     <span class="number">4587</span></span><br><span class="line"></span><br><span class="line">               TOTAL:    <span class="number">15055</span>       TOTAL SWAP PSS:        <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> Objects</span><br><span class="line">               Views:       <span class="number">17</span>         ViewRootImpl:        <span class="number">1</span></span><br><span class="line">         AppContexts:        <span class="number">3</span>           Activities:        <span class="number">1</span></span><br><span class="line">              Assets:        <span class="number">2</span>        AssetManagers:        <span class="number">3</span></span><br><span class="line">       Local Binders:        <span class="number">9</span>        Proxy Binders:       <span class="number">15</span></span><br><span class="line">       Parcel memory:        <span class="number">3</span>         Parcel count:       <span class="number">12</span></span><br><span class="line">    Death Recipients:        <span class="number">0</span>      OpenSSL Sockets:        <span class="number">0</span></span><br><span class="line">            WebViews:        <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> SQL</span><br><span class="line">         MEMORY_USED:        <span class="number">0</span></span><br><span class="line">  PAGECACHE_OVERFLOW:        <span class="number">0</span>          MALLOC_SIZE:        <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>这个信息是在app进程中打印出来的，最终该命令会执行到对应进程的如下接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dumpMemInfo</span><span class="params">(ParcelFileDescriptor pfd, Debug.MemoryInfo mem, <span class="keyword">boolean</span> checkin,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> dumpFullInfo, <span class="keyword">boolean</span> dumpDalvik, <span class="keyword">boolean</span> dumpSummaryOnly,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> dumpUnreachable, String[] args)</span> </span>&#123;</span><br><span class="line">    FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(pfd.getFileDescriptor());</span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> FastPrintWriter(fout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dumpMemInfo(pw, mem, checkin, dumpFullInfo, dumpDalvik, dumpSummaryOnly, dumpUnreachable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        pw.flush();</span><br><span class="line">        IoUtils.closeQuietly(pfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-2-1-细节分析"><a href="#3-2-1-细节分析" class="headerlink" title="3.2.1 细节分析"></a>3.2.1 细节分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">** MEMINFO in pid <span class="number">5304</span> [com.gxa.car.scene] **</span><br><span class="line">                   Pss  Private  Private  SwapPss     Heap     Heap     Heap</span><br><span class="line">                 Total    Dirty    Clean    Dirty     Size    Alloc     Free</span><br><span class="line">                ------   ------   ------   ------   ------   ------   ------</span><br><span class="line">  Native Heap     <span class="number">2737</span>     <span class="number">2668</span>        <span class="number">0</span>        <span class="number">0</span>     <span class="number">9728</span>     <span class="number">8103</span>     <span class="number">1624</span></span><br><span class="line">  Dalvik Heap      <span class="number">635</span>      <span class="number">576</span>        <span class="number">0</span>        <span class="number">0</span>     <span class="number">2736</span>     <span class="number">1200</span>     <span class="number">1536</span></span><br></pre></td></tr></table></figure>
<p>Native Heap是指c/c++ 中malloc出来的堆空间<br>Dalvik Heap是指java中new出来的java堆空间</p>
<p>这里可以看到Native Heap Pss Total列是2737 也就是native代码中分配了2737KB的空间被占用 Heap Size列是9728，是指Native堆最大是这么多KB，后面还有Heap Alloc列是8103，这里是指在虚拟地址中分配了这么多空间，Dalvik Heap同理是指java中占用的空间。</p>
<p>其中Pss Total是指占用了<strong>真实的物理内存的空间</strong>，而Heap Alloc只是占用的<strong>虚拟内存的空间</strong>。是分配了空间，没有使用的那部分内存。</p>
<blockquote>
<p>例如：</p>
<p>此时只在虚拟内存空间增加了8M大小<br>private long[] space = new long[1024*1024];   </p>
<p>如果给space赋值了，就会在真实的物理空间增加大小</p>
<p>for (int i = 0;  i &lt; 1024 * 1024; i++) {<br>​        space[i] = 01;<br>}</p>
</blockquote>
<blockquote>
<p><strong>虚拟内存</strong>：进程空间内的虚拟内存地址，理论上32位cpu一个进程有4GB的虚拟内存可以使用。<br><strong>物理内存</strong>：就是真正写的到内存条上的，真实地址对进程不可见，由操作系统把虚拟内存地址映射到物理内存地址。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dalvik Other      <span class="number">428</span>      <span class="number">428</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">        Stack      <span class="number">252</span>      <span class="number">252</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">       Ashmem        <span class="number">5</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    Other dev       <span class="number">14</span>        <span class="number">0</span>       <span class="number">12</span>        <span class="number">0</span></span><br><span class="line">     .so mmap     <span class="number">1601</span>      <span class="number">120</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .apk mmap      <span class="number">564</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .ttf mmap       <span class="number">59</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .dex mmap     <span class="number">3987</span>        <span class="number">4</span>     <span class="number">2228</span>        <span class="number">0</span></span><br><span class="line">    .oat mmap      <span class="number">306</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">    .art mmap     <span class="number">4131</span>     <span class="number">3800</span>       <span class="number">88</span>        <span class="number">0</span></span><br><span class="line">   Other mmap       <span class="number">13</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">      Unknown      <span class="number">323</span>      <span class="number">288</span>        <span class="number">0</span>        <span class="number">0</span></span><br><span class="line">        TOTAL    <span class="number">15055</span>     <span class="number">8140</span>     <span class="number">2328</span>        <span class="number">0</span>    <span class="number">12464</span>     <span class="number">9303</span>     <span class="number">3160</span></span><br></pre></td></tr></table></figure>
<p>其他的细节信息就是 Stack是指运行中栈空间的使用（函数调用，局部变量等），Ashmem是匿名内存占用的空间，各种mmap是对应类型文件加载部分占用内存（可以部分加载也叫映射到内存）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看某个进程内存详情</span></span><br><span class="line">adb shell cat /proc/&lt;pid&gt;/smaps</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd3ff000-cdc00000 rw-p 00000000 00:01 105348                             &#x2F;dev&#x2F;ashmem&#x2F;dalvik-large object space allocation (deleted)</span><br><span class="line">Size:               8196 kB</span><br><span class="line">Rss:                4100 kB</span><br><span class="line">Pss:                4100 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:      4100 kB</span><br><span class="line">Referenced:         4100 kB</span><br><span class="line">Anonymous:          4100 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">SwapPss:               0 kB</span><br><span class="line">KernelPageSize:        4 kB</span><br><span class="line">MMUPageSize:           4 kB</span><br><span class="line">Locked:                0 kB</span><br></pre></td></tr></table></figure>
<p>Size:指的就是分配了多少虚拟内存；</p>
<p>Rss、Pss指的是实际物理内存使用的大小，由于这个内存段是纯new出来的，没有共享库，所以这两个值是一样的。由于只给4MB的数组赋值，操作系统只给分配了4MB的真实物理内存。</p>
<h5 id="3-2-2-另一种方式统计应用内存"><a href="#3-2-2-另一种方式统计应用内存" class="headerlink" title="3.2.2 另一种方式统计应用内存"></a>3.2.2 另一种方式统计应用内存</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">App Summary</span><br><span class="line">                      Pss(KB)</span><br><span class="line">                       ------</span><br><span class="line">          Java Heap:     <span class="number">4464</span></span><br><span class="line">        Native Heap:     <span class="number">2668</span></span><br><span class="line">               Code:     <span class="number">2352</span></span><br><span class="line">              Stack:      <span class="number">252</span></span><br><span class="line">           Graphics:        <span class="number">0</span></span><br><span class="line">      Private Other:      <span class="number">732</span></span><br><span class="line">             System:     <span class="number">4587</span></span><br><span class="line"></span><br><span class="line">              TOTAL:    <span class="number">15055</span>       TOTAL SWAP PSS:        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Objects</span><br><span class="line">              Views:       <span class="number">17</span>         ViewRootImpl:        <span class="number">1</span></span><br><span class="line">        AppContexts:        <span class="number">3</span>           Activities:        <span class="number">1</span></span><br><span class="line">             Assets:        <span class="number">2</span>        AssetManagers:        <span class="number">3</span></span><br><span class="line">      Local Binders:        <span class="number">9</span>        Proxy Binders:       <span class="number">15</span></span><br><span class="line">      Parcel memory:        <span class="number">3</span>         Parcel count:       <span class="number">12</span></span><br><span class="line">   Death Recipients:        <span class="number">0</span>      OpenSSL Sockets:        <span class="number">0</span></span><br><span class="line">           WebViews:        <span class="number">0</span></span><br><span class="line"></span><br><span class="line">SQL</span><br><span class="line">        MEMORY_USED:        <span class="number">0</span></span><br><span class="line"> PAGECACHE_OVERFLOW:        <span class="number">0</span>          MALLOC_SIZE:        <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>App Summary部分换了一种方式统计Pss内存占用，其Total值和上面部分一致。可以通过App Summary查看到创建了多少对象，应用对象一段事件内是否没有正常释放导致内存溢出的情况。具体含义可以参考如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line">printRow(pw, ONE_COUNT_COLUMN,</span><br><span class="line"><span class="string">&quot;Java Heap:&quot;</span>, memInfo.getSummaryJavaHeap());</span><br><span class="line">printRow(pw, ONE_COUNT_COLUMN,</span><br><span class="line"><span class="string">&quot;Native Heap:&quot;</span>, memInfo.getSummaryNativeHeap());</span><br><span class="line">printRow(pw, ONE_COUNT_COLUMN,</span><br><span class="line"><span class="string">&quot;Code:&quot;</span>, memInfo.getSummaryCode());</span><br><span class="line">printRow(pw, ONE_COUNT_COLUMN,</span><br><span class="line"><span class="string">&quot;Stack:&quot;</span>, memInfo.getSummaryStack());</span><br><span class="line">printRow(pw, ONE_COUNT_COLUMN,</span><br><span class="line"><span class="string">&quot;Graphics:&quot;</span>, memInfo.getSummaryGraphics());</span><br><span class="line">printRow(pw, ONE_COUNT_COLUMN,</span><br><span class="line"><span class="string">&quot;Private Other:&quot;</span>, memInfo.getSummaryPrivateOther());</span><br><span class="line">printRow(pw, ONE_COUNT_COLUMN,</span><br><span class="line"><span class="string">&quot;System:&quot;</span>, memInfo.getSummarySystem());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>meminfo</tag>
      </tags>
  </entry>
  <entry>
    <title>Selinux规则生成，配置，以及解决neverallow方法</title>
    <url>/2021/08/18/Selinux%E8%A7%84%E5%88%99%E7%94%9F%E6%88%90%EF%BC%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3neverallow%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-收集"><a href="#1-收集" class="headerlink" title="1.收集"></a>1.收集</h4><p>查看Selinux当前安全策略模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getenforce</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Enforcing  强制模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Permissive 兼容模式</span></span><br></pre></td></tr></table></figure>


<p>设置Selinux模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置Selinux为兼容模式</span></span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置Selinux为强制模式</span></span><br><span class="line">setenforce 1</span><br></pre></td></tr></table></figure>


<h5 id="1-1-收集日志"><a href="#1-1-收集日志" class="headerlink" title="1.1 收集日志"></a>1.1 收集日志</h5><ul>
<li><p>将selinux安全模式设置成兼容模式，然后运行自己的应用，点检全功能，最后导出dlt或者logcat日志。</p>
</li>
<li><p>搜索<code>avc：</code>并且取出对应的日志，取名为xxx.txt （例如denied.txt）</p>
</li>
<li><p>使用audit2allow 工具转化日志成规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">audit2allow -i denied.txt &gt; selinux_rule.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-配置规则"><a href="#2-配置规则" class="headerlink" title="2 配置规则"></a>2 配置规则</h4><p>获取到selinux_rule.txt如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">============= bluetooth ==============</span></span><br><span class="line">allow bluetooth mediametrics_service:service_manager find;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">============= g7ph_x5r ==============</span></span><br><span class="line">allow g7ph_x5r ip_exec:file &#123; execute execute_no_trans getattr map open read &#125;;</span><br><span class="line">allow g7ph_x5r net_data_file:dir search;</span><br><span class="line">allow g7ph_x5r net_data_file:file &#123; getattr open read &#125;;</span><br><span class="line">allow g7ph_x5r proc_cmdline:file &#123; open read &#125;;</span><br><span class="line">allow g7ph_x5r self:capability net_admin;</span><br><span class="line">allow g7ph_x5r self:netlink_route_socket &#123; bind create getattr nlmsg_write read setopt write &#125;;</span><br><span class="line">allow g7ph_x5r self:udp_socket &#123; create ioctl &#125;;</span><br><span class="line">allow g7ph_x5r vendor_toolbox_exec:file &#123; execute execute_no_trans map &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">============= hal_audio_default ==============</span></span><br><span class="line">allow hal_audio_default hal_vehicle_hwservice:hwservice_manager find;</span><br><span class="line">allow hal_audio_default netd:unix_stream_socket connectto;</span><br><span class="line">allow hal_audio_default self:tcp_socket &#123; connect create &#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">============= bluetooth ==============</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这一行中的bluetooth代表bluetooth.te文件，在device目录找到对应要生效的te把规则加入进去，保证编译通过验证一下还有没有其他规则报出来，如果没有了就说明通过了。</span></span><br></pre></td></tr></table></figure>


<h4 id="3-检查配置"><a href="#3-检查配置" class="headerlink" title="3.检查配置"></a>3.检查配置</h4><p>有的时候权限明明加进去了却还是报相同的错误,这个时候你就得检查你是否加对地方了。</p>
<p>查看如下目录是否有配置的策略。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">out/target/product/msmnile_gvmq/obj/ETC/sepolicy.recovery_intermediates/sepolicy.recovery.conf</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Selinux</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化--分析应用性能</title>
    <url>/2021/08/15/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>对于应用来说响应速度慢、动画播放不流畅、卡顿或耗电量过高，就表示应用的性能不佳。若要解决性能问题，就需要找出应用在哪些情况下不能有效地利用资源（例如 CPU、内存、图形、网络和设备电池）。权衡一个应用的性能好坏的主要几个指标是：CPU，内存，网络，能耗，崩溃率，ANR率和APK大小。针对前面4项性能指标，google提供了对应的工具以便开发者分析自身应用。</p>
<ul>
<li><strong>CPU 性能分析器</strong>：此工具有助于查出运行时性能问题。</li>
<li><strong>内存性能分析器</strong>：此工具有助于跟踪内存分配情况。</li>
<li><strong>网络性能分析器</strong>：此工具可监控网络流量使用情况。</li>
<li><strong>能耗性能分析器</strong>：此工具会跟踪能耗情况，这有助于分析电池电量消耗。</li>
</ul>
<p>如需了解如何使用这些工具，请参阅 <a href="https://developer.android.com/studio/profile/android-profiler">Android Studio 性能分析器</a>页面。</p>
<p>针对应用细节性能指标，借助 Jetpack 基准库衡量各种重要操作：</p>
<ul>
<li><strong>Macrobenchmark</strong>：衡量重要的性能用例，包括应用启动性能用例和由操作触发的重新绘制时性能用例，例如界面动画或滚动。</li>
<li><strong>Benchmark</strong>：衡量特定函数的 CPU 开销。</li>
</ul>
<p>如需详细了解这些库，请参阅<a href="https://developer.android.com/studio/profile/benchmarking-overview">对应用进行基准化分析</a>页面。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>应用优化概述</tag>
      </tags>
  </entry>
  <entry>
    <title>生成bootchart(系统优化)</title>
    <url>/2021/08/30/%E7%94%9F%E6%88%90bootchart-%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="1-bootchart的启动过程"><a href="#1-bootchart的启动过程" class="headerlink" title="1.bootchart的启动过程"></a>1.bootchart的启动过程</h4><p>bootchart的启动时在init.rc中被解析，然后在on post-fs-data阶段data分区挂载之后开启，当收到<code>sys.boot_completed</code>属性置1之后，结束采集bootchart。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">on post-fs-data</span><br><span class="line">	......</span><br><span class="line"><span class="meta">	#</span><span class="bash"> Start bootcharting as soon as possible after the data partition is</span></span><br><span class="line">    # mounted to collect more data.</span><br><span class="line">    mkdir /data/bootchart 0755 shell shell</span><br><span class="line">    bootchart start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里由于系统车机系统定制了，采集的bootchart时间只有20s左右特别短，需要自定义一个属性，开发早期需要看到launcher起来了，手动设置一个属性关闭bootchart</span></span><br><span class="line">on property:sys.boot_completed=1</span><br><span class="line">    bootchart stop</span><br></pre></td></tr></table></figure>


<h4 id="2-采集bootchart开关"><a href="#2-采集bootchart开关" class="headerlink" title="2.采集bootchart开关"></a>2.采集bootchart开关</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Result&lt;Success&gt; <span class="title">do_bootchart_start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We don&#x27;t care about the content, but we do care that /data/bootchart/enabled actually exists.</span></span><br><span class="line">    <span class="comment">// 只要/data/bootchart/enabled文件存在，就开启一个线程开始统计bootchart</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> start;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::ReadFileToString(<span class="string">&quot;/data/bootchart/enabled&quot;</span>, &amp;start)) &#123;</span><br><span class="line">        LOG(VERBOSE) &lt;&lt; <span class="string">&quot;Not bootcharting&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_bootcharting_thread = <span class="keyword">new</span> <span class="built_in">std</span>::thread(bootchart_thread_main);</span><br><span class="line">    <span class="keyword">return</span> Success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-制作bootchart图片"><a href="#3-制作bootchart图片" class="headerlink" title="3.制作bootchart图片"></a>3.制作bootchart图片</h4><p>采集结束之后，会在/data/bootchart目录生成<code>header</code>,<code>proc_diskstats.log</code>,<code>proc_ps.log</code>,<code>proc_stat.log</code>这四个文件，将这四个文件从车机pull出来导入服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用tar -czf bootchart.tgz *，打包所有文件成bootchart.tgz</span></span><br><span class="line">jieou@gxatek-fw-no:/work/jieou/tools/bootchart$ ls</span><br><span class="line">bootchart.tgz  enabled  header  proc_diskstats.log  proc_ps.log  proc_stat.log</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用bootchart 工具生成图片</span></span><br><span class="line">bootchart bootchart.tgz</span><br></pre></td></tr></table></figure>


<h4 id="4-生成结果"><a href="#4-生成结果" class="headerlink" title="4.生成结果"></a>4.生成结果</h4><p>从结果里面看到其实还有很多服务都没有启动结束，而且launcher都没有启动起来。因此就需要第一小节中提到的，需要修改bootchart采集结束的属性，通过手动结束结束bootchart</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-cf936b4a17a125c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bootchart.png"></p>
<h4 id="5-修改之后的bootchart"><a href="#5-修改之后的bootchart" class="headerlink" title="5.修改之后的bootchart"></a>5.修改之后的bootchart</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-052d4adab589aa9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bootchart.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>bootchart</tag>
        <tag>系统优化</tag>
      </tags>
  </entry>
  <entry>
    <title>调查地图发大数据量广播，导致接收端被kill的异常</title>
    <url>/2021/08/18/%E8%A7%A3%E5%86%B3%E5%9C%B0%E5%9B%BE%E5%8F%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B9%BF%E6%92%AD%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%8E%A5%E6%94%B6%E7%AB%AF%E8%A2%ABkill%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>1.</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>广播异常</tag>
      </tags>
  </entry>
  <entry>
    <title>解析cat /proc/meminfo</title>
    <url>/2021/08/16/%E8%A7%A3%E6%9E%90cat-proc-meminfo/</url>
    <content><![CDATA[<h4 id="1-车机原始数据"><a href="#1-车机原始数据" class="headerlink" title="1.车机原始数据"></a>1.车机原始数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>
<p>以上指令可以打印内存信息如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MemTotal:        <span class="number">6266692</span> kB  <span class="comment">// 所有可用的内存大小，物理内存减去预留位和内核使用。系统从加电开始到引导完成，firmware/BIOS要预留一些内存，内核本身要占用一些内存，最后剩下可供内核支配的内存就是MemTotal。这个值在系统运行期间一般是固定不变的，重启会改变。</span></span><br><span class="line">MemFree:         <span class="number">1836516</span> kB  <span class="comment">//表示系统尚未使用的内存。</span></span><br><span class="line">MemAvailable:    <span class="number">3738928</span> kB  <span class="comment">//真正的系统可用内存，系统中有些内存虽然已被使用但是可以回收的，比如cache/buffer、slab都有一部分可以回收，所以这部分可回收的内存加上MemFree才是系统可用的内存</span></span><br><span class="line">Buffers:           <span class="number">67152</span> kB  <span class="comment">//用来给块设备做缓存的内存，(文件系统的 metadata、pages)</span></span><br><span class="line">Cached:          <span class="number">1793152</span> kB  <span class="comment">//分配给文件缓冲区的内存,例如vi一个文件，就会将未保存的内容写到该缓冲区</span></span><br><span class="line">SwapCached:            <span class="number">0</span> kB  <span class="comment">//被高速缓冲存储用的交换空间（硬盘的swap）的大小</span></span><br><span class="line">Active:          <span class="number">1996864</span> kB  <span class="comment">//经常使用的高速缓冲存储器页面文件大小</span></span><br><span class="line">Inactive:        <span class="number">1430604</span> kB  <span class="comment">//不经常使用的高速缓冲存储器文件大小</span></span><br><span class="line">Active(anon):    <span class="number">1569732</span> kB  <span class="comment">//活跃的匿名内存</span></span><br><span class="line">Inactive(anon):     <span class="number">1604</span> kB  <span class="comment">//不活跃的匿名内存</span></span><br><span class="line">Active(file):     <span class="number">427132</span> kB  <span class="comment">//活跃的文件使用内存</span></span><br><span class="line">Inactive(file):  <span class="number">1429000</span> kB  <span class="comment">//不活跃的文件使用内存</span></span><br><span class="line">Unevictable:        <span class="number">2876</span> kB  <span class="comment">//不能被释放的内存页</span></span><br><span class="line">Mlocked:            <span class="number">2876</span> kB  <span class="comment">//系统调用 mlock 家族允许程序在物理内存上锁住它的部分或全部地址空间。这将阻止Linux 将这个内存页调度到交换空间（swap space），即使该程序已有一段时间没有访问这段空间</span></span><br><span class="line">SwapTotal:             <span class="number">0</span> kB  <span class="comment">//交换空间总内存</span></span><br><span class="line">SwapFree:              <span class="number">0</span> kB  <span class="comment">//交换空间空闲内存</span></span><br><span class="line">Dirty:               <span class="number">900</span> kB  <span class="comment">//等待被写回到磁盘的</span></span><br><span class="line">Writeback:             <span class="number">0</span> kB  <span class="comment">//正在被写回的</span></span><br><span class="line">AnonPages:       <span class="number">1569960</span> kB  <span class="comment">//未映射页的内存/映射到用户空间的非文件页表大小</span></span><br><span class="line">Mapped:           <span class="number">952644</span> kB  <span class="comment">//映射文件内存</span></span><br><span class="line">Shmem:              <span class="number">1896</span> kB  <span class="comment">//已经被分配的共享内存</span></span><br><span class="line">Slab:             <span class="number">270360</span> kB  <span class="comment">//内核数据结构缓存</span></span><br><span class="line">SReclaimable:      <span class="number">98248</span> kB  <span class="comment">//可收回slab内存</span></span><br><span class="line">SUnreclaim:       <span class="number">172112</span> kB  <span class="comment">//不可收回slab内存</span></span><br><span class="line">KernelStack:       <span class="number">51008</span> kB  <span class="comment">//内核消耗的内存</span></span><br><span class="line">PageTables:        <span class="number">72332</span> kB  <span class="comment">//管理内存分页的索引表的大小</span></span><br><span class="line">NFS_Unstable:          <span class="number">0</span> kB  <span class="comment">//不稳定页表的大小</span></span><br><span class="line">Bounce:                <span class="number">0</span> kB  <span class="comment">//在低端内存中分配一个临时buffer作为跳转，把位于高端内存的缓存数据复制到此处消耗的内存</span></span><br><span class="line">WritebackTmp:          <span class="number">0</span> kB  <span class="comment">//FUSE用于临时写回缓冲区的内存</span></span><br><span class="line">CommitLimit:     <span class="number">3133344</span> kB  <span class="comment">//系统实际可分配内存</span></span><br><span class="line">Committed_AS:   <span class="number">174521232</span> kB  <span class="comment">//系统当前已分配的内存</span></span><br><span class="line">VmallocTotal:   <span class="number">263061440</span> kB  <span class="comment">//预留的虚拟内存总量</span></span><br><span class="line">VmallocUsed:      <span class="number">138388</span> kB  <span class="comment">//已经被使用的虚拟内存</span></span><br><span class="line">VmallocChunk:          <span class="number">0</span> kB  <span class="comment">//可分配的最大的逻辑连续的虚拟内存</span></span><br><span class="line">CmaTotal:         <span class="number">401408</span> kB  </span><br><span class="line">CmaFree:          <span class="number">397656</span> kB  </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>meminfo</tag>
      </tags>
  </entry>
  <entry>
    <title>调查地图发大数据量广播，导致接收端被kill的异常</title>
    <url>/2021/08/18/%E8%B0%83%E6%9F%A5%E5%9C%B0%E5%9B%BE%E5%8F%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B9%BF%E6%92%AD%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%8E%A5%E6%94%B6%E7%AB%AF%E8%A2%ABkill%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1.问题现象"></a>1.问题现象</h4><p>氛围灯和导航交互过程中，导航发送一个广播之后，接连有五个服务被kill掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JavaBinder: !!! FAILED BINDER TRANSACTION !!!  (parcel size = <span class="number">932116</span>)</span><br><span class="line">BroadcastQueue: Can<span class="string">&#x27;t deliver broadcast to com.gxa.service.messagecenter (pid 2707). Crashing it.</span></span><br><span class="line"><span class="string">BroadcastQueue: Failure sending broadcast Intent &#123; act=com.iflytek.autofly.ACTION_MAP_SEND flg=0x10 (has extras) &#125;</span></span><br><span class="line"><span class="string">BroadcastQueue: android.os.TransactionTooLargeException: data parcel size 932116 bytes</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at android.os.BinderProxy.transactNative(Native Method)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at android.os.BinderProxy.transact(Binder.java:1127)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at android.app.IApplicationThread$Stub$Proxy.scheduleRegisteredReceiver(IApplicationThread.java:1152)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at com.android.server.am.BroadcastQueue.performReceiveLocked(BroadcastQueue.java:494)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at com.android.server.am.BroadcastQueue.deliverToRegisteredReceiverLocked(BroadcastQueue.java:706)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at com.android.server.am.BroadcastQueue.processNextBroadcastLocked(BroadcastQueue.java:866)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at com.android.server.am.BroadcastQueue.processNextBroadcast(BroadcastQueue.java:825)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at com.android.server.am.BroadcastQueue$BroadcastHandler.handleMessage(BroadcastQueue.java:172)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at android.os.Handler.dispatchMessage(Handler.java:106)</span></span><br><span class="line"><span class="string">BroadcastQueue: 	at android.os.Looper.loop(Looper.java:193)</span></span><br><span class="line"><span class="string">W BroadcastQueue: 	at android.os.HandlerThread.run(HandlerThread.java:65)</span></span><br><span class="line"><span class="string">W BroadcastQueue: 	at com.android.server.ServiceThread.run(ServiceThread.java:44)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">AndroidRuntime: Shutting down VM</span></span><br><span class="line"><span class="string">JavaBinder: !!! FAILED BINDER TRANSACTION !!!  (parcel size = 932116)</span></span><br><span class="line"><span class="string">BroadcastQueue: Can&#x27;</span>t deliver broadcast to com.gxatek.cockpit.atmospherelampservice (pid <span class="number">3559</span>). Crashing it.</span><br><span class="line">AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">AndroidRuntime: Process: com.gxa.service.messagecenter, PID: <span class="number">2707</span></span><br><span class="line">AndroidRuntime: android.app.RemoteServiceException: can<span class="string">&#x27;t deliver broadcast</span></span><br><span class="line"><span class="string">AndroidRuntime: 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1745)</span></span><br><span class="line"><span class="string">AndroidRuntime: 	at android.os.Handler.dispatchMessage(Handler.java:106)</span></span><br><span class="line"><span class="string">AndroidRuntime: 	at android.os.Looper.loop(Looper.java:193)</span></span><br><span class="line"><span class="string">AndroidRuntime: 	at android.app.ActivityThread.main(ActivityThread.java:6718)</span></span><br><span class="line"><span class="string">AndroidRuntime: 	at java.lang.reflect.Method.invoke(Native Method)</span></span><br><span class="line"><span class="string">AndroidRuntime: 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)</span></span><br><span class="line"><span class="string">AndroidRuntime: 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 被kill进程</span><br><span class="line">com.gxatek.cockpit.atmospherelampservice</span><br><span class="line">com.gxatek.cockpit.scenesengine</span><br><span class="line">com.iflytek.autofly.naviselect</span><br><span class="line">com.gxatek.cockpit.vpamultimode</span><br><span class="line">com.gxa.service.messagecenter</span><br></pre></td></tr></table></figure>


<h4 id="2-问题定位"><a href="#2-问题定位" class="headerlink" title="2.问题定位"></a>2.问题定位</h4><p>看日志大概问题是<code>FAILED BINDER TRANSACTION</code>,binder传输数据失败，<code>parcel size = 932116</code>parcel大小为932116字节。</p>
<p>然后一看是<code>BroadcastQueue</code>类报出来的，于是乎找到报错的地方</p>
<blockquote>
<p>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bfb8e289ca844e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错点.png"></p>
<p>可以看到调用对端的<code>scheduleRegisteredReceiver</code>方法的时候报了异常，然后捕获异常中输出日志，最后throw一个异常，导致对端进程crash。</p>
<h4 id="3-问题调查"><a href="#3-问题调查" class="headerlink" title="3.问题调查"></a>3.问题调查</h4><p>在源码中添加日志如下，打出两端进程信息，看看广播交互情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b86f17935580ea42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调查添加日志.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BroadcastQueue: performReceiveLocked CallingPid = <span class="number">786</span>, CallingUid = <span class="number">1000</span></span><br><span class="line">BroadcastQueue: intent = Intent &#123; act=com.iflytek.autofly.ACTION_MAP_SEND flg=<span class="number">0x10</span> (has extras) &#125;, data = <span class="keyword">null</span></span><br><span class="line">BroadcastQueue: processname = com.gxatek.cockpit.atmospherelampservice, thread name = android.app.IApplicationThread$Stub$Proxy<span class="meta">@d42f0e6</span></span><br><span class="line"></span><br><span class="line">BroadcastQueue: performReceiveLocked CallingPid = <span class="number">786</span>, CallingUid = <span class="number">1000</span></span><br><span class="line">BroadcastQueue: intent = Intent &#123; act=com.iflytek.autofly.ACTION_MAP_SEND flg=<span class="number">0x10</span> (has extras) &#125;, data = <span class="keyword">null</span></span><br><span class="line">BroadcastQueue: processname = com.gxatek.cockpit.scenesengine, thread name = android.app.IApplicationThread$Stub$Proxy@9f803ef</span><br></pre></td></tr></table></figure>


<p>找到交互双方之后就开始调查是哪一方发送了过大广播。首先注销掉地图的接收广播，只给地图发广播，发现消息中心不会被kill，然后一个一个广播试监听那个广播报的传输数据量过大。最后发现监听<code>com.iflytek.autofly.ACTION_MAP_SEND</code>这个广播，一交互就报<code>toolargeException</code>而崩溃，基本定位到地图发送该广播intent内容超限。</p>
<p>经过地图调查发现：AR导航测试的功能广播打开，导致数据量过大。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>广播异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler机制——底层实现机制</title>
    <url>/2021/09/01/Handler%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1.回顾"></a>1.回顾</h4><p>我们在上一篇文章<a href="http://jackou.top/2021/01/27/Handler%E6%9C%BA%E5%88%B6/">《Handler机制》</a>中详细叙述了Handler运行机制的java层实现，每当分析到jni,就只简要说明了下底层做了什么，因此，我们在这篇文章中详细来分析一下Handler的底层代码，看看底层是如何实现的。首先列出底层有那些方法。先分析简单的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/MessageQueue.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">/*non-static for callbacks*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br></pre></td></tr></table></figure>


<h4 id="2-nativeInit-分析"><a href="#2-nativeInit-分析" class="headerlink" title="2.nativeInit()分析"></a>2.nativeInit()分析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\jni\android_os_MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个NativeMessageQueue对象</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">&quot;Unable to allocate native queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强引用计数+1</span></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="comment">// 将对象地址转化成jlong型，赋值给java层的mPtr参数，以后访问native中的messagequeue对象就通过该指针找到他。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-nativeDestroy-分析"><a href="#3-nativeDestroy-分析" class="headerlink" title="3.nativeDestroy()分析"></a>3.nativeDestroy()分析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeDestroy</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过ptr找到messagequeue对象</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">// 引用计数减一</span></span><br><span class="line">    nativeMessageQueue-&gt;decStrong(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-nativeIsPolling-分析"><a href="#4-nativeIsPolling-分析" class="headerlink" title="4.nativeIsPolling()分析"></a>4.nativeIsPolling()分析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_MessageQueue_nativeIsPolling</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">// 返回当前poll是否空闲，true为空闲，正在等待监听事件产生</span></span><br><span class="line">    <span class="comment">// mPolling在pollInner中被赋值</span></span><br><span class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;getLooper()-&gt;isPolling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-nativeSetFileDescriptorEvents-分析"><a href="#5-nativeSetFileDescriptorEvents-分析" class="headerlink" title="5.nativeSetFileDescriptorEvents()分析"></a>5.nativeSetFileDescriptorEvents()分析</h4><p>nativeSetFileDescriptorEvents()给java层提供了一个接口，上层可以自己选择要监听的事件，事件分为：</p>
<ul>
<li>EVENT_INPUT</li>
<li>EVENT_OUTPUT</li>
<li>EVENT_ERROR</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeSetFileDescriptorEvents</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint fd, jint events)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;setFileDescriptorEvents(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-nativePollOnce-分析"><a href="#6-nativePollOnce-分析" class="headerlink" title="6.nativePollOnce()分析"></a>6.nativePollOnce()分析</h4><p>下面开始分析重头戏，开始分析nativePollOnce()和nativeWake()两个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">// 调用到messagequeue的pollonce方法中去。</span></span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    <span class="comment">// 调用到Looper的pollOnce方法，并且传入超时时间</span></span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system\core\libutils\Looper.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pollOnce(timeoutMillis, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">		<span class="comment">// 判断pollInner处理的结果</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">            ALOGD(<span class="string">&quot;%p ~ pollOnce - returning result %d&quot;</span>, <span class="keyword">this</span>, result);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>result代表pollinner中epoll处理事件的状态</p>
<ul>
<li>POLL_WAKE：调用wate()说明正在等待事件发生</li>
<li>POLL_CALLBACK：将结果返回给回调</li>
<li>POLL_TIMEOUT：epoll_wait()超时</li>
<li>POLL_ERROR:内部错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust the timeout based on when the next message is due.</span></span><br><span class="line">    <span class="comment">// 调整超时事件</span></span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis != <span class="number">0</span> &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">int</span> messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</span><br><span class="line">        <span class="keyword">if</span> (messageTimeoutMillis &gt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; (timeoutMillis &lt; <span class="number">0</span> || messageTimeoutMillis &lt; timeoutMillis)) &#123;</span><br><span class="line">            timeoutMillis = messageTimeoutMillis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are about to idle.</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">	<span class="comment">//阻塞整个线程，等待监听的事件发送，eventCount是epoll_wait的返回，返回需要处理的事件数目</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for poll timeout.</span></span><br><span class="line">    <span class="comment">// 如果过了超时事件，还没事件发生，就直接返回，通知超时</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle all events.</span></span><br><span class="line">	<span class="comment">// 开始处理监听的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">// 如果有事件发送，并且是我们监听的fd并且是输入事件，线程则被唤醒，开始执行被阻塞下面的代码</span></span><br><span class="line">                awoken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;</span></span><br><span class="line">                        <span class="string">&quot;no longer registered.&quot;</span>, epollEvents, fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，继续回顾java如何取message的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">        <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">        <span class="comment">// which is not supported.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用nativePollOnce()线程就阻塞在这里，不继续执行下面代码</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">            <span class="comment">// 唤醒或者阻塞超时就开始执行下面代码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">				<span class="comment">// 下面就是加锁取一个msg返回的逻辑</span></span><br><span class="line">				......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-nativeWake-分析"><a href="#6-nativeWake-分析" class="headerlink" title="6.nativeWake()分析"></a>6.nativeWake()分析</h4><p>上面我们分析了调用nativePollOnce()，线程会被阻塞，不会继续执行下面的代码，要么是被唤醒，要么超时才开始执行下面的代码。下面我们就来看一下线程是如何被唤醒的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">// 调用messagequeue的wake()方法</span></span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 继续往下掉用</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写了一个1到mWakeEventFd中，激活epoll事件，然后线程就被唤醒了</span></span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此唤醒就特别简单，直接向监听的fd中写一个字符即可唤醒线程处理事件。</p>
<p>未完待续，顺势推舟，下面一篇叙述一下epoll是如何使用的方法</p>
<p>HandlerThread、JobIntentService和JobService的使用方法。参考《<a href="git@github.com:oujie123/Handler.git">Handler扩展使用</a>》</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>Framework</tag>
        <tag>Andriod</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll使用详解</title>
    <url>/2021/09/02/epoll%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>epoll - I/O event notification facility</p>
<p>在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。<br>相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。并且，在linux/posix_types.h头文件有这样的声明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">define __FD_SETSIZE  1024</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。</span></span><br></pre></td></tr></table></figure>


<h4 id="2-epoll函数说明"><a href="#2-epoll函数说明" class="headerlink" title="2.epoll函数说明"></a>2.epoll函数说明</h4><p>epoll的接口非常简单，一共就三个函数：</p>
<h5 id="2-1-int-epoll-create-int-size"><a href="#2-1-int-epoll-create-int-size" class="headerlink" title="2.1 int epoll_create(int size);"></a>2.1 int epoll_create(int size);</h5><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>注意：size参数只是告诉内核这个 epoll对象会处理的事件大致数目，而不是能够处理的事件的最大个数。在 Linux最新的一些内核版本的实现中，这个 size参数没有任何意义。</p>
<h5 id="2-2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#2-2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="2.2 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);"></a>2.2 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</h5><p>epoll的事件注册函数，epoll_ctl向 epoll对象中添加、修改或者删除感兴趣的事件，返回0表示成功，否则返回–1，此时需要根据errno错误码判断错误类型。</p>
<p>它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p>
<p>epoll_wait方法返回的事件必然是通过 epoll_ctl添加到 epoll中的。</p>
<p>第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：<br>EPOLL_CTL_ADD：注册新的fd到epfd中；<br>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>EPOLL_CTL_DEL：从epfd中删除一个fd；<br>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>events可以是以下几个宏的集合：<br>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>EPOLLOUT：表示对应的文件描述符可以写；<br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR：表示对应的文件描述符发生错误；<br>EPOLLHUP：表示对应的文件描述符被挂断；<br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<h5 id="2-3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#2-3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="2.3 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);"></a>2.3 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</h5><p>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误，需要检查 errno错误码判断错误类型。</p>
<p>第1个参数 epfd是 epoll的描述符。</p>
<p>第2个参数 events则是分配好的 epoll_event结构体数组，epoll将会把发生的事件复制到 events数组中（events不可以是空指针，内核只负责把数据复制到这个 events数组中，不会去帮助我们在用户态中分配内存。内核这种做法效率很高）。</p>
<p>第3个参数 maxevents表示本次可以返回的最大事件数目，通常 maxevents参数与预分配的events数组的大小是相等的。</p>
<p>第4个参数 timeout表示在没有检测到事件发生时最多等待的时间（单位为毫秒），如果 timeout为0，则表示 epoll_wait在 rdllist链表中为空，立刻返回，不会等待。</p>
<h5 id="2-4-关于ET、LT两种工作模式："><a href="#2-4-关于ET、LT两种工作模式：" class="headerlink" title="2.4 关于ET、LT两种工作模式："></a>2.4 关于ET、LT两种工作模式：</h5><p>epoll有两种工作模式：LT（水平触发）模式和ET（边缘触发）模式。</p>
<p>默认情况下，epoll采用 LT模式工作，这时可以处理阻塞和非阻塞套接字，而上表中的 EPOLLET表示可以将一个事件改为 ET模式。ET模式的效率要比 LT模式高，它只支持非阻塞套接字。</p>
<p> ET模式与LT模式的区别在于：</p>
<p>当一个新的事件到来时，ET模式下当然可以从 epoll_wait调用中获取到这个事件，可是如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字没有新的事件再次到来时，在 ET模式下是无法再次从 epoll_wait调用中获取这个事件的；而 LT模式则相反，只要一个事件对应的套接字缓冲区还有数据，就总能从 epoll_wait中获取这个事件。因此，在 LT模式下开发基于 epoll的应用要简单一些，不太容易出错，而在 ET模式下事件发生时，如果没有彻底地将缓冲区数据处理完，则会导致缓冲区中的用户请求得不到响应。默认情况下，Nginx是通过 ET模式使用 epoll的。</p>
<p>结论:<br>ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样;而LT模式是只要有数据没有处理就会一直通知下去的.</p>
<h4 id="3-epoll使用"><a href="#3-epoll使用" class="headerlink" title="3.epoll使用"></a>3.epoll使用</h4><p>那么究竟如何来使用epoll呢？其实非常简单。<br>通过在包含一个头文件#include &lt;sys/epoll.h&gt; 以及几个简单的API将可以大大的提高你的网络服务器的支持人数。</p>
<p>首先通过create_epoll(int maxfds)来创建一个epoll的句柄，其中maxfds为你epoll所支持的最大句柄数。这个函数会返回一个新的epoll句柄，之后的所有操作将通过这个句柄来进行操作。在用完之后，记得用close()来关闭这个创建出来的epoll句柄。</p>
<p>之后在你的网络主循环里面，每一帧的调用epoll_wait(int epfd, epoll_event events, int max events, int timeout)来查询所有的网络接口，看哪一个可以读，哪一个可以写了。基本的语法为：<br>nfds = epoll_wait(kdpfd, events, maxevents, -1);<br>其中kdpfd为用epoll_create创建之后的句柄，events是一个epoll_event*的指针，当epoll_wait这个函数操作成功之后，epoll_events里面将储存所有的读写事件。max_events是当前需要监听的所有socket句柄数。最后一个timeout是 epoll_wait的超时，为0的时候表示马上返回，为-1的时候表示一直等下去，直到有事件范围，为任意正整数的时候表示等这么长的时间，如果一直没有事件，则范围。一般如果网络主循环是单独的线程的话，可以用-1来等，这样可以保证一些效率，如果是和主逻辑在同一个线程的话，则可以用0来保证主循环的效率。</p>
<p>epoll_wait范围之后应该是一个循环，遍利所有的事件。</p>
<p>几乎所有的epoll程序都使用下面的框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd) <span class="comment">//有新的连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                n = read(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></span><br><span class="line">                ev.data.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="comment">//取数据</span></span><br><span class="line">                sockfd = md-&gt;fd;</span><br><span class="line">                send( sockfd, md-&gt;ptr, <span class="built_in">strlen</span>((<span class="keyword">char</span>*)md-&gt;ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他的处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>服务的代码案例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTIM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts;</span><br><span class="line">    opts=fcntl(sock,F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(opts&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl(sock,GETFL)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = opts|O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span>(fcntl(sock,F_SETFL,opts)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl(sock,SETFL,opts)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, maxi, listenfd, connfd, sockfd,epfd,nfds, portnumber;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> line[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">2</span> == argc )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (portnumber = atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Usage:%s portnumber/a/n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Usage:%s portnumber/a/n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">events</span>[20];</span></span><br><span class="line">    <span class="comment">//生成用于处理accept的epoll专用的文件描述符</span></span><br><span class="line"></span><br><span class="line">    epfd=epoll_create(<span class="number">256</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把socket设置为非阻塞方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//setnonblocking(listenfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置与要处理的事件相关的文件描述符</span></span><br><span class="line"></span><br><span class="line">    ev.data.fd=listenfd;</span><br><span class="line">    <span class="comment">//设置要处理的事件类型</span></span><br><span class="line"></span><br><span class="line">    ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">    <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册epoll事件</span></span><br><span class="line"></span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">char</span> *local_addr=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    inet_aton(local_addr,&amp;(serveraddr.sin_addr));<span class="comment">//htons(portnumber);</span></span><br><span class="line"></span><br><span class="line">    serveraddr.sin_port=htons(portnumber);</span><br><span class="line">    bind(listenfd,(sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    listen(listenfd, LISTENQ);</span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">//等待epoll事件的发生</span></span><br><span class="line"></span><br><span class="line">        nfds=epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//处理所发生的所有事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd)<span class="comment">//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen);</span><br><span class="line">                <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;connfd&lt;0&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//setnonblocking(connfd);</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> *str = inet_ntoa(clientaddr.sin_addr);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;accapt a connection from &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//注册ev</span></span><br><span class="line"></span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLIN)<span class="comment">//如果是已经连接的用户，并且收到数据，那么进行读入。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EPOLLIN&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (sockfd = events[i].data.fd) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (n = read(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;readline error&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line[n] = &#x27;/0&#x27;;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;read &quot;</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//设置用于写操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的写操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">// 如果有数据发送</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                sockfd = events[i].data.fd;</span><br><span class="line">                write(sockfd, line, n);</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLIN</span></span><br><span class="line"></span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Framework</tag>
        <tag>Andriod</tag>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>init脚本说明文档分析</title>
    <url>/2021/03/23/init%E8%84%9A%E6%9C%AC%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Android-Init-Language"><a href="#Android-Init-Language" class="headerlink" title="Android Init Language"></a>Android Init Language</h2><p>The Android Init Language consists of five broad classes of statements:<br>Actions, Commands, Services, Options, and Imports.</p>
<p>All of these are line-oriented, consisting of tokens separated by<br>whitespace.  The c-style backslash escapes may be used to insert<br>whitespace into a token.  Double quotes may also be used to prevent<br>whitespace from breaking text into multiple tokens.  The backslash,<br>when it is the last character on a line, may be used for line-folding.</p>
<p>Lines which start with a <code>#</code> (leading whitespace allowed) are comments.</p>
<p>System properties can be expanded using the syntax<br><code>$&#123;property.name&#125;</code>. This also works in contexts where concatenation is<br>required, such as <code>import /init.recovery.$&#123;ro.hardware&#125;.rc</code>.</p>
<p>Actions and Services implicitly declare a new section.  All commands<br>or options belong to the section most recently declared.  Commands<br>or options before the first section are ignored.</p>
<p>Services have unique names.  If a second Service is defined<br>with the same name as an existing one, it is ignored and an error<br>message is logged.</p>
<h2 id="Init-rc-Files"><a href="#Init-rc-Files" class="headerlink" title="Init .rc Files"></a>Init .rc Files</h2><p>The init language is used in plain text files that take the .rc file<br>extension.  There are typically multiple of these in multiple<br>locations on the system, described below.</p>
<p>/init.rc is the primary .rc file and is loaded by the init executable<br>at the beginning of its execution.  It is responsible for the initial<br>set up of the system.</p>
<p>Devices that mount /system, /vendor through the first stage mount mechanism<br>load all of the files contained within the<br>/{system,vendor,odm}/etc/init/ directories immediately after loading<br>the primary /init.rc.  This is explained in more details in the<br>Imports section of this file.</p>
<p>Legacy devices without the first stage mount mechanism do the following:</p>
<ol>
<li>/init.rc imports /init.${ro.hardware}.rc which is the primary<br>vendor supplied .rc file.</li>
<li>During the mount_all command, the init executable loads all of the<br>files contained within the /{system,vendor,odm}/etc/init/ directories.<br>These directories are intended for all Actions and Services used after<br>file system mounting.</li>
</ol>
<p>One may specify paths in the mount_all command line to have it import<br>.rc files at the specified paths instead of the default ones listed above.<br>This is primarily for supporting factory mode and other non-standard boot<br>modes.  The three default paths should be used for the normal boot process.</p>
<p>The intention of these directories is:</p>
<ol>
<li>/system/etc/init/ is for core system items such as<br>SurfaceFlinger, MediaService, and logcatd.</li>
<li>/vendor/etc/init/ is for SoC vendor items such as actions or<br>daemons needed for core SoC functionality.</li>
<li>/odm/etc/init/ is for device manufacturer items such as<br>actions or daemons needed for motion sensor or other peripheral<br>functionality.</li>
</ol>
<p>All services whose binaries reside on the system, vendor, or odm<br>partitions should have their service entries placed into a<br>corresponding init .rc file, located in the /etc/init/<br>directory of the partition where they reside.  There is a build<br>system macro, LOCAL_INIT_RC, that handles this for developers.  Each<br>init .rc file should additionally contain any actions associated with<br>its service.</p>
<p>An example is the logcatd.rc and Android.mk files located in the<br>system/core/logcat directory.  The LOCAL_INIT_RC macro in the<br>Android.mk file places logcatd.rc in /system/etc/init/ during the<br>build process.  Init loads logcatd.rc during the mount_all command and<br>allows the service to be run and the action to be queued when<br>appropriate.</p>
<p>This break up of init .rc files according to their daemon is preferred<br>to the previously used monolithic init .rc files.  This approach<br>ensures that the only service entries that init reads and the only<br>actions that init performs correspond to services whose binaries are in<br>fact present on the file system, which was not the case with the<br>monolithic init .rc files.  This additionally will aid in merge<br>conflict resolution when multiple services are added to the system, as<br>each one will go into a separate file.</p>
<p>There are two options “early” and “late” in mount_all command<br>which can be set after optional paths. With “–early” set, the<br>init executable will skip mounting entries with “latemount” flag<br>and triggering fs encryption state event. With “–late” set,<br>init executable will only mount entries with “latemount” flag but skip<br>importing rc files. By default, no option is set, and mount_all will<br>process all entries in the given fstab.</p>
<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Actions are named sequences of commands.  Actions have a trigger which<br>is used to determine when the action is executed.  When an event<br>occurs which matches an action’s trigger, that action is added to<br>the tail of a to-be-executed queue (unless it is already on the<br>queue).</p>
<p>Each action in the queue is dequeued in sequence and each command in<br>that action is executed in sequence.  Init handles other activities<br>(device creation/destruction, property setting, process restarting)<br>“between” the execution of the commands in activities.</p>
<p>Actions take the form of:</p>
<pre><code>on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*
   &lt;command&gt;
   &lt;command&gt;
   &lt;command&gt;
</code></pre>
<p>Actions are added to the queue and executed based on the order that<br>the file that contains them was parsed (see the Imports section), then<br>sequentially within an individual file.</p>
<p>For example if a file contains:</p>
<pre><code>on boot
   setprop a 1
   setprop b 2

on boot &amp;&amp; property:true=true
   setprop c 1
   setprop d 2

on boot
   setprop e 1
   setprop f 2
</code></pre>
<p>Then when the <code>boot</code> trigger occurs and assuming the property <code>true</code><br>equals <code>true</code>, then the order of the commands executed will be:</p>
<pre><code>setprop a 1
setprop b 2
setprop c 1
setprop d 2
setprop e 1
setprop f 2
</code></pre>
<h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>Services are programs which init launches and (optionally) restarts<br>when they exit.  Services take the form of:</p>
<pre><code>service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*
   &lt;option&gt;
   &lt;option&gt;
   ...
</code></pre>
<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>Options are modifiers to services.  They affect how and when init<br>runs the service.</p>
<p><code>console [&lt;console&gt;]</code></p>
<blockquote>
<p>This service needs a console. The optional second parameter chooses a<br>  specific console instead of the default. The default “/dev/console” can<br>  be changed by setting the “androidboot.console” kernel parameter. In<br>  all cases the leading “/dev/“ should be omitted, so “/dev/tty0” would be<br>  specified as just “console tty0”.</p>
</blockquote>
<p><code>critical</code></p>
<blockquote>
<p>如果被该标签标记的服务在四分钟内启动四次，该设备将重启进入recovery模式</p>
<p>  This is a device-critical service. If it exits more than four times in<br>  four minutes, the device will reboot into recovery mode.</p>
</blockquote>
<p><code>disabled</code></p>
<blockquote>
<p>如果该服务选项中没有disabled定义，则在init.rc中解析到这个服务的时候，会马上执行这个服务。而如果在服务的选项中增加了disabled定义，则该服务不会在init.rc中启动，需要我们在代码中使用以下方法来启动：property_set(“ctl.start”, “wifi_dhcpcd”);</p>
</blockquote>
<p>  This service will not automatically start with its class.<br>  It must be explicitly started by name.</p>
<p><code>setenv &lt;name&gt; &lt;value&gt;</code></p>
<blockquote>
<p>在启动阶段设置环境变量</p>
<p>Set the environment variable <em>name</em> to <em>value</em> in the launched process.</p>
</blockquote>
<p><code>socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ]</code></p>
<blockquote>
<p>声明socket会在启动之后再/dev/socket/name创建一个socket，再服务启动之后服务端可以绑定到这个socket上，等待客户端连接。</p>
</blockquote>
<p>  dgram： 使用不连续不可靠的数据包连接</p>
<p>  stream： 提供面向连接的稳定数据传输，即TCP协议。</p>
<p>  seqpacket: 提供连续可靠的数据包连接。</p>
<p>  Create a unix domain socket named /dev/socket/<em>name</em> and pass its fd to the<br>  launched process.  <em>type</em> must be “dgram”, “stream” or “seqpacket”.  User and<br>  group default to 0.  ‘seclabel’ is the SELinux security context for the<br>  socket.  It defaults to the service security context, as specified by<br>  seclabel or computed based on the service executable file security context.<br>  For native executables see libcutils android_get_control_socket().</p>
<p><code>enter_namespace &lt;type&gt; &lt;path&gt;</code></p>
<blockquote>
<p>Enters the namespace of type <em>type</em> located at <em>path</em>. Only network namespaces are supported with<br>  <em>type</em> set to “net”. Note that only one namespace of a given <em>type</em> may be entered.</p>
</blockquote>
<p><code>file &lt;path&gt; &lt;type&gt;</code></p>
<blockquote>
<p>Open a file path and pass its fd to the launched process. <em>type</em> must be<br>  “r”, “w” or “rw”.  For native executables see libcutils<br>  android_get_control_file().</p>
</blockquote>
<p><code>user &lt;username&gt;</code></p>
<blockquote>
<p>Change to ‘username’ before exec’ing this service.<br>  Currently defaults to root.  (??? probably should default to nobody)<br>  As of Android M, processes should use this option even if they<br>  require Linux capabilities.  Previously, to acquire Linux<br>  capabilities, a process would need to run as root, request the<br>  capabilities, then drop to its desired uid.  There is a new<br>  mechanism through fs_config that allows device manufacturers to add<br>  Linux capabilities to specific binaries on a file system that should<br>  be used instead. This mechanism is described on<br>  <a href="http://source.android.com/devices/tech/config/filesystem.html">http://source.android.com/devices/tech/config/filesystem.html</a>.  When<br>  using this new mechanism, processes can use the user option to<br>  select their desired uid without ever running as root.<br>  As of Android O, processes can also request capabilities directly in their .rc<br>  files. See the “capabilities” option below.</p>
</blockquote>
<p><code>group &lt;groupname&gt; [ &lt;groupname&gt;\* ]</code></p>
<blockquote>
<p>当执行此服务之后，设置用户组</p>
</blockquote>
<p>  Change to ‘groupname’ before exec’ing this service.  Additional<br>  groupnames beyond the (required) first one are used to set the<br>  supplemental groups of the process (via setgroups()).<br>  Currently defaults to root.  (??? probably should default to nobody)</p>
<p><code>capabilities &lt;capability&gt; [ &lt;capability&gt;\* ]</code></p>
<blockquote>
<p>设置执行这个service需要什么能力，能力定义如下连接</p>
</blockquote>
<p>  Set capabilities when exec’ing this service. ‘capability’ should be a Linux<br>  capability without the “CAP_“ prefix, like “NET_ADMIN” or “SETPCAP”. See<br>  <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">http://man7.org/linux/man-pages/man7/capabilities.7.html</a> for a list of Linux<br>  capabilities.</p>
<p><code>setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;</code></p>
<blockquote>
<p>This applies the given rlimit to the service. rlimits are inherited by child<br>  processes, so this effectively applies the given rlimit to the process tree<br>  started by this service.<br>  It is parsed similarly to the setrlimit command specified below.</p>
</blockquote>
<p><code>seclabel &lt;seclabel&gt;</code></p>
<blockquote>
<p>Change to ‘seclabel’ before exec’ing this service.<br>  Primarily for use by services run from the rootfs, e.g. ueventd, adbd.<br>  Services on the system partition can instead use policy-defined transitions<br>  based on their file security context.<br>  If not specified and no transition is defined in policy, defaults to the init context.</p>
</blockquote>
<p><code>oneshot</code></p>
<blockquote>
<p>如果服务退出之后不重启</p>
<p>Do not restart the service when it exits.</p>
</blockquote>
<p><code>class &lt;name&gt; [ &lt;name&gt;\* ]</code></p>
<blockquote>
<p>定义该服务数据哪一个类，这些服务可以通过该类型一起启动或者停止，如果没有定义class参数，被归为default类型</p>
</blockquote>
<p>  Specify class names for the service.  All services in a<br>  named class may be started or stopped together.  A service<br>  is in the class “default” if one is not specified via the<br>class option. Additional classnames beyond the (required) first</p>
<blockquote>
<p>one are used to group services.<br>  <code>animation class</code><br>  ‘animation’ class should include all services necessary for both<br>  boot animation and shutdown animation. As these services can be<br>  launched very early during bootup and can run until the last stage<br>  of shutdown, access to /data partition is not guaranteed. These<br>  services can check files under /data but it should not keep files opened<br>  and should work when /data is not available.</p>
</blockquote>
<p><code>onrestart</code></p>
<blockquote>
<p>当服务重启之后，需要执行那些命令 system/core/rootdir/init.zygote64_32.rc中，当zygote重启之后，需要重启哪些服务</p>
<p>Execute a Command (see below) when service restarts.</p>
</blockquote>
<p><code>writepid &lt;file&gt; [ &lt;file&gt;\* ]</code></p>
<blockquote>
<p>Write the child’s pid to the given files when it forks. Meant for<br>  cgroup/cpuset usage. If no files under /dev/cpuset/ are specified, but the<br>  system property ‘ro.cpuset.default’ is set to a non-empty cpuset name (e.g.<br>  ‘/foreground’), then the pid is written to file /dev/cpuset/<em>cpuset_name</em>/tasks.</p>
</blockquote>
<p><code>priority &lt;priority&gt;</code></p>
<blockquote>
<p>Scheduling priority of the service process. This value has to be in range<br>  -20 to 19. Default priority is 0. Priority is set via setpriority().</p>
</blockquote>
<p><code>namespace &lt;pid|mnt&gt;</code></p>
<blockquote>
<p>Enter a new PID or mount namespace when forking the service.</p>
</blockquote>
<p><code>oom_score_adjust &lt;value&gt;</code></p>
<blockquote>
<p>给子进程设置oom_adj值</p>
</blockquote>
<p>  Sets the child’s /proc/self/oom_score_adj to the specified value,<br>  which must range from -1000 to 1000.</p>
<p><code>memcg.swappiness &lt;value&gt;</code></p>
<blockquote>
<p>Sets the child’s memory.swappiness to the specified value (only if memcg is mounted),<br>  which must be equal or greater than 0.</p>
</blockquote>
<p><code>memcg.soft_limit_in_bytes &lt;value&gt;</code></p>
<blockquote>
<p>Sets the child’s memory.soft_limit_in_bytes to the specified value (only if memcg is mounted),<br>  which must be equal or greater than 0.</p>
</blockquote>
<p><code>memcg.limit_in_bytes &lt;value&gt;</code></p>
<blockquote>
<p>Sets the child’s memory.limit_in_bytes to the specified value (only if memcg is mounted),<br>  which must be equal or greater than 0.</p>
</blockquote>
<p><code>shutdown &lt;shutdown_behavior&gt;</code></p>
<blockquote>
<p>定义该service的退出行为，如果没有定义，会直接被SIGTERM and SIGKILL杀，如果有定义critical行为的服务，退出的时候不会被杀，除非退出超时了。被标有 “shutdown critical”的服务当退出的时候没有运行，该服务将被重启</p>
</blockquote>
<p>  Set shutdown behavior of the service process. When this is not specified,<br>  the service is killed during shutdown process by using SIGTERM and SIGKILL.<br>  The service with shutdown_behavior of “critical” is not killed during shutdown<br>  until shutdown times out. When shutdown times out, even services tagged with<br>  “shutdown critical” will be killed. When the service tagged with “shutdown critical”<br>  is not running when shut down starts, it will be started.</p>
<h2 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h2><p>Triggers are strings which can be used to match certain kinds of<br>events and used to cause an action to occur.</p>
<p>Triggers are subdivided into event triggers and property triggers.</p>
<p>Event triggers are strings triggered by the ‘trigger’ command or by<br>the QueueEventTrigger() function within the init executable.  These<br>take the form of a simple string such as ‘boot’ or ‘late-init’.</p>
<p>Property triggers are strings triggered when a named property changes<br>value to a given new value or when a named property changes value to<br>any new value.  <strong>These take the form of ‘property:<name>=<value>‘ and</value></name></strong><br><strong>‘property:<name>=*‘ respectively</name></strong>.  Property triggers are additionally<br>evaluated and triggered accordingly during the initial boot phase of<br>init.</p>
<p>An Action can have multiple property triggers but may only have one<br>event trigger.</p>
<p>For example:<br><code>on boot &amp;&amp; property:a=b</code> defines an action that is only executed when<br>the ‘boot’ event trigger happens and the property a equals b.</p>
<p><code>on property:a=b &amp;&amp; property:c=d</code> defines an action that is executed<br>at three times:</p>
<ol>
<li>During initial boot if property a=b and property c=d.</li>
<li>Any time that property a transitions to value b, while property c already equals d.</li>
<li>Any time that property c transitions to value d, while property a already equals b.</li>
</ol>
<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p><code>bootchart [start|stop]</code></p>
<blockquote>
<p>Start/stop bootcharting. These are present in the default init.rc files,<br>  but bootcharting is only active if the file /data/bootchart/enabled exists;<br>  otherwise bootchart start/stop are no-ops.</p>
</blockquote>
<p><code>chmod &lt;octal-mode&gt; &lt;path&gt;</code></p>
<blockquote>
<p>Change file access permissions.</p>
</blockquote>
<p><code>chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;</code></p>
<blockquote>
<p>Change file owner and group.</p>
</blockquote>
<p><code>class_start &lt;serviceclass&gt;</code></p>
<blockquote>
<p>启动serviceclass类的服务</p>
</blockquote>
<p>  Start all services of the specified class if they are<br>  not already running.  See the start entry for more information on<br>  starting services.</p>
<p><code>class_stop &lt;serviceclass&gt;</code></p>
<blockquote>
<p>Stop and disable all services of the specified class if they are<br>  currently running.</p>
</blockquote>
<p><code>class_reset &lt;serviceclass&gt;</code></p>
<blockquote>
<p>Stop all services of the specified class if they are<br>  currently running, without disabling them. They can be restarted<br>  later using <code>class_start</code>.</p>
</blockquote>
<p><code>class_restart &lt;serviceclass&gt;</code></p>
<blockquote>
<p>Restarts all services of the specified class.</p>
</blockquote>
<p><code>copy &lt;src&gt; &lt;dst&gt;</code></p>
<blockquote>
<p>Copies a file. Similar to write, but useful for binary/large<br>  amounts of data.<br>  Regarding to the src file, copying from symbolic link file and world-writable<br>  or group-writable files are not allowed.<br>  Regarding to the dst file, the default mode created is 0600 if it does not<br>  exist. And it will be truncated if dst file is a normal regular file and<br>  already exists.</p>
</blockquote>
<p><code>domainname &lt;name&gt;</code></p>
<blockquote>
<p>Set the domain name.</p>
</blockquote>
<p><code>enable &lt;servicename&gt;</code></p>
<blockquote>
<p>Turns a disabled service into an enabled one as if the service did not<br>  specify disabled.<br>  If the service is supposed to be running, it will be started now.<br>  Typically used when the bootloader sets a variable that indicates a specific<br>  service should be started when needed. E.g.</p>
</blockquote>
<pre><code>on property:ro.boot.myfancyhardware=1
    enable my_fancy_service_for_my_fancy_hardware
</code></pre>
<p><code>exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\* ]</code></p>
<blockquote>
<p>Fork and execute command with the given arguments. The command starts<br>  after “–” so that an optional security context, user, and supplementary<br>  groups can be provided. No other commands will be run until this one<br>  finishes. <em>seclabel</em> can be a - to denote default. Properties are expanded<br>  within <em>argument</em>.<br>  Init halts executing commands until the forked process exits.</p>
</blockquote>
<p><code>exec_background [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt;\* ] ] ] -- &lt;command&gt; [ &lt;argument&gt;\* ]</code></p>
<blockquote>
<p>Fork and execute command with the given arguments. This is handled similarly<br>  to the <code>exec</code> command. The difference is that init does not halt executing<br>  commands until the process exits for <code>exec_background</code>.</p>
</blockquote>
<p><code>exec_start &lt;service&gt;</code></p>
<blockquote>
<p>Start a given service and halt the processing of additional init commands<br>  until it returns.  The command functions similarly to the <code>exec</code> command,<br>  but uses an existing service definition in place of the exec argument vector.</p>
</blockquote>
<p><code>export &lt;name&gt; &lt;value&gt;</code></p>
<blockquote>
<p>Set the environment variable <em>name</em> equal to <em>value</em> in the<br>  global environment (which will be inherited by all processes<br>  started after this command is executed)</p>
</blockquote>
<p><code>hostname &lt;name&gt;</code></p>
<blockquote>
<p>Set the host name.</p>
</blockquote>
<p><code>ifup &lt;interface&gt;</code></p>
<blockquote>
<p>Bring the network interface <em>interface</em> online.</p>
</blockquote>
<p><code>insmod [-f] &lt;path&gt; [&lt;options&gt;]</code></p>
<blockquote>
<p>加载驱动模块</p>
</blockquote>
<p>  Install the module at <em>path</em> with the specified options.<br>  -f: force installation of the module even if the version of the running kernel<br>  and the version of the kernel for which the module was compiled do not match.</p>
<p><code>load_all_props</code></p>
<blockquote>
<p>Loads properties from /system, /vendor, et cetera.<br>  This is included in the default init.rc.</p>
</blockquote>
<p><code>load_persist_props</code></p>
<blockquote>
<p>当data分区解密之后加载persistent属性</p>
</blockquote>
<p>  Loads persistent properties when /data has been decrypted.<br>  This is included in the default init.rc.</p>
<p><code>loglevel &lt;level&gt;</code></p>
<blockquote>
<p>Sets the kernel log level to level. Properties are expanded within <em>level</em>.</p>
</blockquote>
<p><code>mkdir &lt;path&gt; [mode] [owner] [group]</code></p>
<blockquote>
<p>Create a directory at <em>path</em>, optionally with the given mode, owner, and<br>  group. If not provided, the directory is created with permissions 755 and<br>  owned by the root user and root group. If provided, the mode, owner and group<br>  will be updated if the directory exists already.</p>
</blockquote>
<p><code>mount_all &lt;fstab&gt; [ &lt;path&gt; ]\* [--&lt;option&gt;]</code></p>
<blockquote>
<p>Calls fs_mgr_mount_all on the given fs_mgr-format fstab and imports .rc files<br>  at the specified paths (e.g., on the partitions just mounted) with optional<br>  options “early” and “late”.<br>  Refer to the section of “Init .rc Files” for detail.</p>
</blockquote>
<p><code>mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt;\* ] [&lt;options&gt;]</code></p>
<blockquote>
<p>Attempt to mount the named device at the directory <em>dir</em><br>  _flag_s include “ro”, “rw”, “remount”, “noatime”, …<br>  <em>options</em> include “barrier=1”, “noauto_da_alloc”, “discard”, … as<br>  a comma separated string, eg: barrier=1,noauto_da_alloc</p>
</blockquote>
<p><code>restart &lt;service&gt;</code></p>
<blockquote>
<p>Stops and restarts a running service, does nothing if the service is currently<br>  restarting, otherwise, it just starts the service.</p>
</blockquote>
<p><code>restorecon &lt;path&gt; [ &lt;path&gt;\* ]</code></p>
<blockquote>
<p>Restore the file named by <em>path</em> to the security context specified<br>  in the file_contexts configuration.<br>  Not required for directories created by the init.rc as these are<br>  automatically labeled correctly by init.</p>
</blockquote>
<p><code>restorecon_recursive &lt;path&gt; [ &lt;path&gt;\* ]</code></p>
<blockquote>
<p>Recursively restore the directory tree named by <em>path</em> to the<br>  security contexts specified in the file_contexts configuration.</p>
</blockquote>
<p><code>rm &lt;path&gt;</code></p>
<blockquote>
<p>Calls unlink(2) on the given path. You might want to<br>  use “exec – rm …” instead (provided the system partition is<br>  already mounted).</p>
</blockquote>
<p><code>rmdir &lt;path&gt;</code></p>
<blockquote>
<p>Calls rmdir(2) on the given path.</p>
</blockquote>
<p><code>readahead &lt;file|dir&gt; [--fully]</code></p>
<blockquote>
<p>Calls readahead(2) on the file or files within given directory.<br>  Use option –fully to read the full file content.</p>
</blockquote>
<p><code>setprop &lt;name&gt; &lt;value&gt;</code></p>
<blockquote>
<p>Set system property <em>name</em> to <em>value</em>. Properties are expanded<br>  within <em>value</em>.</p>
</blockquote>
<p><code>setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;</code></p>
<blockquote>
<p>Set the rlimit for a resource. This applies to all processes launched after<br>  the limit is set. It is intended to be set early in init and applied globally.<br>  <em>resource</em> is best specified using its text representation (‘cpu’, ‘rtio’, etc<br>  or ‘RLIM_CPU’, ‘RLIM_RTIO’, etc). It also may be specified as the int value<br>  that the resource enum corresponds to.</p>
</blockquote>
<p><code>start &lt;service&gt;</code></p>
<blockquote>
<p>启动service，但是服务启动状态依赖于操作系统调度，无法保证服务的状态</p>
</blockquote>
<p>  Start a service running if it is not already running.<br>  Note that this is <em>not</em> synchronous, and even if it were, there is<br>  no guarantee that the operating system’s scheduler will execute the<br>  service sufficiently to guarantee anything about the service’s status.</p>
<blockquote>
<p>This creates an important consequence that if the service offers<br>  functionality to other services, such as providing a<br>  communication channel, simply starting this service before those<br>  services is <em>not</em> sufficient to guarantee that the channel has<br>  been set up before those services ask for it.  There must be a<br>  separate mechanism to make any such guarantees.</p>
</blockquote>
<p><code>stop &lt;service&gt;</code></p>
<blockquote>
<p>Stop a service from running if it is currently running.</p>
</blockquote>
<p><code>swapon_all &lt;fstab&gt;</code></p>
<blockquote>
<p>Calls fs_mgr_swapon_all on the given fstab file.</p>
</blockquote>
<p><code>symlink &lt;target&gt; &lt;path&gt;</code></p>
<blockquote>
<p>创建一个软连接</p>
<p>Create a symbolic link at <em>path</em> with the value <em>target</em></p>
</blockquote>
<p><code>sysclktz &lt;mins_west_of_gmt&gt;</code></p>
<blockquote>
<p>设置时区</p>
<p>Set the system clock base (0 if system clock ticks in GMT)</p>
</blockquote>
<p><code>trigger &lt;event&gt;</code></p>
<blockquote>
<p>Trigger an event.  Used to queue an action from another<br>  action.</p>
</blockquote>
<p><code>umount &lt;path&gt;</code></p>
<blockquote>
<p>Unmount the filesystem mounted at that path.</p>
</blockquote>
<p><code>verity_load_state</code></p>
<blockquote>
<p>Internal implementation detail used to load dm-verity state.</p>
</blockquote>
<p><code>verity_update_state &lt;mount-point&gt;</code></p>
<blockquote>
<p>Internal implementation detail used to update dm-verity state and<br>  set the partition.<em>mount-point</em>.verified properties used by adb remount<br>  because fs_mgr can’t set them directly itself.</p>
</blockquote>
<p><code>wait &lt;path&gt; [ &lt;timeout&gt; ]</code></p>
<blockquote>
<p>等待一个文件是否存在，当文件存在时立即返回，或到<timeout>指定的超时时间后返回，如果不指定<timeout>，默认超时时间是5秒</timeout></timeout></p>
</blockquote>
<p>  Poll for the existence of the given file and return when found,<br>  or the timeout has been reached. If timeout is not specified it<br>  currently defaults to five seconds.</p>
<p><code>wait_for_prop &lt;name&gt; &lt;value&gt;</code></p>
<blockquote>
<p>等待name指定的属性被设置，如果被设置会立马执行下去</p>
</blockquote>
<p>  Wait for system property <em>name</em> to be <em>value</em>. Properties are expanded<br>  within <em>value</em>. If property <em>name</em> is already set to <em>value</em>, continue<br>  immediately.</p>
<p><code>write &lt;path&gt; &lt;content&gt;</code></p>
<blockquote>
<p>Open the file at <em>path</em> and write a string to it with write(2).<br>  If the file does not exist, it will be created. If it does exist,<br>  it will be truncated. Properties are expanded within <em>content</em>.</p>
</blockquote>
<h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p><code>import &lt;path&gt;</code></p>
<blockquote>
<p>引入扩展的配置文件，如果是一个目录，会解析这个目录下的所有rc文件，如果不是一个目录，不会递归解析子目录</p>
</blockquote>
<p>  Parse an init config file, extending the current configuration.<br>  If <em>path</em> is a directory, each file in the directory is parsed as<br>  a config file. It is not recursive, nested directories will<br>  not be parsed.</p>
<p>The import keyword is not a command, but rather its own section,<br>meaning that it does not happen as part of an Action, but rather,<br>imports are handled as a file is being parsed and follow the below logic.</p>
<p>There are only three times where the init executable imports .rc files:</p>
<ol>
<li>When it imports /init.rc or the script indicated by the property<br><code>ro.boot.init_rc</code> during initial boot.</li>
<li>When it imports /{system,vendor,odm}/etc/init/ for first stage mount<br>devices immediately after importing /init.rc.</li>
<li>When it imports /{system,vendor,odm}/etc/init/ or .rc files at specified<br>paths during mount_all.</li>
</ol>
<p>The order that files are imported is a bit complex for legacy reasons<br>and to keep backwards compatibility.  It is not strictly guaranteed.</p>
<p>The only correct way to guarantee that a command has been run before a<br>different command is to either 1) place it in an Action with an<br>earlier executed trigger, or 2) place it in an Action with the same<br>trigger within the same file at an earlier line.</p>
<p>Nonetheless, the defacto order for first stage mount devices is:</p>
<ol>
<li>/init.rc is parsed then recursively each of its imports are<br>parsed.</li>
<li>The contents of /system/etc/init/ are alphabetized and parsed<br>sequentially, with imports happening recursively after each file is<br>parsed.</li>
<li>Step 2 is repeated for /vendor/etc/init then /odm/etc/init</li>
</ol>
<p>The below pseudocode may explain this more clearly:</p>
<pre><code>fn Import(file)
  Parse(file)
  for (import : file.imports)
    Import(import)

Import(/init.rc)
Directories = [/system/etc/init, /vendor/etc/init, /odm/etc/init]
for (directory : Directories)
  files = &lt;Alphabetical order of directory&#39;s contents&gt;
  for (file : files)
    Import(file)
</code></pre>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Init provides information about the services that it is responsible<br>for via the below properties.</p>
<p><code>init.svc.&lt;name&gt;</code></p>
<blockquote>
<p>State of a named service (“stopped”, “stopping”, “running”, “restarting”)</p>
</blockquote>
<h2 id="Boot-timing"><a href="#Boot-timing" class="headerlink" title="Boot timing"></a>Boot timing</h2><p>以下属性可以看到系统启动时序，[]中的时间戳单位是ns</p>
<p>Init records some boot timing information in system properties.</p>
<p><code>ro.boottime.init</code></p>
<blockquote>
<p>Time after boot in ns (via the CLOCK_BOOTTIME clock) at which the first<br>  stage of init started.</p>
</blockquote>
<p><code>ro.boottime.init.selinux</code></p>
<blockquote>
<p>How long it took the first stage to initialize SELinux.</p>
</blockquote>
<p><code>ro.boottime.init.cold_boot_wait</code></p>
<blockquote>
<p>How long init waited for ueventd’s coldboot phase to end.</p>
</blockquote>
<p><code>ro.boottime.&lt;service-name&gt;</code></p>
<blockquote>
<p>Time after boot in ns (via the CLOCK_BOOTTIME clock) that the service was<br>  first started.</p>
</blockquote>
<h2 id="Bootcharting"><a href="#Bootcharting" class="headerlink" title="Bootcharting"></a>Bootcharting</h2><p>This version of init contains code to perform “bootcharting”: generating log<br>files that can be later processed by the tools provided by <a href="http://www.bootchart.org/">http://www.bootchart.org/</a>.</p>
<p>On the emulator, use the -bootchart <em>timeout</em> option to boot with bootcharting<br>activated for <em>timeout</em> seconds.</p>
<p>On a device:</p>
<pre><code>adb shell &#39;touch /data/bootchart/enabled&#39;
</code></pre>
<p>Don’t forget to delete this file when you’re done collecting data!</p>
<p>The log files are written to /data/bootchart/. A script is provided to<br>retrieve them and create a bootchart.tgz file that can be used with the<br>bootchart command-line utility:</p>
<pre><code>sudo apt-get install pybootchartgui
# grab-bootchart.sh uses $ANDROID_SERIAL.
$ANDROID_BUILD_TOP/system/core/init/grab-bootchart.sh
</code></pre>
<p>One thing to watch for is that the bootchart will show init as if it started<br>running at 0s. You’ll have to look at dmesg to work out when the kernel<br>actually started init.</p>
<h2 id="Comparing-two-bootcharts"><a href="#Comparing-two-bootcharts" class="headerlink" title="Comparing two bootcharts"></a>Comparing two bootcharts</h2><p><code>compare-bootcharts.py</code>脚本可以比较指定进程的启动耗时对比。</p>
<p>A handy script named <strong>compare-bootcharts.py</strong> can be used to compare the<br>start/end time of selected processes. The aforementioned <strong>grab-bootchart.sh</strong><br>will leave a bootchart tarball named bootchart.tgz at /tmp/android-bootchart.<br>If two such barballs are preserved on the host machine under different<br>directories, the script can list the timestamps differences. For example:</p>
<p>Usage: <strong>system/core/init/compare-bootcharts.py <em>base-bootchart-dir</em> <em>exp-bootchart-dir</em></strong></p>
<pre><code>process: baseline experiment (delta) - Unit is ms (a jiffy is 10 ms on the system)
------------------------------------
/init: 50 40 (-10)
/system/bin/surfaceflinger: 4320 4470 (+150)
/system/bin/bootanimation: 6980 6990 (+10)
zygote64: 10410 10640 (+230)
zygote: 10410 10640 (+230)
system_server: 15350 15150 (-200)
bootanimation ends at: 33790 31230 (-2560)
</code></pre>
<h2 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h2><p>systrace可以查看具体某个服务的启动耗时，示例如下</p>
<p>Systrace (<a href="http://developer.android.com/tools/help/systrace.html">http://developer.android.com/tools/help/systrace.html</a>) can be<br>used for obtaining performance analysis reports during boot<br>time on userdebug or eng builds.</p>
<p>Here is an example of trace events of “wm” and “am” categories:</p>
<pre><code>$ANDROID_BUILD_TOP/external/chromium-trace/systrace.py \
      wm am --boot
</code></pre>
<p>This command will cause the device to reboot. After the device is rebooted and<br>the boot sequence has finished, the trace report is obtained from the device<br>and written as trace.html on the host by hitting Ctrl+C.</p>
<p>通过zygote fork出来的进程都可以使用以上方法来查看，但是vold,surfaceflinger等其在zygote之前的服务无法查看</p>
<p>Limitation: recording trace events is started after persistent properties are loaded, so<br>the trace events that are emitted before that are not recorded. Several<br>services such as vold, surfaceflinger, and servicemanager are affected by this<br>limitation since they are started before persistent properties are loaded.<br>Zygote initialization and the processes that are forked from the zygote are not<br>affected.</p>
<h2 id="Debugging-init"><a href="#Debugging-init" class="headerlink" title="Debugging init"></a>Debugging init</h2><p>By default, programs executed by init will drop stdout and stderr into<br>/dev/null. To help with debugging, you can execute your program via the<br>Android program logwrapper. This will redirect stdout/stderr into the<br>Android logging system (accessed via logcat).</p>
<p>For example<br>service akmd /system/bin/logwrapper /sbin/akmd</p>
<p>For quicker turnaround when working on init itself, use:</p>
<pre><code>mm -j &amp;&amp;
m ramdisk-nodeps &amp;&amp;
m bootimage-nodeps &amp;&amp;
adb reboot bootloader &amp;&amp;
fastboot boot $ANDROID_PRODUCT_OUT/boot.img
</code></pre>
<p>Alternatively, use the emulator:</p>
<pre><code>emulator -partition-size 1024 \
    -verbose -show-kernel -no-window
</code></pre>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>init</tag>
      </tags>
  </entry>
  <entry>
    <title>应用和服务裁剪--系统优化</title>
    <url>/2021/09/02/%E5%BA%94%E7%94%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%A3%81%E5%89%AA-%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="1-系统中所有的应用和服务"><a href="#1-系统中所有的应用和服务" class="headerlink" title="1.系统中所有的应用和服务"></a>1.系统中所有的应用和服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pm list packages</span></span><br><span class="line">package:com.android.cts.priv.ctsshim   # tailor</span><br><span class="line">package:com.qualcomm.qti.qms.service.telemetry</span><br><span class="line">package:com.iflytek.autofly.accountcenter</span><br><span class="line">package:com.iflytek.autofly.systemserver</span><br><span class="line">package:com.android.car.messenger</span><br><span class="line">package:com.android.internal.display.cutout.emulation.corner</span><br><span class="line">package:com.gxatek.multiinstanceservice</span><br><span class="line">package:com.qualcomm.qti.improvetouch.service</span><br><span class="line">package:com.android.internal.display.cutout.emulation.double</span><br><span class="line">package:com.android.providers.telephony</span><br><span class="line">package:com.android.providers.calendar # 日历程序支持服务</span><br><span class="line">package:com.iflytek.autofly.naviselect</span><br><span class="line">package:com.gxatek.cockpit.diagnostic</span><br><span class="line">package:com.android.providers.media</span><br><span class="line">package:com.qti.service.colorservice</span><br><span class="line">package:com.android.wallpapercropper # tailor</span><br><span class="line">package:com.android.car.media</span><br><span class="line">package:com.quicinc.cne.CNEService</span><br><span class="line">package:com.android.car.radio</span><br><span class="line">package:com.android.car.trust</span><br><span class="line">package:com.core.system.service</span><br><span class="line">package:com.gxa.car.timesync</span><br><span class="line">package:com.android.protips  # tailor</span><br><span class="line">package:com.gxatek.cockpit.atmospherelampservice</span><br><span class="line">package:com.qiyi.video.pad</span><br><span class="line">package:com.android.documentsui # tailor</span><br><span class="line">package:com.android.externalstorage</span><br><span class="line">package:com.qualcomm.uimremoteclient</span><br><span class="line">package:com.android.htmlviewer # tailor</span><br><span class="line">package:com.gxatek.cockpit.launcher</span><br><span class="line">package:com.android.companiondevicemanager</span><br><span class="line">package:com.android.quicksearchbox # tailor</span><br><span class="line">package:com.android.mms.service  # tailor</span><br><span class="line">package:com.gxa.car.externalkey</span><br><span class="line">package:com.gxa.service.account</span><br><span class="line">package:com.qualcomm.qti.qms.service.connectionsecurity</span><br><span class="line">package:com.android.providers.downloads  # tailor</span><br><span class="line">package:com.gxatek.cockpit.vicelauncher</span><br><span class="line">package:com.desay_svautomotive.svcarinfo</span><br><span class="line">package:com.gxa.car.qnxapp</span><br><span class="line">package:com.gxatek.cockpit.gallery</span><br><span class="line">package:com.android.soundrecorder  # tailor</span><br><span class="line">package:android.car.cluster.loggingrenderer</span><br><span class="line">package:com.gxa.service.carusbupdate</span><br><span class="line">package:com.qualcomm.uimremoteserver</span><br><span class="line">package:com.android.defcontainer  # 应用安装相关的应用，删除可能无法启动</span><br><span class="line">package:com.qti.confuridialer</span><br><span class="line">package:com.desay_svautomotive.service.projectionservice</span><br><span class="line">package:com.android.car.mapsplaceholder</span><br><span class="line">package:com.android.providers.downloads.ui # tailor</span><br><span class="line">package:com.android.pacprocessor</span><br><span class="line">package:com.android.simappdialog   # tailor 插入sim卡的弹窗</span><br><span class="line">package:com.iflytek.cutefly.speechclient.hmi</span><br><span class="line">package:com.android.internal.display.cutout.emulation.tall</span><br><span class="line">package:com.android.certinstaller  # tailor 证书安装</span><br><span class="line">package:com.android.carrierconfig # tailor 可用网络的默认配置</span><br><span class="line">package:android</span><br><span class="line">package:com.android.contacts</span><br><span class="line">package:com.android.camera2</span><br><span class="line">package:com.qualcomm.wfd.service</span><br><span class="line">package:com.gxatek.cockpit.schedule</span><br><span class="line">package:com.android.car.systemupdater</span><br><span class="line">package:com.gxa.car.engineMode</span><br><span class="line">package:com.gxatek.cockpit.msgcenter</span><br><span class="line">package:com.android.car</span><br><span class="line">package:com.android.egg  # tailor 彩蛋</span><br><span class="line">package:com.android.mtp  # ? usb传输协议相关的</span><br><span class="line">package:com.android.nfc  # tailor </span><br><span class="line">package:com.android.stk</span><br><span class="line">package:com.android.backupconfirm</span><br><span class="line">package:com.gxatek.appservice.cluster</span><br><span class="line">package:com.gxa.service.devicemanager</span><br><span class="line">package:com.android.provision #系统初始化引导程序，写入一个DEVICE_PROVISIONED标记</span><br><span class="line">package:com.android.statementservice</span><br><span class="line">package:com.android.settings.intelligence</span><br><span class="line">package:com.android.calendar # tailor日历</span><br><span class="line">package:com.android.systemui.theme.dark</span><br><span class="line">package:com.gxatek.cockpit.carlife</span><br><span class="line">package:com.gxatek.cockpit.carplay</span><br><span class="line">package:com.gxa.car.ncm.overlay</span><br><span class="line">package:com.iflytek.auto.mall.hmi</span><br><span class="line">package:com.android.car.settings</span><br><span class="line">package:com.iflytek.autofly.h5</span><br><span class="line">package:com.qualcomm.qti.dynamicddsservice</span><br><span class="line">package:com.gxa.service.ebcall</span><br><span class="line">package:com.android.car.hvac</span><br><span class="line">package:com.qualcomm.qcrilmsgtunnel</span><br><span class="line">package:com.android.providers.settings</span><br><span class="line">package:com.android.sharedstoragebackup</span><br><span class="line">package:com.gxatek.cockpit.carsettings</span><br><span class="line">package:com.android.printspooler</span><br><span class="line">package:com.qualcomm.qti.improvetouch</span><br><span class="line">package:com.android.dreams.basic</span><br><span class="line">package:com.gxatek.cockpit.applet</span><br><span class="line">package:com.android.webview</span><br><span class="line">package:com.gxatek.cockpit.btcall</span><br><span class="line">package:com.android.se</span><br><span class="line">package:com.android.inputdevices</span><br><span class="line">package:com.android.support.car.lenspicker</span><br><span class="line">package:com.gxa.service.ota</span><br><span class="line">package:com.android.bips</span><br><span class="line">package:com.iflytek.autofly.mediax</span><br><span class="line">package:com.qti.dpmserviceapp</span><br><span class="line">package:com.google.android.car.defaultstoragemonitoringcompanionapp</span><br><span class="line">package:com.android.musicfx  # 原生音效</span><br><span class="line">package:com.gxatek.cockpit.scenesengine</span><br><span class="line">package:com.gxa.car.ncm</span><br><span class="line">package:com.android.cellbroadcastreceiver   # 小区广播</span><br><span class="line">package:android.ext.shared</span><br><span class="line">package:com.android.onetimeinitializer # 首次启动用于装谷歌app的</span><br><span class="line">package:com.android.server.telecom</span><br><span class="line">package:com.android.keychain</span><br><span class="line">package:com.qti.snapdragon.qdcm_ff</span><br><span class="line">package:com.ts.appservice.kanzikotanimationservice</span><br><span class="line">package:com.gxatek.cockpit.weather</span><br><span class="line">package:com.gxa.service.messagecenter</span><br><span class="line">package:com.android.printservice.recommendation</span><br><span class="line">package:com.android.dialer # 原生拨号盘</span><br><span class="line">package:com.android.gallery3d # 相机相框</span><br><span class="line">package:android.ext.services</span><br><span class="line">package:com.desay_svautomotive.multiscreen</span><br><span class="line">package:com.android.calllogbackup #手机通话记录备份工具</span><br><span class="line">package:com.gxatek.cockpit.testcarlife</span><br><span class="line">package:com.gxatek.cockpit.testcarplay</span><br><span class="line">package:com.android.packageinstaller</span><br><span class="line">package:com.android.carrierdefaultapp # 运营商默认流量服务</span><br><span class="line">package:com.gac.cloud.app</span><br><span class="line">package:com.android.car.media.localmediaplayer</span><br><span class="line">package:com.android.proxyhandler  # 自动配置代理</span><br><span class="line">package:com.gxa.car.procmanagement</span><br><span class="line">package:com.android.inputmethod.latin  # 原生输入法</span><br><span class="line">package:com.gxa.appservice.caradapter</span><br><span class="line">package:org.chromium.webview_shell</span><br><span class="line">package:android.car.usb.handler</span><br><span class="line">package:com.gxa.service.cluster</span><br><span class="line">package:com.gxa.service.settings</span><br><span class="line">package:com.android.managedprovisioning #工作组资料设置  ?</span><br><span class="line">package:com.gxa.service.mediacenterservice</span><br><span class="line">package:com.android.dreams.phototable  # PhotoTable屏保</span><br><span class="line">package:com.gxa.cockpit.hvac</span><br><span class="line">package:cn.gaei.appstore</span><br><span class="line">package:com.desaysv.otaservice</span><br><span class="line">package:com.gxa.firewall</span><br><span class="line">package:com.gxatek.cockpit.voicecarctrl</span><br><span class="line">package:com.android.smspush  # 短信推送</span><br><span class="line">package:com.android.wallpaper.livepicker  # 动态墙纸选择器</span><br><span class="line">package:com.gxa.service.weather</span><br><span class="line">package:com.google.android.car.vms.subscriber</span><br><span class="line">package:com.qti.snapdragon.qdcm_mobile</span><br><span class="line">package:com.gxa.appservice.platformadapter.adaptermainservice</span><br><span class="line">package:com.gxa.service.systemui</span><br><span class="line">package:com.android.storagemanager</span><br><span class="line">package:com.android.bookmarkprovider # 书签</span><br><span class="line">package:com.gxatek.cockpit.miniprogram</span><br><span class="line">package:com.android.settings</span><br><span class="line">package:com.qualcomm.qti.sva</span><br><span class="line">package:com.gxatek.cockpit.carservice</span><br><span class="line">package:com.gxatek.cockpit.avdc</span><br><span class="line">package:com.android.calculator2 # 计算器</span><br><span class="line">package:com.gxa.service.bluetooth</span><br><span class="line">package:com.gxatek.cockpit.settings</span><br><span class="line">package:com.android.cts.ctsshim # cts</span><br><span class="line">package:com.gxa.car.audio</span><br><span class="line">package:com.gxa.car.power</span><br><span class="line">package:com.gxa.car.scene</span><br><span class="line">package:com.iflytek.inputmethod</span><br><span class="line">package:com.qti.diagservices</span><br><span class="line">package:com.iflytek.autofly.dms</span><br><span class="line">package:com.android.vpndialogs # VPN</span><br><span class="line">package:com.iflytek.autofly.platformservice</span><br><span class="line">package:com.android.email   # 原生email</span><br><span class="line">package:com.android.music   # 原生music</span><br><span class="line">package:com.android.phone   # 原生phone</span><br><span class="line">package:com.android.shell  # ?</span><br><span class="line">package:com.android.wallpaperbackup # 墙纸备份</span><br><span class="line">package:com.android.providers.blockednumber</span><br><span class="line">package:com.android.providers.userdictionary  # 用户词典Content Provider</span><br><span class="line">package:com.android.emergency  # 急救信息</span><br><span class="line">package:com.gxa.car.wifi.service</span><br><span class="line">package:com.android.location.fused</span><br><span class="line">package:com.android.deskclock  # 自带闹钟</span><br><span class="line">package:com.android.systemui</span><br><span class="line">package:com.android.bluetoothmidiservice</span><br><span class="line">package:com.qualcomm.qti.poweroffalarm</span><br><span class="line">package:com.gxatek.cockpit.vpamultimode</span><br><span class="line">package:com.gxa.permission</span><br><span class="line">package:com.guangqi.chezaiapp</span><br><span class="line">package:com.gxa.car.hardkey</span><br><span class="line">package:com.android.traceur</span><br><span class="line">package:com.gxatek.cockpit.screensaver</span><br><span class="line">package:com.qualcomm.qti.qms.service.trustzoneaccess</span><br><span class="line">package:com.desaysv.ftpserver</span><br><span class="line">package:com.android.bluetooth</span><br><span class="line">package:com.qualcomm.timeservice</span><br><span class="line">package:com.android.providers.contacts</span><br><span class="line">package:com.gxatek.cockpit.dvr</span><br><span class="line">package:com.android.captiveportallogin # 网络连通信测试</span><br><span class="line">package:com.google.android.car.vms.publisher</span><br><span class="line">package:com.gxatek.cockpit.globalsearch</span><br><span class="line">package:org.codeaurora.qti.nrNetworkSettingApp</span><br><span class="line">package:com.gxatek.cockpit.account</span><br></pre></td></tr></table></figure>
<p>一共有201个应用。</p>
<h4 id="2-可裁剪应用"><a href="#2-可裁剪应用" class="headerlink" title="2.可裁剪应用"></a>2.可裁剪应用</h4><p>根据包名搜索应用依赖，没有依赖的可以支持裁掉编译版本试试功能。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用来删减不需要编入到系统的模块</span></span><br><span class="line">PRODUCT_DELETE_PACKAGES += \</span><br><span class="line">	modulename</span><br><span class="line">	</span><br><span class="line">PRODUCT_DELETE_PACKAGES += \</span><br><span class="line">     Email \</span><br><span class="line">     Music \</span><br><span class="line">     TeleService \</span><br><span class="line">     CtsShimPrivPrebuilt \</span><br><span class="line">     WallpaperCropper \</span><br><span class="line">     DocumentsUI \</span><br><span class="line">     HTMLViewer \</span><br><span class="line">     Protips \</span><br><span class="line">     QuickSearchBox \</span><br><span class="line">     DownloadProvider \</span><br><span class="line">     SoundRecorder \</span><br><span class="line">     DownloadProviderUi \</span><br><span class="line">     SimAppDialog \</span><br><span class="line">     CertInstaller \</span><br><span class="line">     CarrierConfig \</span><br><span class="line">     EasterEgg \</span><br><span class="line">     NfcNci \</span><br><span class="line">     Calendar \</span><br><span class="line">     MusicFX \</span><br><span class="line">     CellBroadcastReceiver \</span><br><span class="line">     OneTimeInitializer \</span><br><span class="line">     Dialer \</span><br><span class="line">     Gallery2 \</span><br><span class="line">     CarrierDefaultApp \</span><br><span class="line">     ProxyHandler \</span><br><span class="line">     ManagedProvisioning \</span><br><span class="line">     CarLatinIME \</span><br><span class="line">     WAPPushManager \</span><br><span class="line">     LiveWallpapersPicker \</span><br><span class="line">     BookmarkProvider \</span><br><span class="line">     ExactCalculator \</span><br><span class="line">     CtsShimPrebuilt \</span><br><span class="line">     VpnDialogs \</span><br><span class="line">     WallpaperBackup \</span><br><span class="line">     UserDictionaryProvider \</span><br><span class="line">     EmergencyInfo \</span><br><span class="line">     DeskClock \</span><br><span class="line">     CaptivePortalLogin \</span><br><span class="line">     CalendarProvider</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 或者使用如下Android.mk来裁剪模块</span></span><br><span class="line">LOCAL_PATH:= <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := CarExcludePackages</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">LOCAL_MODULE_CLASS := FAKE</span><br><span class="line">LOCAL_MODULE_SUFFIX := <span class="variable">$(COMMON_ANDROID_PACKAGE_SUFFIX)</span></span><br><span class="line"></span><br><span class="line">LOCAL_OVERRIDES_PACKAGES += \</span><br><span class="line">    Launcher2 \</span><br><span class="line">    Launcher3 \</span><br><span class="line">    CarLauncher</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SYSTEM)</span>/base_rules.mk</span><br><span class="line"></span><br><span class="line"><span class="variable">$(LOCAL_BUILT_MODULE)</span>:</span><br><span class="line">	<span class="variable">$(hide)</span> echo <span class="string">&quot;Fake: <span class="variable">$@</span>&quot;</span></span><br><span class="line">	<span class="variable">$(hide)</span> mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">	<span class="variable">$(hide)</span> touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">PACKAGES.<span class="variable">$(LOCAL_MODULE)</span>.OVERRIDES := <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(LOCAL_OVERRIDES_PACKAGES)</span>)</span></span><br></pre></td></tr></table></figure>


<p>首先通过<code>pm path 包名</code>找到对应编译时的LOCAL_MODULE 或者 LOCAL_PACKAGE_NAME, 然后通过包的名字或者模块名字找到对应的mk, 把模块名字加到<code>PRODUCT_DELETE_PACKAGES</code>下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Email/Android.mk</span></span><br><span class="line">com.android.email   # 原生email</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Music/Android.mk</span></span><br><span class="line">com.android.music   # 原生music</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/services/Telephony/Android.mk</span></span><br><span class="line">com.android.phone   # 原生phone</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/CtsShim/Android.mk</span></span><br><span class="line">com.android.cts.priv.ctsshim # 原生cts app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/WallpaperCropper/Android.mk</span></span><br><span class="line">com.android.wallpapercropper # 壁纸</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Protips/Android.mk</span></span><br><span class="line">com.android.protips # 提示小绿人</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/DocumentsUI/Android.mk</span></span><br><span class="line">com.android.documentsui # 处理文档权限的组件控制对特定文件的访问</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/HTMLViewer/Android.mk</span></span><br><span class="line">com.android.htmlviewer # HTML查看器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/QuickSearchBox/Android.mk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device/qcom/common/base.mk 配置加入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device/qcom/qssi/base.mk 配置加入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> build/make/target/product/core.mk 配置加入</span></span><br><span class="line">com.android.quicksearchbox  # 原生全局搜索</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/services/Mms/Android.mk</span></span><br><span class="line">com.android.mms.service  # 短信服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/providers/DownloadProvider/Android.mk</span></span><br><span class="line">com.android.providers.downloads  # 浏览器点链接下载服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/SoundRecorder/Android.mk</span></span><br><span class="line">com.android.soundrecorder  # 原生录音机</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/providers/DownloadProvider/ui/Android.mk</span></span><br><span class="line">com.android.providers.downloads.ui </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/SimAppDialog/Android.mk</span></span><br><span class="line">com.android.simappdialog # sim插入弹窗</span><br><span class="line"><span class="meta">#</span><span class="bash"> ===========   正常  ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/CertInstaller/Android.mk</span></span><br><span class="line">com.android.certinstaller # 证书安装服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/CarrierConfig/Android.mk</span></span><br><span class="line">com.android.carrierconfig  # 可用网络的默认配置</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/services/Proxy/Android.mk</span></span><br><span class="line">com.android.proxyhandler  # 自动配置代理</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> build/make/target/product/generic_no_telephony.mk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> build/make/target/product/sdk_base.mk</span></span><br><span class="line">com.android.egg # 彩蛋</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Nfc/Android.mk</span></span><br><span class="line">com.android.nfc  # nfc服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Calendar/Android.mk</span></span><br><span class="line">com.android.calendar  # 日历</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/MusicFX/Android.mk</span></span><br><span class="line">com.android.musicfx  # 音效</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/CellBroadcastReceiver/Android.mk</span></span><br><span class="line">com.android.cellbroadcastreceiver # 小区广播</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/OneTimeInitializer/Android.mk</span></span><br><span class="line">com.android.onetimeinitializer # 首次启动用于装谷歌app的</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Dialer/Android.mk</span></span><br><span class="line">com.android.dialer # 原生拨号盘</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Gallery2/Android.mk</span></span><br><span class="line">com.android.gallery3d # 相机相框</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/CarrierDefaultApp/Android.mk</span></span><br><span class="line">com.android.carrierdefaultapp # 运营商默认流量服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/Car/LatinIME/Android.mk</span></span><br><span class="line">com.android.inputmethod.latin  # 原生输入法</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/ManagedProvisioning/Android.mk</span></span><br><span class="line">com.android.managedprovisioning # 工作组资料设置</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/screensavers/PhotoTable/Android.mk</span></span><br><span class="line">com.android.dreams.phototable  # PhotoTable屏保</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/WAPPushManager/Android.mk</span></span><br><span class="line">com.android.smspush  # 短信推送</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/wallpapers/LivePicker/Android.mk</span></span><br><span class="line">com.android.wallpaper.livepicker  # 动态墙纸选择器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/providers/BookmarkProvider/Android.mk</span></span><br><span class="line">com.android.bookmarkprovider # 书签</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/ExactCalculator/Android.mk</span></span><br><span class="line">com.android.calculator2 # 计算器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/CtsShim/Android.mk</span></span><br><span class="line">com.android.cts.ctsshim # cts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/VpnDialogs/Android.mk</span></span><br><span class="line">com.android.vpndialogs # VPN</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/WallpaperBackup/Android.mk</span></span><br><span class="line">com.android.wallpaperbackup # 墙纸备份</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/providers/UserDictionaryProvider/Android.mk</span></span><br><span class="line">com.android.providers.userdictionary  # 用户词典Content Provider</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/EmergencyInfo/Android.mk</span></span><br><span class="line">com.android.emergency  # 急救信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/apps/DeskClock/Android.mk</span></span><br><span class="line">com.android.deskclock  # 自带闹钟</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> frameworks/base/packages/CaptivePortalLogin/Android.mk</span></span><br><span class="line">com.android.captiveportallogin # 网络连通信测试</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> packages/providers/CalendarProvider/Android.mk</span></span><br><span class="line">com.android.providers.calendar # 日历程序支持服务</span><br></pre></td></tr></table></figure>


<h4 id="3-修改编译脚本"><a href="#3-修改编译脚本" class="headerlink" title="3.修改编译脚本"></a>3.修改编译脚本</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># build/core/main.mk</span></span><br><span class="line"><span class="comment"># Filter out the overridden packages before doing expansion</span></span><br><span class="line">product_MODULES := <span class="variable">$(<span class="built_in">filter</span>-out $(<span class="built_in">foreach</span> p, <span class="variable">$(product_MODULES)</span>, \</span></span><br><span class="line"><span class="variable">$(PACKAGES.<span class="variable">$(p)</span>.OVERRIDES)</span>), <span class="variable">$(product_MODULES)</span>)</span><br><span class="line"><span class="comment"># Filter out executables as well</span></span><br><span class="line">product_MODULES := <span class="variable">$(<span class="built_in">filter</span>-out $(<span class="built_in">foreach</span> m, <span class="variable">$(product_MODULES)</span>, \</span></span><br><span class="line"><span class="variable">$(EXECUTABLES.<span class="variable">$(m)</span>.OVERRIDES)</span>), <span class="variable">$(product_MODULES)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filter out PRODUCT_DELETE_PACKAGES标签的模块</span></span><br><span class="line">product_MODULES := <span class="variable">$(<span class="built_in">filter</span>-out $(PRODUCTS.<span class="variable">$(INTERNAL_PRODUCT)</span>.PRODUCT_DELETE_PACKAGES)</span>, <span class="variable">$(product_MODULES)</span>)</span><br></pre></td></tr></table></figure>
<p>INTERNAL_PRODUCT值是: device/qcom/msmnile_gvmq/msmnile_gvmq.mk</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># build/core/product.mk</span></span><br><span class="line">_product_var_list := \</span><br><span class="line">    PRODUCT_NAME \</span><br><span class="line">    PRODUCT_MODEL \</span><br><span class="line">    PRODUCT_LOCALES \</span><br><span class="line">    PRODUCT_AAPT_CONFIG \</span><br><span class="line">    PRODUCT_AAPT_PREF_CONFIG \</span><br><span class="line">    PRODUCT_AAPT_PREBUILT_DPI \</span><br><span class="line">    PRODUCT_PACKAGES \</span><br><span class="line">    <span class="comment"># 添加PRODUCT_DELETE_PACKAGES标签</span></span><br><span class="line">    PRODUCT_DELETE_PACKAGES \</span><br><span class="line">    PRODUCT_PACKAGES_DEBUG \</span><br><span class="line">    PRODUCT_PACKAGES_ENG \</span><br><span class="line">    PRODUCT_PACKAGES_TESTS \</span><br><span class="line">    PRODUCT_DEVICE \</span><br><span class="line">    PRODUCT_MANUFACTURER </span><br></pre></td></tr></table></figure>


<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># device/qcom/common/base.mk</span></span><br><span class="line"></span><br><span class="line">PRODUCT_PACKAGES += liboemaids_system</span><br><span class="line">PRODUCT_PACKAGES += liboemaids_vendor</span><br><span class="line">PRODUCT_PACKAGES += android.hardware.health@2.0-service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入</span></span><br><span class="line"><span class="keyword">include</span> device/qcom/common/tailor.mk</span><br></pre></td></tr></table></figure>


<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># device/gxatek/common/tailor.mk</span></span><br><span class="line">PRODUCT_DELETE_PACKAGES += \</span><br><span class="line">     Email \</span><br><span class="line">     Music \</span><br><span class="line">     TeleService \</span><br><span class="line">     CtsShimPrivPrebuilt \</span><br><span class="line">     WallpaperCropper \</span><br><span class="line">     DocumentsUI \</span><br><span class="line">     HTMLViewer \</span><br><span class="line">     Protips \</span><br><span class="line">     QuickSearchBox \</span><br><span class="line">     DownloadProvider \</span><br><span class="line">     SoundRecorder \</span><br><span class="line">     DownloadProviderUi \</span><br><span class="line">     SimAppDialog \</span><br><span class="line">     CertInstaller \</span><br><span class="line">     CarrierConfig \</span><br><span class="line">     EasterEgg \</span><br><span class="line">     NfcNci \</span><br><span class="line">     Calendar \</span><br><span class="line">     MusicFX \</span><br><span class="line">     CellBroadcastReceiver \</span><br><span class="line">     OneTimeInitializer \</span><br><span class="line">     Dialer \</span><br><span class="line">     Gallery2 \</span><br><span class="line">     CarrierDefaultApp \</span><br><span class="line">     ProxyHandler \</span><br><span class="line">     ManagedProvisioning \</span><br><span class="line">     CarLatinIME \</span><br><span class="line">     WAPPushManager \</span><br><span class="line">     LiveWallpapersPicker \</span><br><span class="line">     BookmarkProvider \</span><br><span class="line">     ExactCalculator \</span><br><span class="line">     CtsShimPrebuilt \</span><br><span class="line">     VpnDialogs \</span><br><span class="line">     WallpaperBackup \</span><br><span class="line">     UserDictionaryProvider \</span><br><span class="line">     EmergencyInfo \</span><br><span class="line">     DeskClock \</span><br><span class="line">     CaptivePortalLogin \</span><br><span class="line">     CalendarProvider</span><br></pre></td></tr></table></figure>


<h4 id="4-优化后结果"><a href="#4-优化后结果" class="headerlink" title="4.优化后结果"></a>4.优化后结果</h4><p>优化前启动日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15506</span> <span class="number">2021</span>/09/<span class="number">02</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">50.728475</span> <span class="number">15.0165</span> <span class="number">191</span> ECU1 am_a LOGD <span class="number">335</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">41558120</span>,com.android.settings/.FallbackHome,<span class="number">902</span>,<span class="number">902</span>]</span><br><span class="line"><span class="number">21304</span> <span class="number">2021</span>/09/08 <span class="number">21</span>:<span class="number">26</span>:<span class="number">15.593283</span> <span class="number">335844.3927</span> <span class="number">221</span> ECU1 am_a LOGD <span class="number">335</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">41558120</span>,com.android.settings/.FallbackHome,<span class="number">902</span>,<span class="number">902</span>]</span><br><span class="line"><span class="number">45648</span> <span class="number">2021</span>/09/08 <span class="number">21</span>:<span class="number">26</span>:<span class="number">29.368316</span> <span class="number">27.0577</span> <span class="number">245</span> ECU1 am_a LOGD <span class="number">335</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">109419867</span>,com.gxatek.cockpit.launcher/.LauncherActivity,<span class="number">5839</span>,<span class="number">5839</span>]</span><br><span class="line"><span class="number">46331</span> <span class="number">2021</span>/09/08 <span class="number">21</span>:<span class="number">26</span>:<span class="number">29.804092</span> <span class="number">28.0021</span> <span class="number">160</span> ECU1 am_a LOGD <span class="number">335</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">143134280</span>,com.gxatek.cockpit.vicelauncher/.MainActivity,<span class="number">1057</span>,<span class="number">1057</span>]</span><br></pre></td></tr></table></figure>
<p>从日志中看到优化前Android启动耗时在28s。</p>
<p>裁剪一半应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">14153 2021/09/02 20:06:50.030267 14.0892 118 ECU1 am_a LOGD 337 log info verbose 1 I/am_activity_launch_time( 739): [0,250243696,com.android.settings/.FallbackHome,933,933]</span><br><span class="line">43483 2021/09/02 20:07:02.283826 27.0223 16 ECU1 am_a LOGD 337 log info verbose 1 I/am_activity_launch_time( 739): [0,141995565,com.gxatek.cockpit.launcher/.LauncherActivity,6054,6054]</span><br><span class="line">44365 2021/09/02 20:07:02.607031 27.0555 130 ECU1 am_a LOGD 337 log info verbose 1 I/am_activity_launch_time( 739): [0,170842785,com.gxatek.cockpit.vicelauncher/.MainActivity,858,858]</span><br></pre></td></tr></table></figure>
<p>从日志中看到优化前Android启动耗时在27s。</p>
<p>裁剪应用之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14475</span> <span class="number">2021</span>/09/<span class="number">02</span> <span class="number">20</span>:<span class="number">06</span>:<span class="number">50.375211</span> <span class="number">13.0238</span> <span class="number">184</span> ECU1 am_a LOGD <span class="number">338</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">54614525</span>,com.android.settings/.FallbackHome,<span class="number">793</span>,<span class="number">793</span>]</span><br><span class="line"><span class="number">19098</span> <span class="number">2021</span>/09/08 <span class="number">21</span>:<span class="number">52</span>:<span class="number">48.474646</span> <span class="number">334249.4242</span> <span class="number">105</span> ECU1 am_a LOGD <span class="number">338</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">54614525</span>,com.android.settings/.FallbackHome,<span class="number">793</span>,<span class="number">793</span>]</span><br><span class="line"><span class="number">39476</span> <span class="number">2021</span>/09/08 <span class="number">21</span>:<span class="number">53</span>:<span class="number">01.071597</span> <span class="number">25.0651</span> <span class="number">3</span> ECU1 am_a LOGD <span class="number">338</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">64801107</span>,com.gxatek.cockpit.launcher/.LauncherActivity,<span class="number">6039</span>,<span class="number">6039</span>]</span><br><span class="line"><span class="number">39755</span> <span class="number">2021</span>/09/08 <span class="number">21</span>:<span class="number">53</span>:<span class="number">01.297294</span> <span class="number">25.0881</span> <span class="number">26</span> ECU1 am_a LOGD <span class="number">338</span> log info verbose <span class="number">1</span> I/am_activity_launch_time( <span class="number">732</span>): [<span class="number">0</span>,<span class="number">178297624</span>,com.gxatek.cockpit.vicelauncher/.MainActivity,<span class="number">830</span>,<span class="number">830</span>]</span><br></pre></td></tr></table></figure>
<p>从日志中看到优化前Android启动耗时在25s。</p>
<p><strong>总结：</strong>根据项目的需求，当车机系统裁掉以上应用后，开机启动耗时可以减少近3s。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统优化</tag>
        <tag>应用服务裁剪</tag>
      </tags>
  </entry>
  <entry>
    <title>解决google原生代码死锁问题</title>
    <url>/2021/09/09/%E8%A7%A3%E5%86%B3google%E5%8E%9F%E7%94%9F%E4%BB%A3%E7%A0%81%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a><strong>1.背景</strong></h4><p>​    测试同学在下午正常测试的时候突然出现系统重启，然后开机界面一直在转圈无法进入Launcher。</p>
<h4 id="2-调查过程"><a href="#2-调查过程" class="headerlink" title="2.调查过程"></a><strong>2.调查过程</strong></h4><h5 id="2-1-问题初诊断"><a href="#2-1-问题初诊断" class="headerlink" title="2.1 问题初诊断"></a>2.1 问题初诊断</h5><p>​    不幸的是车机adb口不好使，首先通过串口进入在Android系统，配置usb模式，让adb好使，通过ADB进入到车机。</p>
<p>​    进入车机之后使用<code>uptime</code>指令查看系统启动时间，看是Android重启，还是QNX重启了。</p>
<p>​    一看uptime的系统启动时间，发现才10分多钟，明显是QNX重启了。那这个问题从一个问题发散成两个问题了。</p>
<ul>
<li><p>QNX故障导致系统整体重启</p>
</li>
<li><p>重启后系统无法进入Launcher</p>
<p>此文章主要记录问题2：系统服务发生死锁导致无法进入Launcher。</p>
</li>
</ul>
<h5 id="2-2-深入调查"><a href="#2-2-深入调查" class="headerlink" title="2.2 深入调查"></a>2.2 深入调查</h5><p><strong>2.2.1 查看进程启动情况</strong></p>
<p>​    <code>ps -A</code>查看所有进程启动情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">mdnsr          733     1    5628   1184 poll_sche+          0 S mdnsd</span><br><span class="line">root           745     2       0      0 worker_th+          0 I [kworker/4:3]</span><br><span class="line">radio          747     1   13924   3064 poll_sche+          0 S ipacm-diag</span><br><span class="line">radio          751     1   22164   6476 futex_wai+          0 S ipacm</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemserver启动</span></span><br><span class="line">system         761   341 4523728 162136 ep_poll             0 S system_server</span><br><span class="line">root           866     2       0      0 worker_th+          0 I [kworker/u13:2]</span><br><span class="line">root           949     2       0      0 worker_th+          0 I [kworker/1:4]</span><br><span class="line">root           950     2       0      0 worker_th+          0 I [kworker/2:3]</span><br><span class="line">root           951     2       0      0 worker_th+          0 I [kworker/2:4]</span><br><span class="line">root           952     2       0      0 worker_th+          0 I [kworker/2:5]</span><br><span class="line">root           954     2       0      0 worker_th+          0 I [kworker/2:6]</span><br><span class="line">root           955     2       0      0 worker_th+          0 I [kworker/1:5]</span><br><span class="line">root           957     2       0      0 worker_th+          0 I [kworker/1:6]</span><br><span class="line">root           964     2       0      0 worker_th+          0 I [kworker/1:7]</span><br><span class="line">root          1006     2       0      0 worker_th+          0 I [kworker/0:3]</span><br><span class="line">root          1007     2       0      0 worker_th+          0 I [kworker/1:8]</span><br><span class="line">root          1008     2       0      0 worker_th+          0 I [kworker/0:4]</span><br><span class="line">root          1012     2       0      0 worker_th+          0 I [kworker/0:5]</span><br><span class="line">root          1015     2       0      0 worker_th+          0 I [kworker/0:6]</span><br><span class="line">root          1017     2       0      0 worker_th+          0 I [kworker/0:7]</span><br><span class="line">root          1020     2       0      0 worker_th+          0 I [kworker/0:8]</span><br><span class="line">root          1021     2       0      0 worker_th+          0 I [kworker/0:9]</span><br><span class="line">root          1022     2       0      0 worker_th+          0 I [kworker/0:10]</span><br><span class="line">root          1023     2       0      0 worker_th+          0 I [kworker/0:11]</span><br><span class="line">root          1025     2       0      0 worker_th+          0 I [kworker/0:12]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 场景服务启动</span></span><br><span class="line">system        1045   341 4361960  67808 ep_poll             0 S com.gxa.car.scene</span><br></pre></td></tr></table></figure>
<p>可以看到SystemServer已经启动完毕，在startOtherService已经把管理上层场景的服务已经拉起，但是后面就没有服务起来了。因此初步判断是有系统服务卡死了！</p>
<p>​    使用<code>kill -3 761</code>将当前所有所有线程的堆栈取出来。</p>
<p>​    在<code>/data/anr</code>路径下会生成一个名为<strong>“trace_00”</strong>的文件。导出此文件，开始分析是哪些线程发送卡死了。</p>
<p><strong>2.2.2 分析trace日志</strong></p>
<p>​    正常看trace一半先看main线程，但是看车机现象是一直卡在开机界面，不会重启，因此可以初步判断不是主线程卡死了，如果是主线程卡死了，watchdog会直接触发重启Android。不过还是看一下main线程状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;main&quot; prio=5 tid=1 Blocked</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x74726b48 self=0x7b90614c00</span><br><span class="line">  | sysTid=729 nice=-2 cgrp=default sched=0/0 handle=0x7c16087548</span><br><span class="line">  | state=S schedstat=( 822945383 262318239 1924 ) utm=56 stm=25 core=1 HZ=100</span><br><span class="line">  | stack=0x7fdac06000-0x7fdac08000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.android.server.am.ActivityManagerService.registerReceiver(ActivityManagerService.java:20857)</span><br><span class="line">  - waiting to lock &lt;0x033008f9&gt; (a com.android.server.am.ActivityManagerService) held by thread 86</span><br><span class="line">  at android.app.ContextImpl.registerReceiverInternal(ContextImpl.java:1488)</span><br><span class="line">  at android.app.ContextImpl.registerReceiver(ContextImpl.java:1449)</span><br><span class="line">  at com.android.server.net.NetworkStatsService.systemReady(NetworkStatsService.java:398)</span><br><span class="line">  at com.android.server.SystemServer.lambda$startOtherServices$4(SystemServer.java:1851)</span><br><span class="line">  at com.android.server.-$$Lambda$SystemServer$s9erd2iGXiS7bbg_mQJUxyVboQM.run(lambda:-1)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.systemReady(ActivityManagerService.java:15282)</span><br><span class="line">  at com.android.server.SystemServer.startOtherServices(SystemServer.java:1777)</span><br><span class="line">  at com.android.server.SystemServer.run(SystemServer.java:444)</span><br><span class="line">  at com.android.server.SystemServer.main(SystemServer.java:303)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:838)</span><br></pre></td></tr></table></figure>
<p>main线程registerReceiver()方法中等待&lt;0x033008f9&gt;这把锁。顺藤摸瓜，看看哪个线程持有这把锁。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;Binder:729_7&quot; prio=5 tid=86 Blocked</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12e80020 self=0x7b87c51000</span><br><span class="line">  | sysTid=1259 nice=-2 cgrp=default sched=0/0 handle=0x7b6e7df4f0</span><br><span class="line">  | state=S schedstat=( 3735363 3189481 17 ) utm=0 stm=0 core=2 HZ=100</span><br><span class="line">  | stack=0x7b6e6e4000-0x7b6e6e6000 stackSize=1009KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.android.server.wm.WindowManagerService.deferSurfaceLayout(WindowManagerService.java:2894)</span><br><span class="line">  - waiting to lock &lt;0x09464241&gt; (a com.android.server.wm.WindowHashMap) held by thread 20</span><br><span class="line">  at com.android.server.am.ActivityManagerService.handleAppDiedLocked(ActivityManagerService.java:5928)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.appDiedLocked(ActivityManagerService.java:6107)</span><br><span class="line">  at com.android.server.am.ActivityManagerService$AppDeathRecipient.binderDied(ActivityManagerService.java:1885)</span><br><span class="line">  - locked &lt;0x033008f9&gt; (a com.android.server.am.ActivityManagerService)</span><br><span class="line">  at android.os.BinderProxy.sendDeathNotice(Binder.java:1193)</span><br></pre></td></tr></table></figure>
<p>名为Binder:729_7的86号线程持有main线程的**&lt;0x033008f9&gt;<strong>锁，但是该线程执行deferSurfaceLayout方法依赖</strong>&lt;0x09464241&gt;**锁（锁的名字WindowHashMap的实例，看源码mWindowMap这个对象）释放。继续顺藤摸瓜。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;android.display&quot; prio=5 tid=20 Blocked</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12c40f88 self=0x7b907ddc00</span><br><span class="line">  | sysTid=806 nice=-4 cgrp=default sched=0/0 handle=0x7b74e0a4f0</span><br><span class="line">  | state=S schedstat=( 28085321 36714886 210 ) utm=1 stm=1 core=3 HZ=100</span><br><span class="line">  | stack=0x7b74d07000-0x7b74d09000 stackSize=1041KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.android.server.policy.PhoneWindowManager.canDismissBootAnimation(PhoneWindowManager.java:7637)</span><br><span class="line">  - waiting to lock &lt;0x0a6033e6&gt; (a java.lang.Object) held by thread 13</span><br><span class="line">  at com.android.server.wm.WindowManagerService.performEnableScreen(WindowManagerService.java:3455)</span><br><span class="line">  - locked &lt;0x09464241&gt; (a com.android.server.wm.WindowHashMap)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.access$1100(WindowManagerService.java:272)</span><br><span class="line">  at com.android.server.wm.WindowManagerService$H.handleMessage(WindowManagerService.java:4861)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:193)</span><br><span class="line">  at android.os.HandlerThread.run(HandlerThread.java:65)</span><br><span class="line">  at com.android.server.ServiceThread.run(ServiceThread.java:44)</span><br></pre></td></tr></table></figure>
<p>android.display线程持有**&lt;0x09464241&gt;<strong>锁，需要释放该锁，依赖执行canDismissBootAnimation()方法释放</strong>&lt;0x0a6033e6&gt;**锁(源码中该锁名字叫mLock),继续顺藤摸瓜。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;android.ui&quot; prio=5 tid=13 Blocked</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12c408b0 self=0x7b907d7c00</span><br><span class="line">  | sysTid=799 nice=-2 cgrp=default sched=0/0 handle=0x7b756324f0</span><br><span class="line">  | state=S schedstat=( 24267703 15746873 101 ) utm=2 stm=0 core=0 HZ=100</span><br><span class="line">  | stack=0x7b7552f000-0x7b75531000 stackSize=1041KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.android.server.wm.WindowManagerService$LocalService.waitForAllWindowsDrawn(WindowManagerService.java:7370)</span><br><span class="line">  - waiting to lock &lt;0x09464241&gt; (a com.android.server.wm.WindowHashMap) held by thread 20</span><br><span class="line">  at com.android.server.policy.PhoneWindowManager.finishKeyguardDrawn(PhoneWindowManager.java:6885)</span><br><span class="line">  at com.android.server.policy.PhoneWindowManager.screenTurningOn(PhoneWindowManager.java:6938)</span><br><span class="line">  - locked &lt;0x0a6033e6&gt; (a java.lang.Object)</span><br><span class="line">  at com.android.server.policy.PhoneWindowManager.systemBooted(PhoneWindowManager.java:7631)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.enableScreenAfterBoot(WindowManagerService.java:3392)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.enableScreenAfterBoot(ActivityManagerService.java:7993)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.ensureBootCompleted(ActivityManagerService.java:8162)</span><br><span class="line">  at com.android.server.am.ActivityManagerService$UiHandler.handleMessage(ActivityManagerService.java:2033)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:193)</span><br><span class="line">  at android.os.HandlerThread.run(HandlerThread.java:65)</span><br><span class="line">  at com.android.server.ServiceThread.run(ServiceThread.java:44)</span><br><span class="line">  at com.android.server.UiThread.run(UiThread.java:43)</span><br></pre></td></tr></table></figure>
<p>android.ui线程持有**&lt;0x0a6033e6&gt;<strong>锁，执行依赖waitForAllWindowsDrawn()依赖</strong>&lt;0x09464241&gt;**释放！！！！</p>
<p><strong>问题终于找到了</strong>：</p>
<p>android.display线程持**&lt;0x09464241&gt;<strong>mWindowMap对象锁，依赖</strong>&lt;0x0a6033e6&gt;**mLock对象锁释放。</p>
<p>android.ui线程持有**&lt;0x0a6033e6&gt;<strong>mLock对象锁，依赖</strong>&lt;0x09464241&gt;**mWindowMap对象锁释放。</p>
<p>发生循环依赖了。<strong>导致死锁的场景发生！！！</strong></p>
<p><strong>解决思路</strong>：发生死锁一般解决办法就是翻看源码解开其中一个方法的锁即可。</p>
<h5 id="2-3源码调查"><a href="#2-3源码调查" class="headerlink" title="2.3源码调查"></a>2.3源码调查</h5><p>从上面分析看主要是执行canDismissBootAnimation()和waitForAllWindowsDrawn()中造成循环依赖了。因此直接调查这两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canDismissBootAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">		<span class="keyword">return</span> mKeyguardDrawComplete;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForAllWindowsDrawn</span><span class="params">(Runnable callback, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> allWindowsDrawn = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">		mWaitingForDrawnCallback = callback;</span><br><span class="line">		getDefaultDisplayContentLocked().waitForAllWindowsDrawn();</span><br><span class="line">		mWindowPlacerLocked.requestTraversal();</span><br><span class="line">		mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT);</span><br><span class="line">		<span class="keyword">if</span> (mWaitingForDrawn.isEmpty()) &#123;</span><br><span class="line">			allWindowsDrawn = <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mH.sendEmptyMessageDelayed(H.WAITING_FOR_DRAWN_TIMEOUT, timeout);</span><br><span class="line">			checkDrawnWindowsLocked();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (allWindowsDrawn) &#123;</span><br><span class="line">		callback.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初步一看，canDismissBootAnimation()方法的mLock锁只是为了保证返回mKeyguardDrawComplete局部变量的原子性。而waitForAllWindowsDrawn()方法的mWindowMap是为了保证那么大一段代码的原子性。</p>
<p><strong>解决办法很简单，移除mKeyguardDrawComplete返回的锁即可。</strong></p>
<p><strong>2.4 解决后代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canDismissBootAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mKeyguardDrawComplete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-回顾"><a href="#3-回顾" class="headerlink" title="3.回顾"></a>3.回顾</h4><p>​    咋一想，居然google原生代码也出现了死锁问题，还想着是不是可以取给google提交一个bug和修复方案，万一采纳了呢，那不是牛逼了。</p>
<p>​    由于当前项目用的Android P的代码，于是赶紧去看看Android Q 谷歌有没有修复该代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canDismissBootAnimation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mDefaultDisplayPolicy.isKeyguardDrawComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># frameworks/base/services/core/java/com/android/server/wm/DisplayPolicy.java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeyguardDrawComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mKeyguardDrawComplete;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>哎哎哎，还是太年轻，too young，too simple了。看来Android P的漏洞，Android Q已经修复了，修复的方法和我开始调查的时候修复的方法一样，还是挺开心的。因此顺利提交代码到项目中了。</p>
<p><strong>附件：</strong></p>
<p>trace原始文件见github笔记记录《trace_00》</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>验证SSL/TLS双向认证过程及原理</title>
    <url>/2020/09/16/%E9%AA%8C%E8%AF%81SSL-TLS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="1-SSL-TLS-介绍"><a href="#1-SSL-TLS-介绍" class="headerlink" title="1. SSL/TLS 介绍"></a>1. SSL/TLS 介绍</h4><p>什么是 SSL, 什么是 TLS 呢？官话说 SSL 是安全套接层 (secure sockets layer), TLS 是 SSL 的继任者，叫传输层安全 (transport layer security)。说白点，就是在明文的上层和 TCP 层之间加上一层加密，这样就保证上层信息传输的安全。如HTTP 协议是明文传输，加上 SSL 层之后，就有了雅称 HTTPS。它存在的唯一目的就是保证上层通讯安全的一套机制。它的发展依次经历了下面几个时期，像手机软件升级一样，每次更新都添加或去除功能，比如引进新的加密算法，修改握手方式等。</p>
<p>SSL1.0: 已废除<br>SSL2.0: RFC6176, 已废除<br>SSL3.0: RFC6101, 基本废除<br>TLS1.0: RFC2246, 少数古董服务器仍在使用<br>TLS1.1: RFC4346<br>TLS1.2: RFC5246, 目前已广泛使用<br>TLS1.3: RFC8446<br>下面我们将介绍 TLS1.x 如何保证通讯安全。</p>
<h4 id="2-CA-amp-SSL-server-amp-SSL-client-介绍"><a href="#2-CA-amp-SSL-server-amp-SSL-client-介绍" class="headerlink" title="2. CA &amp; SSL server &amp; SSL client 介绍"></a>2. CA &amp; SSL server &amp; SSL client 介绍</h4><h5 id="2-1-如何保证安全呢？你说安全就安全吗，究竟是怎么实现的呢？绝对安全吗？"><a href="#2-1-如何保证安全呢？你说安全就安全吗，究竟是怎么实现的呢？绝对安全吗？" class="headerlink" title="2.1 如何保证安全呢？你说安全就安全吗，究竟是怎么实现的呢？绝对安全吗？"></a>2.1 如何保证安全呢？你说安全就安全吗，究竟是怎么实现的呢？绝对安全吗？</h5><p>有人的地方就有江湖，有江湖的地方就没有绝对的安全。但 SSL/TLS 确实可以极大程度保证信息安全。<br>下面根据图一 SSL/TLS 工作流来一览实现过程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-eb3bfe7004507407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SSL_TLS工作流程图.png"></p>
<h5 id="2-1-1-CA-介绍"><a href="#2-1-1-CA-介绍" class="headerlink" title="2.1.1 CA 介绍"></a>2.1.1 CA 介绍</h5><p>CA: 证书授权中心 (certificate authority)<br>它呢，类似于国家出入境管理处一样，给别人颁发护照；<br>也类似于国家工商管理局一样，给公司/企业颁发营业执照。</p>
<p>CA 有两大主要性质：</p>
<p>CA 本身是受信任的（国际认可的）<br>给他受信任的申请对象颁发证书</p>
<blockquote>
<p>和办理护照一样，要确定你的合法身份，你不能是犯罪分子或造反派。当然，你需要被收保护费，同时，CA 机构可以随时吊销你的证书。</p>
</blockquote>
<h5 id="2-1-2-CA-证书长啥样"><a href="#2-1-2-CA-证书长啥样" class="headerlink" title="2.1.2 CA 证书长啥样"></a>2.1.2 CA 证书长啥样</h5><p>其实你的电脑中有一堆证书。你可以看一看嘛：</p>
<p>360 浏览器: 选项/设置-&gt; 高级设置 -&gt; 隐私于安全 -&gt; 管理 HTTPS/SSL 证书 -&gt; 证书颁发机构<br>火狐浏览器: 首选项 -&gt; 高级 -&gt; 证书 -&gt; 查看证书 -&gt; 证书机构<br>chrome浏览器: 设置 -&gt; 高级 -&gt; 管理证书 -&gt; 授权中心<br>ubuntu: /etc/ssl/certs/xxx_CA.pem (或 xxx_Certification_Authority.pem)<br>这些都是 CA 的证书！</p>
<h5 id="2-1-3-CA-的证书-ca-crt-和-SSL-server-的证书-server-crt-是什么关系呢"><a href="#2-1-3-CA-的证书-ca-crt-和-SSL-server-的证书-server-crt-是什么关系呢" class="headerlink" title="2.1.3 CA 的证书 ca.crt 和 SSL server 的证书 server.crt 是什么关系呢"></a>2.1.3 CA 的证书 ca.crt 和 SSL server 的证书 server.crt 是什么关系呢</h5><p>SSL server 自己生成一个私钥/公钥对。server.key/server.pub // 私钥加密，公钥解密！<br>server.pub 生成一个请求文件 server.req. 请求文件中包含有 server 的一些信息，如域名/申请者/公钥等<br>server 将请求文件 server.req 递交给 CA 机构，CA 机构验明正身后，将用 ca.key 和请求文件加密生成 server.crt<br>由于 ca.key 和 ca.crt 是一对，于是 ca.crt 可以用来校验 server.crt.</p>
<p>说明：为了简化 CA 校验证书的过程，本文只介绍了最基本的情况。在实际大多数情况下：</p>
<p>server 端的证书颁发机构 CA 和 client 端的证书颁发机构 CA 通常不同<br>证书实际情况下，可以是证书链，也就是多个上级机构逐级下发证书的链<br>证书校验时，CA 通常可以选择校验证书链的深度，最基础的情况是只校验一级</p>
<h5 id="2-1-4-举例说明"><a href="#2-1-4-举例说明" class="headerlink" title="2.1.4  举例说明"></a>2.1.4  举例说明</h5><p>如果 SSL client 想要校验 SSL server. 那么 SSL server 必须要将他的证书 server.crt 传给 client. 然后 client 用 ca.crt 去校验 server.crt 的合法性。<br>如果 server 是一个钓鱼网站，那么 CA 机构是不会给他颁发合法 server.crt 证书的，这样 client 用 ca.crt 去校验，就会失败。<br>比如：浏览器作为一个 SSL client, 你想访问合法的淘宝网站 <a href="https://www.taobao.com/">https://www.taobao.com</a>, 结果不慎访问到 <a href="https://wwww.jiataobao.com/">https://wwww.jiataobao.com</a>, 那么浏览器将会检验到这个假淘宝钓鱼网站的非法性，提醒用户不要继续访问！这样就可以保证 client 的所有 https 访问都是经过安全检查的。</p>
<h5 id="2-2-不认证-amp-单向认证-amp-双向认证"><a href="#2-2-不认证-amp-单向认证-amp-双向认证" class="headerlink" title="2.2 不认证 &amp; 单向认证 &amp; 双向认证"></a>2.2 不认证 &amp; 单向认证 &amp; 双向认证</h5><p><strong>何为 SSL/TLS 单向认证，双向认证？</strong></p>
<p><strong>单向认证</strong>：指的是只有一个对象校验对端的证书合法性<br>通常是客户端来校验服务器的合法性。那么 client 需要一个 ca.crt, 服务器需要 server.crt, server.key</p>
<blockquote>
<p>例如：浏览器校验各个 HTTPS 网站的合法性。如果导航栏有绿色的小锁，说明网站合法；如果是红色小锁，说明该网站证书校验不过。</p>
</blockquote>
<p>也可以是服务器来校验客户端的合法性。那么 server 需要一个 ca.crt, 客户端需要 client.crt, client.key</p>
<blockquote>
<p>例如: 亚马逊物联网平台(AWS IoT) 给每个设备颁发证书，所有设备要想连接上 AWS, 必须使用其提供的客户端证书</p>
</blockquote>
<p>双向认证：指的是相互校验，服务器需要校验每个 client 证书, client 也需要校验服务器证书<br>server 需要 server.key 、server.crt 、ca.crt<br>client 需要 client.key 、client.crt 、ca.crt</p>
<p>不认证：指的是不相互校验证书，但仍然使用 TLS 连接。</p>
<blockquote>
<p>证书校验只是 TLS 连接过程中的一小步，是可以省略的过程</p>
</blockquote>
<h5 id="2-3-证书详细工作流"><a href="#2-3-证书详细工作流" class="headerlink" title="2.3 证书详细工作流"></a>2.3 证书详细工作流</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-8a797881c3a0d5b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="证书详细工作流程.png"></p>
<p>1）申请认证：服务器需自己生成公钥私钥对 pub_svr &amp; pri_svr，同时根据 pub_svr 生成请求文件 csr, 提交给 CA 机构，csr 中含有公钥、组织信息、个人信息（域名）等信息。(图一中 server.req 就是 csr 请求文件)</p>
<p>2）审核信息：CA 机构通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等。</p>
<p>3）签发证书：如信息审核通过，CA 机构会向申请者签发认证文件：证书。<br>证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。<br>签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名。（图一中生成 server.crt）</p>
<p>4）返回证书：client 如果请求验证服务器，服务器需返回证书文件。（图一中 handshake 传回 server.crt）</p>
<p>5）client验证证书：client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法。客户端然后验证证书相关的域名信息、有效时间是否吊销等信息。<br>客户端会内置信任 CA 的证书信息（包含公钥），如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。(图一中 check 可选，我们可以选择不验证服务器证书的有效性)</p>
<p>6）秘钥协商：验证通过后，server 和 client 将进行秘钥协商。接下来 server 和 client 会采用对称秘钥加密。(对称加密时间性能优)（图一中 pre-master/change_cipher_spec/encrypted_handshake_message 过程）</p>
<p>7）数据传输：SSL server 和 SSL client 采用对称秘钥加密解密数据。</p>
<h5 id="2-4-SSL-TLS单向认证流程"><a href="#2-4-SSL-TLS单向认证流程" class="headerlink" title="2.4 SSL/TLS单向认证流程"></a>2.4 SSL/TLS单向认证流程</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-80b608042419d25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单向认证过程.png"></p>
<p><strong>(1) client_hello</strong><br>客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息，相关信息如下：</p>
<p>支持的最高 TLS 协议版本 version，从低到高依次 SSLv2, SSLv3, TLSv1, TLSv1.1, TLSv1.2, 当前基本不再使用低于 TLSv1 的版本<br>客户端支持的加密套件 cipher suites 列表， 每个加密套件对应前面 TLS 原理中的四个功能的组合：<br>认证算法 Au (身份验证)<br>密钥交换算法 KeyExchange (密钥协商)<br>对称加密算法 Enc (信息加密)<br>信息摘要 Mac (完整性校验)<br>支持的压缩算法 compression methods 列表，用于后续的信息压缩传输<br>随机数 random_C，用于后续的密钥的生成<br>扩展字段 extensions，支持协议与算法的相关参数以及其它辅助信息等，常见的 SNI 就属于扩展字段，后续单独讨论该字段作用<br><strong>(2) server_hello + server_certificate + sever_hello_done</strong><br>server_hello, 服务端返回协商的信息结果，包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 等，其中随机数用于后续的密钥协商<br>server_certificates, 服务器端配置对应的证书链，用于身份验证与密钥交换<br>server_hello_done，通知客户端 server_hello 信息发送结束<br><strong>(3) 证书校验</strong><br>证书/证书链的可信性 trusted certificate path，方法如前文所述<br>证书是否吊销 revocation，有两类方式离线 CRL 与在线 OCSP，不同客户端行为会不同<br>有效期 expiry date，证书是否在有效时间范围<br>域名 domain，核查证书域名是否与当前的访问域名匹配 (CN 字段)</p>
<blockquote>
<p>证书校验没有强制的过程，也就是校验严格和校验宽松通常都是可以配置的，由校验端来确定。</p>
</blockquote>
<p><strong>(4) client_key_exchange + change_cipher_spec + encrypted_handshake_message</strong><br>client_key_exchange: 合法性验证通过之后，客户端计算产生随机数字 pre-master，并用证书公钥加密，发送给服务器<br>此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和 random_S 与自己计算产生的 pre-master，计算得到协商密钥<br>enc_key=Fuc(random_C, random_S, pre-master)<br>change_cipher_spec: 客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信;<br>encrypted_handshake_message: 结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证<br><strong>(5) change_cipher_spec + encrypted_handshake_message</strong><br>服务器用私钥解密加密的 pre-master 数据，基于之前交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥:enc_key=Fuc(random_C, random_S, pre-master);<br>计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性;<br>change_cipher_spec, 验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信;<br>encrypted_handshake_message, 服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥 session secret 与算法加密并发送到客户端;<br><strong>(6) 握手结束</strong><br>客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成</p>
<p><strong>(7) 加密通信</strong><br>开始使用协商密钥与算法进行加密通信。</p>
<h5 id="2-5-实际-wireshark-分析"><a href="#2-5-实际-wireshark-分析" class="headerlink" title="2.5 实际 wireshark 分析"></a>2.5 实际 wireshark 分析</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-4e41b01da66c7ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单向认证校验图.png"></p>
<p>我们搭建的 SSL/TLS 服务器是 192.168.111.100, client 是192.168.111.101. client 需要认证 server 的合法性。<br>我们只看 TLSv1.1 的数据包：<br>第一包 (No. 25) Client Hello 包，即 SSL/TLS 单向认证流程的 (1)<br>第二包 (No. 27) Server Hello 包，包含服务器证书等。即 SSL/TLS 单向认证流程的 (2)<br>第三包 (No. 28) 服务器证书验证完成，同时发送 client key exchange+change cipher spec + encrypted handshake message.即 SSL/TLS 单向认证流程的(4)<br>第四包 (No. 29) 秘钥协商，change cipher spec + encrypted hanshake message.即 SSL/TLS 单向认证流程的 (5)<br>第五包 (No. 30) 握手完成。开始上层数据传输。SSL/TLS 单向认证流程的 (7)</p>
<h5 id="2-6-SSL-TLS-双向认证流程"><a href="#2-6-SSL-TLS-双向认证流程" class="headerlink" title="2.6 SSL/TLS 双向认证流程"></a>2.6 SSL/TLS 双向认证流程</h5><p>和单向认证几乎一样，只是在 client 认证完服务器证书后，client 会将自己的证书 client.crt 传给服务器。服务器验证通过后，开始秘钥协商。</p>
<p><strong>实际 wireshark 分析：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-12c27718781f5104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向认证校验图.png"></p>
<p>和单向认证一样:<br>我们搭建的 SSL/TLS 服务器是 192.168.111.100, client是192.168.111.101. client 需要认证 server 的合法性，server 也需要认证 client 的合法性</p>
<p>我们只看 TLSv1.1 的数据包：<br>第一包 (No. 55) Client Hello 包，即 SSL/TLS 单向认证流程的 (1)<br>第二包 (No. 57) Server Hello 包，包含服务器证书等。即 SSL/TLS 单向认证流程的 (2)<br>第三包 (No. 60) 服务器证书验证完成，同时发送客户端的证书 client.crt ,同时包含 client key exchange+change cipher spec + encrypted handshake message. 即 SSL/TLS 单向认证流程的 (4)<br>第四包 (No. 61)<strong>服务器验证客户端证书的合法性。</strong>通过后进行秘钥协商，change cipher spec + encrypted hanshake message.即 SSL/TLS 单向认证流程的 (5)<br>重传包 (No. 62) 由于网络原因，TCP 重传第No. 60 包。<br>第五包 (No. 64) 握手完成，开始上层数据传输。SSL/TLS 单向认证流程的 (7)</p>
<h5 id="2-7-证书等格式说明"><a href="#2-7-证书等格式说明" class="headerlink" title="2.7 证书等格式说明"></a>2.7 证书等格式说明</h5><p><strong>crt/key/req/csr/pem/der 等拓展名都是什么东东？</strong></p>
<p>.crt 表示证书, .key 表示私钥, .req 表示请求文件,.csr 也表示请求文件, .pem 表示 pem 格式，.der 表示 der 格式。</p>
<blockquote>
<p>文件拓展名你可以随便命名，只是为了理解需要而命名不同的拓展名。但文件中的信息是有格式的，和 exe，PE 格式一样。</p>
</blockquote>
<p>证书有两种格式：<code>pem</code> 格式和 <code>der</code> 格式</p>
<p>所有证书，私钥等都可以是 pem, 也可以是 der 格式，取决于应用需要。<br>pem 和 der 格式可以互转:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -in ca.crt -outform DER -out ca.der  # pem -&gt; der</span><br><span class="line">openssl x509 -inform der -in ca.der -out ca.pem   # der -&gt; pem</span><br></pre></td></tr></table></figure>
<p><strong>pem 格式</strong>：经过加密的文本文件，一般有下面几种开头结尾：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br><span class="line">	or:</span><br><span class="line">-----BEGIN CERTIFICATE REQUEST-----</span><br><span class="line">-----END CERTIFICATE REQUEST-----</span><br><span class="line">	or:</span><br><span class="line">----BEGIN CERTIFICATE-----</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>
<p><strong>der 格式</strong>: 经过加密的二进制文件。</p>
<p><strong>如何查看证书中有什么</strong><br>证书中含有 申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。如查看百度证书详细信息。</p>
<p>a) 先下载百度证书<br>火狐浏览器访问 <a href="https://www.baidu.com/">https://www.baidu.com/</a>, 点击左上角绿色小锁，点击向右箭头，点击更多信息，点击查看证书，点击详细信息，点击导出。即可导出百度的证书 baiducom.crt</p>
<p>b) 命令查看证书详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -noout -text -in baiducom.crt</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-25c41f46d905aae8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令查看证书.png"></p>
<p>详细信息中，有一个字段： <strong>X509v3 Basic Constraints: CA: FALSE</strong><br>该字段指出该证书是否是 CA 证书，还是一般性的非 CA 证书。详细描述见 <a href="https://www.rfc-editor.org/rfc/rfc5280.txt">RFC5280#section-4.2.1.9</a>，同时 RFC5280 也详细描述证书工作方式等。</p>
<h5 id="2-8-SSL-TLS-和-OpenSSL-mbedTLS-是什么关系"><a href="#2-8-SSL-TLS-和-OpenSSL-mbedTLS-是什么关系" class="headerlink" title="2.8 SSL/TLS 和 OpenSSL, mbedTLS 是什么关系"></a>2.8 SSL/TLS 和 OpenSSL, mbedTLS 是什么关系</h5><p>SSL/TLS 是一种工作原理，OpenSSL 和 mbedTLS 是 SSL/TLS 的具体实现，很类似于 TCP/IP 协议和 socket 之间的关系。</p>
<h4 id="三-本地生成-SSL-相关文件"><a href="#三-本地生成-SSL-相关文件" class="headerlink" title="三: 本地生成 SSL 相关文件"></a>三: 本地生成 SSL 相关文件</h4><h5 id="3-1-证书生成脚本"><a href="#3-1-证书生成脚本" class="headerlink" title="3.1 证书生成脚本"></a>3.1 证书生成脚本</h5><p>我们自己本地使用 makefile.sh 脚本建立一个CA (ca.crt + ca.key)，用这个 CA 给 server 和 client 分别颁发证书。</p>
<p><strong>makefile.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   notice, this list of conditions and the following disclaimer <span class="keyword">in</span> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> * Neither the name of the axTLS project nor the names of its</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   contributors may be used to endorse or promote products derived</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   from this software without specific prior written permission.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">&quot;AS IS&quot;</span> AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Generate the certificates and keys <span class="keyword">for</span> testing.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bash">PROJECT_NAME=<span class="string">&quot;TLS Project&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Generate the openssl configuration files.</span></span><br><span class="line">cat &gt; ca_cert.conf &lt;&lt; EOF  </span><br><span class="line">[ req ]</span><br><span class="line">distinguished_name     = req_distinguished_name</span><br><span class="line">prompt                 = no</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line"> O                      = $PROJECT_NAME Dodgy Certificate Authority</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; server_cert.conf &lt;&lt; EOF  </span><br><span class="line">[ req ]</span><br><span class="line">distinguished_name     = req_distinguished_name</span><br><span class="line">prompt                 = no</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line"> O                      = $PROJECT_NAME</span><br><span class="line"> CN                     = 192.168.111.100</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; client_cert.conf &lt;&lt; EOF  </span><br><span class="line">[ req ]</span><br><span class="line">distinguished_name     = req_distinguished_name</span><br><span class="line">prompt                 = no</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line"> O                      = $PROJECT_NAME Device Certificate</span><br><span class="line"> CN                     = 192.168.111.101</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">mkdir ca</span><br><span class="line">mkdir server</span><br><span class="line">mkdir client</span><br><span class="line">mkdir certDER</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> private key generation</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line">openssl genrsa -out client.key 2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cert requests</span></span><br><span class="line">openssl req -out ca.req -key ca.key -new \</span><br><span class="line">            -config ./ca_cert.conf</span><br><span class="line">openssl req -out server.req -key server.key -new \</span><br><span class="line">            -config ./server_cert.conf </span><br><span class="line">openssl req -out client.req -key client.key -new \</span><br><span class="line">            -config ./client_cert.conf </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> generate the actual certs.</span></span><br><span class="line">openssl x509 -req -in ca.req -out ca.crt \</span><br><span class="line">            -sha1 -days 5000 -signkey ca.key</span><br><span class="line">openssl x509 -req -in server.req -out server.crt \</span><br><span class="line">            -sha1 -CAcreateserial -days 5000 \</span><br><span class="line">            -CA ca.crt -CAkey ca.key</span><br><span class="line">openssl x509 -req -in client.req -out client.crt \</span><br><span class="line">            -sha1 -CAcreateserial -days 5000 \</span><br><span class="line">            -CA ca.crt -CAkey ca.key</span><br><span class="line"> </span><br><span class="line">openssl x509 -in ca.crt -outform DER -out ca.der</span><br><span class="line">openssl x509 -in server.crt -outform DER -out server.der</span><br><span class="line">openssl x509 -in client.crt -outform DER -out client.der</span><br><span class="line"></span><br><span class="line">mv ca.crt ca.key ca/</span><br><span class="line">mv server.crt server.key server/</span><br><span class="line">mv client.crt client.key client/</span><br><span class="line"></span><br><span class="line">mv ca.der server.der client.der certDER/</span><br><span class="line"></span><br><span class="line">rm *.conf</span><br><span class="line">rm *.req</span><br><span class="line">rm *.srl </span><br></pre></td></tr></table></figure>


<p>将上述代码保存为 <strong>makefile.sh</strong><br>做如下修改，终端执行。</p>
<p><strong>- 修改 CN 域中 IP 地址为你主机/设备的 IP 地址</strong><br><strong>- [可选] 加密位数 2048 修改为你需要的加密位数</strong></p>
<p>将会看到：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6a51b4e7ae18deb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="脚本自动生成证书.png"></p>
<p>ca目录：保存 ca 的私钥 ca.key 和证书 ca.crt<br>certDER目录:将证书保存为二进制文件 ca.der, client.der, server.der<br>client目录: client.crt, client.key<br>server目录:server.crt, server.key</p>
<h4 id="3-2-删除脚本"><a href="#3-2-删除脚本" class="headerlink" title="3.2 删除脚本"></a>3.2 删除脚本</h4><p><strong>rmfile.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm ca/ -rf</span><br><span class="line">rm certDER/ -rf</span><br><span class="line">rm client/ -rf</span><br><span class="line">rm server/ -rf</span><br></pre></td></tr></table></figure>
<p>将上述代码保存为 rmfile.sh, 终端执行，将会删除产生过的目录和文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./rmfile.sh</span><br></pre></td></tr></table></figure>


<h4 id="3-3-CA-校验证书测试"><a href="#3-3-CA-校验证书测试" class="headerlink" title="3.3 CA 校验证书测试"></a>3.3 CA 校验证书测试</h4><p>我们可在本地使用 CA 证书来分别校验由自己颁发的服务器证书 server.crt 和客户端证书 client.crt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">openssl verify -CAfile ca/ca.crt server/server.crt</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">openssl verify -CAfile ca/ca.crt client/client.crt</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-423fe93728e20aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="校验证书.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>双向认证</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统签名位置及命令</title>
    <url>/2021/09/15/Android%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%E4%BD%8D%E7%BD%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><p>app 需要使用系统的权限 在 AndroidManifest.xml 中声明了系统全下申明了系统权限android:sharedUserId=”android.uid.system”</p>
<h4 id="2-签名文件存放位置"><a href="#2-签名文件存放位置" class="headerlink" title="2.签名文件存放位置"></a>2.签名文件存放位置</h4><p>找到平台签名文件“platform.pk8”和“platform.x509.pem”<br> 文件位置 android/build/target/product/security/</p>
<h4 id="3-签名工具位置"><a href="#3-签名工具位置" class="headerlink" title="3.签名工具位置"></a>3.签名工具位置</h4><p>签名工具“signapk.jar”<br>位置：android/prebuilts/sdk/tools/lib</p>
<h4 id="4-使用签名文件"><a href="#4-使用签名文件" class="headerlink" title="4.使用签名文件"></a>4.使用签名文件</h4><p>签名证书“platform.pk8 ”“platform.x509.pem ”，签名工具“signapk.jar ”放置在同一个文件夹；</p>
<h4 id="5-执行命令"><a href="#5-执行命令" class="headerlink" title="5.执行命令"></a>5.执行命令</h4><p>java -jar signapk.jar platform.x509.pem platform.pk8 nfcbd1.4_30s.apk nfcbd1.4_30s_signed.apk</p>
<p>或者直接在Ubuntu 编译环境执行 java -jar out/host/linux-x86/framework/signapk.jar build/target/product/security/platform.x509.pem build/target/product/security/platform.pk8 input.apk output.apk</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title>addr2line, objdump, ndk-stack使用方法</title>
    <url>/2021/09/15/addr2line-objdump-ndk-stack%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-tombstone日志"><a href="#1-tombstone日志" class="headerlink" title="1.tombstone日志"></a>1.tombstone日志</h4><p>带有符号表的so库放在：</p>
<p>out/target/product/msmnile_gvmq/obj/SHARED_LIBRARIES/<module>_intermediates/LINKED</module></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#00 pc 00000000003bce1c  /system/lib64/libbluetooth.so (bluetooth::Uuid::ToString() const+12)</span><br><span class="line">#01 pc 0000000000180388  /system/lib64/libbluetooth.so (checkIOSDevice(unsigned int, bluetooth::Uuid*) [clone .cfi]+136)</span><br><span class="line">#02 pc 000000000018442c  /system/lib64/libbluetooth.so (btif_dm_search_services_evt(unsigned short, char*) [clone .cfi]+1388)</span><br><span class="line">#03 pc 000000000017cfbc  /system/lib64/libbluetooth.so (bt_jni_msg_ready(void*) [clone .cfi]+136)</span><br><span class="line">#04 pc 0000000000096908  /system/lib64/libchrome.so (base::debug::TaskAnnotator::RunTask(char const*, base::PendingTask*)+248)</span><br><span class="line">#05 pc 00000000000afd14  /system/lib64/libchrome.so (base::MessageLoop::RunTask(base::PendingTask*)+416)</span><br><span class="line">#06 pc 00000000000affbc  /system/lib64/libchrome.so (base::MessageLoop::DeferOrRunPendingTask(base::PendingTask)+52)</span><br><span class="line">#07 pc 00000000000b03f8  /system/lib64/libchrome.so (base::MessageLoop::DoWork()+380)</span><br><span class="line">#08 pc 00000000000b1790  /system/lib64/libchrome.so (base::MessagePumpDefault::Run(base::MessagePump::Delegate*)+180)</span><br><span class="line">#09 pc 00000000000afa08  /system/lib64/libchrome.so (base::MessageLoop::RunHandler()+112)</span><br><span class="line">#10 pc 00000000000cc60c  /system/lib64/libchrome.so (base::RunLoop::Run()+136)</span><br><span class="line">#11 pc 000000000017d54c  /system/lib64/libbluetooth.so (run_message_loop(void*) [clone .cfi]+348)</span><br><span class="line">#12 pc 00000000002b6164  /system/lib64/libbluetooth.so (work_queue_read_cb(void*) [clone .cfi]+120)</span><br><span class="line">#13 pc 00000000002b460c  /system/lib64/libbluetooth.so (run_reactor(reactor_t*, int) [clone .cfi]+416)</span><br><span class="line">#14 pc 00000000002b4440  /system/lib64/libbluetooth.so (reactor_start(reactor_t*) [clone .cfi]+84)</span><br><span class="line">#15 pc 00000000002b5f14  /system/lib64/libbluetooth.so (run_thread(void*) [clone .cfi]+188)</span><br><span class="line">#16 pc 00000000000819b4  /system/lib64/libc.so (__pthread_start(void*)+36)</span><br><span class="line">#17 pc 0000000000023478  /system/lib64/libc.so (__start_thread+68)</span><br></pre></td></tr></table></figure>


<h4 id="2-分析工具概要介绍"><a href="#2-分析工具概要介绍" class="headerlink" title="2.分析工具概要介绍"></a>2.分析工具概要介绍</h4><ul>
<li>addr2line：用来分析单个pc地址对应的源码行数，比如示例log中的第13行中的#00 pc 00000000003bce1c，00000000003bce1c就是crash时pc调用的堆栈地址，用这个地址就可以分析出对应在源码中的行数；</li>
</ul>
<ul>
<li>objdump：用来把相应的so变成汇编语言的asm文件，然后根据地址信息（比如00000000003bce1c）就可以找到更加详细的相关函数信息；</li>
<li>ndk-stack：用来把log信息全部翻译成更加详细的带源码行数信息的log，相当于是在整个crash堆栈信息都执行addr2line命令。</li>
</ul>
<h4 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h4><h5 id="3-1-addr2line"><a href="#3-1-addr2line" class="headerlink" title="3.1 addr2line"></a>3.1 addr2line</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jieou@gxatek-fw-no:/work/jieou/gxa_code/lagvm_p/LINUX/android$ ./prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-addr2line -C -f -e libbluetooth.so 3bce1c</span><br><span class="line">bluetooth::Uuid::ToString() const</span><br><span class="line">system/bt/types/bluetooth/uuid.cc:169</span><br></pre></td></tr></table></figure>


<h5 id="3-2-objdump"><a href="#3-2-objdump" class="headerlink" title="3.2 objdump"></a>3.2 objdump</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-androidkernel-objdump -S libbluetooth.so &gt; libbluetooth.asm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">./prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-androidkernel-objdump -d libbluetooth.so &gt; libbluetooth.txt</span><br></pre></td></tr></table></figure>


<h5 id="3-3-ndk-stack"><a href="#3-3-ndk-stack" class="headerlink" title="3.3 ndk-stack"></a>3.3 ndk-stack</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在Android根目录</span></span><br><span class="line">jieou@gxatek-fw-no:/work/jieou/gxa_code/lagvm_p/LINUX/android$ ndk-stack -sym out/target/product/msmnile_gvmq/obj/SHARED_LIBRARIES -dump out/target/product/msmnile_gvmq/obj/SHARED_LIBRARIES/libbluetooth_intermediates/LINKED/tombstone_00.txt &gt; 1.txt</span><br></pre></td></tr></table></figure>


<h4 id="4-分析过程"><a href="#4-分析过程" class="headerlink" title="4.分析过程"></a>4.分析过程</h4><ul>
<li>拿着tombstone文件首先找到带有符号表so库</li>
<li>使用addr2line对一个或者多个地址进行输出调用栈行数和文件名字</li>
<li>对着代码查看错误逻辑或者是否附近有错误log打出</li>
<li>如果没有log日志，使用objdump反编译so库，然后查看对应地址的寄存器操作情况</li>
</ul>
<h4 id="5-其他工具"><a href="#5-其他工具" class="headerlink" title="5.其他工具"></a>5.其他工具</h4><h5 id="5-1-debuggrep"><a href="#5-1-debuggrep" class="headerlink" title="5.1 debuggrep"></a>5.1 debuggrep</h5><p>触发debuggerd进行相应的dump操作，其中参数<code>-b</code>表示在控制台中输出backtrace，参数tid表示的是需要dump的进程或者线程id。</p>
<p>通过debuggerd -b [pid]，可输出Native进程的调用栈，这些信息是通过解析/proc/[pid]/maps而来的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">debuggrep -b pid/tid</span><br></pre></td></tr></table></figure>


<h5 id="5-2-调用栈"><a href="#5-2-调用栈" class="headerlink" title="5.2 调用栈"></a>5.2 调用栈</h5><p>查看调用栈</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/pid/stack</span><br></pre></td></tr></table></figure>


<h5 id="5-3-打印trace文件"><a href="#5-3-打印trace文件" class="headerlink" title="5.3 打印trace文件"></a>5.3 打印trace文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">echo 1 &gt; /d/tracing/tracing_on</span><br><span class="line">echo 1 &gt; /d/tracing/events/binder/enable</span><br><span class="line">cat /d/tracing/trace_pipe</span><br></pre></td></tr></table></figure>




<p><strong>参考文档</strong></p>
<ol>
<li>《ndk_stack_log.txt》</li>
<li>《libbluetooth.asm》</li>
<li><a href="http://gityuan.com/2016/06/15/android-debuggerd/">《debuggerd守护进程》</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>优化开机动画-系统优化</title>
    <url>/2021/09/17/%E4%BC%98%E5%8C%96%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB-%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="1-谁拉起了开机动画"><a href="#1-谁拉起了开机动画" class="headerlink" title="1. 谁拉起了开机动画"></a>1. 谁拉起了开机动画</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-547cf04fc0fce896.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BootAnimation启动时序.png"></p>
<p>​    在系统上电后，通过内置的rom_code将uboot映像从flash中加载到内存中运行，之后跳转到uboot执行，做一些硬件外设参数的初始化工作，然后从flash中加载kernel到内存中运行并跳转到kernel执行。</p>
<p>​    init进程是kernel的第一个进程，也是Android系统的第一个进程。而跟开机动画有关的，主要是init中做的两件事，一件事是启动surfaceflinger进程,开机动画的启动就是在这里触发；另外一件事是启动zygote进程，zygote进程起来后就fork出了system_server，system_server主要是启动系统服务，如AMS,WMS,PMS等。等待一些关键服务ready后，就开始加载launcher，launcher加载好就触发结束开机动画的操作，从而进入到launcher界面。</p>
<p>​    开机动画是在surfaceflinger中触发,而surfaceflinger进程是在init.rc中启动的，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br></pre></td></tr></table></figure>
<p>​    需要注意的是高版本的Android上，如AndroidP，surfaceflinger进程并不是直接在init.rc文件中启动的，而是通过Android.bp文件去包含启动surfaceflinger.rc文件，然后在该文件中再去启动surfaceflinger:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> frameworks/native/services/surfaceflinger/Android.bp</span></span><br><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;surfaceflinger&quot;,</span><br><span class="line">    defaults: [&quot;surfaceflinger_defaults&quot;],</span><br><span class="line">    init_rc: [&quot;surfaceflinger.rc&quot;],  # 编译的时候将启动脚本放在surfaceflinger.rc</span><br><span class="line">    srcs: [&quot;main_surfaceflinger.cpp&quot;], # 启动之后，会调用main_surfaceflinger的main方法</span><br><span class="line">    whole_static_libs: [</span><br><span class="line">        &quot;libsigchain&quot;,</span><br><span class="line">    ],</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> frameworks/native/services/surfaceflinger/surfaceflinger.rc</span></span><br><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc readproc</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/stune/foreground/tasks</span><br><span class="line">    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0</span><br><span class="line">    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0</span><br><span class="line">    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> system/etc/init/surfaceflinger.rc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统打出来之后，rc文件会放在system/etc/init目录，init进程启动的时候，会自动解析该目录的rc文件，并且启动对应的服务。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = <span class="keyword">new</span> SurfaceFlinger();</span><br><span class="line">    ...</span><br><span class="line">    flinger-&gt;init();</span><br><span class="line">    ...</span><br><span class="line">    flinger-&gt;run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Inform native graphics APIs whether the present timestamp is supported:</span></span><br><span class="line">    <span class="comment">// 创建一个StartPropertySetThread实例，并且调用Start()启动开机动画</span></span><br><span class="line">    <span class="keyword">if</span> (getHwComposer().hasCapability(</span><br><span class="line">            HWC2::Capability::PresentFenceIsNotReliable)) &#123;</span><br><span class="line">        mStartPropertySetThread = <span class="keyword">new</span> StartPropertySetThread(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mStartPropertySetThread = <span class="keyword">new</span> StartPropertySetThread(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartPropertySetThread-&gt;Start() != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Run StartPropertySetThread failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/StartPropertySetThread.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line">StartPropertySetThread::StartPropertySetThread(<span class="keyword">bool</span> timestampPropertyValue):</span><br><span class="line">        Thread(<span class="literal">false</span>), mTimestampPropertyValue(timestampPropertyValue) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">StartPropertySetThread::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> run(<span class="string">&quot;SurfaceFlinger::StartPropertySetThread&quot;</span>, PRIORITY_NORMAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StartPropertySetThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set property service.sf.present_timestamp, consumer need check its readiness</span></span><br><span class="line">    property_set(kTimestampProperty, mTimestampPropertyValue ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="comment">// Clear BootAnimation exit flag</span></span><br><span class="line">    <span class="comment">// 清楚bootanimation标志位，当为1的时候，退出开机动画</span></span><br><span class="line">    property_set(<span class="string">&quot;service.bootanim.exit&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="comment">// Start BootAnimation if not started</span></span><br><span class="line">    <span class="comment">// 启动开机动画service.</span></span><br><span class="line">    property_set(<span class="string">&quot;ctl.start&quot;</span>, <span class="string">&quot;bootanim&quot;</span>);</span><br><span class="line">    <span class="comment">// Exit immediately</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="2-Bootanimation实现流程"><a href="#2-Bootanimation实现流程" class="headerlink" title="2. Bootanimation实现流程"></a>2. Bootanimation实现流程</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// frameworks/base/cmds/bootanimation/bootanim.rc</span><br><span class="line">service bootanim /system/bin/bootanimation</span><br><span class="line">    class core animation</span><br><span class="line">    user graphics</span><br><span class="line">    group graphics audio</span><br><span class="line">    disabled</span><br><span class="line">    oneshot</span><br><span class="line">    writepid /dev/stune/top-app/tasks</span><br></pre></td></tr></table></figure>
<p>通过SurfaceFlinger启动开机动画进程。调用bootanimation_main的main方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># frameworks/base/cmds/bootanimation/bootanimation_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, ANDROID_PRIORITY_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> noBootAnimation = bootAnimationDisabled();</span><br><span class="line">    ALOGI_IF(noBootAnimation,  <span class="string">&quot;boot animation disabled&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!noBootAnimation) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">        waitForSurfaceFlinger();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the boot animation object</span></span><br><span class="line">        sp&lt;BootAnimation&gt; boot = <span class="keyword">new</span> BootAnimation(<span class="keyword">new</span> AudioAnimationCallbacks());</span><br><span class="line">        ALOGV(<span class="string">&quot;Boot animation set up. Joining pool.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGV(<span class="string">&quot;Boot animation exit&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new了一个BootAnimation实例，然后创建了一个binder线程池，用于显示动画时，与surfaceflinger进程通信用。接下来看看BootAnimation的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/bootanimation/BootAnimation.cpp</span></span><br><span class="line">BootAnimation::BootAnimation(sp&lt;Callbacks&gt; callbacks)</span><br><span class="line">        : Thread(<span class="literal">false</span>), mClockEnabled(<span class="literal">true</span>), mTimeIsAccurate(<span class="literal">false</span>),</span><br><span class="line">        mTimeFormat12Hour(<span class="literal">false</span>), mTimeCheckThread(<span class="literal">NULL</span>), mCallbacks(callbacks) &#123;</span><br><span class="line">    <span class="comment">// 创建一个mSession与SurfaceFlinger通信</span></span><br><span class="line">    mSession = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> powerCtl = android::base::GetProperty(<span class="string">&quot;sys.powerctl&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (powerCtl.empty()) &#123;</span><br><span class="line">        mShuttingDown = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mShuttingDown = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了SurfaceComposerClient，用于与surfaceflinger通讯。接下来就到了onFirstRef:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void BootAnimation::onFirstRef() &#123;</span><br><span class="line">    status_t err = mSession-&gt;linkToComposerDeath(this);</span><br><span class="line">    ALOGE_IF(err, &quot;linkToComposerDeath failed (%s) &quot;, strerror(-err));</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        run(&quot;BootAnimation&quot;, PRIORITY_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先注册surfaceflinger的死亡消息通知书<code>linkToComposerDeath</code>，只要surfaceflinger挂掉了，bootanimation进程就会收到通知，从而执行如下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void BootAnimation::binderDied(const wp&lt;IBinder&gt;&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    // woah, surfaceflinger died!</span><br><span class="line">    ALOGD(&quot;SurfaceFlinger died, exiting...&quot;);</span><br><span class="line"></span><br><span class="line">    // calling requestExit() is not enough here because the Surface code</span><br><span class="line">    // might be blocked on a condition variable that will never be updated.</span><br><span class="line">    kill( getpid(), SIGKILL );</span><br><span class="line">    requestExit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接退出，等待surfaceflinger的下一次重启，如果还有来生的话。</p>
<p>onFirstRef在创建了死亡通知书后，还做了一件事，那就是run bootanimation,个中细节不在这里列出，bootanimation重写了readyToRun和threadLoop，我们直接看threadLoop：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BootAnimation::threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> r;</span><br><span class="line">    <span class="comment">// We have no bootanimation file, so we use the stock android logo</span></span><br><span class="line">    <span class="comment">// animation.</span></span><br><span class="line">    <span class="comment">// 如果没有自定义的开机动画包，就是用Android原生的logo做开机动画</span></span><br><span class="line">    <span class="keyword">if</span> (mZipFileName.isEmpty()) &#123;</span><br><span class="line">        r = android();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = movie();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);</span><br><span class="line">    eglDestroyContext(mDisplay, mContext);</span><br><span class="line">    eglDestroySurface(mDisplay, mSurface);</span><br><span class="line">    mFlingerSurface.clear();</span><br><span class="line">    mFlingerSurfaceControl.clear();</span><br><span class="line">    eglTerminate(mDisplay);</span><br><span class="line">    eglReleaseThread();</span><br><span class="line">    IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BootAnimation::movie</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加载该机动画资源</span></span><br><span class="line">    <span class="comment">// 读取zip包，并且解析Desc描述文件，将每部分的配置解析出来保存在animation中，后面播放的时候根据这个配置文件播放开机动画</span></span><br><span class="line">    Animation* animation = loadAnimation(mZipFileName);</span><br><span class="line">    <span class="keyword">if</span> (animation == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">	<span class="comment">// 播放开机动画</span></span><br><span class="line">    playAnimation(*animation);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 释放animation对象</span></span><br><span class="line">    releaseAnimation(animation);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BootAnimation::playAnimation</span><span class="params">(<span class="keyword">const</span> Animation&amp; animation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获得fps和动画宽高</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> pcount = animation.parts.size();</span><br><span class="line">    <span class="keyword">nsecs_t</span> frameDuration = s2ns(<span class="number">1</span>) / animation.fps;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> animationX = (mWidth - animation.width) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> animationY = (mHeight - animation.height) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出每一个part一帧一帧播放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;pcount ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Animation::Part&amp; <span class="title">part</span><span class="params">(animation.parts[i])</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> fcount = part.frames.size();</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle animation package</span></span><br><span class="line">        <span class="keyword">if</span> (part.animation != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            playAnimation(*part.animation);</span><br><span class="line">            <span class="keyword">if</span> (exitPending())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//to next part</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r=<span class="number">0</span> ; !part.count || r&lt;part.count ; r++) &#123;</span><br><span class="line">            	......</span><br><span class="line">                <span class="comment">// 每一帧播完之后都检测一次是否退出播放</span></span><br><span class="line">                checkExit();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BootAnimation::checkExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Allow surface flinger to gracefully request shutdown</span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="comment">// EXIT_PROP_NAME = &quot;service.bootanim.exit&quot;</span></span><br><span class="line">    property_get(EXIT_PROP_NAME, value, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> exitnow = atoi(value);</span><br><span class="line">    <span class="comment">// 如果属性值为1，就请求退出开机动画</span></span><br><span class="line">    <span class="keyword">if</span> (exitnow) &#123;</span><br><span class="line">        requestExit();</span><br><span class="line">        mCallbacks-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，从每一帧开机动画播完之后，都会检测<code>service.bootanim.exit</code>的值，当属性值为1的时候，则开机动画会requestExit, 从而结束开机动画。那是谁给<code>service.bootanim.exit</code>的属性值设置为1呢？</p>
<h4 id="3-bootanimation的结束"><a href="#3-bootanimation的结束" class="headerlink" title="3.bootanimation的结束"></a>3.bootanimation的结束</h4><p>init启动zygote进程之后，由zygote孵化出了system_server，然后system_server启动了各种各种的系统所需的服务，其中就有AMS，AMS启动并ready后，会执行startHomeActivityLocked：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback, TimingsTraceLog traceLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    startHomeActivityLocked(currentUserId, <span class="string">&quot;systemReady&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Intent intent = getHomeIntent();</span><br><span class="line">    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    <span class="keyword">final</span> String myReason = reason + <span class="string">&quot;:&quot;</span> + userId + <span class="string">&quot;:&quot;</span> + resolvedUserId;</span><br><span class="line">    mActivityStartController.startHomeActivity(intent, aInfo, myReason);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>launcher在这里开始加载启动，在launcher的主线程处于空闲时，就会向ActivityManagerService发送一个activityIdle的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>, <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过activityIdleInternalLocked获取到ActivityRecord实例，我们看看具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//Slog.i(TAG, &quot;IDLE: mBooted=&quot; + mBooted + &quot;, fromTimeout=&quot; + fromTimeout);</span></span><br><span class="line">    <span class="keyword">if</span> (isFocusedStack(r.getStack()) || fromTimeout) &#123;</span><br><span class="line">        booting = checkFinishBootingLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会检测开机是否结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFinishBootingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> booting = mService.mBooting;</span><br><span class="line">    <span class="keyword">boolean</span> enableScreen = <span class="keyword">false</span>;</span><br><span class="line">    mService.mBooting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mService.mBooted) &#123;</span><br><span class="line">        mService.mBooted = <span class="keyword">true</span>;</span><br><span class="line">        enableScreen = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">if</span> (booting || enableScreen) &#123;</span><br><span class="line">        mService.postFinishBooting(booting, enableScreen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> booting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会直接进入到postFinishBooting方法中执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AMS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postFinishBooting</span><span class="params">(<span class="keyword">boolean</span> finishBooting, <span class="keyword">boolean</span> enableScreen)</span> </span>&#123;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(FINISH_BOOTING_MSG,</span><br><span class="line">            finishBooting ? <span class="number">1</span> : <span class="number">0</span>, enableScreen ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接发一条消息<code>FINISH_BOOTING_MSG</code>，我们看看具体handler的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> FINISH_BOOTING_MSG: &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.arg1 != <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;FinishBooting&quot;</span>);</span><br><span class="line">        finishBooting();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.arg2 != <span class="number">0</span>) &#123;</span><br><span class="line">        enableScreenAfterBoot();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>最终执行到了enableScreenAfterBoot方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enableScreenAfterBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mWindowManager.enableScreenAfterBoot();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了WMS的方法<code>enableScreenAfterBoot</code>，我们跳入看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableScreenAfterBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    performEnableScreen();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performEnableScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mBootAnimationStopped) &#123;</span><br><span class="line">        Trace.asyncTraceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;Stop bootanim&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// stop boot animation</span></span><br><span class="line">        <span class="comment">// formerly we would just kill the process, but we now ask it to exit so it</span></span><br><span class="line">        <span class="comment">// can choose where to stop the animation.</span></span><br><span class="line">        SystemProperties.set(<span class="string">&quot;service.bootanim.exit&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        mBootAnimationStopped = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里，最终通过设置<code>service.bootanim.exit</code>的值，stop掉了开机动画，接着来的就是发出了开机广播。</p>
<h4 id="4-开机动画优化"><a href="#4-开机动画优化" class="headerlink" title="4.开机动画优化"></a>4.开机动画优化</h4><p>由于当前项目的开机动画由QNX来控制，因此，我们尽量减轻Android开机动画的播放就行。</p>
<h5 id="4-1-分析描述文件"><a href="#4-1-分析描述文件" class="headerlink" title="4.1 分析描述文件"></a>4.1 分析描述文件</h5><p>优化前的配置文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">832 520 30</span><br><span class="line">c 1 30 part0</span><br><span class="line">c 1 0 part1</span><br><span class="line">c 0 0 part2</span><br><span class="line">c 1 30 part3</span><br><span class="line">c 1 0 part4</span><br><span class="line">c 1 0 part5</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一行的三个数字分别表示开机动画在屏幕中的显示宽度、高度以及帧速（fps）。</p>
</li>
<li><p>剩余的每一行都用来描述一个动画片断，<code>p</code> 这个flag表示某一个part的图片的处理方式,bootanimation 程序在处理某part的图片时会参考这个标志.P表示bootanimation可以随时退出当处理完一张图片后,如果bootanimation可以退出. ”C” 则表示必须把这部分的图片处理完毕才可以退出.事实上这个标识只要不为C, 则其行为完全一致.</p>
</li>
<li><p>“1”这个flag表示这part的图片需要循环处理多少次. 1表示处理循环处理一次.”0” 表示无限循环.</p>
</li>
<li><p>“0” 这个flag 表示播放完这部分所有图片后需要pause多久时间。”0” 表示不需要pause。“part0”表示动画的第一部分内容。“part1” 表示动画的第二部分内容。</p>
</li>
</ul>
<p>开始处理新的一帧, 如果这部分part的处理标识不是”c”则可以退出.否则不能退出.<br>处理完一次循环后, 如果这部分part的处理标识是”c”,并且这部分是无限循环,则可以退出.如果不是无限循环则不能退出, 需要完全处理完这部分的图片才可能退出.</p>
<p>优化后的配置文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">832 520 30</span><br><span class="line">p 1 0 part1</span><br></pre></td></tr></table></figure>


<p>然后将资源包放在车机：/system/media/bootanimation.zip</p>
<p>原生的开机动画路径：packages/services/Car/car_product/bootanimations/bootanimation.zip</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>优化开机动画主要原理是开机动画会比较消耗资源，在开机启动服务期间减少开机动画对CPU的消耗，从侧面就提升了Android的启动耗时。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统优化</tag>
        <tag>开机动画</tag>
      </tags>
  </entry>
  <entry>
    <title>双向认证的两种实现方式</title>
    <url>/2021/09/13/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="1-构建Retrofit"><a href="#1-构建Retrofit" class="headerlink" title="1.构建Retrofit"></a>1.构建Retrofit</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = builder.baseurl(baseUrl)</span><br><span class="line">         .sslSocketFactory(SSLHelper.getSSLCertifcation(path, </span><br><span class="line">              StateConfig.getInstance().getCertServerPath(),</span><br><span class="line">              StateConfig.getInstance().getPassword()), <span class="keyword">new</span> 	</span><br><span class="line">                           HttpsUtil.UnSafeTrustManager())</span><br><span class="line">         .hostnameVerifier(<span class="keyword">new</span> HttpsUtil.UnSafeHostnameVerifier())</span><br><span class="line">         .build();</span><br></pre></td></tr></table></figure>
<p>在构建Retrofit实例的时候，传入sslSocketFactory和trustManager</p>
<h4 id="2-PKCS-12格式证书-jks-构建sslSocketFactory"><a href="#2-PKCS-12格式证书-jks-构建sslSocketFactory" class="headerlink" title="2.PKCS#12格式证书(.jks)构建sslSocketFactory"></a>2.PKCS#12格式证书(.jks)构建sslSocketFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SSLSocketFactory <span class="title">getSSLCertifcation</span><span class="params">(String certPath, String certServerPath, String password)</span> </span>&#123;</span><br><span class="line">        SSLSocketFactory sslSocketFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//计算证书密码</span></span><br><span class="line">            password = Utils.SHA1Algorithm(password);</span><br><span class="line">            <span class="comment">// 服务器端需要验证的客户端证书，其实就是客户端的keystore</span></span><br><span class="line">            KeyStore keyStore = KeyStore.getInstance(Constants.CLIENT_KEYSTORE_TYPE);</span><br><span class="line">            <span class="comment">// 客户端信任的服务器端证书</span></span><br><span class="line">            KeyStore trustStore = KeyStore.getInstance(Constants.SERVER_KEYSTORE_TYPE);</span><br><span class="line"></span><br><span class="line">            InputStream ksIn = <span class="keyword">null</span>;</span><br><span class="line">            InputStream tsIn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//读取证书</span></span><br><span class="line">                ksIn = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(certPath));</span><br><span class="line">                tsIn = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(certServerPath));</span><br><span class="line">                <span class="comment">//ksIn = context.getAssets().open(&quot;Data_Secret_CA.pfx&quot;);</span></span><br><span class="line">                <span class="comment">//tsIn = context.getAssets().open(&quot;certCA.bks&quot;);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//加载证书</span></span><br><span class="line">                keyStore.load(ksIn, password.toCharArray());</span><br><span class="line">                trustStore.load(tsIn, Constants.TRUSTSTORE_BKS_PASSWORD.toCharArray());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LogUtils.e(TAG, <span class="string">&quot;please ensure the path of certs contain the certificates !&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ksIn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ksIn.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tsIn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tsIn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(Constants.CERTIFICATE_STANDARD);</span><br><span class="line">            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(Constants.CERTIFICATE_STANDARD);</span><br><span class="line">            trustManagerFactory.init(trustStore);</span><br><span class="line">            keyManagerFactory.init(keyStore, password.toCharArray());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化SSLContext</span></span><br><span class="line">            SSLContext sslContext = SSLContext.getInstance(Constants.PROTOCOL_TYPE);</span><br><span class="line">            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line"></span><br><span class="line">            sslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyStoreException | IOException | NoSuchAlgorithmException | UnrecoverableKeyException |</span><br><span class="line">                KeyManagementException | DigestException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sslSocketFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-PKCS-8格式证书构建sslSocketFactory"><a href="#3-PKCS-8格式证书构建sslSocketFactory" class="headerlink" title="3.PKCS#8格式证书构建sslSocketFactory"></a>3.PKCS#8格式证书构建sslSocketFactory</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GACPemTlsDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String VEHICLE_CRT_PATH = <span class="string">&quot;D:\\gac_xinghe\\vehicleCA.crt&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String VEHICLE_KEY_PATH = <span class="string">&quot;D:\\gac_xinghe\\vehicleCA.key&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String VEHICLE_KEY_PWD = <span class="string">&quot;53A070BD720A2D9ED38EDA72C3EBE854A2AEE92B&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String ROOT_CRT_PATH = <span class="string">&quot;D:\\gac_xinghe\\rootCA.crt&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String API_URL = <span class="string">&quot;https://xx.xx.com&quot;</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, KeyManagementException, UnrecoverableKeyException, InvalidKeyException, InvalidKeySpecException </span>&#123;</span><br><span class="line">		System.setProperty(<span class="string">&quot;javax.net.debug&quot;</span>, <span class="string">&quot;ssl&quot;</span>);<span class="comment">//输出SSL通讯信息</span></span><br><span class="line">		<span class="comment">/* 读取证书证书 */</span></span><br><span class="line">		String vehicleCrt = readVehicleStr(VEHICLE_CRT_PATH);</span><br><span class="line">		Map&lt;String, String&gt; rootMap = readRootCA(ROOT_CRT_PATH);</span><br><span class="line">		String root1 = rootMap.get(<span class="string">&quot;root1&quot;</span>);</span><br><span class="line">		String root2 = rootMap.get(<span class="string">&quot;root2&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*构造客户端证书的KeyStore*/</span></span><br><span class="line">	    <span class="keyword">char</span>[] pwd = <span class="string">&quot;123456&quot;</span>.toCharArray();	<span class="comment">//构造keyStore对象，需要设定的密码，该密码可以任意设置</span></span><br><span class="line">	    </span><br><span class="line">	    Provider bcProvider = <span class="keyword">new</span> BouncyCastleProvider();</span><br><span class="line">	    Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">	    </span><br><span class="line">	    CertificateFactory certificateFactory = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">//构造客户端证书的KeyStore对象</span></span><br><span class="line">	    KeyStore clientCertKeyStore = KeyStore.getInstance(<span class="string">&quot;BKS&quot;</span>, bcProvider);</span><br><span class="line">	    clientCertKeyStore.load(<span class="keyword">null</span>, pwd);</span><br><span class="line">        <span class="comment">//读取车端证书,公钥</span></span><br><span class="line">	    ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(Base64.decodeBase64(vehicleCrt));</span><br><span class="line">	    X509Certificate x509Certificate = (X509Certificate) certificateFactory.generateCertificate(bais);</span><br><span class="line">	    </span><br><span class="line">        <span class="comment">//定义车端证书alias</span></span><br><span class="line">        String keyAlias = <span class="string">&quot;vehicleCA&quot;</span>;</span><br><span class="line">		</span><br><span class="line">        KeyPair keyPair = getKey(VEHICLE_KEY_PWD, VEHICLE_KEY_PATH);</span><br><span class="line">        </span><br><span class="line">        Certificate[] certificates = <span class="keyword">new</span> Certificate[]&#123;x509Certificate&#125;;</span><br><span class="line">        clientCertKeyStore.setKeyEntry(keyAlias, keyPair.getPrivate(), pwd, certificates);</span><br><span class="line">        </span><br><span class="line">	    <span class="comment">//构造可信服务端证书的KeyStore对象</span></span><br><span class="line">	    KeyStore trustKeyStore = KeyStore.getInstance(<span class="string">&quot;BKS&quot;</span>, bcProvider);</span><br><span class="line">	    trustKeyStore.load(<span class="keyword">null</span>, pwd);</span><br><span class="line">	    <span class="comment">//读取根证书</span></span><br><span class="line">	    ByteArrayInputStream trust1Bais = <span class="keyword">new</span> ByteArrayInputStream(Base64.decodeBase64(root1));</span><br><span class="line">	    X509Certificate trust1X509Certificate = (X509Certificate) certificateFactory.generateCertificate(trust1Bais);</span><br><span class="line">	    trustKeyStore.setCertificateEntry(<span class="string">&quot;root1&quot;</span>, trust1X509Certificate);</span><br><span class="line">	    </span><br><span class="line">	    ByteArrayInputStream trust2Bais = <span class="keyword">new</span> ByteArrayInputStream(Base64.decodeBase64(root2));</span><br><span class="line">	    X509Certificate trust2X509Certificate = (X509Certificate) certificateFactory.generateCertificate(trust2Bais);</span><br><span class="line">	    trustKeyStore.setCertificateEntry(<span class="string">&quot;root2&quot;</span>, trust2X509Certificate);</span><br><span class="line">        </span><br><span class="line">        SSLContext sslcontext = SSLContexts.custom()</span><br><span class="line">        		.loadTrustMaterial(trustKeyStore, <span class="keyword">new</span> TrustStrategy()&#123;</span><br><span class="line">        			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        			&#125;&#125;)</span><br><span class="line">        		.loadKeyMaterial(clientCertKeyStore, pwd)</span><br><span class="line">        		.build();</span><br><span class="line">        </span><br><span class="line">        SSLConnectionSocketFactory sslConnectionSocketFactory  = <span class="keyword">new</span> SSLConnectionSocketFactory(</span><br><span class="line">                sslcontext,</span><br><span class="line">                <span class="keyword">new</span> String[] &#123;<span class="string">&quot;TLSv1&quot;</span>, <span class="string">&quot;TLSv1.1&quot;</span>, <span class="string">&quot;TLSv1.2&quot;</span>&#125;,<span class="comment">// 协议</span></span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                SSLConnectionSocketFactory.getDefaultHostnameVerifier());</span><br><span class="line">        </span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">        		.setSSLSocketFactory(sslConnectionSocketFactory)</span><br><span class="line">        		.build();</span><br><span class="line"></span><br><span class="line">		List&lt;NameValuePair&gt; parameters = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</span><br><span class="line">	</span><br><span class="line">		HttpPost httpPost = <span class="keyword">new</span> HttpPost(API_URL);</span><br><span class="line">		httpPost.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(parameters,Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">		</span><br><span class="line">		httpPost.setHeader(<span class="string">&quot;Content-AppKey&quot;</span>, <span class="string">&quot;&quot;</span>); </span><br><span class="line">		httpPost.setHeader(<span class="string">&quot;Content-Signature&quot;</span>,<span class="string">&quot;&quot;</span> );</span><br><span class="line">		httpPost.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded;charset=utf-8&quot;</span>);</span><br><span class="line">		CloseableHttpResponse response = httpClient.execute(httpPost);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> status = response.getStatusLine().getStatusCode();</span><br><span class="line">		System.out.println(<span class="string">&quot;通讯返回状态码：&quot;</span>+status);</span><br><span class="line">		</span><br><span class="line">		HttpEntity entity = response.getEntity();</span><br><span class="line">		</span><br><span class="line">		ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		</span><br><span class="line">		copy(entity.getContent(),outputStream);</span><br><span class="line">		</span><br><span class="line">		String respStr = <span class="keyword">new</span> String(outputStream.toByteArray(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;返回结果：&quot;</span>+respStr);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">4</span>];</span><br><span class="line">		<span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (-<span class="number">1</span> != (n = input.read(buffer))) &#123;</span><br><span class="line">			output.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">			count += n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKey</span><span class="params">(String keyPWD,String keyFile)</span> </span>&#123;</span><br><span class="line">		 Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">		 <span class="keyword">try</span> &#123;</span><br><span class="line">			 File privateKeyFile = <span class="keyword">new</span> File(keyFile); <span class="comment">// private key file in PEM format</span></span><br><span class="line">			 PEMParser pemParser = <span class="keyword">new</span> PEMParser(<span class="keyword">new</span> FileReader(privateKeyFile));</span><br><span class="line">		     Object object = pemParser.readObject();</span><br><span class="line">		     PEMDecryptorProvider decProv = <span class="keyword">new</span> JcePEMDecryptorProviderBuilder().build(keyPWD.toCharArray());</span><br><span class="line">		     JcaPEMKeyConverter converter = <span class="keyword">new</span> JcaPEMKeyConverter().setProvider(<span class="string">&quot;BC&quot;</span>);</span><br><span class="line">		     <span class="keyword">if</span> (object <span class="keyword">instanceof</span> PEMEncryptedKeyPair) &#123;</span><br><span class="line">		    	 <span class="keyword">return</span> converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));</span><br><span class="line">		     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    	 <span class="keyword">return</span> converter.getKeyPair((PEMKeyPair) object);</span><br><span class="line">		     &#125;</span><br><span class="line">		     </span><br><span class="line">		 &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			 <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readVehicleStr</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">		String pemStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            String lineStr = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((lineStr=bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            	<span class="keyword">if</span>(lineStr.length()== <span class="number">0</span> || lineStr.indexOf(<span class="string">&quot;: &quot;</span>)&gt;=<span class="number">0</span> || lineStr.indexOf(<span class="string">&quot;-----BEGIN&quot;</span>)&gt;=<span class="number">0</span> || lineStr.indexOf(<span class="string">&quot;-----END&quot;</span>)&gt;=<span class="number">0</span> ) &#123;</span><br><span class="line">            		<span class="keyword">continue</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            	pemStr+= lineStr.replace(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pemStr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">readRootCA</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, String&gt;  retMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">		String root1Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		String root2Str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> bolCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            String lineStr = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>((lineStr=bufferedReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            	<span class="keyword">if</span>(lineStr.length()== <span class="number">0</span> ) &#123;</span><br><span class="line">            		<span class="keyword">continue</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="keyword">if</span>(lineStr.indexOf(<span class="string">&quot;-----BEGIN&quot;</span>)&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            		bolCount ++ ;</span><br><span class="line">            		<span class="keyword">continue</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="keyword">if</span>(lineStr.indexOf(<span class="string">&quot;-----END&quot;</span>)&gt;=<span class="number">0</span> ) &#123;</span><br><span class="line">            		<span class="keyword">continue</span>;</span><br><span class="line">            	&#125;</span><br><span class="line">            	</span><br><span class="line">            	<span class="keyword">if</span>(bolCount&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            		root1Str+= lineStr.replace(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            		root2Str+= lineStr.replace(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        retMap.put(<span class="string">&quot;root1&quot;</span>, root1Str);</span><br><span class="line">        retMap.put(<span class="string">&quot;root2&quot;</span>, root2Str);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> retMap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>依赖库：bcprov-jdk15on-1.57.jar和bcpkix-jdk15on-1.57.jar</p>
<h4 id="4-使用openssl读取加密私钥"><a href="#4-使用openssl读取加密私钥" class="headerlink" title="4.使用openssl读取加密私钥"></a>4.使用openssl读取加密私钥</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此demo提供一种openssl获取私钥文件的方式</span></span><br><span class="line"><span class="comment">//如果使用EVP_PKEY格式私钥，可以调用EVP_PKEY_set1_RSA接口实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pass_cb</span><span class="params">(<span class="keyword">char</span>* buf,<span class="keyword">int</span> size,<span class="keyword">int</span> rwflag,<span class="keyword">void</span>* u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u || <span class="built_in">strlen</span>((<span class="keyword">char</span>*)u) &lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* pwd = (<span class="keyword">char</span>*)u;</span><br><span class="line"></span><br><span class="line">	LOG_I(<span class="string">&quot;pass_cb ,%s&quot;</span>,pwd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> pass[<span class="number">44</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> plen = <span class="number">44</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用szitrus_certPass 计算得到pass和plen</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> len = plen;</span><br><span class="line"></span><br><span class="line">	 <span class="built_in">memcpy</span>(buf, pass, len);</span><br><span class="line">	 <span class="keyword">return</span> len;</span><br><span class="line">err:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取私钥文件,pass_cb为回调接口，计算口令</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readRSAPrivateKey</span><span class="params">(RSA** rsa,<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">const</span> <span class="keyword">char</span>* pwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!path )</span><br><span class="line">		<span class="keyword">return</span> ERROR_PARAM;</span><br><span class="line"></span><br><span class="line">	FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	fp=  fopen(path,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!*rsa)&#123;</span><br><span class="line">		*rsa = RSA_new();</span><br><span class="line">		<span class="keyword">if</span>(!*rsa)&#123;</span><br><span class="line">			ret = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*rsa = PEM_read_RSAPrivateKey(fp,<span class="literal">NULL</span>,pass_cb,pwd);</span><br><span class="line">	<span class="keyword">if</span>(!*rsa)&#123;</span><br><span class="line">		ret = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span>(fp)&#123;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(*rsa)&#123;</span><br><span class="line">		RSA_free(*rsa);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>查看私钥key是不是PKCS#1, PKCS#1格式的证书没有ASN.1格式</p>
<p><a href="https://lapo.it/asn1js/">ASN.1 JavaScript decoder (lapo.it)</a></p>
<p><strong>参考代码：</strong></p>
<p><a href="git@github.com:oujie123/TLS_Okhttp.git">1.TLS_Okhttp融合</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>双向认证</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Launcher应用Unable to add window</title>
    <url>/2021/09/14/%E8%A7%A3%E5%86%B3Launcher%E5%BA%94%E7%94%A8Unable-to-add-window/</url>
    <content><![CDATA[<h4 id="1-问题关键日志"><a href="#1-问题关键日志" class="headerlink" title="1.问题关键日志"></a>1.问题关键日志</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FATAL EXCEPTION: main</span><br><span class="line"> Process: com.gxatek.cockpit.launcher, PID: <span class="number">16450</span></span><br><span class="line"> java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.gxatek.cockpit.launcher/com.gxatek.cockpit.launcher.LauncherActivity&#125;: android.view.WindowManager$BadTokenException: Unable to add window -- token android.os.BinderProxy@18b6d70 is not valid; is your activity running?</span><br><span class="line"> 	at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:<span class="number">2951</span>)</span><br><span class="line"> 	at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:<span class="number">3086</span>)</span><br><span class="line"> 	at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:<span class="number">78</span>)</span><br><span class="line"> 	at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:<span class="number">108</span>)</span><br><span class="line"> 	at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:<span class="number">68</span>)</span><br><span class="line"> 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">1816</span>)</span><br><span class="line"> 	at android.os.Handler.dispatchMessage(Handler.java:<span class="number">106</span>)</span><br><span class="line"> 	at android.os.Looper.loop(Looper.java:<span class="number">193</span>)</span><br><span class="line"> 	at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6718</span>)</span><br><span class="line"> 	at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line"> 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">493</span>)</span><br><span class="line"> 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">858</span>)</span><br><span class="line"> Caused by: android.view.WindowManager$BadTokenException: Unable to add window -- token android.os.BinderProxy@18b6d70 is not valid; is your activity running?</span><br><span class="line"> 	at android.view.ViewRootImpl.setView(ViewRootImpl.java:<span class="number">798</span>)</span><br><span class="line"> 	at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:<span class="number">356</span>)</span><br><span class="line"> 	at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:<span class="number">93</span>)</span><br><span class="line"> 	at com.iflytek.autofly.cardlist.window.CardListWindowManager.showCardList(CardListWindowManager.java:<span class="number">108</span>)</span><br><span class="line"> 	at com.gxatek.cockpit.launcher.LauncherActivity.onCreate(LauncherActivity.java:<span class="number">153</span>)</span><br><span class="line"> 	at android.app.Activity.performCreate(Activity.java:<span class="number">7144</span>)</span><br><span class="line"> 	at android.app.Activity.performCreate(Activity.java:<span class="number">7135</span>)</span><br><span class="line"> 	at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:<span class="number">1271</span>)</span><br><span class="line"> 	at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:<span class="number">2931</span>)</span><br><span class="line"> 	... <span class="number">11</span> more</span><br></pre></td></tr></table></figure>


<h4 id="2-日志分析"><a href="#2-日志分析" class="headerlink" title="2.日志分析"></a>2.日志分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Unable to start activity ComponentInfo&#123;com.gxatek.cockpit.launcher/com.gxatek.cockpit.launcher.LauncherActivity&#125;: android.view.WindowManager$BadTokenException: Unable to add window -- token android.os.BinderProxy@18b6d70 is not valid; is your activity running?</span><br></pre></td></tr></table></figure>
<p>从关键日志中可以看出系统提示PhoneWindow绑定了Activity，然而在向window上addview的时候，发现Activity已经被销毁了。</p>
<h4 id="3-分析代码"><a href="#3-分析代码" class="headerlink" title="3.分析代码"></a>3.分析代码</h4><p>找到Launcher代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iflytek.autofly.cardlist.window;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardListWindowManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CardListWindowManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        <span class="keyword">this</span>.initCardList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Launcher主界面（LauncherActivity）传入context</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> CardListWindowManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> CardListWindowManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定mWindowManager和LauncherActivity</span></span><br><span class="line">        <span class="keyword">this</span>.mWindowManager和 = (WindowManager)<span class="keyword">this</span>.mContext.getSystemService(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCardList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mCardListView != <span class="keyword">null</span> &amp;&amp; CARD_STATUS) &#123;</span><br><span class="line">            <span class="comment">// 在调用addView的时候没有判断LauncherActivity是否已经被销毁</span></span><br><span class="line">            <span class="keyword">this</span>.mWindowManager.addView(<span class="keyword">this</span>.mCardListView, <span class="keyword">this</span>.mCardListParams);</span><br><span class="line">            CARD_STATUS = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="4-问题修复"><a href="#4-问题修复" class="headerlink" title="4.问题修复"></a>4.问题修复</h4><p>修复方案有两种，第一种是在addview之前对activity判断是否已经finish了；第二种是phonewindow绑定全局context。</p>
<p>修复后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCardList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContext != <span class="keyword">null</span> &amp;&amp; mContext <span class="keyword">instanceof</span> Activity)&#123;</span><br><span class="line">        <span class="comment">// 判断activity是否已经被销毁</span></span><br><span class="line">        <span class="keyword">if</span> (!((Activity)mContext).isFinishing() &amp;&amp; <span class="keyword">this</span>.mCardListView != <span class="keyword">null</span> &amp;&amp; CARD_STATUS) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mWindowManager.addView(<span class="keyword">this</span>.mCardListView, <span class="keyword">this</span>.mCardListParams);</span><br><span class="line">            CARD_STATUS = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
























]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>Launcher</tag>
      </tags>
  </entry>
  <entry>
    <title>解决应用发受保护广播后crash问题</title>
    <url>/2021/09/10/%E8%A7%A3%E5%86%B3%E5%BA%94%E7%94%A8%E5%8F%91%E5%8F%97%E4%BF%9D%E6%8A%A4%E5%B9%BF%E6%92%AD%E5%90%8Ecrash%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><p>​        账号应用在开发过程中发送自定义的受保护广播（protected-broadcast修饰的广播）后发生了crash，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.gxatek.cockpit.account E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">    Process: com.gxatek.cockpit.account, PID: <span class="number">17800</span></span><br><span class="line">    java.lang.SecurityException: Permission Denial: not allowed to send broadcast com.gxa.cockpit.hvac.service from pid=<span class="number">17800</span>, uid=<span class="number">10028</span></span><br><span class="line">        at android.os.Parcel.createException(Parcel.java:<span class="number">1950</span>)</span><br><span class="line">        at android.os.Parcel.readException(Parcel.java:<span class="number">1918</span>)</span><br><span class="line">        at android.os.Parcel.readException(Parcel.java:<span class="number">1868</span>)</span><br><span class="line">        at android.app.IActivityManager$Stub$Proxy.broadcastIntent(IActivityManager.java:<span class="number">3894</span>)</span><br><span class="line">        at android.app.ContextImpl.sendBroadcast(ContextImpl.java:<span class="number">1009</span>)</span><br><span class="line">        at android.content.ContextWrapper.sendBroadcast(ContextWrapper.java:<span class="number">444</span>)</span><br><span class="line">        at com.gxatek.cockpit.account.model.OpenAppModel.gotoHvac(OpenAppModel.java:<span class="number">107</span>)</span><br><span class="line">        at com.gxatek.cockpit.account.presentation.presenter.HomePresenter.openHvacHmi(HomePresenter.java:<span class="number">306</span>)</span><br><span class="line">        at com.gxatek.cockpit.account.presentation.view.fragment.HomeAccountFragment.onClick(HomeAccountFragment.java:<span class="number">502</span>)</span><br><span class="line">        at android.view.View.performClick(View.java:<span class="number">6597</span>)</span><br><span class="line">        at android.view.View.performClickInternal(View.java:<span class="number">6574</span>)</span><br><span class="line">        at android.view.View.access$<span class="number">3100</span>(View.java:<span class="number">778</span>)</span><br><span class="line">        at android.view.View$PerformClick.run(View.java:<span class="number">25885</span>)</span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:<span class="number">873</span>)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:<span class="number">99</span>)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:<span class="number">193</span>)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6718</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">493</span>)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">858</span>)</span><br><span class="line">     Caused by: android.os.RemoteException: Remote stack trace:</span><br><span class="line">        at com.android.server.am.ActivityManagerService.broadcastIntentLocked(ActivityManagerService.java:<span class="number">21358</span>)</span><br><span class="line">        at com.android.server.am.ActivityManagerService.broadcastIntent(ActivityManagerService.java:<span class="number">21987</span>)</span><br><span class="line">        at android.app.IActivityManager$Stub.onTransact$broadcastIntent$(IActivityManager.java:<span class="number">10171</span>)</span><br><span class="line">        at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:<span class="number">167</span>)</span><br><span class="line">        at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:<span class="number">3291</span>)</span><br></pre></td></tr></table></figure>


<h4 id="2-问题调查"><a href="#2-问题调查" class="headerlink" title="2.问题调查"></a>2.问题调查</h4><h5 id="2-1-源码分析"><a href="#2-1-源码分析" class="headerlink" title="2.1 源码分析"></a>2.1 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从log获得到关键信息如下，</span></span><br><span class="line"><span class="comment">// 发送受保护的广播名字：com.gxa.cockpit.hvac.service</span></span><br><span class="line"><span class="comment">// 账号的pid:17800</span></span><br><span class="line"><span class="comment">// 账号的uid:10028</span></span><br><span class="line">Permission Denial: not allowed to send broadcast com.gxa.cockpit.hvac.service from pid=<span class="number">17800</span>, uid=<span class="number">10028</span></span><br></pre></td></tr></table></figure>


<p>顺着调用堆栈，查看ActivityManagerService源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">            String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">&quot;broadcastIntent&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            intent = verifyBroadcastLocked(intent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="comment">// 调用broadcastIntentLocked发送广播</span></span><br><span class="line">            <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</span><br><span class="line">                    callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>,</span><br><span class="line">                    intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                    requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                    callingPid, callingUid, userId);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">            String callerPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">            IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Verify that protected broadcasts are only being sent by system code,</span></span><br><span class="line">        <span class="comment">// and that system code is only sending protected broadcasts.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AndroidManifest.xml中定义了&lt;protected-broadcast&gt;定义的受保护广播</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isProtectedBroadcast;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Remote exception&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 根据uid和应用中persistent标志位判断当前进程是不是isCallerSystem</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem;</span><br><span class="line">        <span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">            <span class="keyword">case</span> ROOT_UID:</span><br><span class="line">            <span class="keyword">case</span> SYSTEM_UID:</span><br><span class="line">            <span class="keyword">case</span> PHONE_UID:</span><br><span class="line">            <span class="keyword">case</span> BLUETOOTH_UID:</span><br><span class="line">            <span class="keyword">case</span> NFC_UID:</span><br><span class="line">            <span class="keyword">case</span> SE_UID:</span><br><span class="line">                isCallerSystem = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                isCallerSystem = (callerApp != <span class="keyword">null</span>) &amp;&amp; callerApp.persistent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First line security check before anything else: stop non-system apps from</span></span><br><span class="line">        <span class="comment">// sending protected broadcasts.</span></span><br><span class="line">        <span class="comment">// 如果不是系统应用，且发送了受保护广播，就抛出安全异常。</span></span><br><span class="line">        <span class="keyword">if</span> (!isCallerSystem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isProtectedBroadcast) &#123;</span><br><span class="line">                <span class="comment">// 应用异常报错地方</span></span><br><span class="line">                String msg = <span class="string">&quot;Permission Denial: not allowed to send broadcast &quot;</span></span><br><span class="line">                        + action + <span class="string">&quot; from pid=&quot;</span></span><br><span class="line">                        + callingPid + <span class="string">&quot;, uid=&quot;</span> + callingUid;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">                    || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// Special case for compatibility: we don&#x27;t want apps to send this,</span></span><br><span class="line">                <span class="comment">// but historically it has not been protected and apps may be using it</span></span><br><span class="line">                <span class="comment">// to poke their own app widget.  So, instead of making it protected,</span></span><br><span class="line">                <span class="comment">// just limit it to the caller.</span></span><br><span class="line">                <span class="keyword">if</span> (callerPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，查看应用AndroidManifest.xml配置文件。</p>
<h5 id="2-2-分析配置文件"><a href="#2-2-分析配置文件" class="headerlink" title="2.2 分析配置文件"></a>2.2 分析配置文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    package&#x3D;&quot;com.gxatek.cockpit.account&quot;</span><br><span class="line">    android:sharedUserId&#x3D;&quot;android.uid.systemui&quot;</span><br><span class="line">    android:versionCode&#x3D;&quot;1&quot;</span><br><span class="line">    android:versionName&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;uses-sdk tools:overrideLibrary&#x3D;&quot;com.bumptech.glide&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- android:sharedUserId&#x3D;&quot;android.uid.systemui&quot; --&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; &#x2F;&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot; &#x2F;&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.RECORD_AUDIO&quot; &#x2F;&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.WAKE_LOCK&quot; &#x2F;&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#x2F;&gt;</span><br><span class="line">    &lt;uses-permission android:name&#x3D;&quot;android.permission.FOREGROUND_SERVICE&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;protected-broadcast android:name&#x3D;&quot;com.gxa.cockpit.hvac.service&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        android:icon&#x3D;&quot;@drawable&#x2F;ic_launcher&quot;</span><br><span class="line">        android:label&#x3D;&quot;@string&#x2F;app_name&quot;</span><br><span class="line">        android:supportsRtl&#x3D;&quot;true&quot;</span><br><span class="line">        android:name&#x3D;&quot;.MyApplication&quot;</span><br><span class="line">        android:usesCleartextTraffic&#x3D;&quot;true&quot;</span><br><span class="line">        android:theme&#x3D;&quot;@style&#x2F;AppThemeWhite&quot;&gt;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>通过查看，账号应用没有配置persistent。</p>
<p>通知账号应用的开发配置该参数为true然后打个包再试了一下。发现还是在崩溃，发现配置没有生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据uid和应用中persistent标志位判断当前进程是不是isCallerSystem</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem;</span><br><span class="line">    <span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">    <span class="keyword">case</span> ROOT_UID:</span><br><span class="line">    <span class="keyword">case</span> SYSTEM_UID:</span><br><span class="line">    <span class="keyword">case</span> PHONE_UID:</span><br><span class="line">    <span class="keyword">case</span> BLUETOOTH_UID:</span><br><span class="line">    <span class="keyword">case</span> NFC_UID:</span><br><span class="line">    <span class="keyword">case</span> SE_UID:</span><br><span class="line">    	isCallerSystem = <span class="keyword">true</span>;</span><br><span class="line">   		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        isCallerSystem = (callerApp != <span class="keyword">null</span>) &amp;&amp; callerApp.persistent;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析发现，配置persistent是在default分支判断的。查看账号的uid还是不为1000,说明还不是系统应用。</p>
<p>继续看Manifest配置文件发现，账号的<code>sharedUserId</code>是<code>android.uid.systemui</code>不是系统，而是和systemui共享uid。</p>
<p>通知账号开发修改<code>sharedUserId</code>是<code>android.uid.system</code>然后再验证。</p>
<p>验证结果显示该配置是生效的。问题得到解决。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>受限广播</tag>
      </tags>
  </entry>
  <entry>
    <title>解决聚媒体应用启动服务异常</title>
    <url>/2021/09/14/%E8%A7%A3%E5%86%B3%E8%81%9A%E5%AA%92%E4%BD%93%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h4 id="1-问题关键日志"><a href="#1-问题关键日志" class="headerlink" title="1.问题关键日志"></a>1.问题关键日志</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FATAL EXCEPTION: main</span><br><span class="line"> Process: com.iflytek.autofly.mediax, PID: <span class="number">6260</span></span><br><span class="line"> java.lang.RuntimeException: Unable to create application com.iflytek.autofly.mediax.App: java.lang.IllegalStateException: Not allowed to start service Intent &#123; cmp=com.iflytek.autofly.mediax/cn.kuwo.service.MainService (has extras) &#125;: app is in background uid UidRecord&#123;d667c54 u10s1000 RCVR idle change:uncached procs:<span class="number">1</span> seq(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#125;</span><br><span class="line"> 	at android.app.ActivityThread.handleBindApplication(ActivityThread.java:<span class="number">5925</span>)</span><br><span class="line"> 	at android.app.ActivityThread.access$<span class="number">1100</span>(ActivityThread.java:<span class="number">200</span>)</span><br><span class="line"> 	at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">1656</span>)</span><br><span class="line"> 	at android.os.Handler.dispatchMessage(Handler.java:<span class="number">106</span>)</span><br><span class="line"> 	at android.os.Looper.loop(Looper.java:<span class="number">193</span>)</span><br><span class="line"> 	at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6718</span>)</span><br><span class="line"> 	at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line"> 	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">493</span>)</span><br><span class="line"> 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">858</span>)</span><br><span class="line"> Caused by: java.lang.IllegalStateException: Not allowed to start service Intent &#123; cmp=com.iflytek.autofly.mediax/cn.kuwo.service.MainService (has extras) &#125;: app is in background uid UidRecord&#123;d667c54 u10s1000 RCVR idle change:uncached procs:<span class="number">1</span> seq(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#125;</span><br><span class="line"> 	at android.app.ContextImpl.startServiceCommon(ContextImpl.java:<span class="number">1577</span>)</span><br><span class="line"> 	at android.app.ContextImpl.startService(ContextImpl.java:<span class="number">1532</span>)</span><br><span class="line"> 	at android.content.ContextWrapper.startService(ContextWrapper.java:<span class="number">664</span>)</span><br><span class="line"> 	at cn.kuwo.service.MainService.connect(SourceFile:<span class="number">84</span>)</span><br><span class="line"> 	at cn.kuwo.service.MainService.connect(SourceFile:<span class="number">63</span>)</span><br><span class="line"> 	at cn.kuwo.unkeep.a.a.a(SourceFile:<span class="number">69</span>)</span><br><span class="line"> 	at cn.kuwo.application.App.onCreate(SourceFile:<span class="number">107</span>)</span><br><span class="line"> 	at com.iflytek.autofly.entadapter.cpsp.kuwo.KuWoAppProxy.onCreate(KuWoAppProxy.java:<span class="number">77</span>)</span><br><span class="line"> 	at com.iflytek.autofly.ent.ENT.startMusicService(ENT.java:<span class="number">74</span>)</span><br><span class="line"> 	at com.iflytek.autofly.mediax.App.onCreate(App.java:<span class="number">264</span>)</span><br><span class="line"> 	at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:<span class="number">1154</span>)</span><br><span class="line"> 	at android.app.ActivityThread.handleBindApplication(ActivityThread.java:<span class="number">5920</span>)</span><br><span class="line"> 	... <span class="number">8</span> more</span><br></pre></td></tr></table></figure>


<h4 id="2-日志分析"><a href="#2-日志分析" class="headerlink" title="2.日志分析"></a>2.日志分析</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">报java.lang.IllegalStateException: Not allowed to start service Intent xxxx app is in background uid UidRecord</span><br></pre></td></tr></table></figure>
<p>Android 8.0 有以下调整：<br>Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 startService() 函数，则该函数将引发一个 IllegalStateException。</p>
<p>新的 Context.startForegroundService() 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 Context.startForegroundService()。</p>
<p>不过，应用必须在创建服务后的五秒内调用该服务的 startForeground() 函数。</p>
<h4 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在启动服务的地方判断系统版本</span></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    context.startForegroundService(<span class="keyword">new</span> Intent(context, ServedService.class));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context.startService(<span class="keyword">new</span> Intent(context, ServedService.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在服务的内部类oncreate方法上也需要添加过滤</span></span><br><span class="line"><span class="keyword">import</span> android.app.Notification;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">           startForeground(<span class="number">1</span>,<span class="keyword">new</span> Notification()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>mediax</tag>
      </tags>
  </entry>
  <entry>
    <title>解决蓝牙因为并发修改数组导致native crash问题</title>
    <url>/2021/09/15/%E8%A7%A3%E5%86%B3%E8%93%9D%E7%89%99%E5%9B%A0%E4%B8%BA%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E5%AF%BC%E8%87%B4native-crash%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h4><p>测试同学在测试的时候发现蓝牙无法自动连接，然后就尝试开/关蓝牙开关按钮来测试是否能重新自动连上蓝牙。但是结果是一直连接不上。</p>
<p>后来在/data/tombstone中发现很多墓碑日志，于是就导出给到我这边分析。</p>
<p>墓碑日志原始文件见附件中。此处描述分析过程。分析过程中主要会使用到：addr2line, objdump, ndk-stack工具。（具体使用方法在《addr2line, objdump, ndk-stack使用方法》中介绍）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pid: <span class="number">18459</span>, tid: <span class="number">18480</span>, name: BT Service Call  &gt;&gt;&gt; com.android.bluetooth &lt;&lt;&lt;</span><br><span class="line">signal <span class="number">11</span> (SIGSEGV), code <span class="number">1</span> (SEGV_MAPERR), fault addr <span class="number">0x84d20a5cc8</span></span><br><span class="line">    x0  00000084d20a5cc8  x1  00000074d218f930  x2  00000074d2000000  x3  <span class="number">0000000000000003</span></span><br><span class="line">    x4  <span class="number">000000000000018f</span>  x5  <span class="number">0000000000000000</span>  x6  2e73612e6c647372  x7  7f7f7f7f7f7f7f7f</span><br><span class="line">    x8  00000074bff8e370  x9  235a76edc05fe912  x10 <span class="number">000000000000018f</span>  x11 382d303030312d30</span><br><span class="line">    x12 303830302d303030  x13 <span class="number">6266343362396635</span>  x14 <span class="number">0000000000000000</span>  x15 00000074bff8db08</span><br><span class="line">    x16 000000755bcf3be0  x17 000000755bc86174  x18 <span class="number">0000000000000001</span>  x19 00000074d20a5cd8</span><br><span class="line">    x20 00000000ffffffff  x21 00000074c093b6d9  x22 00000074c093b6ed  x23 00000074c093b6fc</span><br><span class="line">    x24 00000074c093b721  x25 <span class="number">0000000000000000</span>  x26 <span class="number">0000000000000001</span>  x27 00000074c0a37000</span><br><span class="line">    x28 00000074bff8e371  x29 00000074bff8e350</span><br><span class="line">    sp  00000074bff8e300  lr  00000074c06d338c  pc  00000074c090fe1c</span><br><span class="line"></span><br><span class="line">backtrace:</span><br><span class="line">    #00 pc 00000000003bce1c  /system/lib64/libbluetooth.so (bluetooth::Uuid::ToString() const+12)</span><br><span class="line">    #01 pc 0000000000180388  /system/lib64/libbluetooth.so (checkIOSDevice(unsigned int, bluetooth::Uuid*) [clone .cfi]+136)</span><br><span class="line">    #02 pc 000000000018442c  /system/lib64/libbluetooth.so (btif_dm_search_services_evt(unsigned short, char*) [clone .cfi]+1388)</span><br><span class="line">    #03 pc 000000000017cfbc  /system/lib64/libbluetooth.so (bt_jni_msg_ready(void*) [clone .cfi]+136)</span><br><span class="line">    #04 pc 0000000000096908  /system/lib64/libchrome.so (base::debug::TaskAnnotator::RunTask(char const*, base::PendingTask*)+248)</span><br><span class="line">    #05 pc 00000000000afd14  /system/lib64/libchrome.so (base::MessageLoop::RunTask(base::PendingTask*)+416)</span><br><span class="line">    #06 pc 00000000000affbc  /system/lib64/libchrome.so (base::MessageLoop::DeferOrRunPendingTask(base::PendingTask)+52)</span><br><span class="line">    #07 pc 00000000000b03f8  /system/lib64/libchrome.so (base::MessageLoop::DoWork()+380)</span><br><span class="line">    #08 pc 00000000000b1790  /system/lib64/libchrome.so (base::MessagePumpDefault::Run(base::MessagePump::Delegate*)+180)</span><br><span class="line">    #09 pc 00000000000afa08  /system/lib64/libchrome.so (base::MessageLoop::RunHandler()+112)</span><br><span class="line">    #10 pc 00000000000cc60c  /system/lib64/libchrome.so (base::RunLoop::Run()+136)</span><br><span class="line">    #11 pc 000000000017d54c  /system/lib64/libbluetooth.so (run_message_loop(void*) [clone .cfi]+348)</span><br><span class="line">    #12 pc 00000000002b6164  /system/lib64/libbluetooth.so (work_queue_read_cb(void*) [clone .cfi]+120)</span><br><span class="line">    #13 pc 00000000002b460c  /system/lib64/libbluetooth.so (run_reactor(reactor_t*, int) [clone .cfi]+416)</span><br><span class="line">    #14 pc 00000000002b4440  /system/lib64/libbluetooth.so (reactor_start(reactor_t*) [clone .cfi]+84)</span><br><span class="line">    #15 pc 00000000002b5f14  /system/lib64/libbluetooth.so (run_thread(void*) [clone .cfi]+188)</span><br><span class="line">    #16 pc 00000000000819b4  /system/lib64/libc.so (__pthread_start(void*)+36)</span><br><span class="line">    #17 pc 0000000000023478  /system/lib64/libc.so (__start_thread+68)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下信息以简述描述   </span></span><br><span class="line"><span class="comment">// 栈信息</span></span><br><span class="line"><span class="comment">// 各个寄存器附近的内存信息</span></span><br><span class="line"><span class="comment">// 崩溃附近的log日志</span></span><br><span class="line"><span class="comment">// 各个线程栈信息</span></span><br><span class="line"><span class="comment">// 崩溃附近的所有线程的日志信息</span></span><br><span class="line">--------- log main</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">03.952</span> <span class="number">18459</span> <span class="number">18500</span> W bt_btm_ble: btm_ble_process_adv_pkt_cont device no longer discoverable, discarding advertising packet</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">03.967</span> <span class="number">18459</span> <span class="number">18500</span> W bt_btm_ble: btm_ble_process_adv_pkt_cont device no longer discoverable, discarding advertising packet</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.006</span> <span class="number">18459</span> <span class="number">18480</span> D bt_btif_config: btif_get_device_type: Device [b8:c7:4a:<span class="number">77</span>:<span class="number">58</span>:1e] type <span class="number">1</span></span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.007</span> <span class="number">18459</span> <span class="number">18480</span> W BluetoothRemoteDevices: Skip name update <span class="keyword">for</span> B8:C7:4A:<span class="number">77</span>:<span class="number">58</span>:1E</span><br><span class="line">09-13 15:40:04.007 18459 18480 W BluetoothRemoteDevices: Skip class update for B8:C7:4A:77:58:1E</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.016</span> <span class="number">18459</span> <span class="number">18500</span> W bt_btm_ble: btm_ble_process_adv_pkt_cont device no longer discoverable, discarding advertising packet</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.131</span> <span class="number">18459</span> <span class="number">18500</span> W bt_btm_ble: btm_ble_process_adv_pkt_cont device no longer discoverable, discarding advertising packet</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.140</span> <span class="number">18459</span> <span class="number">18500</span> W bt_btm_ble: btm_ble_process_adv_pkt_cont device no longer discoverable, discarding advertising packet</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.142</span> <span class="number">18459</span> <span class="number">18480</span> D bt_btif_config: btif_get_device_type: Device [e0:cc:f8:<span class="number">71</span>:cd:0b] type <span class="number">1</span></span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.142</span> <span class="number">18459</span> <span class="number">18480</span> W BluetoothRemoteDevices: Skip name update <span class="keyword">for</span> E0:CC:F8:<span class="number">71</span>:CD:0B</span><br><span class="line">09-13 15:40:04.142 18459 18480 W BluetoothRemoteDevices: Skip class update for E0:CC:F8:71:CD:0B</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">04.156</span> <span class="number">18459</span> <span class="number">18500</span> W bt_btm_ble: btm_ble_process_adv_pkt_cont device no </span><br><span class="line">......</span><br></pre></td></tr></table></figure>


<h4 id="2-调查过程"><a href="#2-调查过程" class="headerlink" title="2.调查过程"></a>2.调查过程</h4><p>从日志信息中，我们首先看日志前几行，定位哪个应用，那种类型的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pid: <span class="number">18459</span>, tid: <span class="number">18480</span>, name: BT Service Call  &gt;&gt;&gt; com.android.bluetooth &lt;&lt;&lt;</span><br><span class="line">signal <span class="number">11</span> (SIGSEGV), code <span class="number">1</span> (SEGV_MAPERR), fault addr <span class="number">0x84d20a5cc8</span></span><br></pre></td></tr></table></figure>
<p>从以上信息可以看出问题发生在<code>BT Service Call</code>中，包名为：<code> com.android.bluetooth</code> 。</p>
<p>错误类型是：<code>SIGSEGV段错误</code>，内存地址指向：<code>0x84d20a5cc8</code></p>
<p>确定应用和错误类型之后，开始分析trace文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#00 pc 00000000003bce1c  /system/lib64/libbluetooth.so (bluetooth::Uuid::ToString() const+12)</span><br><span class="line">#01 pc 0000000000180388  /system/lib64/libbluetooth.so (checkIOSDevice(unsigned int, bluetooth::Uuid*) [clone .cfi]+136)</span><br><span class="line">#02 pc 000000000018442c  /system/lib64/libbluetooth.so (btif_dm_search_services_evt(unsigned short, char*) [clone .cfi]+1388)</span><br><span class="line">#03 pc 000000000017cfbc  /system/lib64/libbluetooth.so (bt_jni_msg_ready(void*) [clone .cfi]+136)</span><br></pre></td></tr></table></figure>
<p>从trace文件中可以看到应用最终崩溃在pc指针指向00000000003bce1c地址上。方法是调用bluetooth::Uuid::ToString()，bluetooth::Uuid指向的地址是一个错误的内存地址。</p>
<p>然后使用addr2line工具，找到带有符号表的libbluetooth.so。</p>
<p><strong>注意：</strong>千万不要导出车机系统中/system/lib64/下的libbluetooth.so库，因此该so库没有符号表，根本看不出来是那行函数报错了。</p>
<p><strong>实际：</strong>在源码编译完成之后的out目录下取找带有符号表的so库。路径在：<code>out/target/product/msmnile_gvmq/obj/SHARED_LIBRARIES/&lt;模块名_intermediates&gt;/LINKED/</code>中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> addr2line -aCfe libbluetooth.so 3bce1c</span></span><br><span class="line">0x00000000003bce1c</span><br><span class="line">bluetooth::Uuid::ToString() const</span><br><span class="line">system/bt/types/bluetooth/uuid.cc:169</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> addr2line -aCfe libbluetooth.so 180388</span></span><br><span class="line">0x0000000000180388</span><br><span class="line">checkIOSDevice(unsigned int, bluetooth::Uuid*)</span><br><span class="line">system/bt/btif/src/btif_dm.cc:1377</span><br></pre></td></tr></table></figure>
<p>可以看到<code>system/bt/btif/src/btif_dm.cc</code>的1377行报错。</p>
<p>然后在1377行调用<code>system/bt/types/bluetooth/uuid.cc</code>的169行报错。</p>
<p>然后再源码中找到对应的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IAP_UUID <span class="meta-string">&quot;fecacade-afde-cade-defa-cade00000000&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IAP_UUID_REV <span class="meta-string">&quot;00000000-deca-fade-deca-deafdecacafe&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkIOSDevice</span><span class="params">( <span class="keyword">uint32_t</span> num_uuids, bluetooth::Uuid* p_uuid_list )</span> </span>&#123;</span><br><span class="line">  bluetooth::Uuid* p_temp_uuidlist = p_uuid_list;</span><br><span class="line">  <span class="keyword">bool</span> bresult = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> i = num_uuids - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> temp = p_temp_uuidlist[i].ToString();  <span class="comment">// 1377行报错</span></span><br><span class="line">    <span class="comment">// p_temp_uuidlist[i]对应的对象是bluetooth::Uuid</span></span><br><span class="line">    BTIF_TRACE_DEBUG(<span class="string">&quot;%s:  :uuid[%d] = %s&quot;</span>,</span><br><span class="line">                        __func__, i, temp.c_str() );</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == temp.compare(IAP_UUID)  ||</span><br><span class="line">        <span class="number">0</span> == temp.compare(IAP_UUID_REV) ) &#123;</span><br><span class="line">      bresult = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bresult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p>其实从这里已经可以基本判断是那里错误了，就是p_temp_uuidlist[i]指向的对象是一个错误的地址。那现在到地址哪个i导致报错的呢。在继续追溯以下向上调用栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android/system/bt/btif/src/btif_dm.cc </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">btif_dm_search_services_evt</span><span class="params">(<span class="keyword">uint16_t</span> event, <span class="keyword">char</span>* p_param)</span> </span>&#123;</span><br><span class="line">  tBTA_DM_SEARCH* p_data = (tBTA_DM_SEARCH*)p_param;</span><br><span class="line"></span><br><span class="line">  BTIF_TRACE_EVENT(<span class="string">&quot;%s:  event = %d&quot;</span>, __func__, event);</span><br><span class="line">  <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">    <span class="keyword">case</span> BTA_DM_DISC_RES_EVT: &#123;</span><br><span class="line">      <span class="keyword">bt_property_t</span> prop;</span><br><span class="line">      <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">bt_status_t</span> ret;</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line">         </span><br><span class="line">      prop.type = BT_PROPERTY_UUIDS;</span><br><span class="line">      prop.len = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ((p_data-&gt;disc_res.result == BTA_SUCCESS) &amp;&amp;</span><br><span class="line">          (p_data-&gt;disc_res.num_uuids &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        prop.val = p_data-&gt;disc_res.p_uuid_list;</span><br><span class="line">        prop.len = p_data-&gt;disc_res.num_uuids * Uuid::kNumBytes128;</span><br><span class="line">        <span class="comment">// 遍历扫描到的设备uuid</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_data-&gt;disc_res.num_uuids; i++) &#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">string</span> temp = ((p_data-&gt;disc_res.p_uuid_list + i))-&gt;ToString();</span><br><span class="line">          LOG_INFO(LOG_TAG, <span class="string">&quot;%s index:%d uuid:%s&quot;</span>, __func__, i, temp.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">          此处省略部分代码</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (p_data-&gt;disc_res.num_uuids != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Also write this to the NVRAM */</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">ifdef</span> BTIF_VENDOR_CHK_IOS_DEVICE</span></span><br><span class="line">        <span class="comment">// 如果有uuid就传入uuid的个数和uuid list</span></span><br><span class="line">        <span class="keyword">if</span> (checkIOSDevice(p_data-&gt;disc_res.num_uuids, p_data-&gt;disc_res.p_uuid_list)) &#123;</span><br><span class="line">          BTIF_TRACE_WARNING(<span class="string">&quot;%s:IOS device don&#x27;t response carplay uuid when search services,&quot;</span></span><br><span class="line">              <span class="string">&quot; so do not report uuids when get_remote_services&quot;</span>, __func__);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ret = btif_storage_set_remote_device_property(&amp;bd_addr, &amp;prop);</span><br><span class="line">        ASSERTC(ret == BT_STATUS_SUCCESS, <span class="string">&quot;storing remote services failed&quot;</span>,</span><br><span class="line">                ret);</span><br><span class="line">        <span class="comment">/* Send the event to the BTIF */</span></span><br><span class="line">        HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb, BT_STATUS_SUCCESS,</span><br><span class="line">                  &amp;bd_addr, <span class="number">1</span>, &amp;prop);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: &#123; ASSERTC(<span class="number">0</span>, <span class="string">&quot;unhandled search services event&quot;</span>, event); &#125; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出两个问题：</p>
<ul>
<li>btif_dm_search_services_evt()方法中所有没有加锁</li>
<li>checkIOSDevice()传入的list在取出元素的时候没有判空。</li>
</ul>
<p>充满好奇心的程序员想知道到底是在遍历哪一个元素的时候报的问题。可以查看以下具体的日志文件或者寄存器信息。如果有日志，就可以看看日志文件，简单一点，没有日志，就只能寄存器。</p>
<p>看看源码，在搜到设备的时候就有日志打出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_data-&gt;disc_res.num_uuids; i++) &#123;</span><br><span class="line">    std::string temp = ((p_data-&gt;disc_res.p_uuid_list + i))-&gt;ToString();</span><br><span class="line">    LOG_INFO(LOG_TAG, <span class="string">&quot;%s index:%d uuid:%s&quot;</span>, __func__, i, temp.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在checkIOSDevice()中遍历设备信息的时候也有日志打出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> temp = p_temp_uuidlist[i].ToString(); </span><br><span class="line">    BTIF_TRACE_DEBUG(<span class="string">&quot;%s:  :uuid[%d] = %s&quot;</span>,</span><br><span class="line">                        __func__, i, temp.c_str() );</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">0</span> == temp.compare(IAP_UUID)  ||</span><br><span class="line">        <span class="number">0</span> == temp.compare(IAP_UUID_REV) ) &#123;</span><br><span class="line">      bresult = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>因此，需要看看这部分输出情况。</p>
<p>从trace文件最后的log信息可以看到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.313</span> <span class="number">18459</span> <span class="number">18500</span> W bt_sdp  : sdp_copy_raw_data: list_len:<span class="number">1478</span> cpy_len:<span class="number">1478</span> p:<span class="number">0x74d212100b</span> p_ccb:<span class="number">0x74c0b47820</span> p_db:<span class="number">0x74d21dcc88</span> raw_size:<span class="number">4096</span> raw_used:<span class="number">0</span> raw_data:<span class="number">0x74c0a50fd8</span></span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.410</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">0</span> uuid:0000110a-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">1</span> uuid:<span class="number">00001105</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">2</span> uuid:<span class="number">00001115</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">3</span> uuid:<span class="number">00001116</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">4</span> uuid:<span class="number">0000112f</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">5</span> uuid:<span class="number">00001112</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">6</span> uuid:<span class="number">0000111f</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">7</span> uuid:<span class="number">00001132</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">8</span> uuid:<span class="number">00000000</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">9</span> uuid:<span class="number">00000000</span>-<span class="number">0000</span>-<span class="number">1000</span>-<span class="number">8000</span>-00805f9b34fb</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">10</span> uuid:11c8b310-<span class="number">80e4</span>-<span class="number">4276</span>-afc0-f81590b2177f</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">11</span> uuid:8ce255c0-200a-<span class="number">11e0</span>-ac64-0800200c9a66</span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: btif_dm_search_services_evt index:<span class="number">12</span> uuid:9664aa26-d76c-43ad-<span class="number">9775</span>-d310f253a408</span><br><span class="line"><span class="comment">//btif_dm_search_services_evt()方法打印出扫描出来的设备信息</span></span><br><span class="line"><span class="comment">//checkIOSDevice()没有打印设备信息。然后结合checkIOSDevice()代码遍历列表的逻辑是从数组最后元素开始遍历，因此问题就可以断定了：在checkIOSDevice()遍历数组之前，btif_dm_search_services_evt()遍历结束之后，p_temp_uuidlist被修改过，导致checkIOSDevice()遍历时最后一个元素已经不存在了。所以就导致内存越界crash。</span></span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> D bt_btif_config: btif_get_device_type: Device [<span class="number">18</span>:<span class="number">70</span>:3b:a3:<span class="number">45</span>:<span class="number">5f</span>] type <span class="number">1</span></span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I bt_btif_dm: get_cod remote_cod = <span class="number">0x005a020c</span></span><br><span class="line">09-<span class="number">13</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">12.411</span> <span class="number">18459</span> <span class="number">18480</span> I BluetoothBondStateMachine: bondStateChangeCallback: Status: <span class="number">0</span> Address: <span class="number">18</span>:<span class="number">70</span>:3B:A3:<span class="number">45</span>:<span class="number">5F</span> newState: <span class="number">2</span></span><br></pre></td></tr></table></figure>


<p><strong>问题定论：</strong>遍历校验扫描出来的设备信息的时候，因为没有加锁，导致p_temp_uuidlist在另外线程修改过，然后checkIOSDevice()取出的元素是一个未知的内存地址。然后调用toString()崩溃了。</p>
<h4 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h4><p>3.1 在遍历设备的时候加个互斥锁。防止其他线程在遍历校验设备信息的时候，对p_temp_uuidlist数组的修改。</p>
<p>3.2 在p_temp_uuidlist取出元素的时候，判断以下是否存在该元素，如果不存在就不调用toString()方法。</p>
<h4 id="4-附加信息"><a href="#4-附加信息" class="headerlink" title="4.附加信息"></a>4.附加信息</h4><p>如果需要使用objdump查看反编译的汇编代码，需要使用编译后的objdump.</p>
<p>路径: <code>prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-androidkernel-objdump</code></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>Bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title>调查空调信号上行不显示，点击操作，下行信号无变化</title>
    <url>/2021/09/16/%E8%B0%83%E6%9F%A5%E7%A9%BA%E8%B0%83%E4%BF%A1%E5%8F%B7%E4%B8%8A%E8%A1%8C%E4%B8%8D%E6%98%BE%E7%A4%BA%EF%BC%8C%E7%82%B9%E5%87%BB%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%8B%E8%A1%8C%E4%BF%A1%E5%8F%B7%E6%97%A0%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h4><p>开发同事反馈Vehicle服务下行信号可以发出，但是没有收到回调。给了一份关键日志如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// logD：进程输出日志    326是logD的进程id</span></span><br><span class="line"><span class="comment">// 报错的进程是automotive.vehicle@2.0-impl   进程id是270</span></span><br><span class="line">LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br><span class="line">LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br><span class="line">LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br><span class="line">LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br><span class="line">LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br><span class="line">LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br><span class="line">LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br></pre></td></tr></table></figure>


<h4 id="2-问题调查过程"><a href="#2-问题调查过程" class="headerlink" title="2.问题调查过程"></a>2.问题调查过程</h4><p>调查开始肯定是从报错的进程开始，遍历PID找到进程所有日志，看能不能找到部分线索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KERN KERN <span class="number">326</span> log info verbose <span class="number">1</span> binder: <span class="number">270</span>:<span class="number">282</span> transaction failed <span class="number">29201</span>/-<span class="number">28</span>, size <span class="number">1365540</span>-<span class="number">109248</span> line <span class="number">3274</span></span><br><span class="line">auto LOGD 326 log error verbose 1 E/automotive.vehicle@2.0-impl( 270): Failed to notify client [class or subclass of android.hardware.automotive.vehicle@2.0::IVehicleCallback]@remote, err: Status(EX_TRANSACTION_FAILED): &#x27;FAILED_TRANSACTION: &#x27;</span><br><span class="line">KERN KERN <span class="number">326</span> log info verbose <span class="number">1</span> binder: <span class="number">270</span>:<span class="number">282</span> transaction failed <span class="number">29201</span>/-<span class="number">28</span>, size <span class="number">957540</span>-<span class="number">76608</span> line <span class="number">3274</span></span><br><span class="line">KERN KERN <span class="number">326</span> log info verbose <span class="number">1</span> binder: <span class="number">270</span>:<span class="number">282</span> transaction failed <span class="number">29201</span>/-<span class="number">28</span>, size <span class="number">591540</span>-<span class="number">47328</span> line <span class="number">3274</span></span><br><span class="line">KERN KERN <span class="number">326</span> log info verbose <span class="number">1</span> binder: <span class="number">270</span>:<span class="number">282</span> transaction failed <span class="number">29201</span>/-<span class="number">28</span>, size <span class="number">577940</span>-<span class="number">46240</span> line <span class="number">3274</span></span><br><span class="line">KERN KERN <span class="number">326</span> log info verbose <span class="number">1</span> binder: <span class="number">270</span>:<span class="number">282</span> transaction failed <span class="number">29201</span>/-<span class="number">28</span>, size <span class="number">637140</span>-<span class="number">50976</span> line <span class="number">3274</span></span><br></pre></td></tr></table></figure>
<p>搜索”270“进程id可以看到vehicle进程报了binder传输异常。</p>
<p>然后看到<code>KERN</code>, 是kernal报出来的错误。因此在kernal中去搜索错误报错地方，看是否能找到相关线索。</p>
<p>搜索”transaction failed“</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/msm-4.14/drivers/android/binder.c</span></span><br><span class="line">err_invalid_target_handle:</span><br><span class="line">	<span class="keyword">if</span> (target_thread)</span><br><span class="line">		binder_thread_dec_tmpref(target_thread);</span><br><span class="line">	<span class="keyword">if</span> (target_proc)</span><br><span class="line">		binder_proc_dec_tmpref(target_proc);</span><br><span class="line">	<span class="keyword">if</span> (target_node) &#123;</span><br><span class="line">		binder_dec_node(target_node, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		binder_dec_node_tmpref(target_node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</span><br><span class="line">		     <span class="string">&quot;%d:%d transaction failed %d/%d, size %lld-%lld line %d\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid, return_error, return_error_param,</span><br><span class="line">		     (u64)tr-&gt;data_size, (u64)tr-&gt;offsets_size,</span><br><span class="line">		     return_error_line);</span><br></pre></td></tr></table></figure>
<p>搜索关键词，找到了关键log，binder驱动报错了，我们细数一下日志中每个报错参数的意思。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;%d:%d transaction failed %d/%d, size %lld-%lld line %d\n&quot;</span></span><br><span class="line">proc-&gt;pid, thread-&gt;pid, return_error, return_error_param,(u64)tr-&gt;data_size, (u64)tr-&gt;offsets_size, return_error_line);</span><br><span class="line"></span><br><span class="line"><span class="number">270</span>:<span class="number">282</span> transaction failed <span class="number">29201</span>/-<span class="number">28</span>, size <span class="number">637140</span>-<span class="number">50976</span> line <span class="number">3274</span></span><br><span class="line">    </span><br><span class="line">报错进程id:<span class="number">270</span>   线程id:<span class="number">282</span></span><br><span class="line">错误码：<span class="number">29201</span>(BR_FAILED_REPLY)    标准错误码：-<span class="number">28</span> (No space left on device)</span><br><span class="line">binder_transaction_data的data_size大小为<span class="number">637140</span>字节   </span><br><span class="line">binder_transaction_data的offsets_size数据偏移为<span class="number">50976</span></span><br><span class="line">报错代码行数：<span class="number">3274</span> </span><br></pre></td></tr></table></figure>
<p>因为GOS的linux系统版本是：Linux version 4.14.156；6125项目的kernal代码版本是Linux version 4.14.112的。因此这个报错行数参考意义不大。</p>
<p>从上面日志已经可以大概猜测到是发送的数据量过大。当前的binder_transaction_data的大小是637140字节。</p>
<h4 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="comment">// BINDER_VM_SIZE binder的一次消息传送大小为1M - 8k</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)</span></span><br><span class="line"></span><br><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        <span class="comment">// 构造方法中调用mmap将申请的大小传给binder驱动</span></span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            ALOGE(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.c_str());</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; <span class="number">0</span>, <span class="string">&quot;Binder driver could not be opened.  Terminating.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/msm-4.14/drivers/android/binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="comment">// 如果传入的值大于4M，最多只申请4M</span></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正去分配内存的地方</span></span><br><span class="line">	ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	mutex_lock(&amp;proc-&gt;files_lock);</span><br><span class="line">	proc-&gt;files = get_files_struct(current);</span><br><span class="line">	mutex_unlock(&amp;proc-&gt;files_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bad_arg:</span><br><span class="line">	pr_err(<span class="string">&quot;%s: %d %lx-%lx %s failed %d\n&quot;</span>, __func__,</span><br><span class="line">	       proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/msm-4.14/drivers/android/binder_alloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_alloc_mmap_handler</span><span class="params">(struct binder_alloc *alloc,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	alloc-&gt;buffer = (<span class="keyword">void</span> __user *)vma-&gt;vm_start;</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 申请内核空间内存</span></span><br><span class="line">	alloc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(alloc-&gt;pages[<span class="number">0</span>]) *</span><br><span class="line">				   ((vma&gt;vm_end - vma-&gt;vm_start)- / PAGE_SIZE),</span><br><span class="line">			       GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">&quot;alloc page array&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存binder_buffer指针地址</span></span><br><span class="line">	buffer = kzalloc(<span class="keyword">sizeof</span>(*buffer), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">&quot;alloc buffer struct&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_buf_struct_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!非oneway的传输方式user_data大小就是用户空间传入的大小。</span></span><br><span class="line">	buffer-&gt;user_data = alloc-&gt;buffer;</span><br><span class="line">	list_add(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers);</span><br><span class="line">	buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">	binder_insert_free_buffer(alloc, buffer);</span><br><span class="line">    <span class="comment">// !!!oneway模式传输方式，free_async_space空间只有用户空间传入空间大小的一半。</span></span><br><span class="line">	alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">	binder_alloc_set_vma(alloc, vma);</span><br><span class="line">	mmgrab(alloc-&gt;vma_vm_mm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到如果binder采用Binder oneway方式通信，数据的传输空间大小只有<code>(1M - 8k) / 2</code>，即520190字节。</p>
<p>因此，需要模块具体调查哪个信号传输的数据超过了508kb。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>Binder异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder子系统之调试分析(二)</title>
    <url>/2021/09/22/Binder%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="一-节点创建"><a href="#一-节点创建" class="headerlink" title="一. 节点创建"></a>一. 节点创建</h2><p>上一篇文章已经介绍了binder子系统调试的一些手段,这篇文章再来挑选系统几个核心服务进程来进行分析.</p>
<h4 id="1-1-内核编译选项"><a href="#1-1-内核编译选项" class="headerlink" title="1.1 内核编译选项"></a>1.1 内核编译选项</h4><p>如果系统关闭了debugfs，则通过编辑<code>kernel/arch/arm/configs/×××_defconfig</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;开启debugfs</span><br><span class="line">CONFIG_DEBUG_FS&#x3D;y</span><br><span class="line">&#x2F;&#x2F;有时，可能还需要配置fs的白名单列表，例如：</span><br><span class="line">CONFIG_DEBUG_FS_WHITE_LIST&#x3D;&quot;:&#x2F;tracing:&#x2F;binder:&#x2F;wakeup_sources:&quot;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-创建debugfs"><a href="#1-2-创建debugfs" class="headerlink" title="1.2 创建debugfs"></a>1.2 创建debugfs</h4><p>首先debugfs文件系统默认挂载在节点<code>/sys/kernel/debug</code>，binder驱动初始化的过程会在该节点下先创建<code>/binder</code>目录，然后在该目录下创建下面文件和目录：</p>
<ul>
<li>proc/</li>
<li>stats</li>
<li>state</li>
<li>transactions</li>
<li>transaction_log</li>
<li>failed_transaction_log</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建目录 &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;binder</span><br><span class="line">binder_debugfs_dir_entry_root &#x3D; debugfs_create_dir(&quot;binder&quot;, NULL);</span><br><span class="line">&#x2F;&#x2F;创建目录 &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;binder&#x2F;proc</span><br><span class="line">binder_debugfs_dir_entry_proc &#x3D; debugfs_create_dir(&quot;proc&quot;, binder_debugfs_dir_entry_root);</span><br><span class="line">&#x2F;&#x2F;创建文件&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;binder&#x2F;state</span><br><span class="line">debugfs_create_file(&quot;state&quot;,S_IRUGO, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops);</span><br></pre></td></tr></table></figure>
<p>另外，<code>/d</code>其实是指向<code>/sys/kernel/debug</code>的链接，也可以通过节点<code>/d/binder</code>来访问.</p>
<h2 id="二-节点分析"><a href="#二-节点分析" class="headerlink" title="二. 节点分析"></a>二. 节点分析</h2><p>接下来,看看系统创建的以下5个节点:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;d&#x2F;binder&#x2F;stats (整体以及各个进程的线程数,事务个数等的统计信息)</span><br><span class="line">&#x2F;d&#x2F;binder&#x2F;state (整体以及各个进程的thread&#x2F;node&#x2F;ref&#x2F;buffer的状态信息)</span><br><span class="line">&#x2F;d&#x2F;binder&#x2F;failed_transaction_log (记录32条最近的传输失败事件)</span><br><span class="line">&#x2F;d&#x2F;binder&#x2F;transaction_log (记录32条最近的传输事件)</span><br><span class="line">&#x2F;d&#x2F;binder&#x2F;transactions (遍历所有进程的buffer分配情况)</span><br></pre></td></tr></table></figure>
<p>每个节点所相应的Binder驱动中的输出函数为binder_xxx_show. 例如/d/binder/stats的节点信息,所对应的输出函数binder_stats_show.</p>
<h3 id="2-1-stats"><a href="#2-1-stats" class="headerlink" title="2.1 stats"></a>2.1 stats</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;d&#x2F;binder&#x2F;stats</span><br></pre></td></tr></table></figure>
<p>执行上述语句，所对应的函数<code>binder_stats_show</code>，所输出结果分两部分：</p>
<ol>
<li>整体统计信息<ul>
<li>所有BC_XXX命令的次数；</li>
<li>所有BR_XXX命令的次数；</li>
<li>输出<code>binder_stat_types</code>各个类型的active和total；</li>
</ul>
</li>
<li>遍历所有进程的统计信息：<ul>
<li>当前进程相关的统计信息；</li>
<li>所有BC_XXX命令的次数；</li>
<li>所有BR_XXX命令的次数；</li>
</ul>
</li>
</ol>
<p>其中active是指当前系统存活的个数，total是指系统从开机到现在总共创建过的个数。下面举例来说明输出结果的含义：</p>
<h4 id="2-1-1-整体信息"><a href="#2-1-1-整体信息" class="headerlink" title="2.1.1 整体信息"></a>2.1.1 整体信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binder stats:</span><br><span class="line">BC_TRANSACTION: 235258</span><br><span class="line">BC_REPLY: 163048</span><br><span class="line">BC_FREE_BUFFER: 397853</span><br><span class="line">BC_INCREFS: 22573</span><br><span class="line">BC_ACQUIRE: 22735</span><br><span class="line">BC_RELEASE: 15840</span><br><span class="line">BC_DECREFS: 15810</span><br><span class="line">BC_INCREFS_DONE: 9517</span><br><span class="line">BC_ACQUIRE_DONE: 9518</span><br><span class="line">BC_REGISTER_LOOPER: 421</span><br><span class="line">BC_ENTER_LOOPER: 284</span><br><span class="line">BC_REQUEST_DEATH_NOTIFICATION: 4696</span><br><span class="line">BC_CLEAR_DEATH_NOTIFICATION: 3707</span><br><span class="line">BC_DEAD_BINDER_DONE: 400</span><br><span class="line">BR_TRANSACTION: 235245</span><br><span class="line">BR_REPLY: 163045</span><br><span class="line">BR_DEAD_REPLY: 3</span><br><span class="line">BR_TRANSACTION_COMPLETE: 398300</span><br><span class="line">BR_INCREFS: 9517</span><br><span class="line">BR_ACQUIRE: 9518</span><br><span class="line">BR_RELEASE: 5448</span><br><span class="line">BR_DECREFS: 5447</span><br><span class="line">BR_SPAWN_LOOPER: 462</span><br><span class="line">BR_DEAD_BINDER: 400</span><br><span class="line">BR_CLEAR_DEATH_NOTIFICATION_DONE: 3707</span><br><span class="line">BR_FAILED_REPLY: 3</span><br><span class="line"></span><br><span class="line">proc: active 78 total 382</span><br><span class="line">thread: active 530 total 3196</span><br><span class="line">node: active 1753 total 8134</span><br><span class="line">ref: active 2604 total 13422</span><br><span class="line">death: active 530 total 3991</span><br><span class="line">transaction: active 0 total 195903</span><br><span class="line">transaction_complete: active 0 total 195903</span><br></pre></td></tr></table></figure>
<p>可知：</p>
<ul>
<li>当前系统binder_proc个数为78，binder_thread个数为530，binder_node为1753等信息；</li>
<li>从开机到现在共创建过382个binder_proc，3196个binder_thread等；</li>
<li>transaction active等于零，目前没有活动的transaction事务</li>
</ul>
<p><code>规律:</code> BC_TRANSACTION + BC_REPLY = BR_TRANSACTION_COMPLETE + BR_DEAD_REPLY + BR_FAILED_REPLY</p>
<p>为什么是会是这样呢,因为每次BC_TRANSACTION或着BC_REPLY,都是有相应的BR_TRANSACTION_COMPLETE,在传输不出异常的情况下这个次数是相等,有时候并能transaction成功, 所以还需要加上BR_DEAD_REPLY和BR_FAILED_REPLY的情况.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-736540cf8b684e4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder交互图.png"></p>
<h4 id="2-1-2-各进程信息"><a href="#2-1-2-各进程信息" class="headerlink" title="2.1.2 各进程信息"></a>2.1.2 各进程信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proc 14328</span><br><span class="line">  threads: 3 &#x2F;&#x2F;binder_thread个数</span><br><span class="line">  &#x2F;&#x2F;requested_threads(请求线程数) + requested_threads_started(已启动线程数) &#x2F; max_threads(最大线程数)</span><br><span class="line">  requested threads: 0+1&#x2F;15</span><br><span class="line">  ready threads 2 &#x2F;&#x2F; ready_threads(准备就绪的线程数)</span><br><span class="line">  free async space 520192 &#x2F;&#x2F;可用的异步空间约为520k</span><br><span class="line">  nodes: 3 &#x2F;&#x2F;binder_node个数</span><br><span class="line">  refs: 9 s 9 w 9 &#x2F;&#x2F;引用次数，强引用次数，弱引用次数次数</span><br><span class="line">  buffers: 0 &#x2F;&#x2F;allocated_buffers(已分配的buffer个数)</span><br><span class="line">  pending transactions: 0 &#x2F;&#x2F;proc的todo队列事务个数</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;该进程中BC_XXX 和BR_XXX命令执行次数</span><br><span class="line">  BC_TRANSACTION: 21</span><br><span class="line">  BC_FREE_BUFFER: 24</span><br><span class="line">  BC_INCREFS: 9</span><br><span class="line">  BC_ACQUIRE: 9</span><br><span class="line">  BC_INCREFS_DONE: 3</span><br><span class="line">  BC_ACQUIRE_DONE: 3</span><br><span class="line">  BC_REGISTER_LOOPER: 1</span><br><span class="line">  BC_ENTER_LOOPER: 1</span><br><span class="line">  BC_REQUEST_DEATH_NOTIFICATION: 1</span><br><span class="line">  BR_TRANSACTION: 4</span><br><span class="line">  BR_REPLY: 20</span><br><span class="line">  BR_TRANSACTION_COMPLETE: 21</span><br><span class="line">  BR_INCREFS: 3</span><br><span class="line">  BR_ACQUIRE: 3</span><br><span class="line">  BR_SPAWN_LOOPER: 1</span><br></pre></td></tr></table></figure>
<p>可知进程14328：</p>
<ul>
<li>共有3个binder_thread，最大线程个数上限为15.</li>
<li>共有3个binder_node， 9个binder_ref。</li>
<li>已分配binder_buffer为零，异步可用空间约为520k；</li>
<li>proc-&gt;todo队列为空；</li>
</ul>
<p><strong>Debug Tips：</strong></p>
<ul>
<li>当binder内存紧张时，可查看<code>free async space</code>和<code>buffers:</code>字段；</li>
<li>当系统空闲时，一般来说<code>ready_threads</code> = <code>requested_threads_started</code> + <code>BC_ENTER_LOOPER</code>； 当系统繁忙时<code>ready_threads</code>可能为0.</li>
<li>例如system_server进程的<code>ready_threads</code>线程个数越少，系统可能处于越繁忙的状态；</li>
<li>绝大多数的进程<code>max_threads</code> = 15，而surfaceflinger最大线程个数为4，servicemanager最大线程个数为0(只有主线程)；</li>
<li><code>pending transactions</code>:是指该进程的todo队列事务个数</li>
</ul>
<p>例如，想查看当前系统所有进程的异步可用内存情况，可执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell cat &#x2F;d&#x2F;binder&#x2F;stats | egrep &quot;proc |free async space&quot;</span><br></pre></td></tr></table></figure>
<h4 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct binder_stats &#123;</span><br><span class="line">	int br[_IOC_NR(BR_FAILED_REPLY) + 1]; &#x2F;&#x2F;统计各个binder响应码的个数</span><br><span class="line">	int bc[_IOC_NR(BC_DEAD_BINDER_DONE) + 1]; &#x2F;&#x2F;统计各个binder请求码的个数</span><br><span class="line">	int obj_created[BINDER_STAT_COUNT]; &#x2F;&#x2F;统计各种obj的创建个数</span><br><span class="line">	int obj_deleted[BINDER_STAT_COUNT]; &#x2F;&#x2F;统计各种obj的删除个数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中obj的个数由一个枚举变量<code>binder_stat_types</code>定义。</p>
<p>统计创建与删除的对象</p>
<p><code>binder_stat_types</code>中定义的量：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BINDER_STAT_PROC</td>
<td align="left">binder进程</td>
</tr>
<tr>
<td align="left">BINDER_STAT_THREAD</td>
<td align="left">binder线程</td>
</tr>
<tr>
<td align="left">BINDER_STAT_NODE</td>
<td align="left">binder节点</td>
</tr>
<tr>
<td align="left">BINDER_STAT_REF</td>
<td align="left">binder引用</td>
</tr>
<tr>
<td align="left">BINDER_STAT_DEATH</td>
<td align="left">binder死亡</td>
</tr>
<tr>
<td align="left">BINDER_STAT_TRANSACTION</td>
<td align="left">binder事务</td>
</tr>
<tr>
<td align="left">BINDER_STAT_TRANSACTION_COMPLETE</td>
<td align="left">binder已完成事务</td>
</tr>
</tbody></table>
<p>每个类型相应的调用方法：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">创建调用</th>
<th align="left">删除调用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BINDER_STAT_PROC</td>
<td align="left">binder_open</td>
<td align="left">binder_deferred_release</td>
</tr>
<tr>
<td align="left">BINDER_STAT_THREAD</td>
<td align="left">binder_get_thread</td>
<td align="left">binder_free_thread</td>
</tr>
<tr>
<td align="left">BINDER_STAT_NODE</td>
<td align="left">binder_new_node</td>
<td align="left">binder_thread_read/ binder_node_release/ binder_dec_node</td>
</tr>
<tr>
<td align="left">BINDER_STAT_REF</td>
<td align="left">binder_get_ref_for_node</td>
<td align="left">binder_delete_ref</td>
</tr>
<tr>
<td align="left">BINDER_STAT_DEATH</td>
<td align="left">binder_thread_write</td>
<td align="left">binder_thread_read/ binder_release_work/ binder_delete_ref</td>
</tr>
<tr>
<td align="left">BINDER_STAT_TRANSACTION</td>
<td align="left">binder_transaction</td>
<td align="left">binder_thread_read/ binder_transaction/ binder_release_work/ binder_pop_transaction</td>
</tr>
<tr>
<td align="left">BINDER_STAT_TRANSACTION_COMPLETE</td>
<td align="left">binder_transaction</td>
<td align="left">binder_thread_read/ binder_transaction/ binder_release_work</td>
</tr>
</tbody></table>
<h3 id="2-2-state"><a href="#2-2-state" class="headerlink" title="2.2 state"></a>2.2 state</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;d&#x2F;binder&#x2F;state</span><br></pre></td></tr></table></figure>
<p>执行上述语句，所对应的函数<code>binder_state_show</code>，输出当前系统binder_proc, binder_node等信息；</p>
<h4 id="2-2-1-整体信息"><a href="#2-2-1-整体信息" class="headerlink" title="2.2.1 整体信息"></a>2.2.1 整体信息</h4><p>输出所有死亡节点的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dead nodes:</span><br><span class="line">  node 24713573: u0000007f9fe0c6c0 c0000007f9fe63700 hs 1 hw 1 ls 0 lw 0 is 1 iw 1 proc 12396</span><br><span class="line">  node 24712275: u0000007f9d5f0a80 c0000007fa82d1880 hs 1 hw 1 ls 0 lw 0 is 1 iw 1 proc 12396</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-各进程信息"><a href="#2-2-2-各进程信息" class="headerlink" title="2.2.2 各进程信息"></a>2.2.2 各进程信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proc <span class="number">18650</span></span><br><span class="line">  thread <span class="number">18650</span>: l <span class="number">00</span></span><br><span class="line">  thread <span class="number">18658</span>: l <span class="number">00</span></span><br><span class="line">  thread <span class="number">18663</span>: l <span class="number">12</span></span><br><span class="line">  thread <span class="number">18665</span>: l <span class="number">11</span></span><br><span class="line">  node <span class="number">24805986</span>: u00000000e153f070 c00000000e197dd80 hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span> is <span class="number">1</span> iw <span class="number">1</span> proc <span class="number">12396</span></span><br><span class="line">  node <span class="number">24805990</span>: u00000000e153f090 c00000000e197dda0 hs <span class="number">1</span> hw <span class="number">1</span> ls <span class="number">0</span> lw <span class="number">0</span> is <span class="number">1</span> iw <span class="number">1</span> proc <span class="number">12396</span></span><br><span class="line">  ref <span class="number">24804528</span>: desc <span class="number">0</span> node <span class="number">1</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  ref <span class="number">24804531</span>: desc <span class="number">1</span> node <span class="number">24532956</span> s <span class="number">1</span> w <span class="number">1</span> d <span class="number">0000000000000000</span></span><br><span class="line">  buffer <span class="number">24805817</span>: ffffff8018e00050 size <span class="number">1896</span>:<span class="number">0</span> delivered</span><br><span class="line">  buffer <span class="number">24806788</span>: ffffff8018e00808 size <span class="number">152</span>:<span class="number">0</span> delivered</span><br></pre></td></tr></table></figure>
<p>遍历进程的thread/node/ref/buffer信息. 当然如果存在,还会有pending transaction信息.</p>
<p>Tips:</p>
<ul>
<li>pending transaction: 记录当前所有进程和线程 TODO队列的transaction.</li>
<li>outgoing transaction: 当前线程transaction_stack, 由该线程发出的事务;</li>
<li>incoming transaction: 当前线程transaction_stack, 由需要线程接收的事务;</li>
<li>pending transactions: 记录当前进程总的pending事务;</li>
</ul>
<h4 id="2-2-3-proc"><a href="#2-2-3-proc" class="headerlink" title="2.2.3 proc"></a>2.2.3 proc</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;d&#x2F;binder&#x2F;proc&#x2F;&lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p>可查看单独每个进程更为详细的信息，锁对应的函数<code>binder_proc_show</code>. 这个等价于小节[2.2.2]的内容.</p>
<h3 id="2-3-transactions"><a href="#2-3-transactions" class="headerlink" title="2.3 transactions"></a>2.3 transactions</h3><h4 id="2-3-1-各进程信息"><a href="#2-3-1-各进程信息" class="headerlink" title="2.3.1 各进程信息"></a>2.3.1 各进程信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binder transactions:</span><br><span class="line">proc 20256</span><br><span class="line">  buffer 348035: ffffff800a280050 size 212:0 delivered</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>pid=20256进程，buffer的data_size=212，offsets_size=0，delivered代表已分发的内存块</li>
<li>该命令遍历输出所有进程的情况，可以看出每个进程buffer的分发情况。</li>
</ul>
<p>其实, [小节2.2] state的信息是[小节2.3]的超集, 拥有比这个更为全面, 详细的信息. 比如binder_ref信息只在state里面才有.</p>
<h3 id="2-4-transaction-log"><a href="#2-4-transaction-log" class="headerlink" title="2.4 transaction_log"></a>2.4 transaction_log</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;d&#x2F;binder&#x2F;transaction_log</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">357140: async from 8963:9594 to 10777:0 node 145081 handle 717 size 172:0</span><br><span class="line">357141: call  from 8963:9594 to 435:0 node 1 handle 0 size 80:0</span><br><span class="line">357142: reply from 435:435 to 8963:9594 node 0 handle 0 size 24:8</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug_id&#96;: &#96;call_type&#96; from &#96;from_proc&#96;:&#96;from_thread&#96; to &#96;to_proc&#96;:&#96;to_thread&#96; node &#96;to_node&#96; handle &#96;target_handle&#96; size &#96;data_size&#96;:&#96;offsets_size</span><br></pre></td></tr></table></figure>
<p>call_type：有3种，分别为async, call, reply.</p>
<p>此处的data_size单位是字节数.</p>
<p><code>transaction_log</code>以及还有<code>binder_transaction_log_failed</code>会只会记录最近的32次的transaction过程.</p>
<h3 id="2-5-failed-transaction-log"><a href="#2-5-failed-transaction-log" class="headerlink" title="2.5 failed_transaction_log"></a>2.5 failed_transaction_log</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24423418: async from 713:713 to 1731:0 node 1809 handle 1 size 156:0</span><br><span class="line">24423419: reply from 733:5038 to 1731:4738 node 0 handle -1 size 0:0</span><br><span class="line">0: async from 782:1138 to 0:0 node 974 handle 8 size 88:8</span><br></pre></td></tr></table></figure>
<p>解释: 跟transaction_log是一个原理, 不同的时此处有时候to_proc=0,代表着远程进程已挂.</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式测试代码</title>
    <url>/2020/09/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h4 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h4><h5 id="1-1-普通工程模式"><a href="#1-1-普通工程模式" class="headerlink" title="1.1 普通工程模式"></a>1.1 普通工程模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is mail sender!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is sms sender!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;mail&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sms&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入正确的类型!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-2-多个工厂方法模式"><a href="#1-2-多个工厂方法模式" class="headerlink" title="1.2 多个工厂方法模式"></a>1.2 多个工厂方法模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">        Sender sender = factory.produceMail();</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-3-静态工厂方法模式"><a href="#1-3-静态工厂方法模式" class="headerlink" title="1.3 静态工厂方法模式"></a>1.3 静态工厂方法模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sender sender = SendFactory.produceMail();</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-4-抽象工厂模式"><a href="#1-4-抽象工厂模式" class="headerlink" title="1.4 抽象工厂模式"></a>1.4 抽象工厂模式</h5><p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is mail sender!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is sms sender!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSmsFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Provider provider = <span class="keyword">new</span> SendMailFactory();</span><br><span class="line">        Sender sender = provider.produce();</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-建造者模式"><a href="#2-建造者模式" class="headerlink" title="2.建造者模式"></a>2.建造者模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 角色Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">buildFoot</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function">Person <span class="title">buildPerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManBuilder</span> <span class="keyword">implements</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">     Person person;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ManBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          person = <span class="keyword">new</span> Man();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildbody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          person.setBody(<span class="string">&quot;建造男人的身体&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          person.setFoot(<span class="string">&quot;建造男人的脚&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          person.setHead(<span class="string">&quot;建造男人的头&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Person <span class="title">buildPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> person;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-适配器模式"><a href="#3-适配器模式" class="headerlink" title="3.适配器模式"></a>3.适配器模式</h4><h5 id="3-1-类的适配器模式"><a href="#3-1-类的适配器模式" class="headerlink" title="3.1 类的适配器模式"></a>3.1 类的适配器模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is original method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 与原类中的方法相同 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 新类的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is the targetable method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Targetable target = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target.method1();</span><br><span class="line">        target.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-2-对象的适配器模式"><a href="#3-2-对象的适配器模式" class="headerlink" title="3.2 对象的适配器模式"></a>3.2 对象的适配器模式</h5><p>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，这次不继承Source 类，而是持有 Source 类的实例，以达到解决兼容性的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is the targetable method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        source.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-接口的适配器模式"><a href="#3-3-接口的适配器模式" class="headerlink" title="3.3 接口的适配器模式"></a>3.3 接口的适配器模式</h5><p>接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。</p>
<h4 id="4-装饰模式（Decorator）"><a href="#4-装饰模式（Decorator）" class="headerlink" title="4.装饰模式（Decorator）"></a>4.装饰模式（Decorator）</h4><p>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the original method!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sourceable source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Sourceable source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before decorator!&quot;</span>);</span><br><span class="line">        source.method();</span><br><span class="line">        System.out.println(<span class="string">&quot;after decorator!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sourceable source = <span class="keyword">new</span> Source();</span><br><span class="line">        Sourceable obj = <span class="keyword">new</span> Decorator(source);</span><br><span class="line">        obj.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-策略模式（strategy）"><a href="#5-策略模式（strategy）" class="headerlink" title="5.策略模式（strategy）"></a>5.<strong>策略模式（strategy）</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arrayInt[] = split(exp, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arrayInt[<span class="number">0</span>] - arrayInt[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arrayInt[] = split(exp, <span class="string">&quot;\\+&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arrayInt[<span class="number">0</span>] + arrayInt[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] split(String exp, String opt) &#123;</span><br><span class="line">        String array[] = exp.split(opt);</span><br><span class="line">        <span class="keyword">int</span> arrayInt[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        arrayInt[<span class="number">0</span>] = Integer.parseInt(array[<span class="number">0</span>]);</span><br><span class="line">        arrayInt[<span class="number">1</span>] = Integer.parseInt(array[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> arrayInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String exp = <span class="string">&quot;2+8&quot;</span>;</span><br><span class="line">        ICalculator cal = <span class="keyword">new</span> Plus();</span><br><span class="line">        <span class="keyword">int</span> result = cal.calculate(exp);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-观察者模式（Observer）"><a href="#6-观察者模式（Observer）" class="headerlink" title="6.观察者模式（Observer）"></a>6.观察者模式（Observer）</h4><p>观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;observer1 has received!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;observer2 has received!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>被观察者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*增加观察者*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除观察者*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*通知所有的观察者*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*自身的操作*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; vector = <span class="keyword">new</span> Vector&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        vector.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        vector.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enumeration&lt;Observer&gt; enumo = vector.elements();</span><br><span class="line">        <span class="keyword">while</span> (enumo.hasMoreElements()) &#123;</span><br><span class="line">            enumo.nextElement().update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySubject</span> <span class="keyword">extends</span> <span class="title">AbstractSubject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update self!&quot;</span>);</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject sub = <span class="keyword">new</span> MySubject();</span><br><span class="line">        sub.add(<span class="keyword">new</span> Observer1());</span><br><span class="line">        sub.add(<span class="keyword">new</span> Observer2());</span><br><span class="line">        sub.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder子系统-驱动分析篇</title>
    <url>/2020/09/22/Binder%E5%AD%90%E7%B3%BB%E7%BB%9F-%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90%E7%AF%87/</url>
    <content><![CDATA[<h4 id="1-Linux进程通讯机制有哪些"><a href="#1-Linux进程通讯机制有哪些" class="headerlink" title="1.Linux进程通讯机制有哪些"></a>1.Linux进程通讯机制有哪些</h4><p>共享内存、Socket、消息队列、管道。</p>
<h4 id="2-Binder与传统IPC对比"><a href="#2-Binder与传统IPC对比" class="headerlink" title="2.Binder与传统IPC对比"></a>2.Binder与传统IPC对比</h4><table>
<thead>
<tr>
<th></th>
<th>Binder</th>
<th>共享内存</th>
<th>Socket</th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>需要拷贝一次</td>
<td>无需拷贝</td>
<td>需要拷贝两次</td>
</tr>
<tr>
<td>特点</td>
<td>基于C/S架构，易用性高</td>
<td>控制复杂，易用性低</td>
<td>基于C/S架构，作为一款通讯接口，其传输效率低，开销大</td>
</tr>
<tr>
<td>安全性</td>
<td>为每个APP分配UID，同时支持实名和匿名</td>
<td>依赖上层协议，访问接入点是开放的不安全</td>
<td>依赖上层协议，访问接入点是开放的不安全</td>
</tr>
</tbody></table>
<h4 id="2-Binder整体架构"><a href="#2-Binder整体架构" class="headerlink" title="2.Binder整体架构"></a>2.Binder整体架构</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-79cb8538e8038504.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder子系统架构.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-3707389390e7e6b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder所涉及的类.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-fa6a4a996cdda8b1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder驱动.jpg"></p>
<h4 id="3-Binder驱动方法解析"><a href="#3-Binder驱动方法解析" class="headerlink" title="3.Binder驱动方法解析"></a>3.Binder驱动方法解析</h4><h5 id="3-1-binder-init"><a href="#3-1-binder-init" class="headerlink" title="3.1 binder_init()"></a>3.1 binder_init()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernal/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="comment">// 驱动设备初始化会调用到binder_init()</span></span><br><span class="line">device_initcall(binder_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">char</span> *device_name, *device_names;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建名为binder的单线程工作队列</span></span><br><span class="line">	binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">&quot;binder&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">&quot;binder&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">		binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">&quot;proc&quot;</span>,</span><br><span class="line">						 binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;state&quot;</span>,</span><br><span class="line">				    S_IRUGO,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_state_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;stats&quot;</span>,</span><br><span class="line">				    S_IRUGO,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_stats_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;transactions&quot;</span>,</span><br><span class="line">				    S_IRUGO,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_transactions_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;transaction_log&quot;</span>,</span><br><span class="line">				    S_IRUGO,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    &amp;binder_transaction_log,</span><br><span class="line">				    &amp;binder_transaction_log_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;failed_transaction_log&quot;</span>,</span><br><span class="line">				    S_IRUGO,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    &amp;binder_transaction_log_failed,</span><br><span class="line">				    &amp;binder_transaction_log_fops);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy the module_parameter string, because we don&#x27;t want to</span></span><br><span class="line"><span class="comment">	 * tokenize it in-place.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!device_names) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_device_names_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从配置文件KConfig中读取binder的名字</span></span><br><span class="line">	<span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="string">&quot;,&quot;</span>))) &#123;</span><br><span class="line">		ret = init_binder_device(device_name);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建一个工作队列，如果开启了debugfs功能，则挂载proc/、stats、state、transactions、transaction_log<br>、failed_transaction_log节点。</p>
<p>然后根据配置文件（kernal/drivers/staging/android/Kconfig）中的设备名(ANDROID_BINDER_DEVICES)，分配内存，并且将设备名传到init_binder_device()方法中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_binder_device</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 分配binder_device内存</span></span><br><span class="line">   binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">   <span class="keyword">if</span> (!binder_device)</span><br><span class="line">      <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化binder_device结构体，将binder_fops操作方法注册到内核中</span></span><br><span class="line">   binder_device-&gt;miscdev.fops = &amp;binder_fops;</span><br><span class="line">   binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">   binder_device-&gt;miscdev.name = name;</span><br><span class="line"></span><br><span class="line">   binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">   binder_device-&gt;context.name = name;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册misc设备</span></span><br><span class="line">   ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">   <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      kfree(binder_device);</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将binder_device-&gt;hlist添加到binder_devices中</span></span><br><span class="line">   hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所注册的操作方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="3-2-binder-open"><a href="#3-2-binder-open" class="headerlink" title="3.2 binder_open()"></a>3.2 binder_open()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_dev</span>;</span></span><br><span class="line"></span><br><span class="line">	binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;binder_open: %d:%d\n&quot;</span>,</span><br><span class="line">		     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line"></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;   <span class="comment">//将当前线程的task保存到binder进程的tsk</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);  <span class="comment">//将当前进程的nice值转换为进程优先级</span></span><br><span class="line">	binder_dev = container_of(filp-&gt;private_data, struct binder_device,</span><br><span class="line">				  miscdev);</span><br><span class="line">	proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);   <span class="comment">//开启同步锁</span></span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);   <span class="comment">//binder_proc对象创建数加1</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);  <span class="comment">//将proc_node节点添加到binder_procs的队列头部</span></span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);  <span class="comment">// 初始化已分发的死亡通知列表</span></span><br><span class="line">	filp-&gt;private_data = proc;  <span class="comment">//将这个binder_proc与filp关联起来，这样下次通过filp就能找到这个proc</span></span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);   <span class="comment">//释放同步锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">		<span class="keyword">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * proc debug entries are shared between contexts, so</span></span><br><span class="line"><span class="comment">		 * this will fail if the process tries to open the driver</span></span><br><span class="line"><span class="comment">		 * again with a different context. The priting code will</span></span><br><span class="line"><span class="comment">		 * anyway print all contexts that a given PID has, so this</span></span><br><span class="line"><span class="comment">		 * is not a problem.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,</span><br><span class="line">			binder_debugfs_dir_entry_proc,</span><br><span class="line">			(<span class="keyword">void</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)proc-&gt;pid,</span><br><span class="line">			&amp;binder_proc_fops);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-3-binder-mmap"><a href="#3-3-binder-mmap" class="headerlink" title="3.3 binder_mmap()"></a>3.3 binder_mmap()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">binder_vm_ops</span> =</span> &#123;</span><br><span class="line">   .open = binder_vma_open,</span><br><span class="line">   .close = binder_vma_close,</span><br><span class="line">   .fault = binder_vm_fault,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vma进程的虚拟内存</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (proc-&gt;tsk != current)</span><br><span class="line">      <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户最大设置4M</span></span><br><span class="line">   <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">      vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">   binder_debug(BINDER_DEBUG_OPEN_CLOSE,</span><br><span class="line">           <span class="string">&quot;binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n&quot;</span>,</span><br><span class="line">           proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end,</span><br><span class="line">           (vma-&gt;vm_end - vma-&gt;vm_start) / SZ_1K, vma-&gt;vm_flags,</span><br><span class="line">           (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pgprot_val(vma-&gt;vm_page_prot));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">      ret = -EPERM;</span><br><span class="line">      failure_string = <span class="string">&quot;bad vm_flags&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">   &#125;</span><br><span class="line">   vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line"></span><br><span class="line">   mutex_lock(&amp;binder_mmap_lock);</span><br><span class="line">   <span class="comment">//如果已经做过映射了直接返回错误</span></span><br><span class="line">   <span class="keyword">if</span> (proc-&gt;buffer) &#123;</span><br><span class="line">      ret = -EBUSY;</span><br><span class="line">      failure_string = <span class="string">&quot;already mapped&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//采用 VM_IOREMAP方式分配一块与进程虚拟内存一样大的连续内核空间</span></span><br><span class="line">   area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">   <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      failure_string = <span class="string">&quot;get_vm_area&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//binder进程的buffer指针指向上面分配的内核空间</span></span><br><span class="line">   proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">   <span class="comment">//计算出内核空间与用户空间的偏移地址。偏移地址=用户空间地址 - 内核空间地址</span></span><br><span class="line">   proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">   mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPU_CACHE_VIPT</span></span><br><span class="line">   <span class="keyword">if</span> (cache_is_vipt_aliasing()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (CACHE_COLOUR((vma-&gt;vm_start ^ (<span class="keyword">uint32_t</span>)proc-&gt;buffer))) &#123;</span><br><span class="line">         pr_info(<span class="string">&quot;binder_mmap: %d %lx-%lx maps %p bad alignment\n&quot;</span>, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);</span><br><span class="line">         vma-&gt;vm_start += PAGE_SIZE;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="comment">//分配物理页的指针数组，数组大小为vma的等效page个</span></span><br><span class="line">   proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">   <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      failure_string = <span class="string">&quot;alloc page array&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//计算用户空间需要多大</span></span><br><span class="line">   proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">   vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">   vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//分配物理页面，同时映射到内核空间和进程空间，先分配1个物理页，PAGE_SIZE==4kb。后面不够再分配</span></span><br><span class="line">   <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">      ret = -ENOMEM;</span><br><span class="line">      failure_string = <span class="string">&quot;alloc small buf&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">   &#125;</span><br><span class="line">   buffer = proc-&gt;buffer;</span><br><span class="line">   INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">   <span class="comment">//将buffer连入buffers链表中</span></span><br><span class="line">   list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</span><br><span class="line">   buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>; <span class="comment">//设置此内存可用</span></span><br><span class="line">   binder_insert_free_buffer(proc, buffer); <span class="comment">//将buffer插入 proc-&gt;free_buffers 链表中</span></span><br><span class="line">   proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>; <span class="comment">// 异步的可用空闲空间大小</span></span><br><span class="line">   barrier();</span><br><span class="line">   proc-&gt;files = get_files_struct(current);</span><br><span class="line">   proc-&gt;vma = vma;</span><br><span class="line">   proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*pr_info(&quot;binder_mmap: %d %lx-%lx maps %p\n&quot;,</span></span><br><span class="line"><span class="comment">       proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);*/</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_insert_free_buffer</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">				      struct binder_buffer *new_buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;proc-&gt;free_buffers.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> buffer_size;</span><br><span class="line">	<span class="keyword">size_t</span> new_buffer_size;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!new_buffer-&gt;<span class="built_in">free</span>);</span><br><span class="line"></span><br><span class="line">	new_buffer_size = binder_buffer_size(proc, new_buffer);</span><br><span class="line"></span><br><span class="line">	binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">		     <span class="string">&quot;%d: add free buffer, size %zd, at %p\n&quot;</span>,</span><br><span class="line">		      proc-&gt;pid, new_buffer_size, new_buffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		buffer = rb_entry(parent, struct binder_buffer, rb_node);</span><br><span class="line">		BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//binder_buffer_size计算空闲buffer的大小</span></span><br><span class="line">		buffer_size = binder_buffer_size(proc, buffer);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (new_buffer_size &lt; buffer_size)</span><br><span class="line">			p = &amp;parent-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p = &amp;parent-&gt;rb_right;</span><br><span class="line">	&#125;</span><br><span class="line">	rb_link_node(&amp;new_buffer-&gt;rb_node, parent, p);</span><br><span class="line">	<span class="comment">//将 buffer插入 proc-&gt;free_buffers 链表中</span></span><br><span class="line">	rb_insert_color(&amp;new_buffer-&gt;rb_node, &amp;proc-&gt;free_buffers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-4-binder-ioctl"><a href="#3-4-binder-ioctl" class="headerlink" title="3.4 binder_ioctl()"></a>3.4 binder_ioctl()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*pr_info(&quot;binder_ioctl: %d:%d %x %lx\n&quot;,</span></span><br><span class="line"><span class="comment">			proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></span><br><span class="line"></span><br><span class="line">	trace_binder_ioctl(cmd, arg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进入休眠状态，直到中断唤醒</span></span><br><span class="line">	ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line">	<span class="comment">//根据当前进程的pid，从binder_proc中查找binder_thread</span></span><br><span class="line">	<span class="comment">//如果当前线程已经加入到proc的线程队列则直接返回</span></span><br><span class="line">	<span class="comment">//如果不存在则创建binder_thread，并将当前线程添加到当前的proc</span></span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	<span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同cmd执行不同操作</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_MAX_THREADS:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">		ret = binder_ioctl_set_ctx_mgr(filp);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_THREAD_EXIT:</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS, <span class="string">&quot;%d:%d exit\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		binder_free_thread(proc, thread);</span><br><span class="line">		thread = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> __<span class="title">user</span> *<span class="title">ver</span> =</span> ubuf;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">			     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把用户空间数据ubuf拷贝到bwr,copy的是数据头</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">		     <span class="string">&quot;%d:%d write %lld at %016llx, read %lld at %016llx\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">		     (u64)bwr.write_size, (u64)bwr.write_buffer,</span><br><span class="line">		     (u64)bwr.read_size, (u64)bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当写缓存中有数据，则执行binder写操作</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		trace_binder_write_done(ret);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当有数据可读，则执行读操作</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		trace_binder_read_done(ret);</span><br><span class="line">		<span class="comment">//进程todo队列不为空,则唤醒该队列中的线程</span></span><br><span class="line">		<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">			wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">		     <span class="string">&quot;%d:%d wrote %lld of %lld, read return %lld of %lld\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">		     (u64)bwr.write_consumed, (u64)bwr.write_size,</span><br><span class="line">		     (u64)bwr.read_consumed, (u64)bwr.read_size);</span><br><span class="line">    <span class="comment">// 把内核空间数据bwr拷贝到ubuf</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-数据结构说明"><a href="#4-数据结构说明" class="headerlink" title="4.数据结构说明"></a>4.数据结构说明</h4><h5 id="4-1-file-operations"><a href="#4-1-file-operations" class="headerlink" title="4.1 file_operations"></a>4.1 file_operations</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123; .owner = THIS_MODULE, </span><br><span class="line">.poll = binder_poll, </span><br><span class="line">.unlocked_ioctl = binder_ioctl, </span><br><span class="line">.compat_ioctl = binder_ioctl, </span><br><span class="line">.mmap = binder_mmap, </span><br><span class="line">.open = binder_open, </span><br><span class="line">.flush = binder_flush, </span><br><span class="line">.release = binder_release, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-binder-proc"><a href="#4-2-binder-proc" class="headerlink" title="4.2 binder_proc"></a>4.2 binder_proc</h5><p>每个进程调用open()打开binder驱动都会创建该结构体，用于管理IPC所需的各种信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span> <span class="comment">// 进程节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span> <span class="comment">// binder_thread红黑树的根节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span> <span class="comment">// binder_node红黑树的根节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span> <span class="comment">// binder_ref红黑树的根节点(以handle为key) struct rb_root refs_by_node; // binder_ref红黑树的根节点（以ptr为key） </span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">// 相应进程id </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span> <span class="comment">// 指向进程虚拟地址空间的指针 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vma_vm_mm</span>;</span> <span class="comment">// 相应进程的内存结构体 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span> <span class="comment">//     相应进程的task结构体 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 相应进程的文件结构体 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> deferred_work; </span><br><span class="line">    <span class="keyword">void</span> *buffer; <span class="comment">// 内核空间的起始地址 </span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> user_buffer_offset; <span class="comment">// 内核空间与用户空间的地址偏移量 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span> <span class="comment">// 所有的buffer </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span> <span class="comment">// 空闲的buffer </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span> <span class="comment">// 已分配的buffer </span></span><br><span class="line">    <span class="keyword">size_t</span> free_async_space; <span class="comment">// 异步的可用空闲空间大小 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span> <span class="comment">// 指向物理内存页指针的指针 </span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size; <span class="comment">// 映射的内核空间大小 </span></span><br><span class="line">    <span class="keyword">uint32_t</span> buffer_free; <span class="comment">// 可用内存总大小 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span> <span class="comment">// 进程将要做的事 </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait; <span class="comment">// 等待队列 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span> <span class="comment">// binder统计信息 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span> <span class="comment">// 已分发的死亡通知 </span></span><br><span class="line">    <span class="keyword">int</span> max_threads; <span class="comment">// 最大线程数 </span></span><br><span class="line">    <span class="keyword">int</span> requested_threads; <span class="comment">// 请求的线程数 </span></span><br><span class="line">    <span class="keyword">int</span> requested_threads_started; <span class="comment">// 已启动的请求线程数 </span></span><br><span class="line">    <span class="keyword">int</span> ready_threads; <span class="comment">// 准备就绪的线程个数 </span></span><br><span class="line">    <span class="keyword">long</span> default_priority; <span class="comment">// 默认优先级 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="4-3-binder-node"><a href="#4-3-binder-node" class="headerlink" title="4.3 binder_node"></a>4.3 binder_node</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> debug_id; <span class="comment">// 节点创建时分配，具有全局唯一性，用于调试使用 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span> <span class="comment">// binder节点正常使用，union </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">dead_node</span>;</span> <span class="comment">// binder节点已销毁，union </span></span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span> <span class="comment">// binder所在的进程，见后面小节 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">refs</span>;</span> <span class="comment">// 所有指向该节点的    binder引用队列 </span></span><br><span class="line">    <span class="keyword">int</span> internal_strong_refs; </span><br><span class="line">    <span class="keyword">int</span> local_weak_refs; </span><br><span class="line">    <span class="keyword">int</span> local_strong_refs; </span><br><span class="line">    <span class="keyword">binder_uintptr_t</span> ptr; <span class="comment">// 指向用户空间    binder_node的指针,对应于 </span></span><br><span class="line">    flat_binder_object.binder </span><br><span class="line">    <span class="keyword">binder_uintptr_t</span> cookie; <span class="comment">// 指向用户空间    binder_node的指针，附件数据,对应于 flat_binder_object.cookie </span></span><br><span class="line">    <span class="keyword">unsigned</span> has_strong_ref:<span class="number">1</span>; <span class="comment">// 占位    1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> pending_strong_ref:<span class="number">1</span>; <span class="comment">// 占位    1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> has_weak_ref:<span class="number">1</span>; <span class="comment">// 占位    1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> pending_weak_ref:<span class="number">1</span>; <span class="comment">// 占位    1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> has_async_transaction:<span class="number">1</span>; <span class="comment">// 占位    1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> accept_fds:<span class="number">1</span>; <span class="comment">// 占位    1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> min_priority:<span class="number">8</span>; <span class="comment">// 占位    8bit，最小优先级 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_todo</span>;</span> <span class="comment">// 异步todo队列 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h5 id="4-4-binder-buffer"><a href="#4-4-binder-buffer" class="headerlink" title="4.4 binder_buffer"></a>4.4 binder_buffer</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">// buffer实体的地址 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span> <span class="comment">// buffer实体的地址 </span></span><br><span class="line">    <span class="comment">/* by address */</span> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>; <span class="comment">// 标记是否是空闲buffer，占位1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>; <span class="comment">// 是否允许用户释放，占位1bit unsigned async_transaction:1; // 占位1bit </span></span><br><span class="line">    <span class="keyword">unsigned</span> debug_id:<span class="number">29</span>; <span class="comment">// 占位29bit </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction</span>;</span> <span class="comment">// 该缓存区的需要处理的事务 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span>;</span> <span class="comment">// 该缓存区所需处理的Binder实体 size_t data_size; // 数据大小 </span></span><br><span class="line">    <span class="keyword">size_t</span> offsets_size; <span class="comment">// 数据偏移量 </span></span><br><span class="line">    <span class="keyword">size_t</span> extra_buffers_size; </span><br><span class="line">    <span class="keyword">uint8_t</span> data[<span class="number">0</span>]; <span class="comment">// 数据地址 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="5-binder的jni方法注册"><a href="#5-binder的jni方法注册" class="headerlink" title="5.binder的jni方法注册"></a>5.binder的jni方法注册</h4><h5 id="5-1-zygote启动"><a href="#5-1-zygote启动" class="headerlink" title="5.1 zygote启动"></a>5.1 zygote启动</h5><h5 id="5-1-1-启动zygote进程"><a href="#5-1-1-启动zygote进程" class="headerlink" title="5.1.1 启动zygote进程"></a>5.1.1 启动zygote进程</h5><p>zygote是由init进程通过解析 init.zygote.rc文件而创建的，zygote所对应的可执行程序 app_process，所对应的源文件是 app_main.cpp，进程名为zygote。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> system/core/rootdir/init.zygote32.rc</span></span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start- system-server </span><br><span class="line">class main </span><br><span class="line">socket zygote stream 660 root system </span><br><span class="line">onrestart write /sys/android_power/request_state wake </span><br><span class="line">onrestart write /sys/power/state on </span><br><span class="line">onrestart restart media </span><br><span class="line">onrestart restart netd </span><br><span class="line">writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>
<h5 id="5-1-2-执行-app-main-cpp中的main方法"><a href="#5-1-2-执行-app-main-cpp中的main方法" class="headerlink" title="5.1.2 执行 app_main.cpp中的main方法"></a>5.1.2 执行 app_main.cpp中的main方法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused &quot;parent dir&quot; argument.</span></span><br><span class="line">    <span class="comment">// 解析init.zygote32.rc中执行app_process传入的参数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re not in zygote mode, the only argument we need to pass</span></span><br><span class="line">        <span class="comment">// to RuntimeInit is the application argument.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></span><br><span class="line">        <span class="comment">// copies of them before we overwrite them with the process name.</span></span><br><span class="line">        args.add(application ? String8(<span class="string">&quot;application&quot;</span>) : String8(<span class="string">&quot;tool&quot;</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re in zygote mode.</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">&quot;start-system-server&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">&quot;--abi-list=&quot;</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>());</span><br><span class="line">        set_process_name(niceName.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">// 解析出来是zygote，运行AndroidRuntime.cpp的start方法</span></span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-1-3-AndroidRuntime-start"><a href="#5-1-3-AndroidRuntime-start" class="headerlink" title="5.1.3 AndroidRuntime::start"></a>5.1.3 AndroidRuntime::start</h5><p>调用startReg方法来完成jni方法的注册。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/AndroidRuntime.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Android根目录</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">&quot;/system&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">&quot;/system&quot;</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">&quot;No root directory specified, and /android does not exist.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">// 启动java虚拟机，在之后分析系统启动的时候详细看startVm里面干了什么</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注册JNI方法</span></span><br><span class="line"><span class="comment">     * 注册了之后java层就可以通过jni调用到native层的内容了</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该线程会编程AndroidRuntime线程，如果java代码报AndroidRuntime异常就会从这里退出。</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AndroidRuntime中完成了注册JNI方法的动作。我们在这篇文字主要看Binder的jni方法注册过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This hook causes all future threads created in this process to be</span></span><br><span class="line"><span class="comment">     * attached to the JavaVM.  (This needs to go away in favor of JNI</span></span><br><span class="line"><span class="comment">     * Attach calls.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;--- registering native functions ---\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Every &quot;register&quot; function calls one or more things that return</span></span><br><span class="line"><span class="comment">     * a local reference (e.g. FindClass).  Because we haven&#x27;t really</span></span><br><span class="line"><span class="comment">     * started the VM yet, they&#x27;re all getting stored in the base frame</span></span><br><span class="line"><span class="comment">     * and never released.  Use Push/Pop to manage the storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在去注册jni方法</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//createJavaThread(&quot;fubar&quot;, quickTest, (void*) &quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    	<span class="comment">// 宏，定义了一个函数指针</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            ALOGD(<span class="string">&quot;----------!!! %s failed to load\n&quot;</span>, <span class="built_in">array</span>[i].mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    REG_JNI(register_android_os_SystemProperties),</span><br><span class="line">    <span class="comment">// 注册binder JNI方法</span></span><br><span class="line">    REG_JNI(register_android_os_Binder),</span><br><span class="line">    REG_JNI(register_android_os_Parcel),</span><br><span class="line">    REG_JNI(register_android_nio_utils),</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-2-register-android-os-Binde"><a href="#5-2-register-android-os-Binde" class="headerlink" title="5.2 register_android_os_Binde"></a>5.2 register_android_os_Binde</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定java方法和jni方法</span></span><br><span class="line">    <span class="keyword">if</span> (int_register_android_os_Binder(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 绑定java方法和jni方法</span></span><br><span class="line">    <span class="keyword">if</span> (int_register_android_os_BinderInternal(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 绑定java方法和jni方法</span></span><br><span class="line">    <span class="keyword">if</span> (int_register_android_os_BinderProxy(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    jclass clazz = FindClassOrDie(env, <span class="string">&quot;android/util/Log&quot;</span>);</span><br><span class="line">    gLogOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gLogOffsets.mLogE = GetStaticMethodIDOrDie(env, clazz, <span class="string">&quot;e&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)I&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clazz = FindClassOrDie(env, <span class="string">&quot;android/os/ParcelFileDescriptor&quot;</span>);</span><br><span class="line">    gParcelFileDescriptorOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gParcelFileDescriptorOffsets.mConstructor = GetMethodIDOrDie(env, clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>,</span><br><span class="line"><span class="string">&quot;(Ljava/io/FileDescriptor;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clazz = FindClassOrDie(env, <span class="string">&quot;android/os/StrictMode&quot;</span>);</span><br><span class="line">    gStrictModeCallbackOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gStrictModeCallbackOffsets.mCallback = GetStaticMethodIDOrDie(env, clazz,</span><br><span class="line">            <span class="string">&quot;onBinderStrictModePolicyChange&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>5.2.1 int_register_android_os_Binder()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderPathName = <span class="string">&quot;android/os/Binder&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gBinderMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name,         signature,           funcPtr */</span></span><br><span class="line">    &#123; <span class="string">&quot;getCallingPid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_getCallingPid &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getCallingUid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_getCallingUid &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;clearCallingIdentity&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_clearCallingIdentity &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;restoreCallingIdentity&quot;</span>, <span class="string">&quot;(J)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_restoreCallingIdentity &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;setThreadStrictModePolicy&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_setThreadStrictModePolicy &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getThreadStrictModePolicy&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_getThreadStrictModePolicy &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;flushPendingCommands&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_flushPendingCommands &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;init&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_init &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;destroy&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_destroy &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;blockUntilThreadAvailable&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span>*)android_os_Binder_blockUntilThreadAvailable &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找文件 kBinderPathName = &quot;android/os/Binder&quot;，返回对应Class对象</span></span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderPathName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过gBinderOffsets结构体，保存Java层Binder类的信息，为JNI层访问Java层提供通道</span></span><br><span class="line">    gBinderOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">    gBinderOffsets.mObject = GetFieldIDOrDie(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过RegisterMethodsOrDie，将为gBinderMethods数组完成映射关系，从而为Java层访问 JNI层提供通道</span></span><br><span class="line">    <span class="keyword">return</span> RegisterMethodsOrDie(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, NELEM(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>5.2.2 int_register_android_os_BinderInternal()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gBinderInternalMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">    &#123; <span class="string">&quot;getContextObject&quot;</span>, <span class="string">&quot;()Landroid/os/IBinder;&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_getContextObject &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;joinThreadPool&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_joinThreadPool &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;disableBackgroundScheduling&quot;</span>, <span class="string">&quot;(Z)V&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_disableBackgroundScheduling &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;handleGc&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_handleGc &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderInternalPathName = <span class="string">&quot;com/android/internal/os/BinderInternal&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderInternal</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找到com/android/internal/os/BinderInternal类</span></span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderInternalPathName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过gBinderInternalOffsets，保存Java层BinderInternal类的信息，为JNI层访问java 层提供通道</span></span><br><span class="line">    gBinderInternalOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gBinderInternalOffsets.mForceGc = GetStaticMethodIDOrDie(env, clazz, <span class="string">&quot;forceBinderGc&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过RegisterMethodsOrDie()，将为gBinderInternalMethods数组完成映射关系，从而为 Java层访问JNI层提供通道</span></span><br><span class="line">    <span class="keyword">return</span> RegisterMethodsOrDie(</span><br><span class="line">        env, kBinderInternalPathName,</span><br><span class="line">        gBinderInternalMethods, NELEM(gBinderInternalMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>5.2.3 int_register_android_os_BinderProxy()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gBinderProxyMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">    &#123;<span class="string">&quot;pingBinder&quot;</span>,          <span class="string">&quot;()Z&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_pingBinder&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isBinderAlive&quot;</span>,       <span class="string">&quot;()Z&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_isBinderAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getInterfaceDescriptor&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_getInterfaceDescriptor&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;transactNative&quot;</span>,      <span class="string">&quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_transact&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;linkToDeath&quot;</span>,         <span class="string">&quot;(Landroid/os/IBinder$DeathRecipient;I)V&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_linkToDeath&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;unlinkToDeath&quot;</span>,       <span class="string">&quot;(Landroid/os/IBinder$DeathRecipient;I)Z&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_unlinkToDeath&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;destroy&quot;</span>,             <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_destroy&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">&quot;android/os/BinderProxy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = FindClassOrDie(env, <span class="string">&quot;java/lang/Error&quot;</span>);</span><br><span class="line">    gErrorOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line"></span><br><span class="line">    clazz = FindClassOrDie(env, kBinderProxyPathName);</span><br><span class="line">    gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gBinderProxyOffsets.mConstructor = GetMethodIDOrDie(env, clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice = GetStaticMethodIDOrDie(env, clazz, <span class="string">&quot;sendDeathNotice&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(Landroid/os/IBinder$DeathRecipient;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    gBinderProxyOffsets.mObject = GetFieldIDOrDie(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">    gBinderProxyOffsets.mSelf = GetFieldIDOrDie(env, clazz, <span class="string">&quot;mSelf&quot;</span>,</span><br><span class="line">                                                <span class="string">&quot;Ljava/lang/ref/WeakReference;&quot;</span>);</span><br><span class="line">    gBinderProxyOffsets.mOrgue = GetFieldIDOrDie(env, clazz, <span class="string">&quot;mOrgue&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clazz = FindClassOrDie(env, <span class="string">&quot;java/lang/Class&quot;</span>);</span><br><span class="line">    gClassOffsets.mGetName = GetMethodIDOrDie(env, clazz, <span class="string">&quot;getName&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RegisterMethodsOrDie(</span><br><span class="line">        env, kBinderProxyPathName,</span><br><span class="line">        gBinderProxyMethods, NELEM(gBinderProxyMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>参考文档</strong></p>
<p><a href="https://github.com/oujie123/Binder/tree/master">《代码笔记》</a></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder子系统-ServiceManager篇</title>
    <url>/2021/09/25/Binder%E5%AD%90%E7%B3%BB%E7%BB%9F-ServiceManager%E7%AF%87/</url>
    <content><![CDATA[<h4 id="1-ServiceManager的启动"><a href="#1-ServiceManager的启动" class="headerlink" title="1.ServiceManager的启动"></a>1.ServiceManager的启动</h4><p>ServiceManager作为所有服务大管家总共有三个方法值得关注。</p>
<ul>
<li>main()启动ServiceManager并且注册为大管家（handled = 0）</li>
<li>do_add_service()其他服务将自己加入到ServiceManager中</li>
<li>do_find_service()需要使用到服务端的应用来查询服务，并且获取服务代理</li>
</ul>
<p><img src="/2021/09/25/Binder%E5%AD%90%E7%B3%BB%E7%BB%9F-ServiceManager%E7%AF%87/blog\source_posts\Binder子系统-ServiceManager篇\ServiceManager.jpg" alt="ServiceManager"></p>
<h5 id="1-1-启动servicemanager进程"><a href="#1-1-启动servicemanager进程" class="headerlink" title="1.1 启动servicemanager进程"></a>1.1 启动servicemanager进程</h5><h5 id="1-1-1-解析init-rc启动servicemanger"><a href="#1-1-1-解析init-rc启动servicemanger" class="headerlink" title="1.1.1 解析init.rc启动servicemanger"></a>1.1.1 解析init.rc启动servicemanger</h5><p>ServiceManager是由init进程通过解析init.rc文件而创建的，其所对应的可执行程序servicemanager， 所对应的源文件是service_manager.c，进程名为servicemanager。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// system/core/rootdir/init.rc</span><br><span class="line">service servicemanager /system/bin/servicemanager class core </span><br><span class="line">user system </span><br><span class="line">group system </span><br><span class="line">critical </span><br><span class="line">onrestart restart healthd </span><br><span class="line">onrestart restart zygote </span><br><span class="line">onrestart restart media </span><br><span class="line">onrestart restart surfaceflinger </span><br><span class="line">onrestart restart drm</span><br></pre></td></tr></table></figure>


<h5 id="1-1-2-调用servicemanager的main方法"><a href="#1-1-2-调用servicemanager的main方法" class="headerlink" title="1.1.2 调用servicemanager的main方法"></a>1.1.2 调用servicemanager的main方法</h5><p>调用servicemanager的main方法，启动ServiceManager的入口函数是 service_manager.c中的main()方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/service_manager.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开binder驱动，并且申请128k字节大小的共享内存空间</span></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;failed to open binder driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设为守护进程，成为binder大管理者</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selinux_enabled = is_selinux_enabled();</span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line">    selinux_status_open(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selinux_enabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sehandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;SELinux: Failed to acquire sehandle. Aborting.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getcon(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;SELinux: Failed to acquire service_manager context. Aborting.\n&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">selinux_callback</span> <span class="title">cb</span>;</span></span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log = selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入无限循环，处理client端发来的请求</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-1-3-binder-open"><a href="#1-1-3-binder-open" class="headerlink" title="1.1.3 binder_open()"></a>1.1.3 binder_open()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/binder.c</span></span><br><span class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">size_t</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> <span class="title">vers</span>;</span></span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开binder驱动</span></span><br><span class="line">    bs-&gt;fd = open(<span class="string">&quot;/dev/binder&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;binder: cannot open device (%s)\n&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">&quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">	<span class="comment">// 映射128kb到ServiceManager</span></span><br><span class="line">    <span class="comment">// 通过系统调用，mmap内存映射，mmap必须是page的整数倍(即4kb的整数倍)</span></span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;binder: cannot map device (%s)\n&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-1-4-binder-become-context-manager"><a href="#1-1-4-binder-become-context-manager" class="headerlink" title="1.1.4 binder_become_context_manager()"></a>1.1.4 binder_become_context_manager()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/binder.c </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state *bs)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 通过使用ioctl调用到驱动</span></span><br><span class="line">	<span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_MAX_THREADS:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:  <span class="comment">// 处理该事件</span></span><br><span class="line">		ret = binder_ioctl_set_ctx_mgr(filp);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_THREAD_EXIT:</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS, <span class="string">&quot;%d:%d exit\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		binder_free_thread(proc, thread);</span><br><span class="line">		thread = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> __<span class="title">user</span> *<span class="title">ver</span> =</span> ubuf;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">			     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_set_ctx_mgr</span><span class="params">(struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">kuid_t</span> curr_euid = current_euid();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保证只创建一次</span></span><br><span class="line">	<span class="keyword">if</span> (context-&gt;binder_context_mgr_node) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;BINDER_SET_CONTEXT_MGR already set\n&quot;</span>);</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// uid是否有效，当前刚刚才建立，是无效的</span></span><br><span class="line">	<span class="keyword">if</span> (uid_valid(context-&gt;binder_context_mgr_uid)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!uid_eq(context-&gt;binder_context_mgr_uid, curr_euid)) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;BINDER_SET_CONTEXT_MGR bad uid %d != %d\n&quot;</span>,</span><br><span class="line">			       from_kuid(&amp;init_user_ns, curr_euid),</span><br><span class="line">			       from_kuid(&amp;init_user_ns,</span><br><span class="line">					 context-&gt;binder_context_mgr_uid));</span><br><span class="line">			ret = -EPERM;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置当前线程euid作为service_manager的uid</span></span><br><span class="line">		context-&gt;binder_context_mgr_uid = curr_euid;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//创建service_manager实体</span></span><br><span class="line">	context-&gt;binder_context_mgr_node = binder_new_node(proc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!context-&gt;binder_context_mgr_node) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">	context-&gt;binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">	context-&gt;binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">	context-&gt;binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">	context-&gt;binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_new_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">					   <span class="keyword">binder_uintptr_t</span> ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">					   <span class="keyword">binder_uintptr_t</span> cookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;proc-&gt;nodes.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次，p为空</span></span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		node = rb_entry(parent, struct binder_node, rb_node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给新创建的binder_node 分配内核空间</span></span><br><span class="line">	node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	binder_stats_created(BINDER_STAT_NODE);</span><br><span class="line">    <span class="comment">// 将新创建的node对象添加到proc红黑树</span></span><br><span class="line">	rb_link_node(&amp;node-&gt;rb_node, parent, p);</span><br><span class="line">	rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line">    <span class="comment">// 初始化binder_node</span></span><br><span class="line">	node-&gt;debug_id = ++binder_last_id;</span><br><span class="line">	node-&gt;proc = proc;  <span class="comment">//  proc --》 binder_node</span></span><br><span class="line">	node-&gt;ptr = ptr;</span><br><span class="line">	node-&gt;cookie = cookie;</span><br><span class="line">	node-&gt;work.type = BINDER_WORK_NODE;</span><br><span class="line">	INIT_LIST_HEAD(&amp;node-&gt;work.entry);  <span class="comment">//创建work和todo--》类似 messageQueue</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;node-&gt;async_todo);</span><br><span class="line">	binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">		     <span class="string">&quot;%d:%d node %d u%016llx c%016llx created\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, current-&gt;pid, node-&gt;debug_id,</span><br><span class="line">		     (u64)node-&gt;ptr, (u64)node-&gt;cookie);</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-1-5-binder-loop"><a href="#1-1-5-binder-loop" class="headerlink" title="1.1.5 binder_loop"></a>1.1.5 binder_loop</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;<span class="comment">// 读写要处理的命令</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));<span class="comment">// 设置线程的looper状态为循环状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);<span class="comment">// 不为0，进入binder_thread_read</span></span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不断地binder读数据，没有数据会进入休眠状态</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;binder_loop: ioctl failed (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当收到BR_TRANSACTION之后，会对该指令进行解析</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;binder_loop: unexpected reply?!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;binder_loop: io error %d %s\n&quot;</span>, res, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = len; <span class="comment">// write_size大于0，进入binder_thread_write</span></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) data; <span class="comment">// 此处data为BC_ENTER_LOOPER,写命令</span></span><br><span class="line">    bwr.read_size = <span class="number">0</span>; <span class="comment">// read 不会进去</span></span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); <span class="comment">//命令为：BC_ENTER_LOOPER设置线程的    looper状态为循环状态</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;binder_write: ioctl failed (%s)\n&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把用户空间数据ubuf拷贝到bwr,此处copy的是数据头</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">		     <span class="string">&quot;%d:%d write %lld at %016llx, read %lld at %016llx\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">		     (u64)bwr.write_size, (u64)bwr.write_buffer,</span><br><span class="line">		     (u64)bwr.read_size, (u64)bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当写缓存中有数据，则执行binder写操作</span></span><br><span class="line">    <span class="comment">// 此处是写命令进来，因此调用binder_thread_write</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		trace_binder_write_done(ret);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		trace_binder_read_done(ret);</span><br><span class="line">		<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">			wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理结束之后，将结果通过bwr返回到用户空间</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line">	<span class="keyword">void</span> __user *buffer = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">	<span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">	<span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">		trace_binder_command(cmd);</span><br><span class="line">		<span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">			binder_stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">			proc-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">			thread-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		......</span><br><span class="line">		<span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">			binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">				     <span class="string">&quot;%d:%d BC_ENTER_LOOPER\n&quot;</span>,</span><br><span class="line">				     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			<span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</span><br><span class="line">				thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d ERROR: BC_ENTER_LOOPER called after BC_REGISTER_LOOPER\n&quot;</span>,</span><br><span class="line">					proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//设置线程为BINDER_LOOPER_STATE_ENTERED状态</span></span><br><span class="line">			thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;  </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> __user *buffer = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">	<span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">	<span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//binder_looper等待的时候，consumed为0，会将bwr命令放入BR_NOOP</span></span><br><span class="line">	<span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">//wait_for_proc_work 由于todo为空，wait_for_proc_work是true</span></span><br><span class="line">	wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">				list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 准备就绪的线程个数加1</span></span><br><span class="line">	<span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">		proc-&gt;ready_threads++;</span><br><span class="line"></span><br><span class="line">	.....</span><br><span class="line">      </span><br><span class="line">	<span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">					BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">			wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">						 binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		binder_set_nice(proc-&gt;default_priority);</span><br><span class="line">        <span class="comment">// 非阻塞操作，service_manager是阻塞的，所以if不命中</span></span><br><span class="line">		<span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="comment">// 异步binder</span></span><br><span class="line">			<span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="comment">//开始等待</span></span><br><span class="line">			ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-获取service-manager"><a href="#2-获取service-manager" class="headerlink" title="2.获取service_manager"></a>2.获取service_manager</h4><p>获取Service Manager是通过defaultServiceManager()方法来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IServiceManager.cpp</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">		<span class="comment">//防止SM没有注册</span></span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="comment">//interface_cast返回IBpServiceManager</span></span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-ProcessState-self"><a href="#2-1-ProcessState-self" class="headerlink" title="2.1 ProcessState::self()"></a>2.1 ProcessState::self()</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState; <span class="comment">// 单例模式实例化ProcessState</span></span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp </span></span><br><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())  <span class="comment">// 打开驱动</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap找驱动映射1M - 8k共享内存</span></span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开驱动</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/binder&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置最大线程数为15</span></span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Opening &#x27;/dev/binder&#x27; failed: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-2-ProcessState-getContextObject"><a href="#2-2-ProcessState-getContextObject" class="headerlink" title="2.2 ProcessState::getContextObject"></a>2.2 ProcessState::getContextObject</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 参数为0，相当于handle==0，获取service_manager服务</span></span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找handle对应的handle_entry</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn&#x27;t currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">		<span class="comment">//  SM还不存在 所以会走if语句</span></span><br><span class="line">        <span class="comment">// 当handle值所对应的IBinder不存在或弱引用无效时</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="comment">// 通过ping操作测试binder是否准备就绪</span></span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 如果servicemanager能ping通，则创建BpBinder</span></span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn&#x27;t have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/BpBinder.cpp</span></span><br><span class="line">BpBinder::BpBinder(<span class="keyword">int32_t</span> handle)</span><br><span class="line">    : mHandle(handle)</span><br><span class="line">    , mAlive(<span class="number">1</span>)</span><br><span class="line">    , mObitsSent(<span class="number">0</span>)</span><br><span class="line">    , mObituaries(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;Creating BpBinder %p handle %d\n&quot;</span>, <span class="keyword">this</span>, mHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持强弱引用计数，OBJECT_LIFETIME_WEAK表示目标对象的生命周期受弱指针控制</span></span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    <span class="comment">// handle所对应的 bindle弱引用 + 1</span></span><br><span class="line">    IPCThreadState::self()-&gt;incWeakHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-3-interface-cast"><a href="#2-3-interface-cast" class="headerlink" title="2.3 interface_cast"></a>2.3 interface_cast</h5><p>2.3.1 模板定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/include/binder/IInterface.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模板方法，等价于：IServiceManager::asInterface</span></span><br><span class="line">    <span class="keyword">return</span> INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于asInterface()函数，通过搜索代码，你会发现根本找不到这个方法是在哪里定义这个函数的, 其实是</p>
<p>通过模板函数来定义的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/include/binder/IInterface.h</span></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                          \</span><br><span class="line">    static android::sp&lt;I##INTERFACE&gt; asInterface(                       \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);                  \</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> android::String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;    \</span><br><span class="line">    I##INTERFACE();                                                     \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();                                            \</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line">    <span class="keyword">const</span> android::String16 I##INTERFACE::descriptor(NAME);             \</span><br><span class="line">    <span class="keyword">const</span> android::String16&amp;                                            \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              \</span><br><span class="line">        <span class="keyword">return</span> I##INTERFACE::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)                   \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        android::sp&lt;I##INTERFACE&gt; intr;                                 \</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              \</span><br><span class="line">            intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I##INTERFACE::descriptor).get());               \</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         \</span><br><span class="line">                intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>


<p>2.3.2 IServiceManager头文件使用模板方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/include/binder/IServiceManager.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IServiceManager</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(ServiceManager);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 展开之后</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor; </span><br><span class="line"><span class="function"><span class="keyword">static</span> android::sp&lt; IServiceManager &gt; <span class="title">asInterface</span><span class="params">(<span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> android::String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line">IServiceManager (); </span><br><span class="line"><span class="keyword">virtual</span> ~IServiceManager();</span><br></pre></td></tr></table></figure>
<p>该过程主要是声明asInterface(),getInterfaceDescriptor()方法。</p>
<p>2.3.3 IMPLEMENT_META_INTERFACE实现文件使用模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IServiceManager.cpp</span></span><br><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">&quot;android.os.IServiceManager&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 展开后</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> android::String16 <span class="title">IServiceManager::descriptor</span><span class="params">(<span class="string">&quot;android.os.IServiceManager&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> android::String16&amp;<span class="title">IServiceManager::getInterfaceDescriptor</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">android::sp&lt;IServiceManager&gt; <span class="title">IServiceManager::asInterface</span><span class="params">(<span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)</span> </span>&#123;</span><br><span class="line">    android::sp&lt;IServiceManager&gt; intr;</span><br><span class="line">    <span class="keyword">if</span>(obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        intr = <span class="keyword">static_cast</span>&lt;IServiceManager *&gt;(obj-&gt;queryLocalInterface (IServiceManager::descriptor).get());</span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 等价于 new BpServiceManager(BpBinder)</span></span><br><span class="line">            intr = <span class="keyword">new</span> BpServiceManager(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IServiceManager::IServiceManager () &#123; &#125;</span><br><span class="line">IServiceManager::~ IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure>


<p>2.4 BpServiceManager()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IServiceManager.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpServiceManager</span> :</span> <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BpServiceManager(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/include/binder/IInterface.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> BpInterface&lt;INTERFACE&gt;::BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote)</span><br><span class="line">    : BpRefBase(remote)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/Binder.cpp</span></span><br><span class="line"><span class="comment">//将BpBinder赋值给mRemote</span></span><br><span class="line">BpRefBase::BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; o)</span><br><span class="line">    : mRemote(o.get()), mRefs(<span class="literal">NULL</span>), mState(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemote) &#123;</span><br><span class="line">        mRemote-&gt;incStrong(<span class="keyword">this</span>);           <span class="comment">// Removed on first IncStrong().</span></span><br><span class="line">        mRefs = mRemote-&gt;createWeak(<span class="keyword">this</span>);  <span class="comment">// Held for our entire lifetime.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将ServiceManager的Bpbinder给到mRemote, 然后就可以客户端就可以通过mRemote来完成通信了。</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder子系统-注册服务和获取服务篇</title>
    <url>/2021/09/25/Binder%E5%AD%90%E7%B3%BB%E7%BB%9F-%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E7%AF%87/</url>
    <content><![CDATA[<h3 id="0-交互协议"><a href="#0-交互协议" class="headerlink" title="0.交互协议"></a>0.交互协议</h3><p><img src="https://upload-images.jianshu.io/upload_images/13838098-4e1e1e0bb8c6d89b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端服务端与Binder交互协议.jpg"></p>
<h3 id="1-addService流程"><a href="#1-addService流程" class="headerlink" title="1.addService流程"></a>1.addService流程</h3><h4 id="1-1-SystemServer"><a href="#1-1-SystemServer" class="headerlink" title="1.1 SystemServer"></a>1.1 SystemServer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">    android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 启动mainLooper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize native services.</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether we failed to shut down last time we tried.</span></span><br><span class="line">    <span class="comment">// This call may not return.</span></span><br><span class="line">    performPendingShutdown();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the system context.</span></span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the system service manager.</span></span><br><span class="line">    <span class="comment">// 创建SystemServiceManager</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    <span class="comment">// 将SystemServiceManager</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动AMS等启动类的服务</span></span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For debug builds, log event loop stalls to dropbox for analysis.</span></span><br><span class="line">    <span class="keyword">if</span> (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Enabled StrictMode for system server main thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Wait for installd to finish starting up so that it has a chance to</span></span><br><span class="line">        <span class="comment">// create critical directories such as /data/user with the appropriate</span></span><br><span class="line">        <span class="comment">// permissions.  We need this to complete before we initialize other services.</span></span><br><span class="line">        Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Activity manager runs the show.</span></span><br><span class="line">        <span class="comment">// 通过反射构造AMS并且启动AMS，获取AMS</span></span><br><span class="line">        mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">                ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">        mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">    	<span class="comment">// 将自己和自己所持有的一些服务注册到SM中去，并且启动服务</span></span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The sensor service needs access to package manager service, app ops</span></span><br><span class="line">        <span class="comment">// service, and permissions service, therefore we start it after them.</span></span><br><span class="line">        startSensorService();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将自己和持有的服务都注册到SM中，可以供其他服务调用</span></span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="keyword">true</span>,DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;meminfo&quot;</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>), <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_HIGH);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;gfxinfo&quot;</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;dbinfo&quot;</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;cpuinfo&quot;</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>), <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;permission&quot;</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;processinfo&quot;</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">            <span class="string">&quot;android&quot;</span>, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);</span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建ProcessRecord设置AMS的进程属性并且更新Process链表和OOM adj值</span></span><br><span class="line">            ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">            app.persistent = <span class="keyword">true</span>;</span><br><span class="line">            app.pid = MY_PID;</span><br><span class="line">            app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Unable to find android system package&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-2-ServiceManager-addService"><a href="#1-2-ServiceManager-addService" class="headerlink" title="1.2 ServiceManager.addService"></a>1.2 ServiceManager.addService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/ServiceManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;error in addService&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the service manager</span></span><br><span class="line">        <span class="comment">// 相当于 new ServiceManagerProxy(new BinderProxy);</span></span><br><span class="line">    	<span class="comment">// BinderInternal.getContextObject()返回一个BinderProxy对象</span></span><br><span class="line">        sServiceManager = ServiceManagerNative</span><br><span class="line">                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-2-1-BinderInternal-getContextObject"><a href="#1-2-1-BinderInternal-getContextObject" class="headerlink" title="1.2.1 BinderInternal.getContextObject()"></a>1.2.1 BinderInternal.getContextObject()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/BinderInternal.java</span></span><br><span class="line"><span class="comment">// 是个jni方法，找到对应的cpp文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> IBinder <span class="title">getContextObject</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开 binder驱动（ProcessState是单例的），创建 BpBinder(handle) 对象，并返回</span></span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If the argument is a JavaBBinder, return the Java object that was used to create it.</span></span><br><span class="line"><span class="comment">// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the</span></span><br><span class="line"><span class="comment">// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.</span></span><br><span class="line"><span class="comment">// 如果val是JavaBBinder就返回已经创建的服务端对象，否则返回BinderProxy</span></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是不是JavaBBinder，如果是就把自己返回</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// One of our own!</span></span><br><span class="line">        jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        LOGDEATH(<span class="string">&quot;objectForBinder %p: it&#x27;s our own %p!\n&quot;</span>, val.get(), object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For the rest of the function we will hold this lock, to serialize</span></span><br><span class="line">    <span class="comment">// looking/creation of Java proxies for native Binder proxies.</span></span><br><span class="line">    <span class="function">AutoMutex <span class="title">_l</span><span class="params">(mProxyLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Someone else&#x27;s...  do we know about it?</span></span><br><span class="line">    <span class="comment">// 从 BpBinder中查找 BinderProxy对象，第一次为 null</span></span><br><span class="line">    jobject object = (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    <span class="keyword">if</span> (object != NULL) &#123;</span><br><span class="line">        jobject res = jniGetReferent(env, object);</span><br><span class="line">        <span class="keyword">if</span> (res != NULL) &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;objectForBinder %p: found existing %p!\n&quot;</span>, val.get(), res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGDEATH(<span class="string">&quot;Proxy object %p of IBinder %p no longer in working set!!!&quot;</span>, object, val.get());</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 BinderProxy对象</span></span><br><span class="line">    object = env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    <span class="comment">// 以下if语句主要完成了BinderProxy和BpBinder的绑定</span></span><br><span class="line">    <span class="keyword">if</span> (object != NULL) &#123;</span><br><span class="line">        LOGDEATH(<span class="string">&quot;objectForBinder %p: created new proxy %p !\n&quot;</span>, val.get(), object);</span><br><span class="line">        <span class="comment">// The proxy holds a reference to the native object.</span></span><br><span class="line">        <span class="comment">// BinderProxy.mObject成员变量记录 BpBinder对象</span></span><br><span class="line">        <span class="comment">// 相当于BinderProxy与BpBinder进行绑定</span></span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">        val-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The native object needs to hold a weak reference back to the</span></span><br><span class="line">        <span class="comment">// proxy, so we can retrieve the same proxy if it is still active.</span></span><br><span class="line">        jobject refObject = env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        <span class="comment">// 将 BinderProxy对象信息添加到 BpBinder的成员变量 mObjects中</span></span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also remember the death recipients registered on this proxy</span></span><br><span class="line">        sp&lt;DeathRecipientList&gt; drl = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">        <span class="comment">// BinderProxy.mOrgue成员变量记录死亡通知对象</span></span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast&lt;jlong&gt;(drl.get()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that a new object reference has been created.</span></span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-2-2-ServiceManagerNative-asInterface"><a href="#1-2-2-ServiceManagerNative-asInterface" class="headerlink" title="1.2.2 ServiceManagerNative.asInterface"></a>1.2.2 ServiceManagerNative.asInterface</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/ServiceManagerNative.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为 obj为 BinderProxy，默认返回 null</span></span><br><span class="line">    IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用IServiceManager的BinderProxy创建一个ServiceManagerProxy</span></span><br><span class="line">    <span class="comment">// 此处已经创建好持有SM的BinderProxy对象的ServiceManagerProxy,并且返回到ServiceManager.java中的静态addService方法中。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/os/ServiceManagerNative.java$ServiceManagerProxy.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerProxy</span> <span class="keyword">implements</span> <span class="title">IServiceManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mRemote为 BinderProxy对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-3-ServiceManagerProxy-addService"><a href="#1-3-ServiceManagerProxy-addService" class="headerlink" title="1.3 ServiceManagerProxy.addService()"></a>1.3 ServiceManagerProxy.addService()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/os/ServiceManagerNative.java$ServiceManagerProxy.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerProxy</span> <span class="keyword">implements</span> <span class="title">IServiceManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// 封装data数据包</span></span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        data.writeStrongBinder(service);<span class="comment">//service == AMS，将AMS打包到data中</span></span><br><span class="line">        data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 通过SM的BinderProxy对象将数据发往binder驱动，并且挂起线程</span></span><br><span class="line">        mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-3-1-writeStrongBinder"><a href="#1-3-1-writeStrongBinder" class="headerlink" title="1.3.1 writeStrongBinder"></a>1.3.1 writeStrongBinder</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Parcel.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeStrongBinder</span><span class="params">(IBinder val)</span> </span>&#123;</span><br><span class="line">        nativeWriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_os_Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将java层 Parcel转换为 native层 Parcel</span></span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过ibinder找到AMS的服务端BBinder对象，即JavaBBinder对象</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">status_t</span> err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-1-1-ibinderForJavaObject"><a href="#1-3-1-1-ibinderForJavaObject" class="headerlink" title="1.3.1.1  ibinderForJavaObject()"></a>1.3.1.1  ibinderForJavaObject()</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为是AMS服务端，因此此if命中，从JavaBBinderHolder中拿出JavaBBinder返回</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;GetLongField(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh != <span class="literal">NULL</span> ? jbh-&gt;get(env, obj) : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是客户端就返回BpBinder</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (IBinder*)</span><br><span class="line">            env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGW(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp$JavaBBinderHolder.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBBinderHolder</span> :</span> <span class="keyword">public</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">sp&lt;JavaBBinder&gt; <span class="title">get</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        sp&lt;JavaBBinder&gt; b = mBinder.promote();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个JavaBBinder对象</span></span><br><span class="line">            b = <span class="keyword">new</span> JavaBBinder(env, obj);</span><br><span class="line">            mBinder = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-3-1-2-parcel-gt-writeStrongBinder"><a href="#1-3-1-2-parcel-gt-writeStrongBinder" class="headerlink" title="1.3.1.2 parcel-&gt;writeStrongBinder"></a>1.3.1.2 parcel-&gt;writeStrongBinder</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// !!!!!!注意,此处的val是JavaBBinder对象!!!!!!!!!!</span></span><br><span class="line"><span class="comment">// frameworks/native/libs/binder/Parcel.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">flatten_binder</span><span class="params">(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	<span class="comment">// 当前进程有 Binder，所以本地 Binder不为空</span></span><br><span class="line">        <span class="comment">// localBinder()如果是AMS本身就返回this,如果是代理就返回NULL，因为当前是AMS自己注册，所有返回的是this,不为空</span></span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123; <span class="comment">// !local: local是空的话,!local才为真,才会命中该if</span></span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// // 将Binder对象扁平化，转换成 flat_binder_object对象</span></span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);<span class="comment">// 保存AMS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">status_t</span> <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*binder*/</span>, <span class="keyword">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将flat_binder_object写入到parcel中</span></span><br><span class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-3-2-mRemote-transact"><a href="#1-3-2-mRemote-transact" class="headerlink" title="1.3.2 mRemote.transact"></a>1.3.2 mRemote.transact</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Binder.java$BinderProxy.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">pingBinder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isBinderAlive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用transact向native的Bpbinder发送消息,最终通过BpBinder发送给驱动周转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">&quot;Unreasonably large binder buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Java对象转化为cpp的parcel对象</span></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 BpBinder 对象</span></span><br><span class="line">    <span class="comment">// gBinderProxyOffsets.mObject就是上面绑定的BpBinder</span></span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用BpBinder的transact方法发送对象</span></span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/BpBinder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="comment">// 调用IPCThreadState的transact发送数据</span></span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  数据错误检查</span></span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TF_ACCEPT_FDS = 0x10：允许回复中包含文件描述符 </span></span><br><span class="line">    <span class="comment">// TF_ONE_WAY：当前业务是异步的，不需要等待 </span></span><br><span class="line">    <span class="comment">// TF_ROOT_OBJECT：所包含的内容是根对象 </span></span><br><span class="line">    <span class="comment">// TF_STATUS_CODE：所包含的内容是 32-bit 的状态值</span></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        LOG_ONEWAY(<span class="string">&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;</span>, getpid(), getuid(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">&quot;READ REPLY&quot;</span> : <span class="string">&quot;ONE WAY&quot;</span>);</span><br><span class="line">     <span class="comment">// 整理数据，并把结果存入 mOut 中。（在 talkWithDriver方法中才会将命令真正发送给 Binder驱动）</span></span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是同步就命中if,否则走else</span></span><br><span class="line">    <span class="comment">// waitForResponse中才是正在发送数据到驱动的地方</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将所有数据包打包成binder_transaction_data</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将指令(BC_TRANSACTION)和数据包写道mOut中</span></span><br><span class="line">    <span class="comment">// waitForResponse中将数据通过talkWithDriver发送到驱动</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环调用talkWithDriver()等待结果,一旦有结果,马上通过switch进行解析</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line">        </span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Processing waitForResponse Command: &quot;</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当客户端与binder驱动沟通完之后,会回到这里,客户端收到BR_TRANSACTION_COMPLETE</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读的 buffer是否为空。现在读为 null</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读的时候不能写 mOut</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();<span class="comment">// 在 bwr中填写需要 write的大小和内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we&#x27;ll read.</span></span><br><span class="line">    <span class="comment">// 刚刚是mOut写了数据,因此needRead为 null，走 else</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// while循环条件不会成立，只执行一次</span></span><br><span class="line">        <span class="comment">// 写入命令 BC_TRANSACTION</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-3-3-进入驱动写数据"><a href="#1-3-3-进入驱动写数据" class="headerlink" title="1.3.3 进入驱动写数据"></a>1.3.3 进入驱动写数据</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="comment">// 因为是BINDER_WRITE_READ,因此走binder_ioctl_write_read(),然后写数据调到binder_thread_write()中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此次从用户空间拷贝的不是数据,数据在binder_transaction中拷贝</span></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">                               cmd == BC_REPLY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此处 reply为 false（cmd == BC_TRANSACTION）</span></span><br><span class="line">	<span class="keyword">if</span> (reply) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 此处因为是找SM,SM的handle是0,因此走else</span></span><br><span class="line">		<span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取目标对象的 target_node，目标是 service_manager，所以可以直接使用全局变量 binder_context_mgr_node</span></span><br><span class="line">			target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">		e-&gt;to_node = target_node-&gt;debug_id;</span><br><span class="line">        <span class="comment">// target_proc为 service_manager进程</span></span><br><span class="line">		target_proc = target_node-&gt;proc;</span><br><span class="line">        ......</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到 service_manager进程的 todo队列 </span></span><br><span class="line">    target_list = &amp;target_proc-&gt;todo; </span><br><span class="line">    target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个 binder_transaction 变量（即变量 t），用于描述本次要进行的 transaction（最后将其加入 target_thread-&gt;todo）。</span></span><br><span class="line">    <span class="comment">// 这样当目标对象被唤醒时，它就可以从这个队列中取出需要做的工作。</span></span><br><span class="line">    <span class="comment">// 此处为将把数据写入共享内存做准备</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个binder_work变量（即变量 tcomplete），用于说明当前调用者线程有一宗未完成的 transaction（它最后会被添加到本线程的 todo队列中）</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给 transaction结构体赋值，即变量 t</span></span><br><span class="line">    <span class="comment">// 如果是同步,命中if</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        <span class="comment">// 把当前 thread保存到 transaction的 from字段,为了记住需要返回的线程</span></span><br><span class="line">		t-&gt;from = thread;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sender_euid = task_euid(proc-&gt;tsk); </span><br><span class="line">    t-&gt;to_proc = target_proc; <span class="comment">// 此次通信目标进程为 service_manager进程 </span></span><br><span class="line">    t-&gt;to_thread = target_thread; </span><br><span class="line">    t-&gt;code = tr-&gt;code; <span class="comment">// 此次通信 code = ADD_SERVICE_TRANSACTION </span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags; <span class="comment">// 此次通信 flags = 0 </span></span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从接收端(service_manager进程中)分配 buffer(为完成本条 transaction申请内存，从 binder_mmap开辟的空间中申请内存) </span></span><br><span class="line">    <span class="comment">// 此处分配的内存都是接收端通过mmap申请的与Binder驱动的共享内存</span></span><br><span class="line">    <span class="comment">// t-&gt;buffer指向共享区域</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, extra_buffers_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// !!!!!!!!!!!!!!!!此处才是真正的一次数据拷贝!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分别拷贝用户空间的 binder_transaction_data中 ptr.buffer和 ptr.offsets到内核 </span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>) tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">			   tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">			fp = to_flat_binder_object(hdr);</span><br><span class="line">            <span class="comment">// 创建 binder_ref，service_manager的 binder引用对象,下面分析</span></span><br><span class="line">			ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">		binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        <span class="comment">// 同步命中该if</span></span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">		t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">		t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">     <span class="comment">// 记录本次 transaction,以备后期查询 （service_manager通过这个知道是谁调用的，从而返回数据）</span></span><br><span class="line">		thread-&gt;transaction_stack = t;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION; <span class="comment">// 设置 t的类型为 BINDER_WORK_TRANSACTION,让服务开始处理的时候需要用到该type </span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list); <span class="comment">// 将 t加入目标的处理队列中 </span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; <span class="comment">// 设置 binder_work的类型为 BINDER_WORK_TRANSACTION_COMPLETE ,后面service_manager读的时候需要用到这个type</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); <span class="comment">// 当前线程有一个未完成的操作</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait) wake_up_interruptible(target_wait);<span class="comment">// 唤醒目标，即 service_manager</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处通过wake_up_interruptible唤醒service_manager,service_manager通过<code>binder_thread_read</code>的BINDER_WORK_TRANSACTIONcase开始处理事务.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_binder</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">				   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> thread-&gt;proc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> =</span> t-&gt;to_proc;</span><br><span class="line"></span><br><span class="line">	node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">	<span class="keyword">if</span> (!node) &#123;</span><br><span class="line">		node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">		<span class="keyword">if</span> (!node)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">		node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 binder_ref</span></span><br><span class="line">	ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line">	<span class="keyword">if</span> (!ref)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变类型为 BINDER_TYPE_HANDLE</span></span><br><span class="line">	<span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">		fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">	fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">	fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">	fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">	binder_inc_ref(ref, fp-&gt;hdr.type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-3-4-驱动中目标进程读数据-service-manager已被唤醒"><a href="#1-3-4-驱动中目标进程读数据-service-manager已被唤醒" class="headerlink" title="1.3.4 驱动中目标进程读数据(service_manager已被唤醒)"></a>1.3.4 驱动中目标进程读数据(service_manager已被唤醒)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel/drivers/staging/android/binder.c </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg, struct binder_thread *thread)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// service_manager开始通过binder_thread_read读数据</span></span></span><br><span class="line"><span class="function">ret </span>= binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前面把一个 binder_work添加到 thread-&gt;todo队列中，所以 w不为空，类型为 BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">			w = list_first_entry(&amp;thread-&gt;todo, struct binder_work,</span><br><span class="line">					     entry);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接看switch case, type是BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">			cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">         	<span class="comment">// 写入命令 BR_TRANSACTION_COMPLETE</span></span><br><span class="line">            <span class="comment">// 此处完成时客户端发送BC_TRANSACTION,服务端响应BR_TRANSACTION_COMPLETE操作</span></span><br><span class="line">			<span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此,客户端驱动的交互完成!!!!!!客户端收到BR_TRANSACTION_COMPLETE, 回到waitForResponse()方法开始处理返回命令.</p>
<h5 id="1-3-5-返回用户空间并且挂起客户端"><a href="#1-3-5-返回用户空间并且挂起客户端" class="headerlink" title="1.3.5 返回用户空间并且挂起客户端"></a>1.3.5 返回用户空间并且挂起客户端</h5><p>此处返回用户空间处理驱动返回的BR_TRANSACTION_COMPLETE命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/libs/binder/IPCThreadState.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处mIn是有数据的,再次执行 talkWithDriver方法，这个时候 bwr.write_size==0,bwr.read_size还是大于 0，所以直接执行驱动中 binder_thread_read</span></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">                <span class="comment">// 当前为同步，不会进入 if，继续 while循环</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/drivers/staging/android/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread, 		<span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size, <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时因为客户端线程还在等在服务端响应,thread-&gt;transaction_stack不为null,因此wait_for_proc_work为false</span></span><br><span class="line">	wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">				list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    </span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">		......</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (non_block) &#123;  <span class="comment">// 由于是同步的命中else</span></span><br><span class="line">			<span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 让客户端挂起</span></span><br><span class="line">			ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-3-6-service-manager开始处理消息"><a href="#1-3-6-service-manager开始处理消息" class="headerlink" title="1.3.6 service_manager开始处理消息"></a>1.3.6 service_manager开始处理消息</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">            <span class="comment">// 主要是把用户的请求复制到 service_manager中并对各种队列进行调整</span></span><br><span class="line">			t = container_of(w, struct binder_transaction, work);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// target_node == SM</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> =</span> t-&gt;buffer-&gt;target_node;</span><br><span class="line"></span><br><span class="line">			tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">			tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">			t-&gt;saved_priority = task_nice(current);</span><br><span class="line">			<span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;</span><br><span class="line">			    !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">				binder_set_nice(t-&gt;priority);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) ||</span><br><span class="line">				 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">				binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">            <span class="comment">// 设置服务端处理指令.</span></span><br><span class="line">			cmd = BR_TRANSACTION;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tr.target.ptr = <span class="number">0</span>;</span><br><span class="line">			tr.cookie = <span class="number">0</span>;</span><br><span class="line">			cmd = BR_REPLY;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向用户空间发送指令.此时SM会收到BR_TRANSACTION指令</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时binder驱动把BR_TRANSACTION发送到SM中,因此SM的BBinder会解析这个指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意,此时是在servicemanager/binder.c中</span></span><br><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/binder.c</span></span><br><span class="line"><span class="comment">// SM 在启动之后就一直在binder_loop()中死循环收命令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析命令</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> =</span> (struct binder_transaction_data *) ptr;</span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(*txn)) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;parse: txn too small!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line">				<span class="comment">// reply初始化</span></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);  <span class="comment">// 由 svcmgr_handler 处理请求</span></span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);<span class="comment">// 将 reply发给 binder驱动</span></span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/service_manager.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE: <span class="comment">// 316 注册指定服务 if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, txn-&gt;sender_pid))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验服务权限,查看是否可以注册</span></span><br><span class="line">    <span class="keyword">if</span> (!svc_can_register(s, len, spid, uid)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;add_service(&#x27;%s&#x27;,%x) uid=%d - PERMISSION DENIED\n&quot;</span>,</span><br><span class="line">             str8(s, len), handle, uid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找是否服务已经存在</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;handle) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;add_service(&#x27;%s&#x27;,%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n&quot;</span>,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            svcinfo_death(bs, si); <span class="comment">// 服务已注册时，释放相应的服务</span></span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;  <span class="comment">// 重新放入新的</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (!si) &#123;  <span class="comment">// 内存不足，无法分配足够内存</span></span><br><span class="line">            ALOGE(<span class="string">&quot;add_service(&#x27;%s&#x27;,%x) uid=%d - OUT OF MEMORY\n&quot;</span>,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>)); ;<span class="comment">// 内存拷贝服务信息</span></span><br><span class="line">        si-&gt;name[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist;  <span class="comment">// svclist保存所有已注册的服务</span></span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以 BC_ACQUIRE命令，handle为目标的信息，通过ioctl发送给 binder驱动，binder_ref强引用加1操作</span></span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    <span class="comment">// 以 BC_REQUEST_DEATH_NOTIFICATION命令的信息，通过ioctl发送给 binder驱动，主要用于清理内存等收尾工作</span></span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理完添加消息之后, SM的Bbinder发送处理结束消息给binder</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/cmds/servicemanager/binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">binder_uintptr_t</span> buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_free;</span><br><span class="line">        <span class="keyword">binder_uintptr_t</span> buffer;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_reply;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) data;</span><br><span class="line"></span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER; <span class="comment">// free buffer命令</span></span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY; <span class="comment">// 设置命令</span></span><br><span class="line">    data.txn.target.ptr = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123; <span class="comment">// status == 0</span></span><br><span class="line">        data.txn.flags = TF_STATUS_CODE;</span><br><span class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        data.txn.offsets_size = <span class="number">0</span>;</span><br><span class="line">        data.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)&amp;status;</span><br><span class="line">        data.txn.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data.txn.flags = <span class="number">0</span>;</span><br><span class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</span><br><span class="line">        data.txn.offsets_size = ((<span class="keyword">char</span>*) reply-&gt;offs) - ((<span class="keyword">char</span>*) reply-&gt;offs0);</span><br><span class="line">        data.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)reply-&gt;data0;</span><br><span class="line">        data.txn.data.ptr.offsets = (<span class="keyword">uintptr_t</span>)reply-&gt;offs0;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data)); <span class="comment">// 向 Binder驱动通信</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder驱动通过binder_write_read()方法和binder_thread_write()方法收到BC_REPLY之后,调用<code>binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY, 0);</code>方法</p>
<p>像通知客户端一样通知服务端BR_TRANSACTION_COMPLETE,并且将SM挂起.当服务端被挂起之后,通过<code>wake_up_interruptible(target_wait);</code>唤醒客户端. </p>
<p>当客户端被唤醒之后, Binder会在case:BINDER_WORK_TRANSACTION中通知客户端BR_REPLY. 表示此次Binder通信结束.</p>
<h3 id="2-调用流程"><a href="#2-调用流程" class="headerlink" title="2.调用流程"></a>2.调用流程</h3><h5 id="2-1-如何注册到SM中"><a href="#2-1-如何注册到SM中" class="headerlink" title="2.1 如何注册到SM中"></a>2.1 如何注册到SM中</h5><p>getIServiceManager().addService(name, service, false);</p>
<ul>
<li>getIServiceManager — new ServiceManagerProxy(new BinderProxy())<ul>
<li>ServiceManagerNative.asInterface(BinderInternal.getContextObject())<ul>
<li>BinderInternal.getContextObject  — 返回 BinderProxy 对象<ul>
<li>ProcessState::self()-&gt;getContextObject：创建一个BpBinder</li>
<li>javaObjectForIBinder – BinderProxy 和 BpBinder 互相绑定</li>
</ul>
</li>
<li>ServiceManagerNative.asInterface<ul>
<li>返回 ServiceManagerProxy</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>addService<ul>
<li>data.writeStrongBinder(service); – service == AMS — 将AMS 放入 data中</li>
<li>mRemote.transact — mRemote == BinderProxy<ul>
<li>获取BpBinder  — IPCThreadState::transact<ul>
<li>1.writeTransactionData — out 写入命令 –write  — cmd == BC_TRANSACTION</li>
<li>2.waitForResponse<ul>
<li>talkWithDriver – 非常重要 — 代码非常长<ul>
<li>binder_transaction<ul>
<li>handle == 0 –》 sm</li>
<li><ol>
<li>target_node</li>
<li>proc</li>
<li>todo,wait</li>
<li>创建t，tcomplete，</li>
<li>数据拷贝</li>
<li>binder_transaction_binder –&gt; handle</li>
<li>thread-&gt;transaction_stack = t; —&gt; 方便sm找到client</li>
<li>t-&gt;work.type = BINDER_WORK_TRANSACTION; – 给sm – 做事</li>
<li>tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; – 给client–挂起</li>
<li>wake_up_interruptible 唤醒sm</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>client挂起<ul>
<li>BR_NOOP ，BR_TRANSACTION_COMPLETE</li>
<li>wait_event_freezable — 挂起</li>
</ul>
</li>
<li>sm处理添加服务<ul>
<li>BINDER_WORK_TRANSACTION — 要处理 cmd == BR_TRANSACTION</li>
<li><ol>
<li>reply初始化</li>
<li>res = func(bs, txn, &amp;msg, &amp;reply); — 函数指针 — svcmgr_handler作用：获取或者添加 service<ol>
<li>sm是用 svclist  保存所有服务的</li>
</ol>
</li>
<li>binder_send_reply — bc_reply</li>
<li>t-&gt;work.type = BINDER_WORK_TRANSACTION; — 给Client<br>list_add_tail(&amp;t-&gt;work.entry, target_list);<pre><code>   tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; -- 给SM --- 被挂起
   list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
</code></pre>
</li>
<li>wake_up_interruptible(target_wait); – 唤醒 Client</li>
</ol>
</li>
</ul>
</li>
<li>client 被唤醒<ul>
<li>在binder_thread_read()被挂起，当唤醒的时候继续执行</li>
<li>BINDER_WORK_TRANSACTION — cmd = BR_REPLY;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-SM-处理-onTransact"><a href="#2-2-SM-处理-onTransact" class="headerlink" title="2.2 SM 处理 onTransact"></a>2.2 SM 处理 onTransact</h5><ul>
<li><p>IPCThreadState::executeCommand</p>
<ul>
<li><p>error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</p>
<pre><code> &amp;reply, tr.flags);
</code></pre>
</li>
<li><p> JavaBBinder.onTransact — C++</p>
</li>
<li><p>jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</p>
<pre><code> code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); -- Binder.java.execTransact 方法
</code></pre>
</li>
</ul>
</li>
</ul>
<p>binder_node  — binder对象</p>
<p>binder_ref – binder引用</p>
<p>线程池管理</p>
<ul>
<li>主线程 – 不会退出，非主线程 </li>
<li>线程最大数  — 15个 — 非主线程</li>
<li>主线程有一个  – 不算这在线程最大数</li>
<li>线程真正最大数 ： 15 + 1 + 其他线程</li>
</ul>
<p>ProcessState代表一个进程，每一个线程都执行在IPCThreadState中，如果没有线程就会去创建一个。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-5e6fbaa095f979a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder进程与线程.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7ef87a22bc27930d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder类关系图.png"></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tcpdump采集网络请求，使用wireshark查看</title>
    <url>/2021/09/28/%E4%BD%BF%E7%94%A8tcpdump%E9%87%87%E9%9B%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BD%BF%E7%94%A8wireshark%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//  tcpdump参数说明</span><br><span class="line">-a：尝试将网络和广播地址转换成名称； </span><br><span class="line">-c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作； </span><br><span class="line">-d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出； </span><br><span class="line">-dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出； </span><br><span class="line">-ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出； </span><br><span class="line">-e：在每列倾倒资料上显示连接层级的文件头； </span><br><span class="line">-f：用数字显示网际网络地址； </span><br><span class="line">-F&lt;表达文件&gt;：指定内含表达方式的文件； </span><br><span class="line">-i&lt;网络界面&gt;：使用指定的网络截面送出数据包； </span><br><span class="line">-l：使用标准输出列的缓冲区； </span><br><span class="line">-n：不把主机的网络地址转换成名字； </span><br><span class="line">-N：不列出域名； </span><br><span class="line">-O：不将数据包编码最佳化； </span><br><span class="line">-p：不让网络界面进入混杂模式； </span><br><span class="line">-q ：快速输出，仅列出少数的传输协议信息； </span><br><span class="line">-r&lt;数据包文件&gt;：从指定的文件读取数据包数据； </span><br><span class="line">-s&lt;数据包大小&gt;：设置每个数据包的大小； </span><br><span class="line">-S：用绝对而非相对数值列出TCP关联数； </span><br><span class="line">-t：在每列倾倒资料上不显示时间戳记； </span><br><span class="line">-tt： 在每列倾倒资料上显示未经格式化的时间戳记； </span><br><span class="line">-T&lt;数据包类型&gt;：强制将表达方式所指定的数据包转译成设置的数据包类型； </span><br><span class="line">-v：详细显示指令执行过程； </span><br><span class="line">-vv：更详细显示指令执行过程； </span><br><span class="line">-x：用十六进制字码列出数据包资料； </span><br><span class="line">-w&lt;数据包文件&gt;：把数据包数据写入指定的文件。</span><br></pre></td></tr></table></figure>


<h4 id="2-实用命令实例"><a href="#2-实用命令实例" class="headerlink" title="2.实用命令实例"></a>2.实用命令实例</h4><p>2.1 默认启动，可以在控制台输出当前车机所有网络交互的数据包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump</span><br></pre></td></tr></table></figure>


<p>2.2 监视指定网络接口的数据包</p>
<p>查看经过wifi接口的数据包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i wlan0</span><br></pre></td></tr></table></figure>


<p>2.3 监视指定主机和端口的数据包</p>
<p>如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump tcp port 23 and host 210.27.48.1</span><br></pre></td></tr></table></figure>


<p>2.4 输出cap文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i wlan0 -w account.cap</span><br></pre></td></tr></table></figure>


<h4 id="3-使用wireshark查看网络请求交互过程"><a href="#3-使用wireshark查看网络请求交互过程" class="headerlink" title="3.使用wireshark查看网络请求交互过程"></a>3.使用wireshark查看网络请求交互过程</h4><p>首先ping一下请求的域名，查看TSP的ip是多少，可以看到TSP的ip是：193.112.237.202</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">64 bytes from 193.112.237.202: icmp_seq=4 ttl=52 time=19.675 ms</span><br></pre></td></tr></table></figure>


<p>将account.cap拉入wireshark, 在过滤器中过滤无用的交互逻辑</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ip.dst == 193.112.237.202 || ip.dst == 10.41.175.123</span><br></pre></td></tr></table></figure>


<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2014b1cb700b3e6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="车机与tsp交互数据包.png"></p>
<p>然后分析车机与TSP交互的数据包。可以看到wireshark将http握手的报文涂成灰色了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d62668c5741783cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一次完整的网络交互.png"></p>
<p>点开ApplicationData数据包，可以看到传输的数据报是加密的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-2387ea3d3c6f3e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TLS加密后的数据.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>双向认证</tag>
      </tags>
  </entry>
  <entry>
    <title>Init.rc文件解析版</title>
    <url>/2020/07/28/InitRc%E8%A7%A3%E6%9E%90%E7%89%88/</url>
    <content><![CDATA[<blockquote>
<h3 id="Android-Init-Language"><a href="#Android-Init-Language" class="headerlink" title="Android Init Language"></a>Android Init Language</h3><p>Android Init Language中由5类语法组成，分别是Actions, Commands, Services, Options, and Imports </p>
<p> 每一行是一个语句，单词之间用空格分开，如果单词中有空格可以用反斜杠转义，也可以用双引号来引用文本避免和空格冲突，如果一行语句太长可以用 \ 换行，用 # 表示注释</p>
<p> Actions和Services可以作为一个独立的Section,所有的Commands和Options从属于紧挨着的Actions或Services，定义在第一个Section前的Commands和Options将被忽略掉 </p>
<p> Actions和Services都是唯一的，如果定义了两个一样的Action，第二个Action的Command将追加到第一个Action，<br> 如果定义了两个一样的Service，第二个Service将被忽略掉并打印错误日志</p>
<h3 id="Init-rc-Files"><a href="#Init-rc-Files" class="headerlink" title="Init .rc Files"></a>Init .rc Files</h3><p>Android Init Language是用后缀为.rc的纯文本编写的,而且是由多个分布在不同目录下的.rc文件组成,如下所述 </p>
<p> /init.rc 是最主要的一个.rc文件，它由init进程在初始化时加载，主要负责系统初始化,它会导入 /init.${ro.hardware}.rc ，这个是系统级核心厂商提供的主要.rc文件</p>
<p> 当执行 mount_all 语句时，init进程将加载所有在 /{system,vendor,odm}/etc/init/ 目录下的文件，挂载好文件系统后，这些目录将会为Actions和Services服务</p>
<p> 有一个特殊的目录可能被用来替换上面的三个默认目录，这主要是为了支持工厂模式和其他非标准的启动模式,上面三个目录用于正常的启动过程</p>
<p> 这三个用于扩展的目录是</p>
<ol>
<li><p>/system/etc/init/ 用于系统本身，比如SurfaceFlinger, MediaService, and logcatd.</p>
</li>
<li><p>/vendor/etc/init/ 用于SoC(系统级核心厂商，如高通),为他们提供一些核心功能和服务</p>
</li>
<li><p>/odm/etc/init/ 用于设备制造商（odm定制厂商，如华为、小米），为他们的传感器或外围设备提供一些核心功能和服务</p>
</li>
</ol>
<p>所有放在这三个目录下的Services二进制文件都必须有一个对应的.rc文件放在该目录下，并且要在.rc文件中定义service结构,<br> 有一个宏LOCAL_INIT_RC,可以帮助开发者处理这个问题. 每个.rc文件还应当包含一些与该服务相关的actions</p>
<p> 举个例子，在system/core/logcat目录下有logcatd.rc和Android.mk这两个文件. Android.mk文件中用LOCAL_INIT_RC这个宏，在编译时将logcatd.rc放在/system/etc/init/目录下,init进程在调用 mount_all 时将其加载，在合适的时机运行其定义的service并将action放入队列</p>
<p> 将init.rc根据不同服务分拆到不同目录，要比之前放在单个init.rc文件好. 这种方案确保init读取的service和action信息能和同目录下的Services二进制文件更加符合,不再像以前单个init.rc那样.<br> 另外，这样还可以解决多个services加入到系统时发生的冲突，因为他们都拆分到了不同的文件中</p>
<p> 在 mount_all 语句中有 “early” 和 “late” 两个可选项，当 early 设置的时候，init进程将跳过被 latemount 标记的挂载操作，并触发fs encryption state 事件，<br> 当 late 被设置的时候，init进程只会执行 latemount 标记的挂载操作，但是会跳过导入的 .rc文件的执行. 默认情况下，不设置任何选项，init进程将执行所有挂载操作</p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>Actions由一行行命令组成. trigger用来决定什么时候触发这些命令,当一个事件满足trigger的触发条件时，<br> 这个action就会被加入到处理队列中（除非队列中已经存在）</p>
<p> 队列中的action按顺序取出执行，action中的命令按顺序执行. 这些命令主要用来执行一些操作（设备创建/销毁，属性设置，进程重启）</p>
<p> Actions的格式如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">on <span class="tag">&lt;<span class="name">trigger</span>&gt;</span> [&amp;&amp; <span class="tag">&lt;<span class="name">trigger</span>&gt;</span>]*</span><br><span class="line">   <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">command</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>Services是init进程启动的程序,它们也可能在退出时自动重启. Services的格式如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>Options是Services的参数配置. 它们影响Service如何运行及运行时机</p>
<p> console [<console>]</console></p>
<p> Service需要控制台. 第二个参数console的意思是可以设置你想要的控制台类型，默认控制台是/dev/console ,/dev 这个前缀通常是被忽略的，比如你要设置控制台 /dev/tty0 ,那么只需要设置为console tty0</p>
<p> critical</p>
<p> 表示Service是严格模式. 如果这个Service在4分钟内退出超过4次，那么设备将重启进入recovery模式</p>
<p> disabled</p>
<p> 表示Service不能以class的形式启动，只能以name的形式启动</p>
<p> setenv <name> <value></value></name></p>
<p> 在Service启动时设置name-value的环境变量</p>
<p> socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]</seclabel></group></user></perm></type></name></p>
<p> 创建一个unix域的socket,名字叫/dev/socket/name , 并将fd返回给Service. type 只能是 “dgram”, “stream” or “seqpacket”.<br> User 和 group 默认值是 0. ‘seclabel’ 是这个socket的SELinux安全上下文,它的默认值是service安全策略或者基于其可执行文件的安全上下文.<br> 它对应的本地实现在libcutils的android_get_control_socket</p>
<p> file <path></path> <type></type></p>
<p> 打开一个文件，并将fd返回给这个Service. type 只能是 “r”, “w” or “rw”. 它对应的本地实现在libcutils的android_get_control_file </p>
<p> user <username></username></p>
<p> 在启动Service前将user改为username,默认启动时user为root(或许默认是无).<br> 在Android M版本，如果一个进程想拥有Linux capabilities（相当于Android中的权限吧），也只能通过设置这个值. 以前，一个程序要想有Linux capabilities，必须先以root身份运行，然后再降级到所需的uid.<br> 现在已经有一套新的机制取而代之，它通过fs_config允许厂商赋予特殊二进制文件Linux capabilities. 这套机制的说明文档在<a href="http://source.android.com/devices/tech/config/filesystem.html">http://source.android.com/devices/tech/config/filesystem.html</a>.<br> 当使用这套新的机制时，程序可以通过user参数选择自己所需的uid,而不需要以root权限运行. 在Android O版本，<br> 程序可以通过capabilities参数直接申请所需的能力，参见下面的capabilities说明</p>
<p> group <groupname> [ <groupname>* ]</groupname></groupname></p>
<p> 在启动Service前将group改为第一个groupname,第一个groupname是必须有的，<br> 默认值为root（或许默认值是无），第二个groupname可以不设置，用于追加组（通过setgroups）.</p>
<p> capabilities <capability> [ <capability>* ]</capability></capability></p>
<p> 在启动Service时将capabilities设置为capability. ‘capability’ 不能是”CAP_” prefix, like “NET_ADMIN” or “SETPCAP”. 参考<br> <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">http://man7.org/linux/man-pages/man7/capabilities.7.html</a> ，里面有capability的说明.</p>
<p> seclabel <seclabel></seclabel></p>
<p> 在启动Service前将seclabel设置为seclabel. 主要用于在rootfs上启动的service，比如ueventd, adbd.<br> 在系统分区上运行的service有自己的SELinux安全策略，如果不设置，默认使用init的安全策略.</p>
<p> oneshot</p>
<p> 退出后不再重启</p>
<p> class <name> [ <name>* ]</name></name></p>
<p> 为Service指定class名字. 同一个class名字的Service会被一起启动或退出,默认值是”default”,第二个name可以不设置，用于service组.</p>
<p> animation class</p>
<p> animation class 主要包含为开机动画或关机动画服务的service. 它们很早被启动，而且直到关机最后一步才退出.<br> 它们不允许访问/data 目录，它们可以检查/data目录，但是不能打开 /data 目录，而且需要在 /data 不能用时也正常工作 .</p>
<p> onrestart </p>
<p> 在Service重启时执行命令.</p>
<p> writepid <file> [ <file>* ]</file></file></p>
<p> 当Service调用fork时将子进程的pid写入到指定文件. 用于cgroup/cpuset的使用，当/dev/cpuset/下面没有文件但ro.cpuset.default的值却不为空时,<br> 将pid的值写入到/dev/cpuset/cpuset_name/tasks文件中</p>
<p> priority <priority></priority></p>
<p> 设置进程优先级. 在-20～19之间，默认值是0,能过setpriority实现</p>
<p> namespace &lt;pid|mnt&gt;</p>
<p> 当fork这个service时，设置pid或mnt标记</p>
<p> oom_score_adjust <value></value></p>
<p> 设置子进程的 /proc/self/oom_score_adj 的值为 value,在 -1000 ～ 1000之间.</p>
<h3 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h3><p>Triggers 是个字符串，当一些事件发生满足该条件时，一些actions就会被执行</p>
<p> Triggers分为事件Trigger和属性Trigger</p>
<p> 事件Trigger由trigger 命令或QueueEventTrigger方法触发.它的格式是个简单的字符串，比如’boot’ 或 ‘late-init’.</p>
<p> 属性Trigger是在属性被设置或发生改变时触发. 格式是’property:<name>=<value>‘或’property:<name>=*’,它会在init初始化设置属性的时候触发.</name></value></name></p>
<p> 属性Trigger定义的Action可能有多种触发方式，但是事件Trigger定义的Action可能只有一种触发方式</p>
<p> 比如：</p>
<p> on boot &amp;&amp; property:a=b 定义了action的触发条件是，boot Trigger触发，并且属性a的值等于b</p>
<p> on property:a=b &amp;&amp; property:c=d 这个定义有三种触发方式:</p>
<ol>
<li>在初始化时，属性a=b,属性c=d.</li>
<li>在属性c=d的情况下，属性a被改为b.</li>
<li>A在属性a=b的情况下，属性c被改为d.</li>
</ol>
<h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootchart [start|stop]</span><br></pre></td></tr></table></figure>

<p> 启动或终止bootcharting. 这个出现在init.rc文件中，但是只有在/data/bootchart/enabled文件存在的时候才有效，否则不能工作</p>
<p> chmod <octal-mode> <path></path></octal-mode></p>
<p> 修改文件读写权限</p>
<p> chown <owner> <group> <path></path></group></owner></p>
<p> 修改文件所有者或所属用户组</p>
<p> class_start <serviceclass></serviceclass></p>
<p> 启动所有以serviceclass命名的未启动的service(service有一个name，也有个class，<br> 这里的serviceclass就是class,class_start和后面的start是两种启动方式，class_start是class形式启动，start是name形式启动)</p>
<p> class_stop <serviceclass> </serviceclass></p>
<p> 终止所有以serviceclass命名的正在运行的service</p>
<p> class_reset <serviceclass></serviceclass></p>
<p> 终止所有以serviceclass命名的正在运行的service,但是不禁用它们. 它们可以稍后被class_start重启</p>
<p> class_restart <serviceclass></serviceclass></p>
<p> 重启所有以serviceclass命名的service</p>
<p> copy <src> <dst></dst></src></p>
<p> 复制一个文件，与write相似，比较适合二进制或比较大的文件.</p>
<p> 对于src,从链接文件、world-writable或group-writable复制是不允许的.</p>
<p> 对于dst，如果目标文件不存在，则默认权限是0600,如果存在就覆盖掉</p>
<p> domainname <name></name></p>
<p> 设置域名</p>
<p> enable <servicename></servicename></p>
<p> 将一个禁用的service设置为可用.<br> 如果这个service在运行，那么就会重启.<br> 一般用在bootloader时设置属性，然后启动一个service，比如<br> on property:ro.boot.myfancyhardware=1<br> enable my_fancy_service_for_my_fancy_hardware<br> exec [ <seclabel> [ <user> [ <group>* ] ] ] – <command> [ <argument>* ]<br> 新建子进程并运行一个带指定参数的命令. 这个命令指定了seclabel（安全策略），user(所有者)，group(用户组).<br> 直到这个命令运行完才可以运行其他命令，seclabel可以设置为 - 表示用默认值，argument表示属性值.<br> 直到子进程新建完毕，init进程才继续执行.</argument></group></user></seclabel></p>
<p> exec_start <service></service></p>
<p> 启动一个service，只有当执行结果返回，init进程才能继续执行. 这个跟exec相似，只是将一堆参数的设置改在在service中定义</p>
<p> export <name> <value></value></name></p>
<p> 设置环境变量name-value. 这个环境变量将被所有已经启动的service继承</p>
<p> hostname <name> </name></p>
<p> 设置主机名</p>
<p> ifup <interface></interface></p>
<p> 开启指定的网络接口</p>
<p> insmod [-f] <path></path> [<options>]</options></p>
<p> 安装path下的模块，指定参数options.</p>
<p> -f 表示强制安装，即便是当前Linux内核版本与之不匹配</p>
<p> load_all_props</p>
<p> 加载/system, /vendor等目录下的属性，这个用在init.rc中</p>
<p> load_persist_props</p>
<p> 加载/data 下的持久化属性. 这个用在init.rc中</p>
<p> loglevel <level></level></p>
<p> 设置日志输出等级，level表示等级</p>
<p> mkdir <path></path> [mode] [owner] [group]</p>
<p> 创建一个目录，path是路径，mode是读写权限，默认值是755,owner是所有者，默认值root,group是用户组,默认值是root.<br> 如果该目录已存在，则覆盖他们的mode,owner等设置</p>
<p> mount_all <fstab> [ <path></path> ]* [–<option>]</option></fstab></p>
<p> 当手动触发 “early” 和 “late”时，调用fs_mgr_mount_all 函数，指定fstab配置文件，并导入指定目录下的.rc文件<br> 详情可以查看init.rc文件中的有关定义</p>
<p> mount <type> <device> <dir> [ <flag>* ] [<options>]</options></flag></dir></device></type></p>
<p> 在dir目录下挂载一个名叫device的设备</p>
<p> _flag 包括 “ro”, “rw”, “remount”, “noatime”, …</p>
<p> options 包括 “barrier=1”, “noauto_da_alloc”, “discard”, … 用逗号分开，比如 barrier=1,noauto_da_alloc</p>
<p> restart <service></service></p>
<p> 终止后重启一个service,如果这个service刚被重启就什么都不做，如果没有在运行，就启动</p>
<p> restorecon <path></path> [ <path></path>* ]</p>
<p> 恢复指定目录下文件的安全上下文.第二个path是安全策略文件. 指定目录不需要必须存在，因为它只需要在init中正确标记</p>
<p> restorecon_recursive <path></path> [ <path></path>* ]</p>
<p> 递归地恢复指定目录下的安全上下文，第二个path是安全策略文件位置</p>
<p> rm <path></path></p>
<p> 调用 unlink(2)删除指定文件. 最好用exec – rm …代替，因为这样可以确保系统分区已经挂载好</p>
<p> rmdir <path></path></p>
<p> 调用 rmdir(2) 删除指定目录</p>
<p> setprop <name> <value></value></name></p>
<p> 设置属性name-value </p>
<p> setrlimit <resource> <cur> <max></max></cur></resource></p>
<p> 指定一个进程的资源限制</p>
<p> start <service> </service></p>
<p> 启动一个未运行的service</p>
<p> stop <service></service></p>
<p> 终止一个正在运行的service</p>
<p> swapon_all <fstab></fstab></p>
<p> 调用 fs_mgr_swapon_all，指定fstab配置文件.</p>
<p> symlink <target> <path></path></target></p>
<p> 在path下创建一个指向target的链接</p>
<p> sysclktz <mins_west_of_gmt></mins_west_of_gmt></p>
<p> 重置系统基准时间(如果是格林尼治标准时间则设置为0)</p>
<p> trigger <event></event></p>
<p> 触发事件event，由一个action触发到另一个action队列</p>
<p> umount <path></path></p>
<p> 卸载指定path的文件系统</p>
<p> verity_load_state</p>
<p> 内部实现是加载dm-verity的状态</p>
<p> verity_update_state <mount-point></mount-point></p>
<p> 内部实现是设置dm-verity的状态，并且设置partition.mount-point.verified的属性. 用于adb重新挂载，<br> 因为fs_mgr 不能直接设置它。 </p>
<p> wait <path></path> [ <timeout> ]</timeout></p>
<p> 查看指定路径是否存在. 如果发现则返回,可以设置超时时间，默认值是5秒</p>
<p> wait_for_prop <name> <value></value></name></p>
<p> 等待name属性的值被设置为value，如果name的值一旦被设置为value，马上继续</p>
<p> write <path></path> <content></content></p>
<p> 打开path下的文件，并用write(2)写入content内容. 如果文件不存在就会被创建，如果存在就会被覆盖掉</p>
<h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>import关键字不是一个命令，但是如果有.rc文件包含它就会马上解析它里面的section,用法如下：</p>
<p> import <path></path></p>
<p> 解析path下的.rc文件 ，括展当前文件的配置。如果path是个目录，这个目录下所有.rc文件都被解析，但是不会递归,<br> import被用于以下两个地方：</p>
<p> 1.在初始化时解析init.rc文件</p>
<p> 2.在mount_all时解析{system,vendor,odm}/etc/init/等目录下的.rc文件</p>
<p> 后面的内容主要是一些跟调试init进程相关的东西，比如init.svc.<name>可以查看service启动的状态，<br> ro.boottime.init记录一些关键的时间点，Bootcharting是一个图表化的性能监测工具等</name></p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Init</tag>
      </tags>
  </entry>
  <entry>
    <title>Launcher启动分析-系统优化</title>
    <url>/2021/10/09/Launcher%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90-%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="1-Launcher耗时大方向优化"><a href="#1-Launcher耗时大方向优化" class="headerlink" title="1.Launcher耗时大方向优化"></a>1.Launcher耗时大方向优化</h4><h5 id="1-1-IO优化"><a href="#1-1-IO优化" class="headerlink" title="1.1 IO优化"></a>1.1 IO优化</h5><p>MyApplication和LauncherActivity Oncreate()中IO操作判断哪些是必须的，非必须的，使用子线程或者延后加载。默认启动VPA界面，可以先将布局加载出来之后，然后通知退出开机动画，使用IdleHandle加载资源显示具体的资源内容。</p>
<h5 id="1-2-懒加载或者初始化时机"><a href="#1-2-懒加载或者初始化时机" class="headerlink" title="1.2 懒加载或者初始化时机"></a>1.2 懒加载或者初始化时机</h5><p>Launcher有三个Fragment：MapFragment、VpaFragment和CarFragment。默认启动的VpaFragment，其他两个Fragment不显示，相关资源不要在启动界面加载。</p>
<h5 id="1-3-找退出开机动画的时机"><a href="#1-3-找退出开机动画的时机" class="headerlink" title="1.3 找退出开机动画的时机"></a>1.3 找退出开机动画的时机</h5><p>由于当前项目开机动画由QNX来控制，Android原生开机动画被QNX图层覆盖，因此Launcher需要</p>
<h4 id="2-MyApplication耗时分析"><a href="#2-MyApplication耗时分析" class="headerlink" title="2.MyApplication耗时分析"></a>2.MyApplication耗时分析</h4><h5 id="2-1-initConfig"><a href="#2-1-initConfig" class="headerlink" title="2.1 initConfig();"></a>2.1 initConfig();</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-3b63bfee2fec645e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="initConfig.png"></p>
<p>初始化配置耗费470ms, 其中加载so库耗时231ms, 初始化资源花费212ms.</p>
<p>此部分主要涉及IO操作：</p>
<p><strong>建议：</strong></p>
<ul>
<li>so库如果属于VPA不相关的库，延迟加载该库。</li>
<li>initRes()方法中有大量地图相关的配置文件和资源加载，尽量延后到VPA启动之后或者在加载MapFragment的时候在初始化这部分资源。</li>
</ul>
<h5 id="2-2-TtsPlayManager-init-this"><a href="#2-2-TtsPlayManager-init-this" class="headerlink" title="2.2 TtsPlayManager.init(this);"></a>2.2 TtsPlayManager.init(this);</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-05d6eb2d175c7bdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TtsPlayManager.png"></p>
<p>TtsPlayManager的初始化方法主要实现了初始speaker和初始化naviTts.</p>
<p>其中初始speaker消耗8.6ms, 初始化navi Tts消耗70.2ms.</p>
<p><strong>建议：</strong></p>
<ul>
<li>navi Tts初始化推迟加载</li>
</ul>
<h5 id="2-3-CommonUtil-initLayerStyle-；"><a href="#2-3-CommonUtil-initLayerStyle-；" class="headerlink" title="2.3  CommonUtil.initLayerStyle()；"></a>2.3  CommonUtil.initLayerStyle()；</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-3c6d47e1e553125f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="initLayerStyle.png"></p>
<p>存解析json配置文件，消耗42ms.</p>
<p>建议：</p>
<ul>
<li>如果和地图相关的初始化是否可以和地图初始化放一起。</li>
</ul>
<h5 id="2-4-FontsOverrideUtil-setDefaultFont"><a href="#2-4-FontsOverrideUtil-setDefaultFont" class="headerlink" title="2.4 FontsOverrideUtil.setDefaultFont();"></a>2.4 FontsOverrideUtil.setDefaultFont();</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-1edc61b95f1d31df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置字体.png"></p>
<p>加载三类字体，每个耗时17ms左右</p>
<p>建议：</p>
<ul>
<li>此处只是列出耗时，如果却有必要，可不优化。</li>
</ul>
<h4 id="3-LauncherActivity耗时分析"><a href="#3-LauncherActivity耗时分析" class="headerlink" title="3. LauncherActivity耗时分析"></a>3. LauncherActivity耗时分析</h4><h5 id="3-1-加载布局文件"><a href="#3-1-加载布局文件" class="headerlink" title="3.1 加载布局文件"></a>3.1 加载布局文件</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-0ce6ee6ad3b02e9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载view.png"></p>
<p>主界面加载布局文件消耗41ms。此处看加载布局文件耗时不算多，确实需要优化可以考虑使用异步加载布局。</p>
<p><strong>建议：</strong></p>
<ul>
<li>异步加载布局</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> AsyncLayoutInflater(<span class="keyword">this</span>).inflate(R.layout.activity_main, <span class="keyword">null</span>, <span class="keyword">new</span> AsyncLayoutInflater.OnInflateFinishedListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInflateFinished</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="keyword">int</span> resid, <span class="meta">@Nullable</span> ViewGroup parent)</span> </span>&#123;</span><br><span class="line">            setContentView(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意此处或者当VPA fragment加载完成之后考虑一下是否可以通知开机动画退出？</strong>内容的展示后面加载出来在更新。</li>
</ul>
<h5 id="3-2-自定义viewpage耗时"><a href="#3-2-自定义viewpage耗时" class="headerlink" title="3.2 自定义viewpage耗时"></a>3.2 自定义viewpage耗时</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-eacc605e8c4e4076.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义ViewPage加载布局耗时.png"></p>
<p>从图中可以看到自定义ViewPage在测量阶段耗时1.36s。(后面细化分析每个fragment启动耗时)</p>
<p>从下面细化调用栈看，ViewPage中有加载三个fragment：MapFragment、VpaFragment和CarFragment。</p>
<h5 id="3-2-1-VPA-Fragment加载耗时"><a href="#3-2-1-VPA-Fragment加载耗时" class="headerlink" title="3.2.1 VPA Fragment加载耗时"></a>3.2.1 VPA Fragment加载耗时</h5><p>VPA fragment由两部分内容构成，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-92895ea2041a8e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vpafragment1.png"></p>
<p>第一部分加载布局耗时115ms。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7142fc0b55491348.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vpafragment2.png"></p>
<p>第二部分加载布局耗时110ms。</p>
<p>看了代码以上两部分耗时主要是加载布局文件耗时，可以暂时不优化。</p>
<h5 id="3-2-2-MapFragment加载耗时"><a href="#3-2-2-MapFragment加载耗时" class="headerlink" title="3.2.2 MapFragment加载耗时"></a>3.2.2 MapFragment加载耗时</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-efee34e7eb144948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="map fragment.png"></p>
<p>从上图中可以看到map fragment加载耗时840ms, 其中初始化消耗103ms, 加载显示地图资源(showMap())消耗736ms。</p>
<p>在showMap()方法中主要完成两部分工作：初始化view(101ms)和初始化地图资源(635ms)。</p>
<h5 id="3-2-3-CarFragment加载耗时"><a href="#3-2-3-CarFragment加载耗时" class="headerlink" title="3.2.3 CarFragment加载耗时"></a>3.2.3 CarFragment加载耗时</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-aebbd20a93e61b33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CarFragment.png"></p>
<p>从图中可以看出CarFragment主要完成的是布局加载，可以暂时不优化。</p>
<h5 id="3-2-4-fragment加载总结"><a href="#3-2-4-fragment加载总结" class="headerlink" title="3.2.4 fragment加载总结"></a>3.2.4 fragment加载总结</h5><p>结合当前交付场景：Launcher启动之后只需要展示VPA Fragment，因此需要FO实现viewpage懒加载机制。</p>
<p>我看当前代码是自定义viewgroup来实现的viewpage，是否可以直接使用viewpage2自带懒加载效果，或者结合viewpage+fragment，利用setUserVisibleHint(boolean isvisible)和isViewCreated()来实现懒加载效果。</p>
<p>从上面分析看，如果只加载VPA Fragment,不加载MapFragment和Car Fragment，应该至少可以优化 <strong>1s</strong> 以上的启动耗时。</p>
<h4 id="4-通知QNX退出开机动画"><a href="#4-通知QNX退出开机动画" class="headerlink" title="4. 通知QNX退出开机动画"></a>4. 通知QNX退出开机动画</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.gxatek.cockpit.launcher.LauncherActivity</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    Logger.d(TAG, <span class="string">&quot;onStart, CarPowerManager.connect()&quot;</span>);</span><br><span class="line">    mPower = CarPowerManager.getInstance(getApplicationContext(), carPowerEventListener);</span><br><span class="line">    mPower.connect();</span><br><span class="line">    <span class="keyword">if</span> (curIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        ((MapFragment) currentFragment).showMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CarPowerEventListener carPowerEventListener = <span class="keyword">new</span> CarPowerEventListener() &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCarPowerServiceConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Logger.d(TAG, <span class="string">&quot;CarPowerManager onCarPowerServiceConnected, CarPowerManager.exitAnimationReq&quot;</span>);</span><br><span class="line">        mPower.exitAnimationReq();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，Launcher通知开机动画退出的时机是：当所有布局和资源加载完成(onCreate())之后，再去绑定CarPower服务，绑定成功之后通知qnx退出开机动画。</p>
<p>正常情况下绑定服务也会耗时200-300ms。</p>
<p>因此在此环节的优化建议：</p>
<ul>
<li>在onCreate()中加载完布局之后就绑定CarPower服务</li>
<li>当VPA Fragment布局加载完成之后就通知QNX退出开机动画。</li>
</ul>
<h4 id="5-其他优化建议"><a href="#5-其他优化建议" class="headerlink" title="5.其他优化建议"></a>5.其他优化建议</h4><h5 id="5-1-Arouter插件优化"><a href="#5-1-Arouter插件优化" class="headerlink" title="5.1 Arouter插件优化"></a>5.1 Arouter插件优化</h5><p>我看项目代码中有用到Arouter插件，可以在项目中集成Arouter Gradle 插件来实现自动注册功能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-beddc2deae814580.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arouter优化.png"></p>
<h5 id="5-2-EventBus-Apt优化"><a href="#5-2-EventBus-Apt优化" class="headerlink" title="5.2 EventBus Apt优化"></a>5.2 EventBus Apt优化</h5><p><em>EventBus 3.0</em>之前的版本是没有索引的，检索订阅方法是通过反射获取的。我们都知道反射的效率令人堪忧，如果频繁地调用的话，肯定会对程序的性能造成影响。而<em>greenrobot</em>也意识到这个问题，所以在<em>EventBus 3.0</em>版本新增一个索引的功能，它主要是通过在编译期处理，生成订阅者和订阅方法的对应关系并缓存起来，从而在程序运行时能快速索引。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4f346359b9969e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eventbus优化.png"></p>
<h5 id="5-3-SharedPreference优化"><a href="#5-3-SharedPreference优化" class="headerlink" title="5.3 SharedPreference优化"></a>5.3 SharedPreference优化</h5><p>如果启动时加载的sharedpreference过大，可以拆分sharedpreference，将启动需要的配置分成一个sharedpreference，不相关的配置分成另一个sharedpreference。降低启动依赖配置文件的加载和解析时间。</p>
<p><strong>参考文档：</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/30601168">1.《你知道android的MessageQueue.IdleHandler吗？》</a></p>
<p><a href="https://github.com/alibaba/ARouter">2.《alibaba/ARouter:  A framework for assisting in the renovation of Android componentization (帮助 Android App 进行组件化改造的路由框架) (github.com)》</a></p>
<p><a href="https://www.jianshu.com/p/3f9e55a3628a">3.《EventBus源码详解（二）：进阶使用 》</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>Launcher</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统启动流程分析</title>
    <url>/2021/09/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写这篇blog背景是项目在做系统启动耗时优化，之前看了两遍罗升阳大神《Android系统源代码情景分析》都只是看了，没有实践，没有运用到项目中，因此借项目在做系统优化的机会，再次将Android系统的启动流程细细的在撸一遍，边撸边思考哪些点可以优化。</p>
<p><strong>声明：</strong>由于家里面的代码是去年下的，去年还在做Android O（android-8.0.0_r1）的系统项目，如果博客中有方法在你的代码中找不到，要么选择和我一起看Android O的R1版本代码，要么可以尝试找找你下载版本的源码是否有对我博客中的代码进行封装。因为我经常发现google会将代码在不同版本中封装。大致流程肯定是完全一样的。</p>
<p><strong>说明：</strong>这篇博客着实有点长，我本来想分几篇写的，但是感觉分几篇就不完整了，分散了心里始终感觉哪里不对头，所有就没分散。<strong>我不能保证你一定能看完这篇博客，但是我可以保证你看完这篇博客，你肯定会对Android系统启动有更深的理解。</strong>为了方便理解，我先丢两张图，先看图有个直观的认识，再看方法实现了什么功能更容易理解，也更容易在跟踪方法调用迷糊时找到调入的地方。</p>
<p>如果看不清楚，原图下载传送门：<a href="https://github.com/oujie123/PicFactory/tree/master/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90">系统启动分析</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-16a9c1104596572c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android启动流程.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-25069836292c204c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android系统启动_简略方法.png"></p>
<h4 id="1-Android系统大致启动流程"><a href="#1-Android系统大致启动流程" class="headerlink" title="1.Android系统大致启动流程"></a>1.Android系统大致启动流程</h4><p>第一步：  启动电源以及系统启动<br>当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后 执行引导程序。</p>
<p>第二步：引导程序<br>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针 对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qi bootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运 营商加锁和限制的地方。<br>引导程序分两个阶段执行。<br>第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；<br>第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程 序可以根据配置参数或者输入数据设置内核。<br>Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。传统的加载器包含两个文件， 需要在这里说明：<br>init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；<br>main.c初始化硬件（闹钟、主板、键盘、控制台），创建linux标签</p>
<p>第三步：内核<br>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表， 加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第 一个进程 </p>
<p>第四步：init进程<br>init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进 程，并调用init中的main()方法执行init进程的职责。 </p>
<p>第五步：启动zygote进程，通过zygote启动SystemServer，当服务都启动完成之后，启动Lancher App，然后退出开机动画。我们就可以看到桌面应用，此时启动过程就结束了。</p>
<h4 id="2-启动init进程"><a href="#2-启动init进程" class="headerlink" title="2.启动init进程"></a>2.启动init进程</h4><p>init进程是Android系统中及其重要的第一个进程，是由内核拉起来的第一个用户进程。</p>
<p>init进程主要完成了三件事情。</p>
<ul>
<li>创建和挂载启动所需要的文件目录 </li>
<li>初始化和启动属性服务 </li>
<li>解析init.rc配置文件并启动Zygote进程</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \system\core\init\init.cpp main()</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 1.C++中主函数有两个参数，第一个参数argc表示参数个数，第二个参数是参数列表，也就是具体 的参数 </span></span><br><span class="line"><span class="comment">* 2.init的main函数有两个其它入口，一是参数中有ueventd，进入ueventd_main,二是参数中 有watchdogd，进入watchdogd_main </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 1.strcmp是String的一个函数，比较字符串，相等返回0 </span></span><br><span class="line"><span class="comment">    * 2.C++中0也可以表示false </span></span><br><span class="line"><span class="comment">    * 3.basename是C库中的一个函数，得到特定的路径中的最后一个&#x27;/&#x27;后面的内容， </span></span><br><span class="line"><span class="comment">    * 比如/sdcard/miui_recovery/backup，得到的结果是backup </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">&quot;ueventd&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//当argv[0]的内容为ueventd 时，strcmp的值为0,！strcmp为1 </span></span><br><span class="line">		<span class="comment">//1表示true，也就执行ueventd_main,ueventd主要是负责设备节点的创建、权限设定等一系列工作</span></span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">&quot;watchdogd&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//watchdogd俗称看门狗，用于 系统出问题时重启系统</span></span><br><span class="line">        <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        <span class="comment">//初始化重启系统的处理信号，内部通过sigaction 注册信号，当监听到该信号时重启系统</span></span><br><span class="line">        install_reboot_signal_handlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_environment(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看是否有环境变量INIT_SECOND_STAGE</span></span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (getenv(<span class="string">&quot;INIT_SECOND_STAGE&quot;</span>) == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.init的main方法会执行两次，由is_first_stage控制,first_stage就是第一阶段要做的事</span></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear the umask.</span></span><br><span class="line">        <span class="comment">//清空文件权限</span></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">        <span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line">        <span class="comment">//mount是用来挂载文件系统的，mount属于Linux系统调用</span></span><br><span class="line">        mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>);</span><br><span class="line">        mkdir(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>);;<span class="comment">//创建目录，第一个参数是目录路径，第二个是读写权限</span></span><br><span class="line">        mkdir(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">        mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">        mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC));</span><br><span class="line">        <span class="comment">// Don&#x27;t expose the raw commandline to unprivileged processes.</span></span><br><span class="line">        chmod(<span class="string">&quot;/proc/cmdline&quot;</span>, <span class="number">0440</span>);<span class="comment">//用于修改文件/目录的读写权限</span></span><br><span class="line">        <span class="keyword">gid_t</span> groups[] = &#123; AID_READPROC &#125;;</span><br><span class="line">        <span class="comment">// 用来将list数组中所标明的组加入到目前进程的组设置中</span></span><br><span class="line">        setgroups(arraysize(groups), groups);</span><br><span class="line">        mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        mount(<span class="string">&quot;selinuxfs&quot;</span>, <span class="string">&quot;/sys/fs/selinux&quot;</span>, <span class="string">&quot;selinuxfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//mknod用于创建Linux中的设备文件</span></span><br><span class="line">        mknod(<span class="string">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class="number">0600</span>, makedev(<span class="number">1</span>, <span class="number">11</span>));</span><br><span class="line">        mknod(<span class="string">&quot;/dev/random&quot;</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line">        mknod(<span class="string">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that tmpfs is mounted on /dev and we have /dev/kmsg, we can actually</span></span><br><span class="line">        <span class="comment">// talk to the outside world...</span></span><br><span class="line">        <span class="comment">//将标准输入输出重定向到&quot;/sys/fs/selinux/null&quot;</span></span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">&quot;init first stage started!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to mount required partitions early ...&quot;</span>;</span><br><span class="line">            panic();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Avb即Android Verfied boot,功能包括Secure Boot, verfying boot 和dm-verity, </span></span><br><span class="line">		<span class="comment">//原理都是对二进制文件进行签名，在系统启动时进行认证，确保系统运行的是合法的二进制镜像文件。 </span></span><br><span class="line">		<span class="comment">//其中认证的范围涵盖：bootloader，boot.img，system.img</span></span><br><span class="line">        <span class="comment">// 通过调用FsManagerAvbHandle::Open()-&gt;FsManagerAvbOps::AvbSlotVerify-&gt;avb_slot_verify最终去验证每个分区。</span></span><br><span class="line">        <span class="comment">// 当验证成功之后，会将版本信息写到环境变量 INIT_AVB_VERSION 中</span></span><br><span class="line">        SetInitAvbVersionInRecovery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up SELinux, loading the SELinux policy.</span></span><br><span class="line">        <span class="comment">//加载SELinux policy，也就是安全策略，</span></span><br><span class="line">        selinux_initialize(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;re in the kernel domain, so re-exec init to transition to the init domain now</span></span><br><span class="line">        <span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line">        <span class="comment">// 我们执行第一遍init的main方法是在kernel domain，所以要重新执行init文件，切换到加载了selinux策略的init domain，</span></span><br><span class="line">        <span class="keyword">if</span> (restorecon(<span class="string">&quot;/init&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">&quot;restorecon failed&quot;</span>;</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置进入第二阶段标志位，进入第二阶段</span></span><br><span class="line">        setenv(<span class="string">&quot;INIT_SECOND_STAGE&quot;</span>, <span class="string">&quot;true&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> kNanosecondsPerMillisecond = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">uint64_t</span> start_ms = start_time.time_since_epoch().count() / kNanosecondsPerMillisecond;</span><br><span class="line">        setenv(<span class="string">&quot;INIT_STARTED_AT&quot;</span>, StringPrintf(<span class="string">&quot;%&quot;</span> PRIu64, start_ms).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>* args[] = &#123; path, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        <span class="comment">// 重新执行init,由于标志位置为了，因此再次执行init会进入阶段。</span></span><br><span class="line">        execv(path, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">        <span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we&#x27;re in the second stage of init.</span></span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;init second stage started!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up a session keyring that all processes will have access to. It</span></span><br><span class="line">    <span class="comment">// will hold things like FBE encryption keys. No process should override</span></span><br><span class="line">    <span class="comment">// its session keyring.</span></span><br><span class="line">    keyctl(KEYCTL_GET_KEYRING_ID, KEY_SPEC_SESSION_KEYRING, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">    close(open(<span class="string">&quot;/dev/.booting&quot;</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化属性系统，并从指定文件读取属性</span></span><br><span class="line">    <span class="comment">// bionic/libc/bionic/system_properties.c</span></span><br><span class="line">    <span class="comment">// __system_property_area_init-&gt;map_prop_area_rw-&gt;打开/dev/__properties__文件-&gt;并且映射128kb空间大小内存来存属性键值对。</span></span><br><span class="line">    property_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If arguments are passed both on the command line and in DT,</span></span><br><span class="line">    <span class="comment">// properties set in DT always have priority over the command-line ones.</span></span><br><span class="line">    <span class="comment">//接下来的一系列操作都是从各个文件读取一些属性，然后通过property_set设置系统属性</span></span><br><span class="line">    <span class="comment">// 1.这句英文的大概意思是，如果参数同时从命令行和DT传过来，DT的优先级总是大于命令行的。</span></span><br><span class="line">    <span class="comment">// 2.DT即device-tree，中文意思是设备树，这里面记录自己的硬件配置和系统运行参数，参考http://www.wowotech.net/linux_kenrel/why-dt.html</span></span><br><span class="line">    process_kernel_dt();<span class="comment">//处理DT属性</span></span><br><span class="line">    process_kernel_cmdline();<span class="comment">//处理命令行属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate the kernel variables to internal variables</span></span><br><span class="line">    <span class="comment">// used by init as well as the current required properties.</span></span><br><span class="line">    export_kernel_boot_props();<span class="comment">//处理其他的一些属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the time that init started available for bootstat to log.</span></span><br><span class="line">    property_set(<span class="string">&quot;ro.boottime.init&quot;</span>, getenv(<span class="string">&quot;INIT_STARTED_AT&quot;</span>));</span><br><span class="line">    property_set(<span class="string">&quot;ro.boottime.init.selinux&quot;</span>, getenv(<span class="string">&quot;INIT_SELINUX_TOOK&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set libavb version for Framework-only OTA match in Treble build.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* avb_version = getenv(<span class="string">&quot;INIT_AVB_VERSION&quot;</span>);</span><br><span class="line">    <span class="comment">// 将avb版本设置到系统属性中</span></span><br><span class="line">    <span class="keyword">if</span> (avb_version) property_set(<span class="string">&quot;ro.boot.avb_version&quot;</span>, avb_version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up our environment.</span></span><br><span class="line">    <span class="comment">// 清除环境变量</span></span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_SECOND_STAGE&quot;</span>);</span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_STARTED_AT&quot;</span>);</span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_SELINUX_TOOK&quot;</span>);</span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_AVB_VERSION&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set up SELinux for second stage.</span></span><br><span class="line">    selinux_initialize(<span class="literal">false</span>);</span><br><span class="line">    selinux_restore_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例，并返回epoll的文件描述符</span></span><br><span class="line">    epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;epoll_create1 failed&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是创建handler处理子进程终止信号，创建一个匿名 socket并注册到epoll进行监听</span></span><br><span class="line">    signal_handler_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中加载一些属性，读取usb配置</span></span><br><span class="line">    <span class="comment">// 涉及到的文件，/system/etc/prop.default，/odm/default.prop，/vendor/default.prop</span></span><br><span class="line">    property_load_boot_defaults();</span><br><span class="line">    export_oem_lock_status();<span class="comment">// 设置ro.boot.flash.locked 属性</span></span><br><span class="line">    start_property_service();<span class="comment">//开启一个socket监听系统属性的设置</span></span><br><span class="line">    set_usb_controller();<span class="comment">//设置sys.usb.controller 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//init.rc文件中方法映射,例如“class_start”-&gt; &quot;do_class_start&quot;</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">    Action::set_function_map(&amp;function_map);<span class="comment">//将function_map存放到Action中作 为成员属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用不同的parse解析init.rc文件中的不同字段，并且将service保存在servicelist中</span></span><br><span class="line">    Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;service&quot;</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;on&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">    parser.AddSectionParser(<span class="string">&quot;import&quot;</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootscript = GetProperty(<span class="string">&quot;ro.boot.init_rc&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.empty()) &#123;</span><br><span class="line">        <span class="comment">// 以下目录的所有rc文件默认都会被解析</span></span><br><span class="line">        parser.ParseConfig(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line">        parser.set_is_system_etc_init_loaded(</span><br><span class="line">                parser.ParseConfig(<span class="string">&quot;/system/etc/init&quot;</span>));</span><br><span class="line">        parser.set_is_vendor_etc_init_loaded(</span><br><span class="line">                parser.ParseConfig(<span class="string">&quot;/vendor/etc/init&quot;</span>));</span><br><span class="line">        parser.set_is_odm_etc_init_loaded(parser.ParseConfig(<span class="string">&quot;/odm/etc/init&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">        parser.set_is_system_etc_init_loaded(<span class="literal">true</span>);</span><br><span class="line">        parser.set_is_vendor_etc_init_loaded(<span class="literal">true</span>);</span><br><span class="line">        parser.set_is_odm_etc_init_loaded(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Turning this on and letting the INFO logging be discarded adds 0.2s to</span></span><br><span class="line">    <span class="comment">// Nexus 9 boot time, so it&#x27;s disabled by default.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) parser.DumpState();<span class="comment">//打印一些当前Parser的信息，默认是不执行的</span></span><br><span class="line"></span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// QueueEventTrigger用于触发Action,这里触发early-init事件</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;early-init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">    <span class="comment">//QueueBuiltinAction用于添加Action，第一个参数是 Action要执行的Command,第二个是Trigger</span></span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class="line">    <span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">    am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line">    am.QueueBuiltinAction(set_mmap_rnd_bits_action, <span class="string">&quot;set_mmap_rnd_bits&quot;</span>);</span><br><span class="line">    am.QueueBuiltinAction(set_kptr_restrict_action, <span class="string">&quot;set_kptr_restrict&quot;</span>);</span><br><span class="line">    am.QueueBuiltinAction(keychord_init_action, <span class="string">&quot;keychord_init&quot;</span>);</span><br><span class="line">    am.QueueBuiltinAction(console_init_action, <span class="string">&quot;console_init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line">    <span class="comment">// wasn&#x27;t ready immediately after wait_for_coldboot_done</span></span><br><span class="line">    am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">&quot;mix_hwrng_into_linux_rng&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">&quot;ro.bootmode&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">&quot;charger&quot;</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">&quot;charger&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">&quot;late-init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">&quot;queue_property_triggers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">        <span class="keyword">int</span> epoll_timeout_ms = <span class="number">-1</span>; <span class="comment">//epoll超时时间，相当于阻塞时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();<span class="comment">//执行一个command</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            restart_processes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there&#x27;s a process that needs restarting, wake up in time for that.</span></span><br><span class="line">            <span class="keyword">if</span> (process_needs_restart_at != <span class="number">0</span>) &#123;</span><br><span class="line">                epoll_timeout_ms = (process_needs_restart_at - time(<span class="literal">nullptr</span>)) * <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">if</span> (epoll_timeout_ms &lt; <span class="number">0</span>) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there&#x27;s more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="comment">//当还有命令要执行时，将epoll_timeout_ms设置为0</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        * 1.epoll_wait与epoll_create1、epoll_ctl是一起使用的 </span></span><br><span class="line"><span class="comment">        * 2.epoll_create1用于创建epoll的文件描述符，epoll_ctl、epoll_wait都把它创建的fd作为第一个参数传入 </span></span><br><span class="line"><span class="comment">        * 3.epoll_ctl用于操作epoll，EPOLL_CTL_ADD：注册新的fd到epfd中， </span></span><br><span class="line"><span class="comment">        EPOLL_CTL_MOD：修改已经注册的fd的监听事件，EPOLL_CTL_DEL：从epfd中删除一个fd； </span></span><br><span class="line"><span class="comment">        * 4.epoll_wait用于等待事件的产生，epoll_ctl调用EPOLL_CTL_ADD时会传入需要监听什么类型的事件， </span></span><br><span class="line"><span class="comment">        *比如EPOLLIN表示监听fd可读，当该fd有可读的数据时，调用epoll_wait经过epoll_timeout_ms时间就会把该事件的信息返回给&amp;ev </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, epoll_timeout_ms));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">&quot;epoll_wait failed&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//当有event返回时，取出 ev.data.ptr（之前epoll_ctl注册时的回调函数），直接执行 </span></span><br><span class="line">            <span class="comment">//在signal_handler_init和start_property_service有注册两个fd的监听，一个用于监听SIGCHLD(子进程结束信号)，一个用于监听属性设置</span></span><br><span class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-解析init-rc"><a href="#3-解析init-rc" class="headerlink" title="3.解析init.rc"></a>3.解析init.rc</h4><p>init.rc是一个非常重要的配置文件，它是由Android初始化语言（Android Init Language）编写的脚本，它主要包含五种类型语句：Action（Action中包含了一系列的Command）、Commands（init语言中的命令）、Services（由init进程启动的服务）、Options（对服务进行配置的选项）和Import（引入其他配置文件）。init.rc的配置代码如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> \system\core\rootdir\init.rc</span> </span><br><span class="line">on init # L41</span><br><span class="line">	sysclktz 0</span><br><span class="line"><span class="meta">   #</span><span class="bash"> Mix device-specific information into the entropy pool</span>    </span><br><span class="line">   copy /proc/cmdline /dev/urandom</span><br><span class="line">   copy /default.prop /dev/urandom</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* //设置触发器     </span><br><span class="line">	&lt;command&gt;</span><br><span class="line">    &lt;command&gt; //动作触发之后要执行的命令</span><br><span class="line">    </span><br><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* #&lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt;</span><br><span class="line">    &lt;option&gt;  #Options是Services的参数配置. 它们影响Service如何运行及运行时机     </span><br><span class="line">    group &lt;groupname&gt; [ &lt;groupname&gt;\* ] #在启动Service前将group改为第一个 groupname,第一个groupname是必须有的，默认值为root（或许默认值是无），第二个groupname可以不设置，用于追加组（通过 setgroups）</span><br><span class="line">    priority &lt;priority&gt; #设置进程优先级. 在-20～19之间，默认值是0,能过 setpriority实现</span><br><span class="line">    socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ] #创建 一个unix域的socket,名字叫/dev/socket/name , 并将fd返回给Service. type 只能是 &quot;dgram&quot;, &quot;stream&quot; or &quot;seqpacket&quot;.</span><br></pre></td></tr></table></figure>


<h5 id="3-1-Action"><a href="#3-1-Action" class="headerlink" title="3.1 Action"></a>3.1 Action</h5><p>Action：  通过触发器trigger，即以on开头的语句来决定执行相应的service的时机，具体有如下时机：</p>
<ul>
<li>on early-init; 在初始化早期阶段触发； </li>
<li>on init; 在初始化阶段触发；</li>
<li>on late-init; 在初始化晚期阶段触发；</li>
<li>on boot/charger：  当系统启动/充电时触发，还包含其他情况，此处不一一列举； </li>
<li>on property:=: 当属性值满足条件时触发</li>
</ul>
<h5 id="3-2-Service"><a href="#3-2-Service" class="headerlink" title="3.2 Service"></a>3.2 Service</h5><p>服务Service，以 service开头，由init进程启动，一般运行在init的一个子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service在启动时会通过 fork方式生成子进程。<br>例如：   service servicemanager /system/bin/servicemanager代表的是服务名为 servicemanager，服务执行的路径为/system/bin/servicemanager。</p>
<h5 id="3-3-Command"><a href="#3-3-Command" class="headerlink" title="3.3 Command"></a>3.3 Command</h5><p>下面列举常用的命令:</p>
<ul>
<li>class_start <service_class_name>：  启动属于同一个class的所有服务；</service_class_name></li>
<li> start <service_name>：  启动指定的服务，若已启动则跳过；</service_name></li>
<li>stop <service_name>：  停止正在运行的服务 </service_name></li>
<li>setprop  ：设置属性值</li>
<li>mkdir ：创建指定目录</li>
<li>symlink  <sym_link>：  创建连接到的<sym_link>符号链接；</sym_link></sym_link></li>
<li>write  ：  向文件path中写入字符串；</li>
<li>exec： fork并执行，会阻塞init进程直到程序完毕；</li>
<li>exprot：设定环境变量；</li>
<li>loglevel ：设置log级别</li>
</ul>
<h5 id="3-4-Options"><a href="#3-4-Options" class="headerlink" title="3.4 Options"></a>3.4 Options</h5><p>Options是Service的可选项，与service配合使用</p>
<ul>
<li>disabled: 不随class自动启动，只有根据service名才启动； </li>
<li>oneshot: service退出后不再重启；</li>
<li>user/group：  设置执行服务的用户/用户组，默认都是root；</li>
<li>class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； onrestart:当服务重启时执行相应命令；</li>
<li>socket: 创建名为 /dev/socket/<name>的socket</name></li>
<li>critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式 </li>
<li><strong>default</strong>: 意味着disabled=false，oneshot=false，critical=false。</li>
</ul>
<p>下面看看zygote的rc脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote -- start-system-server</span><br><span class="line">   class main    </span><br><span class="line">   priority -20    </span><br><span class="line">   user root</span><br><span class="line">   group root readproc reserved_disk    </span><br><span class="line">   socket zygote stream 660 root system</span><br><span class="line">   onrestart write /sys/android_power/request_state wake</span><br><span class="line">   onrestart write /sys/power/state on</span><br><span class="line">   onrestart restart audioserver</span><br><span class="line">   onrestart restart cameraserver</span><br><span class="line">   onrestart restart media</span><br><span class="line">   onrestart restart netd</span><br><span class="line">   onrestart restart wificond</span><br><span class="line">   writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>


<h5 id="3-5-逐行解析脚本"><a href="#3-5-逐行解析脚本" class="headerlink" title="3.5 逐行解析脚本"></a>3.5 逐行解析脚本</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system\core\init\init_parser.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Use a parser with const input and remove this copy</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">data_copy</span><span class="params">(data.begin(), data.end())</span></span>;</span><br><span class="line">    data_copy.push_back(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    parse_state state;</span><br><span class="line">    state.filename = filename.c_str();</span><br><span class="line">    state.line = <span class="number">0</span>;</span><br><span class="line">    state.ptr = &amp;data_copy[<span class="number">0</span>];</span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_EOF:</span><br><span class="line">            <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                <span class="comment">// 结束解析</span></span><br><span class="line">                section_parser-&gt;EndSection();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> T_NEWLINE:</span><br><span class="line">            state.line++;</span><br><span class="line">            <span class="keyword">if</span> (args.empty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                    section_parser-&gt;EndSection();</span><br><span class="line">                &#125;</span><br><span class="line">                section_parser = section_parsers_[args[<span class="number">0</span>]].get();</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">                <span class="comment">// 逐行解析</span></span><br><span class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123;</span><br><span class="line">                    parse_error(&amp;state, <span class="string">&quot;%s\n&quot;</span>, ret_err.c_str());</span><br><span class="line">                    section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseLineSection(args, state.filename,</span><br><span class="line">                                                      state.line, &amp;ret_err)) &#123;</span><br><span class="line">                    parse_error(&amp;state, <span class="string">&quot;%s\n&quot;</span>, ret_err.c_str());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            args.clear();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_TEXT:</span><br><span class="line">            args.emplace_back(state.text);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \system\core\init\service.cpp </span></span><br><span class="line"><span class="function">Result&lt;Success&gt; <span class="title">ServiceParser::ParseSection</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args,                                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (args.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;services must have a name and a program&quot;</span>;  &#125;</span><br><span class="line">   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];    <span class="keyword">if</span> (!IsValidName(name)) &#123;</span><br><span class="line">       <span class="keyword">return</span> Error() &lt;&lt; <span class="string">&quot;invalid service name &#x27;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;  &#125;</span><br><span class="line">   Subcontext* restart_action_subcontext = <span class="literal">nullptr</span>;    <span class="keyword">if</span> (subcontexts_) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; subcontext : *subcontexts_) &#123;</span><br><span class="line">           <span class="keyword">if</span> (StartsWith(filename, subcontext.path_prefix())) &#123;                restart_action_subcontext = &amp;subcontext;</span><br><span class="line">               <span class="keyword">break</span>;        &#125;</span><br><span class="line">     &#125;  &#125;</span><br><span class="line">   <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">str_args</span><span class="params">(args.begin() + <span class="number">2</span>, args.end())</span></span>;</span><br><span class="line">   service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, restart_action_subcontext, str_args);<span class="comment">//构建出一个service对象</span></span><br><span class="line">   <span class="keyword">return</span> Success(); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \system\core\init\service.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServiceParser::EndSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service_) &#123;</span><br><span class="line">        <span class="comment">// 如果上面解析的service不为空，就加入到ServiceManager中</span></span><br><span class="line">        ServiceManager::GetInstance().AddService(<span class="built_in">std</span>::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面解析完成后，接下来就是启动Service,这里我们以启动Zygote来分析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> \system\core\rootdir\init.rc L680</span> </span><br><span class="line">on nonencrypted</span><br><span class="line">   class_start main #class_start是一个命令，通过do_class_start函数处理    </span><br><span class="line">   class_start 	late_start</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># system\core\init\builtins.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Result&lt;Success&gt; <span class="title">do_class_start</span><span class="params">(<span class="keyword">const</span> BuiltinArguments&amp; args)</span> </span>&#123;    </span><br><span class="line">   <span class="comment">// Starting a class does not start services which are explicitly disabled.</span></span><br><span class="line">   <span class="comment">// They must  be started individually.</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; service : ServiceList::GetInstance()) &#123;        </span><br><span class="line">       <span class="keyword">if</span> (service-&gt;classnames().count(args[<span class="number">1</span>])) &#123;</span><br><span class="line">           <span class="comment">// 调用刚刚注册的service的StartIfNotDisabled()方法</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">auto</span> result = service-&gt;StartIfNotDisabled(); !result) &#123;</span><br><span class="line">               LOG(ERROR) &lt;&lt; <span class="string">&quot;Could not start service &#x27;&quot;</span> &lt;&lt; service-&gt;name()                           &lt;&lt; <span class="string">&quot;&#x27; as part of class &#x27;&quot;</span> &lt;&lt; args[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;&#x27;: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">      	 &#125;      </span><br><span class="line">       &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">   <span class="keyword">return</span> Success(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \system\core\init\service.cpp </span></span><br><span class="line"><span class="function">Result&lt;Success&gt; <span class="title">Service::StartIfNotDisabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!(flags_ &amp; SVC_DISABLED)) &#123;        </span><br><span class="line">       <span class="keyword">return</span> Start();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       flags_ |= SVC_DISABLED_START;  &#125;</span><br><span class="line">   	   <span class="keyword">return</span> Success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Starting a service removes it from the disabled or reset state and</span></span><br><span class="line">    <span class="comment">// immediately takes it out of the restarting state if it was in there.</span></span><br><span class="line">    flags_ &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果service已经启动了，就不启动了</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_RUNNING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="comment">//判断需要启动的service的对应的执行文件是否存在，不存在则不启动service</span></span><br><span class="line">    <span class="keyword">if</span> (stat(args_[<span class="number">0</span>].c_str(), &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;cannot find &#x27;&quot;</span> &lt;&lt; args_[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#x27;, disabling &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> scon;</span><br><span class="line">    <span class="keyword">if</span> (!seclabel_.empty()) &#123;</span><br><span class="line">        scon = seclabel_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">&quot;computing context for service &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        scon = ComputeContextFromExecutable(name_, args_[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (scon == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;starting service &#x27;&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;&#x27;...&quot;</span>;</span><br><span class="line">	<span class="comment">//如果子进程没有启动，则调用fork函数创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (namespace_flags_) &#123;</span><br><span class="line">        pid = clone(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, namespace_flags_ | SIGCHLD, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//当期代码逻辑在子进程中运行</span></span><br><span class="line">        umask(<span class="number">077</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (namespace_flags_ &amp; CLONE_NEWPID) &#123;</span><br><span class="line">            <span class="comment">// This will fork again to run an init process inside the PID</span></span><br><span class="line">            <span class="comment">// namespace.</span></span><br><span class="line">            SetUpPidNamespace(name_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ei : envvars_) &#123;</span><br><span class="line">            add_environment(ei.name.c_str(), ei.value.c_str());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::for_each(descriptors_.begin(), descriptors_.end(),</span><br><span class="line">                      <span class="built_in">std</span>::bind(&amp;DescriptorInfo::CreateAndPublish, <span class="built_in">std</span>::placeholders::_1, scon));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See if there were &quot;writepid&quot; instructions to write to files under /dev/cpuset/.</span></span><br><span class="line">        <span class="keyword">auto</span> cpuset_predicate = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</span><br><span class="line">            <span class="keyword">return</span> android::base::StartsWith(path, <span class="string">&quot;/dev/cpuset/&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> iter = <span class="built_in">std</span>::find_if(writepid_files_.begin(), writepid_files_.end(), cpuset_predicate);</span><br><span class="line">        <span class="keyword">if</span> (iter == writepid_files_.end()) &#123;</span><br><span class="line">            <span class="comment">// There were no &quot;writepid&quot; instructions for cpusets, check if the system default</span></span><br><span class="line">            <span class="comment">// cpuset is specified to be used for the process.</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> default_cpuset = android::base::GetProperty(<span class="string">&quot;ro.cpuset.default&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!default_cpuset.empty()) &#123;</span><br><span class="line">                <span class="comment">// Make sure the cpuset name starts and ends with &#x27;/&#x27;.</span></span><br><span class="line">                <span class="comment">// A single &#x27;/&#x27; means the &#x27;root&#x27; cpuset.</span></span><br><span class="line">                <span class="keyword">if</span> (default_cpuset.front() != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    default_cpuset.insert(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (default_cpuset.back() != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    default_cpuset.push_back(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                writepid_files_.push_back(</span><br><span class="line">                    StringPrintf(<span class="string">&quot;/dev/cpuset%stasks&quot;</span>, default_cpuset.c_str()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> pid_str = StringPrintf(<span class="string">&quot;%d&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : writepid_files_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!WriteStringToFile(pid_str, file)) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">&quot;couldn&#x27;t write &quot;</span> &lt;&lt; pid_str &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; file;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioprio_class_ != IoSchedClass_NONE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (android_set_ioprio(getpid(), ioprio_class_, ioprio_pri_)) &#123;</span><br><span class="line">                PLOG(ERROR) &lt;&lt; <span class="string">&quot;failed to set pid &quot;</span> &lt;&lt; getpid()</span><br><span class="line">                            &lt;&lt; <span class="string">&quot; ioprio=&quot;</span> &lt;&lt; ioprio_class_ &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ioprio_pri_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needs_console) &#123;</span><br><span class="line">            setsid();</span><br><span class="line">            OpenConsole();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ZapStdio();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// As requested, set our gid, supplemental gids, uid, context, and</span></span><br><span class="line">        <span class="comment">// priority. Aborts on failure.</span></span><br><span class="line">        SetProcessAttributes();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; strs;</span><br><span class="line">        <span class="comment">//调用execv函数，启动sevice子进程</span></span><br><span class="line">        ExpandArgs(args_, &amp;strs);</span><br><span class="line">        <span class="keyword">if</span> (execve(strs[<span class="number">0</span>], (<span class="keyword">char</span>**) &amp;strs[<span class="number">0</span>], (<span class="keyword">char</span>**) ENV) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">&quot;cannot execve(&#x27;&quot;</span> &lt;&lt; strs[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="4-zygote启动"><a href="#4-zygote启动" class="headerlink" title="4.zygote启动"></a>4.zygote启动</h4><p>上面看到了解析了init.rc之后就可以启动服务。下面我们来看看zygote是如何启动的，启动起来干了什么事情。</p>
<h5 id="4-1-Zygote简述"><a href="#4-1-Zygote简述" class="headerlink" title="4.1 Zygote简述"></a>4.1 Zygote简述</h5><p>Zygote是一个C/S模型，Zygote进程作为服务端，它主要负责创建Java虚拟机，加载系统资源，启动SystemServer进程，以及在后续运行过程中启动普通的应用程序，其他进程作为客户端向它发 出“孵化”请求，而Zygote接收到这个请求后就“孵化”出一个新的进程。比如，当点击Launcher里的 应用程序图标去启动一个新的应用程序进程时，这个请求会到达框架层的核心服务 ActivityManagerService中，当AMS收到这个请求后，它通过调用Process类发出一个“孵化”子进 程的Socket请求，而Zygote监听到这个请求后就立刻fork一个新的进程出来。</p>
<p>zygote的启动脚本文件是：init.zygoteXX.rc，在init.rc中会引用该rc文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import /init.$&#123;ro.zygote&#125;.rc</span><br></pre></td></tr></table></figure>
<p>${ro.zygote} 会被替换成 ro.zyogte 的属性值，这个是由不同的硬件厂商自己定制的， 有四个值，</p>
<ul>
<li>zygote32： zygote 进程对应的执行程序是 app_process (纯 32bit 模式)</li>
<li>zygote64： zygote 进程对应的执行程序是 app_process64 (纯 64bit 模式)</li>
<li>zygote32_64：  启动两个 zygote 进程 (名为 zygote 和 zygote_secondary)，对应的执行程序分别 是 app_process32 (主模式)</li>
<li>zygote64_32：    启动两个 zygote 进程 (名为 zygote 和 zygote_secondary)，对应的执行程序分别 是 app_process64 (主模式)、app_process32</li>
</ul>
<h5 id="4-2-启动runtime"><a href="#4-2-启动runtime" class="headerlink" title="4.2 启动runtime"></a>4.2 启动runtime</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 位置：system\core\rootdir\init.rc  L560</span></span><br><span class="line">start zygote</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> It is recommended to put unnecessary data/ initialization from post-fs- data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to start-zygote <span class="keyword">in</span> device<span class="string">&#x27;s init.rc to unblock zygote start. on zygote-start &amp;&amp; property:ro.crypto.state=unencrypted</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> A/B update verifier that marks a successful boot.    exec_start update_verifier_nonencrypted</span></span><br><span class="line">   start netd</span><br><span class="line">   start zygote</span><br><span class="line">   start zygote_secondary</span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=unsupported   # A/B update verifier that marks a successful boot.   exec_start update_verifier_nonencrypted</span><br><span class="line">   start netd</span><br><span class="line">   start zygote</span><br><span class="line">   start zygote_secondary</span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file</span><br><span class="line"><span class="meta">   #</span><span class="bash"> A/B update verifier that marks a successful boot.    exec_start update_verifier_nonencrypted</span></span><br><span class="line">   start netd</span><br><span class="line">   start zygote</span><br><span class="line">   start zygote_secondary</span><br></pre></td></tr></table></figure>
<p>无论是否启动FDE/FBE加密，都依赖zygote-start，zygote-start 是在 on late-init 中触发的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Mount filesystems and start core system services.</span></span><br><span class="line">on late-init</span><br><span class="line">   trigger early-fs</span><br><span class="line"><span class="meta">   #</span><span class="bash"> Mount fstab <span class="keyword">in</span> init.&#123;<span class="variable">$device</span>&#125;.rc by mount_all <span class="built_in">command</span>. Optional parameter</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> <span class="string">&#x27;--early&#x27;</span> can be specified to skip entries with <span class="string">&#x27;latemount&#x27;</span>.</span>    </span><br><span class="line"><span class="meta">   #</span><span class="bash"> /system and /vendor must be mounted by the end of the fs stage,</span>    </span><br><span class="line"><span class="meta">   #</span><span class="bash"> <span class="keyword">while</span> /data is optional.</span></span><br><span class="line">   trigger fs</span><br><span class="line">   trigger post-fs</span><br><span class="line">   </span><br><span class="line"><span class="meta">   #</span><span class="bash"> Mount fstab <span class="keyword">in</span> init.&#123;<span class="variable">$device</span>&#125;.rc by mount_all with <span class="string">&#x27;--late&#x27;</span> parameter</span>    </span><br><span class="line"><span class="meta">   #</span><span class="bash"> to only mount entries with <span class="string">&#x27;latemount&#x27;</span>. This is needed <span class="keyword">if</span> <span class="string">&#x27;--early&#x27;</span> is</span>    </span><br><span class="line"><span class="meta">   #</span><span class="bash"> specified <span class="keyword">in</span> the previous mount_all <span class="built_in">command</span> on the fs stage.</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> With /system mounted and properties form /system + /factory available,</span>    </span><br><span class="line"><span class="meta">   #</span><span class="bash"> some services can be started.</span></span><br><span class="line">   trigger late-fs</span><br><span class="line"><span class="meta">   #</span><span class="bash"> Now we can mount /data. File encryption requires keymaster to decrypt</span>    </span><br><span class="line"><span class="meta">   #</span><span class="bash"> /data, <span class="built_in">which</span> <span class="keyword">in</span> turn can only be loaded when system properties are present.</span></span><br><span class="line">   trigger post-fs-data</span><br><span class="line"><span class="meta">   #</span><span class="bash"> Now we can start zygote <span class="keyword">for</span> devices with file based encryption</span></span><br><span class="line">   </span><br><span class="line">   trigger zygote-start #zygote-start 是在on late-init 中触发的。</span><br><span class="line"><span class="meta">   #</span><span class="bash"> Load persist properties and override properties (<span class="keyword">if</span> enabled) from /data.</span></span><br><span class="line">   trigger load_persist_props_action</span><br><span class="line"><span class="meta">   #</span><span class="bash"> Remove a file to wake up anything waiting <span class="keyword">for</span> firmware.</span></span><br><span class="line">   trigger firmware_mounts_complete</span><br><span class="line">   trigger early-boot</span><br><span class="line">   trigger boot</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bootmode == <span class="string">&quot;charger&quot;</span>) &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;charger&quot;</span>);    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;late-init&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不是充电模式，就触发late-init，最后触发start zygote。</p>
<p><strong>app_processXX位置\frameworks\base\cmds\app_process目录下</strong>。</p>
<h5 id="4-3-zygote启动代码分析"><a href="#4-3-zygote启动代码分析" class="headerlink" title="4.3 zygote启动代码分析"></a>4.3 zygote启动代码分析</h5><blockquote>
<p>位置\frameworks\base\cmds\app_process\app_main.cpp<br>在app_main.cpp的main函数中，主要做的事情就是参数解析. 这个函数有两种启动模式：</p>
<ol>
<li>一种是zygote模式，也就是初始化zygote进程，传递的参数有–start-system-server –socket- name=zygote，前者表示启动SystemServer，后者指定socket的名称</li>
<li>一种是application模式，也就是启动普通应用程序，传递的参数有class名字以及class带的参数<br>两者最终都是调用AppRuntime对象的start函数，加载ZygoteInit或RuntimeInit两个Java类，并将之前 整理的参数传入进去</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\cmds\app_process\app_main.cpp main()  L280 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果rc脚本传入的--zygote参数，就将zygote设置为true。</span></span><br><span class="line">        zygote = <span class="literal">true</span>;</span><br><span class="line">        niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;            </span><br><span class="line">        startSystemServer = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        application = <span class="literal">true</span>;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">      <span class="comment">//这些Java的应用都是通过AppRuntime.start（className)开始的</span></span><br><span class="line">      <span class="comment">//其实AppRuntime是AndroidRuntime的子类，它主要实现了几个回调函数，而start()方法是实现在AndroidRuntime这个方法类里</span></span><br><span class="line">       runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">       runtime.start(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);    </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\core\jni\androidRuntime.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">&quot;start-system-server&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &#x27;startSystemServer == true&#x27; means runtime is obsolete and not run from</span></span><br><span class="line"><span class="comment">     * init.rc anymore, so we print out the boot start event here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取环境变量，确认系统根目录</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">&quot;/system&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">&quot;/system&quot;</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">&quot;No root directory specified, and /android does not exist.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">// 启动虚拟机</span></span><br><span class="line">    <span class="comment">//startVM的前半部分是在处理虚拟机的启动参数，处理完配置参数后，会调用libart.so提供 的一个接口：JNI_CreateJavaVM函数</span></span><br><span class="line">    <span class="comment">// 在创建虚拟机的时候，首先会通过Runtime的create方法创建单例的Runtime对象，runtime负责提供art虚拟机的运行时环境，然后调用其init方法来初始化虚拟机。</span></span><br><span class="line">    <span class="comment">// 创建虚拟机一共做了五个事情：</span></span><br><span class="line">    <span class="comment">// 1.new gc::heap()，创建Heap对象，这是虚拟机管理对内存的起点。 </span></span><br><span class="line">    <span class="comment">// 2.new JavaVmExt(),创建Java虚拟机实例。</span></span><br><span class="line">    <span class="comment">// 3.Thread::attach()，attach主线程 </span></span><br><span class="line">    <span class="comment">// 4.创建ClassLinker</span></span><br><span class="line">    <span class="comment">// 5.初始化ClassLinker,成功attach到runtime环境后，创建ClassLinker实例负责管理java class</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调虚拟机创建成功，解析类名，并且找到对应的Class对象。</span></span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 注册jni方法，以便java层可以调用</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建main方法中的两个参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用main()启动对应的进程，如果是zygoteinit就调用zygoteinit的main方法启动zygote</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\core\java\com\android\internal\os\RuntimeInit.java</span></span><br><span class="line"><span class="comment">// 虚拟机创建好之后，创建java Runtime.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">        enableDdms();</span><br><span class="line">        <span class="keyword">if</span> (argv.length == <span class="number">2</span> &amp;&amp; argv[<span class="number">1</span>].equals(<span class="string">&quot;application&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;RuntimeInit: Starting application&quot;</span>);</span><br><span class="line">            <span class="comment">//将System.out 和    System.err 输出重定向到Android 的Log系统（定义在android.util.Log)</span></span><br><span class="line">            redirectLogStreams();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;RuntimeInit: Starting tool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// commonInit(): 初始化了一下系统属性，其中最重要的一点就是设置了一个未捕捉异常的 handler，当代码有任何未知异常，就会执行它，</span></span><br><span class="line">        commonInit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Now that we&#x27;re running in interpreted code, call back into native code</span></span><br><span class="line"><span class="comment">         * to run the system.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	<span class="comment">// 回调native java Runtime已经启动完毕</span></span><br><span class="line">        nativeFinishInit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Leaving RuntimeInit!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\core\jni\androidRuntime.cpp nativeFinishInit() L225 </span></span><br><span class="line"><span class="comment">/** Code written in the Java Programming Language calls here from main(). */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeFinishInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span>&#123;</span><br><span class="line">   <span class="comment">// 调到要启动的进程中</span></span><br><span class="line">   gCurRuntime-&gt;onStarted(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\cmds\app_process\app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onStarted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">&quot;App process: starting thread pool.\n&quot;</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    AndroidRuntime* ar = AndroidRuntime::getRuntime();</span><br><span class="line">    <span class="comment">// 调用ZygoteInit的main方法.回应到runtime.start(&quot;...ZygoteInit&quot;)</span></span><br><span class="line">    ar-&gt;callMain(mClassName, mClass, mArgs);</span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">    hardware::IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-3-启动zygote"><a href="#4-3-启动zygote" class="headerlink" title="4.3 启动zygote"></a>4.3 启动zygote</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 创建一个LocalServerSocket，等待AMS发起fork子进程通知</span></span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">        <span class="comment">// an error.</span></span><br><span class="line">        ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to setpgid(0,0)&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Report Zygote start time to tron unless it is a runtime restart</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;1&quot;</span>.equals(SystemProperties.get(<span class="string">&quot;sys.boot_completed&quot;</span>))) &#123;</span><br><span class="line">                MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;boot_zygote_init&quot;</span>,</span><br><span class="line">                        (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String bootTimeTag = Process.is64Bit() ? <span class="string">&quot;Zygote64Timing&quot;</span> : <span class="string">&quot;Zygote32Timing&quot;</span>;</span><br><span class="line">            BootTimingsTraceLog bootTimingsTraceLog = <span class="keyword">new</span> BootTimingsTraceLog(bootTimeTag,</span><br><span class="line">                    Trace.TRACE_TAG_DALVIK);</span><br><span class="line">            bootTimingsTraceLog.traceBegin(<span class="string">&quot;ZygoteInit&quot;</span>);</span><br><span class="line">            RuntimeInit.enableDdms();</span><br><span class="line">            <span class="comment">// Start profiling the zygote initialization.</span></span><br><span class="line">            SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">            String socketName = <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line">            String abiList = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">                <span class="comment">// zygote.rc脚本传参启动systemserver</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                    startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;--enable-lazy-preload&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                    <span class="comment">// 在zygoteXX.rc脚本可以加--enable-lazy-preload参数来懒加载资源和class类</span></span><br><span class="line">                    enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unknown command line argument: &quot;</span> + argv[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (abiList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No ABI list supplied.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zygoteServer.registerServerSocket(socketName);</span><br><span class="line">            <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">            <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">            <span class="comment">// 如果没有懒加载，就加载class和资源</span></span><br><span class="line">            <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">                bootTimingsTraceLog.traceBegin(<span class="string">&quot;ZygotePreload&quot;</span>);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">                preload(bootTimingsTraceLog);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">                bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygotePreload</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Zygote.resetNicePriority();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finish profiling the zygote initialization.</span></span><br><span class="line">            SamplingProfilerIntegration.writeZygoteSnapshot();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">            bootTimingsTraceLog.traceBegin(<span class="string">&quot;PostZygoteInitGC&quot;</span>);</span><br><span class="line">            <span class="comment">//主动进行一次资源GC</span></span><br><span class="line">            gcAndFinalize();</span><br><span class="line">            bootTimingsTraceLog.traceEnd(); <span class="comment">// PostZygoteInitGC</span></span><br><span class="line"></span><br><span class="line">            bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygoteInit</span></span><br><span class="line">            <span class="comment">// Disable tracing so that forked processes do not inherit stale tracing tags from</span></span><br><span class="line">            <span class="comment">// Zygote.</span></span><br><span class="line">            Trace.setTracingEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">            Zygote.nativeUnmountStorageOnInit();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set seccomp policy</span></span><br><span class="line">            Seccomp.setPolicy();</span><br><span class="line"></span><br><span class="line">            ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                <span class="comment">// 启动systemserver</span></span><br><span class="line">                startSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line">            <span class="comment">// 死循环等待socket有数据读入</span></span><br><span class="line">            zygoteServer.runSelectLoop(abiList);</span><br><span class="line"></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Zygote.MethodAndArgsCaller caller) &#123;</span><br><span class="line">            <span class="comment">// 通过抛异常的方式来调用子进程的main可以清空调用栈。</span></span><br><span class="line">            caller.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;System zygote died with exception&quot;</span>, ex);</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到Zygote启动一共干了如下几个事情：</p>
<ul>
<li>启动LocalServerSocket</li>
<li>加载class和各种资源</li>
<li>启动systemserver</li>
<li>runSelectLoop中epoll等待客户端socket连接</li>
<li>根据客户端传过来的参数，在run()中反射调用ActivityThread的main()方法来启动app进程。</li>
</ul>
<p>下面我们来分别看一下以上几个方法中做了什么。</p>
<h5 id="4-3-1-加载class和各种资源"><a href="#4-3-1-加载class和各种资源" class="headerlink" title="4.3.1 加载class和各种资源"></a>4.3.1 加载class和各种资源</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(BootTimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;begin preload&quot;</span>);</span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">&quot;BeginIcuCachePinning&quot;</span>);</span><br><span class="line">    	<span class="comment">// 将ICU数据通常由软引用保存固定在内存中。如果没有这一点，那么当Zygote GC在gcAndFinalize()中运行时，将收集在类预加载过程中直接创建的引用。</span></span><br><span class="line">        beginIcuCachePinning();</span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// BeginIcuCachePinning</span></span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">&quot;PreloadClasses&quot;</span>);</span><br><span class="line">    	<span class="comment">// 加载类</span></span><br><span class="line">        preloadClasses();</span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// PreloadClasses</span></span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">&quot;PreloadResources&quot;</span>);</span><br><span class="line">    	<span class="comment">// 加载资源</span></span><br><span class="line">        preloadResources();</span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// PreloadResources</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="string">&quot;PreloadOpenGL&quot;</span>);</span><br><span class="line">    	<span class="comment">// 加载OpenGL</span></span><br><span class="line">        preloadOpenGL();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</span><br><span class="line">    	<span class="comment">// 加载共享库</span></span><br><span class="line">        preloadSharedLibraries();</span><br><span class="line">    	<span class="comment">// 加载内置字体</span></span><br><span class="line">        preloadTextResources();</span><br><span class="line">        <span class="comment">// Ask the WebViewFactory to do any initialization that must run in the zygote process,</span></span><br><span class="line">        <span class="comment">// for memory sharing purposes.</span></span><br><span class="line">        WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">        endIcuCachePinning();</span><br><span class="line">    	<span class="comment">// 注册AndroidKeysReprovider并预热已注册的程序。</span></span><br><span class="line">        warmUpJcaProviders();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;end preload&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sPreloadComplete = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中只有<strong>类加载、资源和字体加载</strong>有必要分析一下，因为在做精细系统启动优化的时候可能会涉及到该部分内容。其他的就预加载就是单纯的加载。</p>
<p><strong>4.3.1.1 preloadClasses();</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预加载类的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRELOADED_CLASSES = <span class="string">&quot;/system/etc/preloaded-classes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> VMRuntime runtime = VMRuntime.getRuntime();</span><br><span class="line"></span><br><span class="line">        InputStream is;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过流读入需要预加载的类</span></span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(PRELOADED_CLASSES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Couldn&#x27;t find &quot;</span> + PRELOADED_CLASSES + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader br</span><br><span class="line">                = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is), <span class="number">256</span>);</span><br><span class="line">			<span class="comment">// 一下代码解析并且加载类</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Skip comments and blank lines.</span></span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.startsWith(<span class="string">&quot;#&quot;</span>) || line.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_DALVIK, line);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                        Log.v(TAG, <span class="string">&quot;Preloading &quot;</span> + line + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Load and explicitly initialize the given class. Use</span></span><br><span class="line">                    <span class="comment">// Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups</span></span><br><span class="line">                    <span class="comment">// (to derive the caller&#x27;s class-loader). Use true to force initialization, and</span></span><br><span class="line">                    <span class="comment">// null for the boot classpath class-loader (could as well cache the</span></span><br><span class="line">                    <span class="comment">// class-loader of this class in a variable).</span></span><br><span class="line">                    <span class="comment">// null代表使用Bootstrap ClassLoader最高级引导类加载器加载，加载后的类保存在该类加载器中。之后的类加载都会依托双亲委托机制，不重复加载相同的类。</span></span><br><span class="line">                    Class.forName(line, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">              ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>4.3.1.2 preloadResources();</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VMRuntime runtime = VMRuntime.getRuntime();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        mResources = Resources.getSystem();</span><br><span class="line">        mResources.startPreloading();</span><br><span class="line">        <span class="keyword">if</span> (PRELOAD_RESOURCES) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Preloading resources...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">            TypedArray ar = mResources.obtainTypedArray(</span><br><span class="line">                    com.android.internal.R.array.preloaded_drawables);</span><br><span class="line">            <span class="comment">// 更具索引id加载图片资源</span></span><br><span class="line">            <span class="keyword">int</span> N = preloadDrawables(ar);</span><br><span class="line">            ar.recycle();</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.3.1.3 preloadTextResources();</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadTextResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加载字体到map中</span></span><br><span class="line">    Hyphenator.init();</span><br><span class="line">    <span class="comment">// 创建画笔，设置默认字体</span></span><br><span class="line">    TextView.preloadFontCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\android\text\Hyphenator.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sMap.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 需要支持的语言</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AVAILABLE_LANGUAGES.length; i++) &#123;</span><br><span class="line">            HyphenationData data = AVAILABLE_LANGUAGES[i];</span><br><span class="line">            <span class="comment">// 加载对应语言的字体</span></span><br><span class="line">            Hyphenator h = loadHyphenator(data);</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sMap.put(Locale.forLanguageTag(data.mLanguageTag), h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOCALE_FALLBACK_DATA.length; i++) &#123;</span><br><span class="line">            String language = LOCALE_FALLBACK_DATA[i][<span class="number">0</span>];</span><br><span class="line">            String fallback = LOCALE_FALLBACK_DATA[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 解析后的语言保存到map中</span></span><br><span class="line">            sMap.put(Locale.forLanguageTag(language), sMap.get(Locale.forLanguageTag(fallback)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HyphenationData[] AVAILABLE_LANGUAGES = &#123;</span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;as&quot;</span>, INDIC_MIN_PREFIX, INDIC_MIN_SUFFIX), <span class="comment">// Assamese</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;bg&quot;</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="comment">// Bulgarian</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;bn&quot;</span>, INDIC_MIN_PREFIX, INDIC_MIN_SUFFIX), <span class="comment">// Bengali</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;cu&quot;</span>, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// Church Slavonic</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;pt&quot;</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="comment">// Portuguese</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;sl&quot;</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="comment">// Slovenian</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;ta&quot;</span>, INDIC_MIN_PREFIX, INDIC_MIN_SUFFIX), <span class="comment">// Tamil</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;te&quot;</span>, INDIC_MIN_PREFIX, INDIC_MIN_SUFFIX), <span class="comment">// Telugu</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;tk&quot;</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="comment">// Turkmen</span></span><br><span class="line">        <span class="keyword">new</span> HyphenationData(<span class="string">&quot;und-Ethi&quot;</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="comment">// Any language in Ethiopic script</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>


<h5 id="4-3-2-启动systemserver"><a href="#4-3-2-启动systemserver" class="headerlink" title="4.3.2 启动systemserver"></a>4.3.2 启动systemserver</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName, ZygoteServer zygoteServer)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">        <span class="comment">// 设置systemserver启动参数</span></span><br><span class="line">        String args[] = &#123;</span><br><span class="line">            <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1032,3001,3002,3003,3006,3007,3009,3010&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">            <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">            <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">            <span class="comment">// 创建子进程</span></span><br><span class="line">            pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                    parsedArgs.gids,</span><br><span class="line">                    parsedArgs.debugFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.permittedCapabilities,</span><br><span class="line">                    parsedArgs.effectiveCapabilities);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="comment">// 在子进程中执行SystemServer代码</span></span><br><span class="line">            handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果systemserver类已经被加载了，命中if；否则创建类加载器并且启动参数传给systemserver进程，首次我们分析SystemServer没有被夹在的情况</span></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] args = parsedArgs.remainingArgs;</span><br><span class="line">            <span class="comment">// If we have a non-null system server class path, we&#x27;ll have to duplicate the</span></span><br><span class="line">            <span class="comment">// existing arguments and append the classpath to it. ART will handle the classpath</span></span><br><span class="line">            <span class="comment">// correctly when we exec a new process.</span></span><br><span class="line">            <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String[] amendedArgs = <span class="keyword">new</span> String[args.length + <span class="number">2</span>];</span><br><span class="line">                amendedArgs[<span class="number">0</span>] = <span class="string">&quot;-cp&quot;</span>;</span><br><span class="line">                amendedArgs[<span class="number">1</span>] = systemServerClasspath;</span><br><span class="line">                System.arraycopy(args, <span class="number">0</span>, amendedArgs, <span class="number">2</span>, args.length);</span><br><span class="line">                args = amendedArgs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                    parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                    VMRuntime.getCurrentInstructionSet(), <span class="keyword">null</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建类加载器</span></span><br><span class="line">                cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">				<span class="comment">// 将当前执行的线程与类加载器绑定，即设成主线程</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 将剩余的参数传给Systemserver线程</span></span><br><span class="line">            ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* should never reach here */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (RuntimeInit.DEBUG) &#123;</span><br><span class="line">            Slog.d(RuntimeInit.TAG, <span class="string">&quot;RuntimeInit: Starting application from zygote&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ZygoteInit&quot;</span>);</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line"></span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">    	<span class="comment">// 此方法中就会去通过反射调用main方法了，留一下点悬念，待会儿启动APP分析的时候详细看下面的调用，此处我们理解就是调用了SystemServer的main()，在新的进程中拉起了systemserver。具体SystemServer中干了什么，专门用一章来分析。</span></span><br><span class="line">        RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-3-3-runSelectLoop"><a href="#4-3-3-runSelectLoop" class="headerlink" title="4.3.3 runSelectLoop()"></a>4.3.3 runSelectLoop()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 增加Zygote的socket服务端的fd为监听对象。</span></span><br><span class="line">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">                pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;poll failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果有POLLIN事件，并且遍历的不是最后一个ZygoteConnection进入else</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取ZygoteConnection，其实ZygoteConnection就可以理解成一个socket客户端，因为在创建的时候持有一个socket。</span></span><br><span class="line">                    <span class="comment">// 执行ZygoteConnection的runOnce()方法</span></span><br><span class="line">                    <span class="keyword">boolean</span> done = peers.get(i).runOnce(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                        peers.remove(i);</span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\com\android\internal\os\ZygoteConnection.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">(ZygoteServer zygoteServer)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">         <span class="comment">// 该方法前面的都不用管，就是获取启动参数和一些权限校验</span></span><br><span class="line">			<span class="comment">// fork一个子进程</span></span><br><span class="line">            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet, parsedArgs.appDataDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            logAndPrintError(newStderr, <span class="string">&quot;Exception creating pipe&quot;</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            logAndPrintError(newStderr, <span class="string">&quot;Invalid zygote arguments&quot;</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">            logAndPrintError(newStderr,</span><br><span class="line">                    <span class="string">&quot;Zygote security policy prevents request: &quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in child</span></span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 处理子进程预启动的事务,关闭客户端socket，并且重新开启标准io</span></span><br><span class="line">                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">                <span class="comment">// throw Zygote.MethodAndArgsCaller or exec().</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">                IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">                childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\com\android\internal\os\ZygoteConnection.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">            FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * By the time we get here, the native code has closed the two actual Zygote</span></span><br><span class="line"><span class="comment">         * socket connections, and substituted /dev/null in their place.  The LocalSocket</span></span><br><span class="line"><span class="comment">         * objects still need to be closed properly.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 关闭客户端socket</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of the postFork event.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                    parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                    VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                    pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过zygote进程启动的进程，在此方法中调用待启动进程的main方法</span></span><br><span class="line">            ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                    parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\com\android\internal\os\ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (RuntimeInit.DEBUG) &#123;</span><br><span class="line">            Slog.d(RuntimeInit.TAG, <span class="string">&quot;RuntimeInit: Starting application from zygote&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ZygoteInit&quot;</span>);</span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line"></span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">    	<span class="comment">// 设置一些runtime参数，并且调用带启动进程的main方法</span></span><br><span class="line">        RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\com\android\internal\os\RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">        <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">        <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">        <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">        <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">        nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></span><br><span class="line">        <span class="comment">// holding on to a lot of memory that isn&#x27;t needed.</span></span><br><span class="line">    	<span class="comment">// 让带启动的进程堆大小最大只能占0.75 * 最大堆内存</span></span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Arguments args;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            Slog.e(TAG, ex.getMessage());</span><br><span class="line">            <span class="comment">// let the process exit</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The end of of the RuntimeInit event (see #zygoteInit).</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remaining arguments are passed to the start class&#x27;s static main</span></span><br><span class="line">    	<span class="comment">// 反射得到待执行的类和得到其中的main()，最终通过抛异常的方式，回到zygoteInit的main方法中</span></span><br><span class="line">        invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>反射得到待执行的类和得到其中的main()，最终通过抛异常的方式，回到zygoteInit的main方法中！！</p>
<p>反射得到待执行的类和得到其中的main()，最终通过抛异常的方式，回到zygoteInit的main方法中！！</p>
<p>反射得到待执行的类和得到其中的main()，最终通过抛异常的方式，回到zygoteInit的main方法中！！</p>
<p>重要的事情说三遍！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Missing class when invoking static main &quot;</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Missing static main on &quot;</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Problem getting static main on &quot;</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Main method is not public and static on &quot;</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">         * by invoking the exception&#x27;s run() method. This arrangement</span></span><br><span class="line"><span class="comment">         * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">         * up the process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Zygote.MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码没什么好说的，一眼就可以看懂，返回得到main方法之后，将main()和参数封装到MethodAndArgsCaller中，清栈返回ZygoteInit.main()。</p>
<h5 id="4-3-4-caller-run"><a href="#4-3-4-caller-run" class="headerlink" title="4.3.4 caller.run();"></a>4.3.4 caller.run();</h5><p>从4.3.3小节我们拿到了待执行应用的main()和启动参数。然后经过caller.run()真正的来调用main()执行带启动应用的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\com\android\internal\os\Zygote.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** method to call */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** argument array */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">            mMethod = method;</span><br><span class="line">            mArgs = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 反射调用main方法</span></span><br><span class="line">                mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause = ex.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>应用启动的真相终于被挖出来了，此处ActivityThread的main方法被调用，一个应用就正式被启动起来了！！！！</p>
<p>此处并没有完，我们上面讲到了SystemServer启动过程还没有将，需要单独拿一章来讲，本来想单独开一篇帖子来叙述，但是单独开一篇就感觉这篇启动分析的文章断了。所以还是继续往下分析吧。</p>
<h4 id="5-SystemServer启动"><a href="#5-SystemServer启动" class="headerlink" title="5. SystemServer启动"></a>5. SystemServer启动</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-fe05fa76b50c26bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SystemServer启动阶段图.png"></p>
<p>System Server 是Zygote fork 的第一个Java 进程，  这个进程非常重要，因为他们有很多的系统线程， 提供所有核心的系统服务。它们都是运行在system_server的进程 里。还有很多“Binder-x”的线程，它们是各个Service为了响应应用程序远程调用请求而创建的。除此之 外，还有很多内部的线程，比如 ”UI thread”, “InputReader”, “InputDispatch” 等等。</p>
<p>从4.3.2小节我们看到了Zygote调用了StartSystemServer来启动SystemServer，我们只分析到了调用到SystemServer的main方法就没有分析了，因此，我们在该章专门叙述调用main()之后发生了什么故事。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\services\java\com\android\server\SystemServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SystemServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check for factory test mode.</span></span><br><span class="line">    mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line">    <span class="comment">// Remember if it&#x27;s runtime restart(when sys.boot_completed is already set) or reboot</span></span><br><span class="line">    <span class="comment">// 正常启动mRuntimeRestart为false</span></span><br><span class="line">    mRuntimeRestart = <span class="string">&quot;1&quot;</span>.equals(SystemProperties.get(<span class="string">&quot;sys.boot_completed&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main()中方法很简单，真正有内容的在run()中。其中run()方法中重点干了四个事情：</p>
<ul>
<li>初始化必要的SystemServer环境参数</li>
<li>启动引导服务</li>
<li>启动核心服务</li>
<li>启动其他服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           traceBeginAndSlog(<span class="string">&quot;InitBeforeStartServices&quot;</span>);</span><br><span class="line">           <span class="comment">// If a device&#x27;s clock is before 1970 (before 0), a lot of</span></span><br><span class="line">           <span class="comment">// APIs crash dealing with negative numbers, notably</span></span><br><span class="line">           <span class="comment">// java.io.File#setLastModified, so instead we fake it and</span></span><br><span class="line">           <span class="comment">// hope that time from cell towers or NTP fixes it shortly.</span></span><br><span class="line">           <span class="comment">// 初始化系统时间</span></span><br><span class="line">           <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">               Slog.w(TAG, <span class="string">&quot;System clock is before 1970; setting to 1970.&quot;</span>);</span><br><span class="line">               SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           <span class="comment">// Default the timezone property to GMT if not set.</span></span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           <span class="comment">// 设置时区</span></span><br><span class="line">           String timezoneProperty =  SystemProperties.get(<span class="string">&quot;persist.sys.timezone&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">               Slog.w(TAG, <span class="string">&quot;Timezone not set; setting to GMT.&quot;</span>);</span><br><span class="line">               SystemProperties.set(<span class="string">&quot;persist.sys.timezone&quot;</span>, <span class="string">&quot;GMT&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If the system has &quot;persist.sys.language&quot; and friends set, replace them with</span></span><br><span class="line">           <span class="comment">// &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated</span></span><br><span class="line">           <span class="comment">// using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by</span></span><br><span class="line">           <span class="comment">// AndroidRuntime using the same set of system properties, but only the system_server</span></span><br><span class="line">           <span class="comment">// and system apps are allowed to set them.</span></span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           <span class="comment">// <span class="doctag">NOTE:</span> Most changes made here will need an equivalent change to</span></span><br><span class="line">           <span class="comment">// core/jni/AndroidRuntime.cpp</span></span><br><span class="line">           <span class="comment">// 设置语言</span></span><br><span class="line">           <span class="keyword">if</span> (!SystemProperties.get(<span class="string">&quot;persist.sys.language&quot;</span>).isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">               SystemProperties.set(<span class="string">&quot;persist.sys.locale&quot;</span>, languageTag);</span><br><span class="line">               SystemProperties.set(<span class="string">&quot;persist.sys.language&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">               SystemProperties.set(<span class="string">&quot;persist.sys.country&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">               SystemProperties.set(<span class="string">&quot;persist.sys.localevar&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// The system server should never make non-oneway calls</span></span><br><span class="line">           Binder.setWarnOnBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Here we go!</span></span><br><span class="line">           Slog.i(TAG, <span class="string">&quot;Entered the Android system server!&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">           EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);</span><br><span class="line">           <span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">               MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;boot_system_server_init&quot;</span>, uptimeMillis);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// In case the runtime switched since last boot (such as when</span></span><br><span class="line">           <span class="comment">// the old runtime was removed in an OTA), set the system</span></span><br><span class="line">           <span class="comment">// property so that it is in sync. We can | xq oqi&#x27;t do this in</span></span><br><span class="line">           <span class="comment">// libnativehelper&#x27;s JniInvocation::Init code where we already</span></span><br><span class="line">           <span class="comment">// had to fallback to a different runtime because it is</span></span><br><span class="line">           <span class="comment">// running as root and we need to be the system user to set</span></span><br><span class="line">           <span class="comment">// the property. http://b/11463182</span></span><br><span class="line">           SystemProperties.set(<span class="string">&quot;persist.sys.dalvik.vm.lib.2&quot;</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Enable the sampling profiler.</span></span><br><span class="line">           <span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">               SamplingProfilerIntegration.start();</span><br><span class="line">               mProfilerSnapshotTimer = <span class="keyword">new</span> Timer();</span><br><span class="line">               mProfilerSnapshotTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           SamplingProfilerIntegration.writeSnapshot(<span class="string">&quot;system_server&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Mmmmmm... more memory!</span></span><br><span class="line">           VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// The system server has to run all of the time, so it needs to be</span></span><br><span class="line">           <span class="comment">// as efficient as possible with its memory usage.</span></span><br><span class="line">           VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Some devices rely on runtime fingerprint generation, so make sure</span></span><br><span class="line">           <span class="comment">// we&#x27;ve defined it before booting further.</span></span><br><span class="line">           Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Within the system server, it is an error to access Environment paths without</span></span><br><span class="line">           <span class="comment">// explicitly specifying a user.</span></span><br><span class="line">           Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Within the system server, any incoming Bundles should be defused</span></span><br><span class="line">           <span class="comment">// to avoid throwing BadParcelableException.</span></span><br><span class="line">           BaseBundle.setShouldDefuse(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">           BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Increase the number of binder threads in system_server</span></span><br><span class="line">           BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">           android.os.Process.setThreadPriority(</span><br><span class="line">               android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">           android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">           Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Initialize native services.</span></span><br><span class="line">           System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check whether we failed to shut down last time we tried.</span></span><br><span class="line">           <span class="comment">// This call may not return.</span></span><br><span class="line">           performPendingShutdown();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//=======以上方法就是初始化系统的一些环境，看方法名都知道干了什么====</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//=======以下开始实际干活了=====================================</span></span><br><span class="line">           <span class="comment">// Initialize the system context.</span></span><br><span class="line">           <span class="comment">// 创建系统句柄，有了该句柄后面的服务才能拿到系统资源</span></span><br><span class="line">           createSystemContext();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Create the system service manager.</span></span><br><span class="line">           mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">           mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">           LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">           <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">           SystemServerInitThreadPool.get();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Start services.</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">           <span class="comment">// 启动引导服务</span></span><br><span class="line">           startBootstrapServices();</span><br><span class="line">           <span class="comment">// 启动核心服务</span></span><br><span class="line">           startCoreServices();</span><br><span class="line">           <span class="comment">// 启动其他服务</span></span><br><span class="line">           startOtherServices();</span><br><span class="line">           SystemServerInitThreadPool.shutdown();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">           Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">           <span class="keyword">throw</span> ex;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           traceEnd();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// For debug builds, log event loop stalls to dropbox for analysis.</span></span><br><span class="line">       <span class="keyword">if</span> (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">           Slog.i(TAG, <span class="string">&quot;Enabled StrictMode for system server main thread.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) &#123;</span><br><span class="line">           <span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">           MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;boot_system_server_ready&quot;</span>, uptimeMillis);</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> MAX_UPTIME_MILLIS = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">           <span class="keyword">if</span> (uptimeMillis &gt; MAX_UPTIME_MILLIS) &#123;</span><br><span class="line">               Slog.wtf(SYSTEM_SERVER_TIMING_TAG,</span><br><span class="line">                       <span class="string">&quot;SystemServer init took too long. uptimeMillis=&quot;</span> + uptimeMillis);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Loop forever.</span></span><br><span class="line">    	<span class="comment">// 死循环等待其他客户端来获取服务，响应客户端请求。</span></span><br><span class="line">       Looper.loop();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-1-createSystemContext"><a href="#5-1-createSystemContext" class="headerlink" title="5.1 createSystemContext()"></a>5.1 createSystemContext()</h5><p>初始化必要的SystemServer环境参数，比如系统时间、默认时区、语言、load一些Library等等， 初始化Looper，我们在主线程中使用到的looper就是在SystemServer中进行初始化的<br>初始化Context，只有初始化一个Context才能进行启动Service等操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">        mSystemContext = activityThread.getSystemContext();</span><br><span class="line">        mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Context systemUiContext = activityThread.getSystemUiContext();</span><br><span class="line">        systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ActivitThread是在这里创建的，此处的Activitythread是系统的ActivityThread，和应用的ActivityThread有区别，下面给出区别。创建了ActivitThread就获得了ResourcesManager，就可以获得各种资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\android\app\ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">systemMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The system process on low-memory devices do not get to use hardware</span></span><br><span class="line">        <span class="comment">// accelerated drawing, since this can add too much overhead to the</span></span><br><span class="line">        <span class="comment">// process.</span></span><br><span class="line">        <span class="keyword">if</span> (!ActivityManager.isHighEndGfx()) &#123;</span><br><span class="line">            ThreadedRenderer.disable(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ThreadedRenderer.enableForegroundTrimming();</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 创建ActivityThread，在ActivityThread中其实就是去获取ResourcesManager，不在赘述。</span></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    	<span class="comment">// 此处就体现了SystemServer的ActivityThread和应用的ActivityThread不同之处。</span></span><br><span class="line">    	<span class="comment">// 系统的attch传入的是true, 而应用的是传入的false</span></span><br><span class="line">        thread.attach(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">    	<span class="comment">// 如果是应用走if,系统走else</span></span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    ensureJitEnabled();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">            BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                    <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                    <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                    <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">&quot;Dalvik max=&quot;</span> + (dalvikMax/<span class="number">1024</span>) + <span class="string">&quot; total=&quot;</span> + (runtime.totalMemory()/<span class="number">1024</span>) + <span class="string">&quot; used=&quot;</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                        mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t set application object here -- if the system crashes,</span></span><br><span class="line">            <span class="comment">// we can&#x27;t display an alert, we just want to die die die.</span></span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;system_process&quot;</span>,</span><br><span class="line">                    UserHandle.myUserId());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">                ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                        <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">                mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                mInitialApplication.onCreate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">&quot;Unable to instantiate Application():&quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add dropbox logging to libcore</span></span><br><span class="line">    	<span class="comment">// 打印应用或者系统崩溃日志</span></span><br><span class="line">        DropBox.setReporter(<span class="keyword">new</span> DropBoxReporter());</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出：</p>
<ul>
<li>如果是<strong>应用</strong>，系统会监控应用的内存是否在于堆内存的3/4，如果大于3/4了，ActivityThread就会通知AMS，销毁一些当前进程的activity。</li>
<li>如果是<strong>系统</strong>，仅仅创建Context并且调用Application.onCreate()方法。</li>
</ul>
<p>下面继续分析Context的创建过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例创建ContextImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ContextImpl <span class="title">getSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mSystemContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mSystemContext = ContextImpl.createSystemContext(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mSystemContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\android\app\ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createSystemContext</span><span class="params">(ActivityThread mainThread)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统包信息</span></span><br><span class="line">        LoadedApk packageInfo = <span class="keyword">new</span> LoadedApk(mainThread);</span><br><span class="line">        <span class="comment">// 封装系统ContextImpl</span></span><br><span class="line">        ContextImpl context = <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 设置系统资源</span></span><br><span class="line">        context.setResources(packageInfo.getResources());</span><br><span class="line">        <span class="comment">// 更新配置信息</span></span><br><span class="line">        context.mResources.updateConfiguration(context.mResourcesManager. getConfiguration(), context.mResourcesManager.getDisplayMetrics());</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>LoadedApk()一看名字就知道是封装Apk信息的，他有两个构造方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装应用apk信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadedApk</span><span class="params">(ActivityThread activityThread, ApplicationInfo aInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, ClassLoader baseLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode, <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mActivityThread = activityThread;</span><br><span class="line">        setApplicationInfo(aInfo);</span><br><span class="line">        mPackageName = aInfo.packageName;</span><br><span class="line">        mBaseClassLoader = baseLoader;</span><br><span class="line">        mSecurityViolation = securityViolation;</span><br><span class="line">        mIncludeCode = includeCode;</span><br><span class="line">        mRegisterPackage = registerPackage;</span><br><span class="line">        mDisplayAdjustments.setCompatibilityInfo(compatInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装系统apk信息</span></span><br><span class="line">LoadedApk(ActivityThread activityThread) &#123;</span><br><span class="line">        mActivityThread = activityThread;</span><br><span class="line">        mApplicationInfo = <span class="keyword">new</span> ApplicationInfo();</span><br><span class="line">        mApplicationInfo.packageName = <span class="string">&quot;android&quot;</span>;</span><br><span class="line">        mPackageName = <span class="string">&quot;android&quot;</span>;</span><br><span class="line">        mAppDir = <span class="keyword">null</span>;</span><br><span class="line">        mResDir = <span class="keyword">null</span>;</span><br><span class="line">        mSplitAppDirs = <span class="keyword">null</span>;</span><br><span class="line">        mSplitResDirs = <span class="keyword">null</span>;</span><br><span class="line">        mOverlayDirs = <span class="keyword">null</span>;</span><br><span class="line">        mSharedLibraries = <span class="keyword">null</span>;</span><br><span class="line">        mDataDir = <span class="keyword">null</span>;</span><br><span class="line">        mDataDirFile = <span class="keyword">null</span>;</span><br><span class="line">        mDeviceProtectedDataDirFile = <span class="keyword">null</span>;</span><br><span class="line">        mCredentialProtectedDataDirFile = <span class="keyword">null</span>;</span><br><span class="line">        mLibDir = <span class="keyword">null</span>;</span><br><span class="line">        mBaseClassLoader = <span class="keyword">null</span>;</span><br><span class="line">        mSecurityViolation = <span class="keyword">false</span>;</span><br><span class="line">        mIncludeCode = <span class="keyword">true</span>;</span><br><span class="line">        mRegisterPackage = <span class="keyword">false</span>;</span><br><span class="line">        mClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        mResources = Resources.getSystem();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，系统资源的句柄已经创建完成了，那我们来看看该句柄提供了哪些常用的方法，供外部调用来获取系统资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\core\java\android\app\ContextImpl.java</span></span><br><span class="line"><span class="comment">// 获取系统的context</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createSystemContext</span><span class="params">(ActivityThread mainThread)</span> </span>&#123;</span><br><span class="line">        LoadedApk packageInfo = <span class="keyword">new</span> LoadedApk(mainThread);</span><br><span class="line">        ContextImpl context = <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        context.setResources(packageInfo.getResources());</span><br><span class="line">        context.mResources.updateConfiguration(context.mResourcesManager. getConfiguration(),context.mResourcesManager.getDisplayMetrics());</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该Context是包含了系统主题资源，主要用于UI，在使用的时候，需要确保创建的系统ui Context是在相同的LoadedApk的context中</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createSystemUiContext</span><span class="params">(ContextImpl systemContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LoadedApk packageInfo = systemContext.mPackageInfo;</span><br><span class="line">        ContextImpl context = <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, systemContext.mMainThread, packageInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        context.setResources(createResources(<span class="keyword">null</span>, packageInfo, <span class="keyword">null</span>, Display.DEFAULT_DISPLAY, <span class="keyword">null</span>, packageInfo.getCompatibilityInfo()));</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app的Context</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createAppContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;packageInfo&quot;</span>);</span><br><span class="line">        ContextImpl context = <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        context.setResources(packageInfo.getResources());</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity的context</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createActivityContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, <span class="keyword">int</span> displayId, Configuration overrideConfiguration)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，系统资源的创建和提供的接口已经叙述完毕，下面可以开始启动服务了。</p>
<h5 id="5-2-启动引导服务"><a href="#5-2-启动引导服务" class="headerlink" title="5.2 启动引导服务"></a>5.2 启动引导服务</h5><p>从方法名字就可以看出来该阶段启动的是其他服务依赖的关键服务。包含：安装器、AMS、PMS、LightService、DMS、PKMS、UMS、OMS等，具体某个服务的启动，后面写Blog分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for installd to finish starting up so that it has a chance to</span></span><br><span class="line">        <span class="comment">// create critical directories such as /data/user with the appropriate</span></span><br><span class="line">        <span class="comment">// permissions.  We need this to complete before we initialize other services.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartInstaller&quot;</span>);</span><br><span class="line">     	<span class="comment">// 安装器</span></span><br><span class="line">        Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In some cases after launching an app we need to access device identifiers,</span></span><br><span class="line">        <span class="comment">// therefore register the device identifier policy before the activity manager.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;DeviceIdentifiersPolicyService&quot;</span>);</span><br><span class="line">        mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Activity manager runs the show.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动AMS</span></span><br><span class="line">        mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">                ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">        mActivityManagerService.setInstaller(installer);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Power manager needs to be started early because other services need it.</span></span><br><span class="line">        <span class="comment">// Native daemons may be watching for it to be registered so it must be ready</span></span><br><span class="line">        <span class="comment">// to handle incoming binder calls immediately (including being able to verify</span></span><br><span class="line">        <span class="comment">// the permissions for those calls).</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartPowerManager&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动PMS</span></span><br><span class="line">        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that the power manager has been started, let the activity manager</span></span><br><span class="line">        <span class="comment">// initialize power management features.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;InitPowerManagement&quot;</span>);</span><br><span class="line">        mActivityManagerService.initPowerManagement();</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bring up recovery system in case a rescue party needs a reboot</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.getBoolean(<span class="string">&quot;config.disable_noncore&quot;</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartRecoverySystemService&quot;</span>);</span><br><span class="line">            mSystemServiceManager.startService(RecoverySystemService.class);</span><br><span class="line">            traceEnd();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that we have the bare essentials of the OS up and running, take</span></span><br><span class="line">        <span class="comment">// note that we just booted, which might send out a rescue party if</span></span><br><span class="line">        <span class="comment">// we&#x27;re stuck in a runtime restart loop.</span></span><br><span class="line">        RescueParty.noteBoot(mSystemContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Manages LEDs and display backlight so we need it to bring up the display.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartLightsService&quot;</span>);</span><br><span class="line">        mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Display manager is needed to provide display metrics before package manager</span></span><br><span class="line">        <span class="comment">// starts up.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartDisplayManager&quot;</span>);</span><br><span class="line">    	<span class="comment">// 显示服务</span></span><br><span class="line">        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need the default display before we can initialize the package manager.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;WaitForDisplay&quot;</span>);</span><br><span class="line">    	<span class="comment">// 等待显示阶段</span></span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService. PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only run &quot;core&quot; apps if we&#x27;re encrypting the device.</span></span><br><span class="line">        String cryptState = SystemProperties.get(<span class="string">&quot;vold.decrypt&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Detected encryption in progress - only parsing core apps&quot;</span>);</span><br><span class="line">            mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Device encrypted - only parsing core apps&quot;</span>);</span><br><span class="line">            mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the package manager.</span></span><br><span class="line">        <span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;boot_package_manager_init_start&quot;</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">        &#125;</span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartPackageManagerService&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动PKMS</span></span><br><span class="line">        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">        mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">        mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">        traceEnd();</span><br><span class="line">        <span class="keyword">if</span> (!mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;boot_package_manager_init_ready&quot;</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Manages A/B OTA dexopting. This is a bootstrap service as we need it to rename</span></span><br><span class="line">        <span class="comment">// A/B artifacts after boot, before anything else might touch/need them.</span></span><br><span class="line">        <span class="comment">// Note: this isn&#x27;t needed during decryption (we don&#x27;t have /data anyways).</span></span><br><span class="line">        <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> disableOtaDexopt = SystemProperties.getBoolean(<span class="string">&quot;config.disable_otadexopt&quot;</span>,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!disableOtaDexopt) &#123;</span><br><span class="line">                traceBeginAndSlog(<span class="string">&quot;StartOtaDexOptService&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    reportWtf(<span class="string">&quot;starting OtaDexOptService&quot;</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    traceEnd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartUserManagerService&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动UMS</span></span><br><span class="line">        mSystemServiceManager.startService(UserManagerService.LifeCycle.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize attribute cache used to cache resources from packages.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;InitAttributerCache&quot;</span>);</span><br><span class="line">        AttributeCache.init(mSystemContext);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;SetSystemProcess&quot;</span>);</span><br><span class="line">		<span class="comment">//启动AMS系统进程的应用实例</span></span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DisplayManagerService needs to setup android.display scheduling related policies</span></span><br><span class="line">        <span class="comment">// since setSystemProcess() would have overridden policies due to setProcessGroup</span></span><br><span class="line">        mDisplayManagerService.setupSchedulerPolicies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Manages Overlay packages</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartOverlayManagerService&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动OMS</span></span><br><span class="line">        mSystemServiceManager.startService(<span class="keyword">new</span> OverlayManagerService(mSystemContext, installer));</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The sensor service needs access to package manager service, app ops</span></span><br><span class="line">        <span class="comment">// service, and permissions service, therefore we start it after them.</span></span><br><span class="line">        <span class="comment">// Start sensor service in a separate thread. Completion should be checked</span></span><br><span class="line">        <span class="comment">// before using it.</span></span><br><span class="line">        mSensorServiceStart = SystemServerInitThreadPool.get().submit(() -&gt; &#123;</span><br><span class="line">            BootTimingsTraceLog traceLog = <span class="keyword">new</span> BootTimingsTraceLog(</span><br><span class="line">                    SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">            traceLog.traceBegin(START_SENSOR_SERVICE);</span><br><span class="line">            startSensorService();</span><br><span class="line">            traceLog.traceEnd();</span><br><span class="line">        &#125;, START_SENSOR_SERVICE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-3-startCoreServices"><a href="#5-3-startCoreServices" class="headerlink" title="5.3 startCoreServices()"></a>5.3 startCoreServices()</h5><p>启动核心服务比较简单，主要启动DropBoxManagerService、BatteryService、UsageStatsService和WebViewUpdateService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Records errors and logs, for example wtf()</span></span><br><span class="line">       traceBeginAndSlog(<span class="string">&quot;StartDropBoxManager&quot;</span>);</span><br><span class="line">       mSystemServiceManager.startService(DropBoxManagerService.class);</span><br><span class="line">       traceEnd();</span><br><span class="line"></span><br><span class="line">       traceBeginAndSlog(<span class="string">&quot;StartBatteryService&quot;</span>);</span><br><span class="line">       <span class="comment">// Tracks the battery level.  Requires LightService.</span></span><br><span class="line">       mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line">       traceEnd();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Tracks application usage stats.</span></span><br><span class="line">       traceBeginAndSlog(<span class="string">&quot;StartUsageService&quot;</span>);</span><br><span class="line">       mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">       mActivityManagerService.setUsageStatsManager(</span><br><span class="line">               LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line">       traceEnd();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Tracks whether the updatable WebView is in a ready state and watches for update installs.</span></span><br><span class="line">       traceBeginAndSlog(<span class="string">&quot;StartWebViewUpdateService&quot;</span>);</span><br><span class="line">       mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">       traceEnd();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-4-startOtherServices"><a href="#5-4-startOtherServices" class="headerlink" title="5.4 startOtherServices()"></a>5.4 startOtherServices()</h5><p>启动其他服务就不细说了，太多了，套路都一样。主要来分析一下其他服务启动完成之后，又干了什么，Launcher是如何被拉起来的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 前面象征性的放一点启动其他服务代码</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">&quot;StartKeyChainSystemService&quot;</span>);</span><br><span class="line">    mSystemServiceManager.startService(KeyChainSystemService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">&quot;StartSchedulingPolicyService&quot;</span>);</span><br><span class="line">    ServiceManager.addService(<span class="string">&quot;scheduling_policy&quot;</span>, <span class="keyword">new</span> SchedulingPolicyService());</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">&quot;StartTelecomLoaderService&quot;</span>);</span><br><span class="line">    mSystemServiceManager.startService(TelecomLoaderService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 接下来会回调各个服务启动完成的回调，在各个服务中可以执行响应的操作</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">&quot;MakeWindowManagerServiceReady&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// WMS启动结束回调</span></span><br><span class="line">        wm.systemReady();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">&quot;making Window Manager Service ready&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法最后!!!!</span></span><br><span class="line">    <span class="comment">// 方法最后!!!!</span></span><br><span class="line">    <span class="comment">// 方法最后!!!!</span></span><br><span class="line">    <span class="comment">// 在方法最后回调AMS.SystemReady()，然后第一个参数传入的是一个Runnable。</span></span><br><span class="line">     mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">     	 Slog.i(TAG, <span class="string">&quot;Making services ready&quot;</span>);</span><br><span class="line">         traceBeginAndSlog(<span class="string">&quot;StartActivityManagerReadyPhase&quot;</span>);</span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">             SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         traceEnd();</span><br><span class="line">         traceBeginAndSlog(<span class="string">&quot;StartObservingNativeCrashes&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             reportWtf(<span class="string">&quot;observing native crashes&quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">         traceEnd();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// No dependency on Webview preparation in system server. But this should</span></span><br><span class="line">         <span class="comment">// be completed before allowring 3rd party</span></span><br><span class="line">         <span class="keyword">final</span> String WEBVIEW_PREPARATION = <span class="string">&quot;WebViewFactoryPreparation&quot;</span>;</span><br><span class="line">         Future&lt;?&gt; webviewPrep = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">             webviewPrep = SystemServerInitThreadPool.get().submit(() -&gt; &#123;</span><br><span class="line">                 Slog.i(TAG, WEBVIEW_PREPARATION);</span><br><span class="line">                 BootTimingsTraceLog traceLog = <span class="keyword">new</span> BootTimingsTraceLog(</span><br><span class="line">                     SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">                 traceLog.traceBegin(WEBVIEW_PREPARATION);</span><br><span class="line">                 ConcurrentUtils.waitForFutureNoInterrupt(mZygotePreload, <span class="string">&quot;Zygote preload&quot;</span>);</span><br><span class="line">                 mZygotePreload = <span class="keyword">null</span>;</span><br><span class="line">                 mWebViewUpdateService.prepareWebViewInSystemServer();</span><br><span class="line">                 traceLog.traceEnd();</span><br><span class="line">             &#125;, WEBVIEW_PREPARATION);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         traceBeginAndSlog(<span class="string">&quot;StartSystemUI&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 启动systemui</span></span><br><span class="line">             startSystemUi(context, windowManagerF);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             reportWtf(<span class="string">&quot;starting System UI&quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">         traceEnd();</span><br><span class="line">         traceBeginAndSlog(<span class="string">&quot;MakeNetworkScoreReady&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 启动网络评分机制</span></span><br><span class="line">             <span class="keyword">if</span> (networkScoreF != <span class="keyword">null</span>) networkScoreF.systemReady();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             reportWtf(<span class="string">&quot;making Network Score Service ready&quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">         traceEnd();</span><br><span class="line">         traceBeginAndSlog(<span class="string">&quot;MakeNetworkManagementServiceReady&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (networkManagementF != <span class="keyword">null</span>) networkManagementF.systemReady();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             reportWtf(<span class="string">&quot;making Network Managment Service ready&quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">         ......</span><br><span class="line">         <span class="comment">// 设置启动阶段</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">             SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">         traceEnd();</span><br><span class="line"></span><br><span class="line">         ......</span><br><span class="line">     &#125;, BOOT_TIMINGS_TRACE_LOG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok, 继续分析AMS ready之后干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback, BootTimingsTraceLog traceLog)</span> </span>&#123;</span><br><span class="line">        traceLog.traceBegin(<span class="string">&quot;PhaseActivityManagerReady&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 由于goingCallback中还有服务没有回调systemReady,所以此处为false，继续往下走。</span></span><br><span class="line">            <span class="keyword">if</span> (mSystemReady) &#123;</span><br><span class="line">                <span class="comment">// If we&#x27;re done calling all the receivers, run the next &quot;boot phase&quot; passed in by the SystemServer</span></span><br><span class="line">                <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    goingCallback.run();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        retrieveSettings();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前用户id,之后启动launcher之前会判断该用户是否解锁</span></span><br><span class="line">            currentUserId = mUserController.getCurrentUserIdLocked();</span><br><span class="line">            readGrantedUriPermissionsLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调systemserver中的run()，通知其他服务SystemReady()</span></span><br><span class="line">        <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Only start up encryption-aware persistent apps; once user is</span></span><br><span class="line">            <span class="comment">// unlocked we&#x27;ll come back around and start unaware apps</span></span><br><span class="line">            <span class="comment">// 启动Manifest中配置了Persistent属性的App</span></span><br><span class="line">            startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start up initial activity.</span></span><br><span class="line">            mBooting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 启动HomeActivity,此处其实是启动的FallbcakHome Activity</span></span><br><span class="line">            startHomeActivityLocked(currentUserId, <span class="string">&quot;systemReady&quot;</span>);</span><br><span class="line"></span><br><span class="line">           ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-启动FallbcakHome和Launcher"><a href="#6-启动FallbcakHome和Launcher" class="headerlink" title="6 启动FallbcakHome和Launcher"></a>6 启动FallbcakHome和Launcher</h4><p>可以看到FallbcakHome的category配置也是HOME，当系统开启了FBE之后，SystemServer首先会启动FallbackHome，在FallbackHome中检查用户是否解锁。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- packages\apps\Settings\AndroidManifest.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Triggered when user-selected home app isn&#x27;t encryption aware --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.FallbackHome&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:excludeFromRecents</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;nosensor&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/FallbackHome&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;-1000&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.HOME&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FallbackHome</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;FallbackHome&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROGRESS_TIMEOUT = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册解锁广播</span></span><br><span class="line">        registerReceiver(mReceiver, <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_UNLOCKED));</span><br><span class="line">        maybeFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果用户已经解锁</span></span><br><span class="line">        <span class="keyword">if</span> (getSystemService(UserManager.class).isUserUnlocked()) &#123;</span><br><span class="line">            <span class="comment">// 构建launcher的Intent</span></span><br><span class="line">            <span class="keyword">final</span> Intent homeIntent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN)</span><br><span class="line">                    .addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">            <span class="keyword">final</span> ResolveInfo homeInfo = getPackageManager().resolveActivity(homeIntent, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(getPackageName(), homeInfo.activityInfo.packageName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UserManager.isSplitSystemUser()</span><br><span class="line">                        &amp;&amp; UserHandle.myUserId() == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;User unlocked but no home; let&#x27;s hope someone enables one soon?&quot;</span>);</span><br><span class="line">                mHandler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;User unlocked and real home found; let&#x27;s go!&quot;</span>);</span><br><span class="line">                <span class="comment">// 如果用户已经解锁，并且找到了Launcher的主界面，退出FallbackHome界面。</span></span><br><span class="line">                getSystemService(PowerManager.class).userActivity(</span><br><span class="line">                        SystemClock.uptimeMillis(), <span class="keyword">false</span>);</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FallbackHome请求finish自己，当然会请求执行onPasue方法： ActivityManagerService.activityPaused –》触发调用到ActivityStack.activityPausedLocked –》 调用到 ActivityStack.completePauseLocked —》 调用到 ActivityStack.finishCurrentActivityLocked –》调用到 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked –》ActivityStack.resumeTopActivityUncheckedLocked -》 ActivityStack.resumeTopActivityInnerLocked -》 ActivityStack.resumeTopActivityInNextFocusableStack -》 ActivityStackSupervisor.resumeHomeStackTask -》最后调用到了ActivityManagerService.startHomeActivityLocked。</p>
<p>跟踪调用栈会发现，如果当category是HOME被销毁之后，最终又会调用到startHomeActivityLocked中。</p>
<p>此处调用startHomeActivityLocked的reason是<strong>noMoreActivities resumeHomeStackTask</strong>，没有找到可返回的Home主页，然后mActivityStarter.startHomeActivityLocked再起启动Home Activity就是启动的Launcher的启动页了。</p>
<p>此次，Launcher界面终于启动起来了，此篇分析系统启动的过程的帖子终于写完了。</p>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h4><blockquote>
<ol>
<li>init 根据init.rc 运行 app_process, 并携带‘–zygote’ 和 ’–startSystemServer’ 参数。</li>
<li>AndroidRuntime.cpp::start() 里将启动JavaVM，并且注册所有framework相关的系统JNI接口。</li>
<li>第一次进入Java世界，运行ZygoteInit.java::main() 函数初始化Zygote. Zygote 并创建Socket的 server 端。</li>
<li>然后fork一个新的进程并在新进程里初始化SystemServer. Fork之前，Zygote是preload常用的 Java类库，以及系统的resources，同时GC（）清理内存空间，为子进程省去重复的工作。</li>
<li>SystemServer 里将所有的系统Service初始化，包括ActivityManager 和 WindowManager, 他们 是应用程序运行起来的前提。</li>
<li>依次同时，Zygote监听服务端Socket，等待新的应用启动请求。</li>
<li>ActivityManager ready 之后寻找系统的“Startup” Application, 将请求发给Zygote。</li>
<li>Zygote收到请求后，fork出一个新的进程。</li>
<li>Zygote监听并处理SystemServer 的 SIGCHID 信号，一旦System Server崩溃，立即将自己杀死。 init会重启Zygote.</li>
</ol>
</blockquote>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>此帖子最初的学习资源来自罗升阳大神《Android系统源代码情景分析（第三版）》。回顾写此篇文章主要是工作需要用到了，再次翻读此书，结合Android O的源码，更细，更深入的理解了源码的调用栈和方法含义。</p>
<p><strong>建议：</strong>如果第一次看系统启动流程，最好看低版本系统的源码，因为高版本的代码google用了很多设计模式进行封装和重构了，很多看着看着就不知道跳到哪里去了，低版本的代码还是很容易看懂的。</p>
<p><strong>参考文章：</strong></p>
<p>罗升阳大神《Android系统源代码情景分析（第三版）》(至于第几版，最好买最新的吧，第三版分析的源码在当前项目Andorid P和Q源码中很多都被重构了)</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
        <tag>系统启动</tag>
      </tags>
  </entry>
  <entry>
    <title>重温ActivityManagerService--应用启动流程分析</title>
    <url>/2021/10/11/%E9%87%8D%E6%B8%A9ActivityManagerService-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前一篇文章<a href="http://jackou.top/2021/10/10/%E9%87%8D%E6%B8%A9ActivityManagerService/">《重温ActivityManagerService》</a>重温了AMS，记录了AMS启动过程，与AMS交互的几个重要的类和数据结构。</p>
<p>分析的笔记见：<a href="https://github.com/oujie123/AMS">AMS源码分析笔记</a></p>
<p>此文章主要记录一个应用是如何启动起来的。其中分析启动过程我将以两种不同的启动方式来分析：</p>
<ul>
<li>根Activity的启动流程(进程没有启动的状态)</li>
<li>子Activity的启动过程(进程已经启动)</li>
</ul>
<h4 id="1-图解Acitivity启动过程"><a href="#1-图解Acitivity启动过程" class="headerlink" title="1 图解Acitivity启动过程"></a>1 图解Acitivity启动过程</h4><p>凡事由浅入深，一口气带出全过程必然一脸蒙蔽。因此我先放出一张简易版的子Activity的启动过程图。小伙伴们肯定可以看懂一个界面是如何启动起来的。但是该图只能说明大致流程，没有考虑进程还没有启动的情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-60752c5c3d10da21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动子Activity流程图.png"></p>
<p>然后看看稍微详细一些的子Activity启动流程图，可以更加详细得明白APP和AMS是如何调度的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-06dd703f39ca0012.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子Activity组件启动过程.png"></p>
<p>最后看看详细的根Activity的启动流程图，可以全面看清楚一个应用从无到启动完成的过程。后面章节也会详细叙述每个步骤做了什么。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c4550a545827d08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根Activity组件启动过程.png"></p>
<p>注意：根Activity的23步到24步还做了很多事件，例如AMS通过Socket请求Zygote fork一个子进程等操作没有画入到该流程图中，因为该过程在<a href="http://jackou.top/2021/09/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">《Android系统启动流程分析》</a>中有分析到，此处只列出了调用AMS的startProcessLocked()就启动了一个进程，然后调用了ActivityThread的main()方法。</p>
<p><strong>小结：</strong></p>
<p>Launcher组件启动MainActivity组件的过程：</p>
<ul>
<li>(1)Launcher组件向AMS发送一个启动MAinActivity组件的进程间通信请求</li>
<li>(2)AMS首先将要启动的MAinActivity组件信息保存下来，然后再向Launcher组件发送一个进入中止状态的进程间通信请求。</li>
<li>(3)Launcher组件进入到中止状态之后，就会向AMS发送一个已进入中止状态的进程间通信请求，以便AMS可以继续执行启动MAinActivity组件的操作。</li>
<li>(4)AMS发现用来运行MAinActivity组件的应用程序进程不存在，因此，他就会先启动一个新的应用程序进程。</li>
<li>(5)新的应用程序进程启动完成之后，就会向AMS发送一个启动完成的进程间通信请求，以便AMS可以继续执行启动MAinActivity组件的操作。</li>
<li>(6)AMS将第2步保存下来的MAinActivity组件的信息发送给第4步创建的应用程序进程，以便它可以将MAinActivity组件启动起来。</li>
</ul>
<p>Ok, let’s go! 为了叙述的完整性，我们还是从启动根Activity开始分析，因此启动子Activity绝大多数步骤是沿用启动根Activity的流程。</p>
<h4 id="2-启动根Activity"><a href="#2-启动根Activity" class="headerlink" title="2.启动根Activity"></a>2.启动根Activity</h4><p>启动根Activity我们以在Launcher应用中点击Icon开始分析。</p>
<h5 id="2-1-在Launcher进程中完成的操作"><a href="#2-1-在Launcher进程中完成的操作" class="headerlink" title="2.1 在Launcher进程中完成的操作"></a>2.1 在Launcher进程中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-f67f409ebf55dc18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Launcher_startActivity.png"></p>
<p>在Launcher进程中完成了以下五个步骤的调用，具体实现的功能如下：</p>
<ul>
<li>1.用户调用launcher的startActivitySafely，设置Activity组件启动标志位Intent.FLAG_ACTIVITY_NEW_TASK为1，然后调用父类的startActivity。</li>
<li>2.调用startActivityForResult(intent,int)，第二个参数为-1，表示不需要知道即将启动的Activity组件的执行结果。</li>
<li>3.传递ApplicationThread给AMS，以便AMS告知Launcher可以进入pause状态，mToken对象指向AMS中的ActivityRecord，每一个已经启动的activity都会在AMS中记录一个ActivityRecord，用来记录activity组件运行状态。</li>
<li>4.在execStartActivity中通过AMS的代理对象调用AMS的startActivity。</li>
<li>5.AMS代理透传信息。</li>
</ul>
<h5 id="2-2-在ActivityManagerService中完成的操作"><a href="#2-2-在ActivityManagerService中完成的操作" class="headerlink" title="2.2 在ActivityManagerService中完成的操作"></a>2.2 在ActivityManagerService中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-4170f51ba60e65d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMS_pause.png"></p>
<p>从6至12步骤是在AMS中完成的操作，具体实现的功能如下：</p>
<ul>
<li>6.AMS内部有一个activityStack，用来描述一个activity组件堆栈，在该步骤中进一步调用mActivityStack的startActivityMayWait进一步响应进程间通信请求。</li>
<li>7.在PMS中解析Intent的内容，以获得要启动activity组件的信息。然后调用startActivityLocked继续启动activity</li>
<li>8.每一个应用程序都会使用ProcessRecord对象来描述并且保存在AMS内部。通过传进来的ApplicationThread在AMS中查询到Launcher的ProcessRecord。从mHistory堆栈中获得launcher组件的ActivityRecord。创建一个Mactivity的ActivityRecord。调用<strong>startActivityUncheckedLocked</strong>启动目标组件</li>
<li>9.判断新启动的activity是否要在新任务中启动，在AMS中查询该任务是否已经存在。为MainActivity创建新的任务，并且将该任务加入到AMS的task堆栈中。将目标ActivityRecord保存在mHistory中，并且把MAinActivity放在栈顶，调用resumeTopActivityLocked。</li>
<li>10.从栈顶取出activity，判断当前activity是不是被激活的activity，如果是，并且状态是Resumed直接退出，说明已经启动了。判断当前activity是否是上一次被中止的activity组件。由于当前activity是launcher，调用startPausingLocked来通知他进入pause状态。</li>
<li>11.向launcher发送一个中止通知，并且在AMS中发送一个中止超时消息，如果Launcher没有在超时时间内返回，那么就认为Launcher没有响应了。</li>
<li>12.透传参数给ApplicationThread。</li>
</ul>
<h5 id="2-3-在Launcher进程中完成的操作"><a href="#2-3-在Launcher进程中完成的操作" class="headerlink" title="2.3 在Launcher进程中完成的操作"></a>2.3 在Launcher进程中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-3a0cf155ad2d7ef9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launcher_pause.png"></p>
<p>从13至17步骤是在Launcher中完成的操作，具体内容如下：</p>
<ul>
<li><p>13.调用ActivityThread的queueOrSendMessage，这个步骤已经在launcher进程中。准备将通知暂停的消息抛到主线程。</p>
</li>
<li><p>14.封装一个message发送到mH主线程。</p>
</li>
<li><p>15.处理activityThread发来的PAUSE_ACTIVITY</p>
</li>
<li><p>16.(1)从launcher进程中的mActivities中取出ActivityClientRecord。   </p>
<p>​      (2)调用performUserLeavingActivity向launcher组件发送一个用户离开事件通知，即调用成员函数onUserLeaveHint<br>​      (3)调用performPauseActivity向Launcher发送中止事件通知，调用成员函数onPause<br>​      (4)调用QueuedWork类的静态方法waitToFinish()等待完成前面的一些数据写入操作。为了回到Resumed状态时，能够恢复当前的状态信息。<br>​      (5)调用handlePauseActivity向AMS发送中止Launcher组件的进程间通信请求。</p>
</li>
<li><p>17.从AMS代理调用activityPaused。</p>
</li>
</ul>
<h5 id="2-4-在ActivityManagerService中完成的操作"><a href="#2-4-在ActivityManagerService中完成的操作" class="headerlink" title="2.4 在ActivityManagerService中完成的操作"></a>2.4 在ActivityManagerService中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-7d4048413ec85411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMS_startproc.png"></p>
<p>从18至23步骤是在AMS中完成的操作，具体实现的功能如下：</p>
<ul>
<li>18.收到launcher已经暂停的通知之后，调用activitystack的activityPaused.</li>
<li>19.从mHistory取出launcher的ActivityRecord，从mHandler中移除暂停超时通知。调用completePauseLocked。</li>
<li>20.把当前进入mPausingAcitivity取出，如果是空的，表示当前正在进入中止的Activity已经进入了Paused状态。检查当前系统是不是正在进入睡眠或者关闭状态。</li>
<li>21.取出栈顶的ActivityRecord，MainActivity的app是空的，所以调用startSpecificActivityLocked将MainActivity的进程启动起来。</li>
<li>22.通过activityRecord中的UID和进程名字查找是否存在MAinActivity所在的进程，如果存在则直接通知Activity启动，否则AMS的startProcessLocked来启动MAinActivity应用进程。如果进程已经起来了，那就调用realStartActivityLocked</li>
<li>23.(1)通过processName和uid判断ProcessRecord是否存在，如果不存在，调用startProcessLocked启动新进程。<br>   (2)创建新进程用户Id和用户组Id<br>   (3)Process.start方法启动一个新的应用进程<br>   (4)将新创建的ProcessRecord保存在AMS的mPidsSelfLocked中，并且发送一个启动计时Message，如果超时AMS认为进程启动失败，否则AMS就会通知应用启动Maintivity。</li>
</ul>
<h5 id="2-5-在Launcher进程中完成的操作"><a href="#2-5-在Launcher进程中完成的操作" class="headerlink" title="2.5 在Launcher进程中完成的操作"></a>2.5 在Launcher进程中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-27a2d375d4741231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launcher_attach.png"></p>
<p>24步之前，AMS会调到Zygote, Zygote会fork一个进程出来，然后调用Launcher的ActivityThread.main().</p>
<p>从24至25步骤是在Launcher中完成的操作，具体内容如下：</p>
<ul>
<li>24.此步骤已经进入了新进程Main方法，在Main方法中新建MainLooper，然后new一个ActivityThread，并且调用attach方法，最后Looper循环起来。在ActivityThread中新建一个ApplicationThread，通过AMS代理调用attachApplication。</li>
<li>25.新建进程状态透传给AMS。此处将IApplicationThread传递给AMS，AMS之后就可以通过Binder 客户端和新起来的进程通信了。</li>
</ul>
<h5 id="2-6-在ActivityManagerService中完成的操作"><a href="#2-6-在ActivityManagerService中完成的操作" class="headerlink" title="2.6  在ActivityManagerService中完成的操作"></a>2.6  在ActivityManagerService中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-a032c9f3f57e2f87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMS_launch_activity.png"></p>
<p>从27至30步骤是在AMS中完成的操作，具体实现的功能如下：</p>
<ul>
<li>27.(1)通过PID在AMS中找到新建的ProcessRecors并且初始化他们。<br>   (2)移除应用启动超时消息<br>   (3)获取栈顶activityRecord，并且判断栈顶的activityRecord和要启动的是不是一致的。如果是一致的，调用activityStack的realStartAcitivityLocked</li>
<li>28.将ActivityRecord的app值赋成新建的APP，然后将activity组件存入app所描述的进程中。然后在app描述的线程中调用scheduleLauncherActivity来通知新创建的进程启动activityRecord所描述的组件，即MainActivity</li>
<li>29.透传activityRecord信息</li>
<li>30.此步已经回到了新启动的应用进程。新建一个ActivityClientRecord，将AMS传来的参数对该ActivityClientRecord初始化，并且调用queueOrSendMessage</li>
</ul>
<h5 id="2-7-在Launcher进程中完成的操作"><a href="#2-7-在Launcher进程中完成的操作" class="headerlink" title="2.7 在Launcher进程中完成的操作"></a>2.7 在Launcher进程中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-949a9af07d271dca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launcher_handle_create.png"></p>
<p>从31至35步骤是在Launcher中完成的操作，具体内容如下：</p>
<ul>
<li>31.封装一个message向主线程handle一个消息。</li>
<li>32.通过ActivityClientRecord的applicationInfo查询新启动应用程序的包信息。然后调用handleLaunchActivity来启动一个新的activity</li>
<li>33.调用performLaunchActivity将MainActivity启动起来，并且调用HandleResumeActivity表示当前activity已经处于已激活状态。</li>
<li>34.(1)获取componentName，并且用ActivityClientRecord.packageInfo的类加载器加载MainActivity类。<br>   (2)ActivityClientRecord.packageInfo的makeApplication创建一个Application对象。<br>   (3)如果上面加载的MainActivity不是空的。新建一个contextImpl并且用ActivityClientRecord来初始化他。<br>   (4)调用activity.attach来初始化activity<br>   (5)调用mInstrumentation.callActivityOnCreate<br>   (6)将activityClientRecord的token作为关键字，并且将他保存在Activity的mActivity中。token是一个Binder代理，指向AMS中对应activity的ActivityRecrod</li>
<li>35.onCreate被调用，加载用户界面，已经对用户界面上的控件进行初始化。</li>
</ul>
<h5 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h5><p>MainActivity组件作为应用程序Activity的根activity，他启动起来就意味着应用程序启动起来了。因此我们可以将一个根Activity的启动过程看做一个Android应用程序的启动过程。</p>
<h4 id="3-启动子Activity"><a href="#3-启动子Activity" class="headerlink" title="3.启动子Activity"></a>3.启动子Activity</h4><p>启动子Activity和启动根Activity步骤相似度非常高，只是在<strong>startActivityUncheckedLocked</strong>中判断是否能通过AcitivityRecord获得到IApplicationThread，如果获取不到就说明进程没有启动，就去先启进程；如果不为空，就直接启动子Activity。</p>
<h5 id="3-1-在Launcher进程中完成的操作"><a href="#3-1-在Launcher进程中完成的操作" class="headerlink" title="3.1 在Launcher进程中完成的操作"></a>3.1 在Launcher进程中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-90826b5c0f73244a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launcher_sub_startactivity.png"></p>
<p>从1至5步骤是在Launcher中完成的操作，具体内容如下：</p>
<ul>
<li>1.设置intent，调用startActivity</li>
<li>2.3.4.5.沿用根activity启动的流程，并且目前是在原应用进程中执行。</li>
</ul>
<h5 id="3-2-在ActivityManagerService中完成的操作"><a href="#3-2-在ActivityManagerService中完成的操作" class="headerlink" title="3.2 在ActivityManagerService中完成的操作"></a>3.2 在ActivityManagerService中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-5f4784aef0efccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMS_sub_pause.png"></p>
<p>从6至12步骤是在AMS中完成的操作，具体实现的功能如下：</p>
<ul>
<li>6.7.8.沿用根activity流程。从这三步开始在AMS进程中执行。</li>
<li>9.判断是否需要创建一个新的任务来启动子activity组件。将新建的activityRecord加入到mHistory中。调用resumeTopActivityLocked</li>
<li>10.检查要启动的activity是否已经是当前激活的activity，判断要启动的activity的是否是上次中止的activity。</li>
<li>11.发送暂停通知，并且开始计时</li>
<li>12.透传暂停通知</li>
</ul>
<h5 id="3-3-在Launcher进程中完成的操作"><a href="#3-3-在Launcher进程中完成的操作" class="headerlink" title="3.3 在Launcher进程中完成的操作"></a>3.3 在Launcher进程中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-2ccabb674a36158e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launcher_sub_pause.png"></p>
<p>从13至17步骤是在Launcher中完成的操作，具体内容如下：</p>
<ul>
<li>13.调用queueOrSendMessage</li>
<li>14.封装message并且发送到主线程</li>
<li>15.处理暂停事件</li>
<li>16.(1)获得前一个组件ActivityClientRecord<br>   (2)向前一个组件发送离开通知，调用onUserLeaveHint<br>   (3)调用前一个组件的中止通知onPause<br>   (4)等待前一个组件将数据写入磁盘</li>
<li>17.将前一个组件已经暂停的通知告知AMS</li>
</ul>
<h5 id="3-4-在ActivityManagerService中完成的操作"><a href="#3-4-在ActivityManagerService中完成的操作" class="headerlink" title="3.4 在ActivityManagerService中完成的操作"></a>3.4 在ActivityManagerService中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-44a8baa4a5925847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMS_sub_launch_activity.png"></p>
<p>从18至25步骤是在AMS中完成的操作，具体实现的功能如下：</p>
<ul>
<li>18.透传已暂停通知给AMS</li>
<li>19.暂停计时，设置上一个activity为pause状态</li>
<li>20.设置中止中的activity为上一个activity，说明暂停状态已经结束</li>
<li>21.取出栈顶的ActivityRecord，SubActivity的app是空的，所以调用startSpecificActivityLocked将SubActivity的进程启动起来。</li>
<li>22.查看processRecord是否是空，如果不是空，则调用realStartActivityLocked真正启动一个activity</li>
<li>23.将ActivityRecord的app值赋成新建的APP，然后将activity组件存入app所描述的进程中。然后在app描述的线程中调用scheduleLauncherActivity来通知新创建的进程启动activityRecord所描述的组件，即SubActivity</li>
<li>24.透传activityRecord信息</li>
<li>25.用传来的activityRecord初始化activityClientRecord</li>
</ul>
<h5 id="3-5-在Launcher进程中完成的操作"><a href="#3-5-在Launcher进程中完成的操作" class="headerlink" title="3.5 在Launcher进程中完成的操作"></a>3.5 在Launcher进程中完成的操作</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-776f2f2f4240ebdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="launcher_sub_handle_create.png"></p>
<p>从26至30步骤是在Launcher中完成的操作，具体实现的功能如下：</p>
<ul>
<li>26.封装一个message，向主线程发送一个message</li>
<li>27.获取APK资源来处理启动activity事件</li>
<li>28.调用performLaunchActivity将MainActivity启动起来，并且调用HandleResumeActivity表示当前activity已经处于已激活状态。</li>
<li>29.(1)获取componentName，并且用ActivityClientRecord.packageInfo的类加载器加载MainActivity类。<br>   (2)ActivityClientRecord.packageInfo的makeApplication创建一个Application对象。<br>   (3)如果上面加载的MainActivity不是空的。新建一个contextImpl并且用ActivityClientRecord来初始化他。<br>   (4)调用activity.attach来初始化activity<br>   (5)调用mInstrumentation.callActivityOnCreate<br>   (6)将activityClientRecord的token作为关键字，并且将他保存在Activity的mActivity中。token是一个Binder代理，指向AMS中对应activity的ActivityRecrod</li>
<li>30.onCreate被调用，加载用户界面，已经对用户界面上的控件进行初始化。</li>
</ul>
<h5 id="3-6-说明"><a href="#3-6-说明" class="headerlink" title="3.6 说明"></a>3.6 说明</h5><p>如果子activity设置了android：process属性为另一个进程，启动过程跟MainActivity启动一样，只是不用再新建一个task了，因为子activity的android:taskAffinity和MAinActivity是一样的，MainActivity已经新创建了一个task，可以在同一个task中进程。</p>
<h4 id="4-Android-O方法调用栈"><a href="#4-Android-O方法调用栈" class="headerlink" title="4.Android O方法调用栈"></a>4.Android O方法调用栈</h4><h5 id="4-1-Launcher请求AMS阶段"><a href="#4-1-Launcher请求AMS阶段" class="headerlink" title="4.1 Launcher请求AMS阶段"></a>4.1 Launcher请求AMS阶段</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-f1181020bb236b9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Launcher2Ams_startactivity.png"></p>
<h5 id="4-2-AMS到ApplicationThread阶段"><a href="#4-2-AMS到ApplicationThread阶段" class="headerlink" title="4.2 AMS到ApplicationThread阶段"></a>4.2 AMS到ApplicationThread阶段</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-3ee22e7d5386aebd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Ams2ApplicationThread.png"></p>
<h5 id="4-3-ApplicationThread到Activity阶段"><a href="#4-3-ApplicationThread到Activity阶段" class="headerlink" title="4.3 ApplicationThread到Activity阶段"></a>4.3 ApplicationThread到Activity阶段</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-4422a7056225da71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ApplicationThread2Activity.png"></p>
<h5 id="4-4-SDK-28之后，AMS启动Activity"><a href="#4-4-SDK-28之后，AMS启动Activity" class="headerlink" title="4.4 SDK 28之后，AMS启动Activity"></a>4.4 SDK 28之后，AMS启动Activity</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-cf5618e677794e8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ApplicationThread2ActivityAfter28.png"></p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title>重温ActivityManagerService</title>
    <url>/2021/10/10/%E9%87%8D%E6%B8%A9ActivityManagerService/</url>
    <content><![CDATA[<h4 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h4><p>ActivityManagerService是Android系统中一个特别重要的系统服务，也是我们上层APP打交道最多的系统服务之一。ActivityManagerService（以下简称AMS） 主要负责四大组件的启动、切换、调度以及应 用进程的管理和调度工作。所有的APP应用都需要与AMS打交道。</p>
<p>Activity Manager的组成主要分为以下几个部分：</p>
<ul>
<li>1.服务代理：由ActivityManagerProxy实现，用于与Server端提供的系统服务进行进程间通信</li>
<li>2.服务中枢：ActivityManagerNative继承自Binder并实现IActivityManager，它提供了服务接口和 Binder接口的相互转化功能，并在内部存储服务代理对像，并提供了getDefault方法返回服务代理</li>
<li>3.Client：由ActivityManager封装一部分服务接口供Client调用。ActivityManager内部通过调用 ActivityManagerNative的getDefault方法，可以得到一个ActivityManagerProxy对像的引用，进而通过该代理对像调用远程服务的方法</li>
<li>4.Server:由ActivityManagerService实现，提供Server端的系统服务</li>
</ul>
<h4 id="2-从不同角度看AMS"><a href="#2-从不同角度看AMS" class="headerlink" title="2.从不同角度看AMS"></a>2.从不同角度看AMS</h4><h5 id="2-1-从java角度看"><a href="#2-1-从java角度看" class="headerlink" title="2.1 从java角度看"></a>2.1 从java角度看</h5><p>从java角度来看，ams就是一个java对象，实现了Ibinder接口，所以它是一个用于进程之间通信的接口，这个对象初始化是在systemServer.java 的run()方法里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    mService = <span class="keyword">new</span> ActivityManagerService(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="2-2-AMS是一个服务"><a href="#2-2-AMS是一个服务" class="headerlink" title="2.2  AMS是一个服务"></a>2.2  AMS是一个服务</h5><p>ActivityManagerService从名字就可以看出，它是一个服务，用来管理Activity，而且是一个系统服 务，就是包管理服务，电池管理服务，震动管理服务等。</p>
<h5 id="2-3-AMS是一个Binder"><a href="#2-3-AMS是一个Binder" class="headerlink" title="2.3  AMS是一个Binder"></a>2.3  AMS是一个Binder</h5><p>ams实现了Ibinder接口，所以它是一个Binder，这意味着他不但可以用于进程间通信，还是一个 线程，因为一个Binder就是一个线程。 </p>
<p>如果我们启动一个hello World安卓用于程序，里面不另外启动其他线程，这个里面最少要启动4个线程：</p>
<ul>
<li>main线程，只是程序的主线程，也是日常用到的最多的线程，也叫UI线程，因为android的组 件是非线程安全的，所以只允许UI/MAIN线程来操作。 </li>
<li>GC线程，java有垃圾回收机制，每个java程序都有一个专门负责垃圾回收的线程。 </li>
<li>Binder1 就是我们的ApplicationThread，这个类实现了Ibinder接口，用于进程之间通信，具体来说，就是我们程序和AMS通信的工具 </li>
<li>Binder2 就是我们的ViewRootImpl.W对象，他也是实现了IBinder接口，就是用于我们的应用程序和 wms通信的工具。</li>
</ul>
<h4 id="3-AMS的启动过程"><a href="#3-AMS的启动过程" class="headerlink" title="3. AMS的启动过程"></a>3. AMS的启动过程</h4><p>AMS是在SystemServer中被添加的，  所以先到SystemServer中查看初始化。详细的SystemServer启动过程可以参考<a href="http://jackou.top/2021/09/27/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android系统启动流程分析</a>的第五章节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">	<span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize the system context.</span></span><br><span class="line">            createSystemContext();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the system service manager.</span></span><br><span class="line">            mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">            mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">            <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">            SystemServerInitThreadPool.get();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start services.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">            <span class="comment">// 启动引导服务中启动AMS</span></span><br><span class="line">            startBootstrapServices();</span><br><span class="line">            startCoreServices();</span><br><span class="line">            startOtherServices();</span><br><span class="line">            SystemServerInitThreadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop forever.</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Activity manager runs the show.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">        mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">                ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">        mActivityManagerService.setInstaller(installer);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Power manager needs to be started early because other services need it.</span></span><br><span class="line">        <span class="comment">// Native daemons may be watching for it to be registered so it must be ready</span></span><br><span class="line">        <span class="comment">// to handle incoming binder calls immediately (including being able to verify</span></span><br><span class="line">        <span class="comment">// the permissions for those calls).</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartPowerManager&quot;</span>);</span><br><span class="line">        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that the power manager has been started, let the activity manager</span></span><br><span class="line">        <span class="comment">// initialize power management features.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;InitPowerManagement&quot;</span>);</span><br><span class="line">    	<span class="comment">// 初始化AMS中的powerManager</span></span><br><span class="line">        mActivityManagerService.initPowerManagement();</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;SetSystemProcess&quot;</span>);</span><br><span class="line">		<span class="comment">//启动系统进程的应用实例</span></span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>AMS是通过SystemServiceManager.startService去启动的，参数是 ActivityManagerService.Lifecycle.class，  首先看看startService方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SystemService <span class="title">startService</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//此处的SystemService是生命周期</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serviceClass = (Class&lt;SystemService&gt;)Class.forName(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Starting &quot;</span> + className);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> String name = serviceClass.getName();</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Starting &quot;</span> + name);</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">&quot;StartService &quot;</span> + name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the service.</span></span><br><span class="line">            <span class="keyword">if</span> (!SystemService.class.isAssignableFrom(serviceClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to create &quot;</span> + name</span><br><span class="line">                        + <span class="string">&quot;: service must extend &quot;</span> + SystemService.class.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> T service;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">                service = constructor.newInstance(mContext);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">               ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startService(service);</span><br><span class="line">			<span class="comment">//此service是lifecycle</span></span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Register it.</span></span><br><span class="line">        <span class="comment">//加入到列表中</span></span><br><span class="line">        mServices.add(service);</span><br><span class="line">        <span class="comment">// Start it.</span></span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//lifecycle的onStart()方法</span></span><br><span class="line">			<span class="comment">//最终调到ActivityManagerService.start方法</span></span><br><span class="line">            service.onStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to start service &quot;</span> + service.getClass().getName()</span><br><span class="line">                    + <span class="string">&quot;: onStart threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        warnIfTooLong(System.currentTimeMillis() - time, service, <span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>startService方法很简单，是通过传进来的class然后反射创建对应的service服务。所以此处创建的是 Lifecycle的实例，  然后通过startService启动了AMS服务。</p>
<p>那我们再去看看ActivityManagerService.Lifecycle这个类的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(context);</span><br><span class="line">            mService = <span class="keyword">new</span> ActivityManagerService(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mService.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ActivityManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mService;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Lifecycle中单纯的创建AMS对象。接着看AMS构造方法中干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line">        LockGuard.installLock(<span class="keyword">this</span>, LockGuard.INDEX_ACTIVITY);</span><br><span class="line">        mInjector = <span class="keyword">new</span> Injector();</span><br><span class="line">        mContext = systemContext;</span><br><span class="line"></span><br><span class="line">        mFactoryTest = FactoryTest.getMode();</span><br><span class="line">    	<span class="comment">//获取当前的 ActivityThread，当前在SystemServer中，因此是SystemServer创建context的时候创建的ActivityThread。</span></span><br><span class="line">        mSystemThread = ActivityThread.currentActivityThread();</span><br><span class="line">        mUiContext = mSystemThread.getSystemUiContext();</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Memory class: &quot;</span> + ActivityManager.staticGetMemoryClass());</span><br><span class="line"></span><br><span class="line">        mPermissionReviewRequired = mContext.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_permissionReviewRequired);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 创建Handler线程，用来处理handler消息</span></span><br><span class="line">        mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">                THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        mHandler = <span class="keyword">new</span> MainHandler(mHandlerThread.getLooper());</span><br><span class="line">    	<span class="comment">//处理ui相关msg的Handler</span></span><br><span class="line">        mUiHandler = mInjector.getUiHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//管理AMS的一些常量，厂商定制系统就可能修改此处</span></span><br><span class="line">        mConstants = <span class="keyword">new</span> ActivityManagerConstants(<span class="keyword">this</span>, mHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* static; one-time init here */</span></span><br><span class="line">        <span class="keyword">if</span> (sKillHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sKillThread = <span class="keyword">new</span> ServiceThread(TAG + <span class="string">&quot;:kill&quot;</span>,</span><br><span class="line">                    THREAD_PRIORITY_BACKGROUND, <span class="keyword">true</span> <span class="comment">/* allowIo */</span>);</span><br><span class="line">            sKillThread.start();</span><br><span class="line">            sKillHandler = <span class="keyword">new</span> KillHandler(sKillThread.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 前台广播队列</span></span><br><span class="line">        mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">                <span class="string">&quot;foreground&quot;</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">    	<span class="comment">// 后台广播队列</span></span><br><span class="line">        mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">                <span class="string">&quot;background&quot;</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line">    	<span class="comment">// 系统会优先遍历发送前台广播</span></span><br><span class="line">        mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line">        mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//初始化管理Service的ActiveServices对象</span></span><br><span class="line">        mServices = <span class="keyword">new</span> ActiveServices(<span class="keyword">this</span>);</span><br><span class="line">        mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>);<span class="comment">//初始化Provider的管理者</span></span><br><span class="line">        mAppErrors = <span class="keyword">new</span> AppErrors(mUiContext, <span class="keyword">this</span>);<span class="comment">//初始化APP错误日志的打印器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move creation of battery stats service outside of activity manager service.</span></span><br><span class="line">    	<span class="comment">//创建电池统计服务，并输出到指定目录</span></span><br><span class="line">        File dataDir = Environment.getDataDirectory();</span><br><span class="line">        File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">&quot;system&quot;</span>);</span><br><span class="line">        systemDir.mkdirs();</span><br><span class="line">        mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemDir, mHandler);</span><br><span class="line">        mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">        mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">    	<span class="comment">//创建进程统计分析服务，追踪统计哪些进程有滥用或不良行为</span></span><br><span class="line">        mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></span><br><span class="line">                : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line">        mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mProcessStats = <span class="keyword">new</span> ProcessStatsService(<span class="keyword">this</span>, <span class="keyword">new</span> File(systemDir, <span class="string">&quot;procstats&quot;</span>));</span><br><span class="line"></span><br><span class="line">        mAppOpsService = mInjector.getAppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">&quot;appops.xml&quot;</span>), mHandler);</span><br><span class="line">        mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> IAppOpsCallback.Stub() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opChanged</span><span class="params">(<span class="keyword">int</span> op,<span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; </span><br><span class="line">                            	packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mAppOpsService.checkOperation(op, uid, packageName)</span><br><span class="line">                                    != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                                runInBackgroundDisabled(uid);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//加载Uri的授权文件</span></span><br><span class="line">        mGrantFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(systemDir, <span class="string">&quot;urigrants.xml&quot;</span>));</span><br><span class="line">		<span class="comment">//负责管理多用户</span></span><br><span class="line">        mUserController = <span class="keyword">new</span> UserController(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//vr功能的控制器</span></span><br><span class="line">        mVrController = <span class="keyword">new</span> VrController(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//初始化OpenGL版本号</span></span><br><span class="line">        GL_ES_VERSION = SystemProperties.getInt(<span class="string">&quot;ro.opengles.version&quot;</span>,</span><br><span class="line">            ConfigurationInfo.GL_ES_VERSION_UNDEFINED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SystemProperties.getInt(<span class="string">&quot;sys.use_fifo_ui&quot;</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            mUseFifoUiScheduling = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTrackingAssociations = <span class="string">&quot;1&quot;</span>.equals(SystemProperties.get(<span class="string">&quot;debug.track-associations&quot;</span>));</span><br><span class="line">        mTempConfig.setToDefaults();</span><br><span class="line">        mTempConfig.setLocales(LocaleList.getDefault());</span><br><span class="line">        mConfigurationSeq = mTempConfig.seq = <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//管理ActivityStack的重要类，这里面记录着activity状态信息，是AMS中的核心类</span></span><br><span class="line">        mStackSupervisor = createStackSupervisor();</span><br><span class="line">        mStackSupervisor.onConfigurationChanged(mTempConfig);</span><br><span class="line">    	<span class="comment">//根据当前可见的Activity类型，控制Keyguard遮挡，关闭和转换。Keyguard就是锁屏相关页面</span></span><br><span class="line">        mKeyguardController = mStackSupervisor.mKeyguardController;</span><br><span class="line">    	<span class="comment">// 管理APK的兼容性配置，解析/data/system/packages-compat.xml文件，该文件用于存储那些需要考虑屏幕尺寸的APK信息。</span></span><br><span class="line">        mCompatModePackages = <span class="keyword">new</span> CompatModePackages(<span class="keyword">this</span>, systemDir, mHandler);</span><br><span class="line">    	<span class="comment">// Intent防火墙，Google定义了一组规则，来过滤intent，如果触发了，则intent会 被系统丢弃，且不会告知发送者。</span></span><br><span class="line">        mIntentFirewall = <span class="keyword">new</span> IntentFirewall(<span class="keyword">new</span> IntentFirewallInterface(), mHandler);</span><br><span class="line">        mTaskChangeNotificationController =</span><br><span class="line">                <span class="keyword">new</span> TaskChangeNotificationController(<span class="keyword">this</span>, mStackSupervisor, mHandler);</span><br><span class="line">        <span class="comment">//这是activity启动的处理类，这里管理者activity启动中用到的intent信息和flag 标识，也和stack和task有重要的联系    </span></span><br><span class="line">    	mActivityStarter = <span class="keyword">new</span> ActivityStarter(<span class="keyword">this</span>, mStackSupervisor);</span><br><span class="line">        mRecentTasks = <span class="keyword">new</span> RecentTasks(<span class="keyword">this</span>, mStackSupervisor);</span><br><span class="line">		<span class="comment">//启动一个线程专门跟进cpu当前状态信息，AMS对当前cpu状态了如指掌，可以更加高效的安排其他工作</span></span><br><span class="line">        mProcessCpuThread = <span class="keyword">new</span> Thread(<span class="string">&quot;CpuTracker&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mProcessCpuTracker) &#123;</span><br><span class="line">                    mProcessCpuInitLatch.countDown();</span><br><span class="line">                    mProcessCpuTracker.init();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                                <span class="keyword">long</span> nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">                                <span class="keyword">long</span> nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">                                <span class="comment">//Slog.i(TAG, &quot;Cpu delay=&quot; + nextCpuDelay</span></span><br><span class="line">                                <span class="comment">//        + &quot;, write delay=&quot; + nextWriteDelay);</span></span><br><span class="line">                                <span class="keyword">if</span> (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                                    nextCpuDelay = nextWriteDelay;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (nextCpuDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    mProcessCpuMutexFree.set(<span class="keyword">true</span>);</span><br><span class="line">                                    <span class="keyword">this</span>.wait(nextCpuDelay);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        updateCpuStatsNow();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Slog.e(TAG, <span class="string">&quot;Unexpected exception collecting process stats&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//看门狗，监听进程。这个类每分钟调用一次监视器。如果进程没有任何返回就杀掉</span></span><br><span class="line">        Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">        Watchdog.getInstance().addThread(mHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>创建完AMS对象之后，就会通过Lifecycle的start()方法调用到AMS的start()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//移除所有进程组</span></span><br><span class="line">        removeAllProcessGroups();</span><br><span class="line">        mProcessCpuThread.start();</span><br><span class="line"></span><br><span class="line">        mBatteryStatsService.publish(mContext);</span><br><span class="line">        mAppOpsService.publish(mContext);</span><br><span class="line">        Slog.d(<span class="string">&quot;AppOps&quot;</span>, <span class="string">&quot;AppOpsService published&quot;</span>);</span><br><span class="line">        LocalServices.addService(ActivityManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">        <span class="comment">// Wait for the synchronized block started in mProcessCpuThread,</span></span><br><span class="line">        <span class="comment">// so that any other acccess to mProcessCpuTracker from main thread</span></span><br><span class="line">        <span class="comment">// will be blocked during mProcessCpuTracker initialization.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待mProcessCpuThread完成初始化后，释放锁，初始化期间禁止访问</span></span><br><span class="line">            mProcessCpuInitLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Interrupted wait during start&quot;</span>, e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Interrupted wait during start&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上AMS构造好之后，SystetmServer就会调用AMS的setSystemProcess()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">            ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;meminfo&quot;</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>));</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;gfxinfo&quot;</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;dbinfo&quot;</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">                ServiceManager.addService(<span class="string">&quot;cpuinfo&quot;</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;permission&quot;</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">            ServiceManager.addService(<span class="string">&quot;processinfo&quot;</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 查询Android的应用信息</span></span><br><span class="line">            ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                    <span class="string">&quot;android&quot;</span>, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);</span><br><span class="line">            mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">                app.persistent = <span class="keyword">true</span>;</span><br><span class="line">                app.pid = MY_PID;</span><br><span class="line">                app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">                app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">                <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                    mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">                &#125;</span><br><span class="line">                updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                updateOomAdjLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Unable to find android system package&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>setSystemProcess()中主要完成如下三件事情：</p>
<ul>
<li><p>将ActivityManagerService注册到ServiceManager中，其次将几个与系统性能调试相关 的服务注册到ServiceManager。</p>
</li>
<li><p>查询并处理ApplicationInfo。首先调用PackageManagerService的接口，查询包名为android的应用程 序的ApplicationInfo信息，对应于framework-res.apk。然后以该信息为参数调用ActivityThread上的 installSystemApplicationInfo方法。</p>
</li>
<li><p>创建并处理ProcessRecord。调用ActivityManagerService上的newProcessRecordLocked，创建一个 ProcessRecord类型的对象，并保存该对象的信息</p>
</li>
</ul>
<p>至此，AMS就启动完成了。</p>
<h4 id="4-与AMS相关重要类说明"><a href="#4-与AMS相关重要类说明" class="headerlink" title="4. 与AMS相关重要类说明"></a>4. 与AMS相关重要类说明</h4><h5 id="4-1-ProcessRecord-数据结构"><a href="#4-1-ProcessRecord-数据结构" class="headerlink" title="4.1 ProcessRecord 数据结构"></a>4.1 ProcessRecord 数据结构</h5><p>4.1.1 第一类数据：描述身份的数据</p>
<ul>
<li>1.ApplicationInfo info：AndroidManifest.xml中定义的Application信息 </li>
<li>2.boolean isolated：是不是isolated进程 </li>
<li>3.int uid：进程uid </li>
<li>4.int userId：这个是android做的多用户系统id，就像windows可以登录很多用户一样，android 也希望可以实现类似的多用户 </li>
<li>5.String processName：进程名字，默认情况下是包名 </li>
<li>6.UidRecord uidRecord：记录已经使用的uid </li>
<li>7.IApplicationThread thread：这个很重要，它是ApplicationThread的客户端，AMS就是通过这个对象给apk进程发送异步消息的（管理四大组件的消息），所以只有这个对象不为空的情况下， 才代表apk进程可是使用了 </li>
<li>8.int pid：进程的pid </li>
<li>9.String procStatFile：proc目录下每一个进程都有一个以pid命名的目录文件，这个目录下记载着进程的详细信息，这个目录及目录下的文件是内核创建的， proc是内核文件系统，proc就是 process的缩写，设计的目的就是导出进程内核信息 </li>
<li>10.int[] gids：gid组 </li>
<li>11.CompatibilityInfo compat : 兼容性信息 </li>
<li>12.String requiredAbi : abi信息 </li>
<li>13.String instructionSet : 指令集信息’</li>
</ul>
<p>4.1.2 第二类数据：描述进程中组件的数据</p>
<ul>
<li><p>1.pkgList：进程中运行的包 </p>
</li>
<li><p>2.ArraySet pkgDeps：进程运行依赖的包 </p>
</li>
<li><p>3.ArrayList activities：进程启动的所有的activity组件记录表 </p>
</li>
<li><p>4.ArraySet services：进程启动的所有的service组件记录表 </p>
</li>
<li><p>5.ArraySet executingServices：正在运行的服务。</p>
<p>正在运行（executing）是怎么定义的？首先需要明确的是系统是怎么控制组件的？发送消息给apk进程，apk进程处理消息，上报消息完成，这被定义为一个完整的执行过程，因此正在执行（executing）被定义为发送消息到上报完成这段时间。</p>
</li>
<li><p>6.ArraySet connections：绑定service的客户端记录表 </p>
</li>
<li><p>7.ArraySet receivers：广播接收器的记录表 </p>
</li>
<li><p>8.ContentProviderRecord pubProviders：pub是publish（发布）的意思，ContentProvider需要安装然后把自己发布到系统（AMS）中后才能使用，安装指的是apk进程加载ContentProvider 子类、初始化、创建数据库等过程，发布是将ContentProvider的binder客户端注册到AMS中 。</p>
</li>
<li><p>9.ArrayList conProviders：使用ContentProvider的客户端记录表 </p>
</li>
<li><p>10.BroadcastRecord curReceiver：当前进程正在执行的广播</p>
</li>
</ul>
<p>4.1.3 第三类数据：描述进程状态的数据</p>
<ul>
<li>1.int maxAdj：进程的adj上限（adjustment） </li>
<li>2.int curRawAdj：当前正在计算的adj，这个值有可能大于maxAdj </li>
<li>3.int setRawAdj：上次计算的curRawAdj设置到lowmemorykiller系统后的adj </li>
<li>4.int curAdj：当前正在计算的adj，这是curRawAdj被maxAdj削平的值 </li>
<li>5.int setAdj：上次计算的curAdj设置到lowmemorykiller系统后的adj </li>
<li>6.int verifiedAdj：setAdj校验后的值 </li>
<li>7.int curSchedGroup：正在计算的调度组 </li>
<li>8.int setSchedGroup：保存上次计算的调度组 </li>
<li>9.int curProcState：正在计算的进程状态 </li>
<li>10.int repProcState：发送给apk进程的状态 </li>
<li>11.int setProcState：保存上次计算的进程状态 </li>
<li>12.int pssProcState：pss进程状态 </li>
<li>13.ProcessState baseProcessTracker：进程状态监测器 </li>
<li>14.int adjSeq：计算adj的序列数 </li>
<li>15.int lruSeq：lru序列数 </li>
<li>16.IBinder forcingToForeground:强制将进程的状态设置为前台运行的IBinder，IBinder代表的是组件的ID，这个是整个android系统唯一</li>
</ul>
<p>4.1.4 第四类数据：和pss相关的数据</p>
<blockquote>
<p>VSS- Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）<br>RSS- Resident Set Size 实际使用物理内存（包含共享库占用的内存）<br>PSS- Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）<br>USS- Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） </p>
<p>一般来说内存占用大小有如下规律：VSS &gt;= RSS &gt;= PSS &gt;= USS</p>
</blockquote>
<ul>
<li>1.long initialIdlePss：初始化pss </li>
<li>2.long lastPss：上次pss </li>
<li>3.long lastSwapPss：上次SwapPss数据 </li>
<li>4.long lastCachedPss：上次CachedPss数据 </li>
<li>5.long lastCachedSwapPss：上次CachedSwapPss数据</li>
</ul>
<p>4.1.5 第五类数据：和时间相关的数据</p>
<ul>
<li>1.long lastActivityTime：上次使用时间 </li>
<li>2.long lastPssTime：上次计算pss的时间 </li>
<li>3.long nextPssTime：下次计算pss的时间 </li>
<li>4.long lastStateTime：上次设置进程状态的时间 </li>
<li>5.long lastWakeTime：持有wakelock的时长 </li>
<li>6.long lastCpuTime：上次计算占用cpu的时长 </li>
<li>7.long curCpuTime：当前最新占用cpu的时长 </li>
<li>8.long lastRequestedGc：上次发送gc命令给apk进程的时间 </li>
<li>9.long lastLowMemory：上次发送低内存消息给apk进程的时间 </li>
<li>10.long lastProviderTime：上次进程中ContentProvider被使用的时间 </li>
<li>11.long interactionEventTime：上次发送交互时间时间 </li>
<li>12.long fgInteractionTime：变成前台的时间</li>
</ul>
<p>4.1.6 第六类数据：crash和anr相关的数据</p>
<ul>
<li>1.IBinder.DeathRecipient deathRecipient：apk进程退出运行的话，会触发这个对象的 binderDied()方法，来回收系统资源 </li>
<li>2.boolean crashing：进程已经crash </li>
<li>3.Dialog crashDialog：crash对话框 </li>
<li>4.boolean forceCrashReport：强制crash对话框显示 </li>
<li>5.boolean notResponding：是否处于anr状态 </li>
<li>6.Dialog anrDialog：anr显示对话框 </li>
<li>7.Runnable crashHandler：crash回调 </li>
<li>8.ActivityManager.ProcessErrorStateInfo crashingReport:crash报告的进程状态 </li>
<li>9.ActivityManager.ProcessErrorStateInfo notRespondingReport:anr报告的进程状态 </li>
<li>10.String waitingToKill:后台进程被kill原因 </li>
<li>11.ComponentName errorReportReceiver:接收error信息的组件</li>
</ul>
<p>4.1.7 第七类数据：和instrumentation相关的数据</p>
<p>instrumentation 也可以说是apk的一个组件，如果我们提供的话，系统会默认使用 Instrumentation.java类，按照我们一般的理解，UI 线程控制activity的生命周期，是直接调用Activity 类的方法，实际是这样子的，UI线程调用的是instrumentation的方法，由它在调用Activity涉及生命周期的方法，所有如果我们覆写了instrumentation的这些方法，就可以了解所有的Activity的生命周期了</p>
<ul>
<li>1.ComponentName instrumentationClass：AndroidManifest.xml中定义的instrumentation信 息 </li>
<li>2.ApplicationInfo instrumentationInfo：instrumentation应用信息 </li>
<li>3.String instrumentationProfileFile：instrumentation配置文件 </li>
<li>4.IInstrumentationWatcher instrumentationWatcher：instrumentation监测器 </li>
<li>5.IUiAutomationConnection instrumentationUiAutomationConnection：UiAutomation连接器 </li>
<li>6.ComponentName instrumentationResultClass：返回结果组件</li>
</ul>
<p>4.1.8 第八类数据：电源信息和调试信息</p>
<ul>
<li>1.BatteryStatsImpl mBatteryStats:电量信息 </li>
<li>2.BatteryStatsImpl.Uid.Proc curProcBatteryStats：当前进程电量信息 </li>
<li>3.boolean debugging:处于调试中 </li>
<li>4.boolean waitedForDebugger:等待调试 </li>
<li>5.Dialog waitDialog:等待对话框 </li>
<li>6.String adjType:adj类型（或者说标示） </li>
<li>7.int adjTypeCode:adj类型码（也是一种标示） </li>
<li>8.Object adjSource:改变adj的组件记录表 </li>
<li>9.int adjSourceProcState:影响adj的进程状态 </li>
<li>10.Object adjTarget：改变adj的组件 </li>
<li>11.String shortStringName：进程记录表的字符串显示 </li>
<li>12.String stringName：进程记录表的字符串显示</li>
</ul>
<p>4.1.9 第九类数据：状态boolean值分类</p>
<ul>
<li><p>1.进程声明周期相关的</p>
<ul>
<li>a.boolean starting:进程正在启动 </li>
<li>b.boolean removed:进程系统资源已经清理 </li>
<li>c.boolean killedByAm:进程被AMS主动kill掉 </li>
<li>d.boolean killed:进程被kill掉了 </li>
<li>e:boolean persistent:常驻内存进程</li>
</ul>
</li>
<li><p>2.组件状态影响进程行为的</p>
<ul>
<li>a.boolean empty:空进程，不含有任何组件的进程 </li>
<li>b.boolean cached:缓存进程 </li>
<li>c.boolean bad:60s内连续crash两次的进程被定义为bad进程 </li>
<li>d.boolean hasClientActivities:进程有Activity绑定其他Service </li>
<li>e.boolean hasStartedServices:进程中包含启动了的Service </li>
<li>f.boolean foregroundServices:进程中包含前台运行的Service </li>
<li>g.boolean foregroundActivities:进程中包含前台运行的Activity </li>
<li>h.boolean repForegroundActivities: 是否上次上报了前台Activity</li>
<li>i.boolean systemNoUi:系统进程，没有显示UI </li>
<li>j.boolean hasShownUi:重进程启动开始，是否已经显示UI </li>
<li>k.boolean pendingUiClean: 是否希望清楚UI资源</li>
<li>l.boolean hasAboveClient:进程中有组件使用BIND_ABOVE_CLIENT标志绑定其他Service </li>
<li>m.boolean treatLikeActivity:进程中有组件使用BIND_TREAT_LIKE_ACTIVITY标志绑定其他 Service </li>
<li>n.boolean execServicesFg:前台执行Service </li>
<li>o.boolean setIsForeground:设置运行前台UI</li>
</ul>
</li>
</ul>
<ul>
<li>3.其他 <ul>
<li>a. boolean serviceb:进程存在service B list中 </li>
<li>b.boolean serviceHighRam:由于内存原因，进程强制存在service B list中 </li>
<li>c.boolean notCachedSinceIdle:进程自从上次空闲，是否属于缓存进程 </li>
<li>d.boolean procStateChanged:进程状态改变 </li>
<li>e.boolean reportedInteraction:是否报告交互事件 </li>
<li>f.boolean unlocked:解锁状态下进程启动 </li>
<li>g.boolean usingWrapper:zygote是否使用了wrapper启动apk进程 </li>
<li>h.boolean reportLowMemory:报告低内存 </li>
<li>i.boolean inFullBackup:进程中存在backup组件在运行 </li>
<li>j.boolean whitelistManager:和电源管理相关</li>
</ul>
</li>
</ul>
<h5 id="4-2-ProcessRecord容器"><a href="#4-2-ProcessRecord容器" class="headerlink" title="4.2 ProcessRecord容器"></a>4.2 ProcessRecord容器</h5><p>永久性容器 </p>
<p>1.mProcessNames：根据进程名字检索进程记录表 </p>
<p>2.mPidsSelfLocked：根据进程pid检索进程记录表 </p>
<p>3.mLruProcesses：lru进程记录表容器，这个容器使用的是最近最少使用算法对进程记录表进行排序，越是处于上层的越是最近使用的，对于系统来说就是最重要的，在内存吃紧回收进程时，越不容易被回收，实现起来也很简单 </p>
<p>临时性容器 </p>
<p>1.mPersistentStartingProcesses：常驻内存进程启动时容器 </p>
<p>2.mProcessesOnHold：进程启动挂起容器 </p>
<p>3.mProcessesToGc：将要执行gc回收的进程容器 </p>
<p>4.mPendingPssProcesses：将要计算Pss数据的进程容器 </p>
<p>一个特别的容器 </p>
<p>1.mRemovedProcesses:从名字上的意思是已经移除的进程，那么什么是已经移除的进程？移除的 进程为什么还需要保存？</p>
<p>如果进程不重启的话，pid会设置为0，就代表无效。</p>
<h5 id="4-3-与Activity管理有关的数据结构"><a href="#4-3-与Activity管理有关的数据结构" class="headerlink" title="4.3 与Activity管理有关的数据结构"></a>4.3 与Activity管理有关的数据结构</h5><h5 id="4-3-1-ActivityRecord"><a href="#4-3-1-ActivityRecord" class="headerlink" title="4.3.1 ActivityRecord"></a>4.3.1 ActivityRecord</h5><p>ActivityRecord，源码中的注释介绍：An entry in the history stack, representing an activity. </p>
<p>翻译：历史栈中的一个条目，代表一个activity。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityRecord</span> <span class="keyword">extends</span> <span class="title">WindowToken</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// ActivityRecord所在的TaskRecord</span></span><br><span class="line">	<span class="keyword">private</span> TaskRecord task; </span><br><span class="line">    <span class="comment">// 该Activity由哪个栈管理者管理</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStackSupervisor mStackSupervisor;</span><br><span class="line">    </span><br><span class="line">    ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller,</span><br><span class="line">            <span class="keyword">int</span> _launchedFromPid, <span class="keyword">int</span> _launchedFromUid, String _launchedFromPackage,</span><br><span class="line">            <span class="meta">@Nullable</span> String _launchedFromFeature, Intent _intent, String _resolvedType,</span><br><span class="line">            ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,</span><br><span class="line">            String _resultWho, <span class="keyword">int</span> _reqCode, <span class="keyword">boolean</span> _componentSpecified,</span><br><span class="line">            <span class="keyword">boolean</span> _rootVoiceInteraction, ActivityStackSupervisor supervisor,</span><br><span class="line">            ActivityOptions options, ActivityRecord sourceRecord) &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从ActivityRecord的构造方法可以看出，要在AMS中构建一个ActivityRecord, 需要将大量信息保存在ActivityRecord中，AMS在管理各个Activity的时候，就容易知道该ActivityRecord属于哪些进程，由哪些资源，如何启动。</p>
<p>ActivityRecord中存在着大量的成员变量，包含了一个Activity的所有信息。 ActivityRecord中的成员变量task表示其所在的TaskRecord，由此可以看出：<strong>ActivityRecord与 TaskRecord建立了联系。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\services\core\java\com\android\server\am\ActivityStarter.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,String resolvedType, ......,TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 在通过ActivityStarter启动Activity的时候创建ActivityRecord</span></span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),  resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>, 	mSupervisor, container, options, sourceRecord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-3-2-TaskRecord"><a href="#4-3-2-TaskRecord" class="headerlink" title="4.3.2 TaskRecord"></a>4.3.2 TaskRecord</h5><p>TaskRecord，内部维护一个 ArrayList 用来保存ActivityRecord。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\services\core\java\com\android\server\am\TaskRecord.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRecord</span> <span class="keyword">extends</span> <span class="title">ConfigurationContainer</span> <span class="keyword">implements</span> <span class="title">TaskWindowContainerListener</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> taskId; <span class="comment">//任务ID</span></span><br><span class="line">	<span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; mActivities; <span class="comment">//使用一个ArrayList来保存所有的ActivityRecord</span></span><br><span class="line">	<span class="keyword">private</span> ActivityStack mStack; <span class="comment">//TaskRecord所在的ActivityStack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加Activity到顶部</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addActivityToTop</span><span class="params">(com.android.server.am.ActivityRecord r)</span> </span>&#123;</span><br><span class="line">		addActivityAtIndex(mActivities.size(), r);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加Activity到指定的索引位置</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addActivityAtIndex</span><span class="params">(<span class="keyword">int</span> index, ActivityRecord r)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">		r.setTask(<span class="keyword">this</span>);<span class="comment">//为ActivityRecord设置TaskRecord，就是这里建立的联系</span></span><br><span class="line">		index = Math.min(size, index);</span><br><span class="line">		mActivities.add(index, r);<span class="comment">//添加到mActivities</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到TaskRecord中使用了一个ArrayList来保存所有的ActivityRecord。 同样，TaskRecord中的mStack表示其所在的ActivityStack。 startActivity()时也会创建一个TaskRecord</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \frameworks\base\services\core\java\com\android\server\am\ActivityStarter.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">setTaskFromReuseOrCreateNewTask</span><span class="params">(TaskRecord taskToAffiliate, <span class="keyword">int</span> preferredLaunchStackId, ActivityStack topStack)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个createTaskRecord，实际上是调用ActivityStack里面的createTaskRecord（）方法</span></span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = mTargetStack.createTaskRecord(</span><br><span class="line">                    mSupervisor.getNextTaskIdForUserLocked(mStartActivity.userId),</span><br><span class="line">                    mNewTaskInfo != <span class="keyword">null</span> ? mNewTaskInfo : mStartActivity.info,</span><br><span class="line">                    mNewTaskIntent != <span class="keyword">null</span> ? mNewTaskIntent : mIntent, mVoiceSession,</span><br><span class="line">                    mVoiceInteractor, !mLaunchTaskBehind <span class="comment">/* toTop */</span>, mStartActivity.mActivityType);</span><br><span class="line">            addOrReparentStartingActivity(task, <span class="string">&quot;setTaskFromReuseOrCreateNewTask - mReuseTask&quot;</span>);</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-3-3-ActivityStack"><a href="#4-3-3-ActivityStack" class="headerlink" title="4.3.3 ActivityStack"></a>4.3.3 ActivityStack</h5><p>ActivityStack,内部维护了一个 ArrayList ，用来管理TaskRecord。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityStack</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StackWindowController</span>&gt; <span class="keyword">extends</span> <span class="title">ConfigurationContainer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">StackWindowListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用一个ArrayList来保存TaskRecord</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;TaskRecord&gt; mTaskHistory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有一个ActivityStackSupervisor，所有的运行中的ActivityStacks都通过它来进行管</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ActivityStackSupervisor mStackSupervisor;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TaskRecord <span class="title">createTaskRecord</span><span class="params">(<span class="keyword">int</span> taskId, ActivityInfo info, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> toTop, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个task</span></span><br><span class="line">        TaskRecord task = <span class="keyword">new</span> TaskRecord(mService, taskId, info, intent, voiceSession,</span><br><span class="line">                voiceInteractor, type);</span><br><span class="line">        <span class="comment">//将task添加到ActivityStack中去</span></span><br><span class="line">        addTask(task, toTop, <span class="string">&quot;createTaskRecord&quot;</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTask</span><span class="params">(<span class="keyword">final</span> TaskRecord task, <span class="keyword">int</span> position, <span class="keyword">boolean</span> schedulePictureInPictureModeChange, String reason)</span> </span>&#123;</span><br><span class="line">        mTaskHistory.remove(task);<span class="comment">//若存在，先移除</span></span><br><span class="line">        position = getAdjustedPositionForTask(task, position, <span class="keyword">null</span> <span class="comment">/* starting */</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> toTop = position &gt;= mTaskHistory.size();</span><br><span class="line">        <span class="keyword">final</span> ActivityStack prevStack = preAddTask(task, reason, toTop);</span><br><span class="line"></span><br><span class="line">        mTaskHistory.add(position, task);<span class="comment">//添加task到mTaskHistory</span></span><br><span class="line">        task.setStack(<span class="keyword">this</span>);<span class="comment">//为TaskRecord设置ActivityStack,关联TaskRecord和ActivityStack</span></span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到ActivityStack使用了一个ArrayList来保存TaskRecord。 另外，ActivityStack中还持有ActivityStackSupervisor对象，这个是用来管理ActivityStacks的。 ActivityStack是由ActivityStackSupervisor来创建的，实际ActivityStackSupervisor就是用来管理 ActivityStack的。</p>
<h5 id="4-3-4-ActivityStackSupervisor"><a href="#4-3-4-ActivityStackSupervisor" class="headerlink" title="4.3.4 ActivityStackSupervisor"></a>4.3.4 ActivityStackSupervisor</h5><p>ActivityStackSupervisor，顾名思义，就是用来管理ActivityStack的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityStackSupervisor</span> <span class="keyword">extends</span> <span class="title">ConfigurationContainer</span> <span class="keyword">implements</span> <span class="title">DisplayListener</span> </span>&#123;</span><br><span class="line">    ActivityStack mHomeStack;<span class="comment">//管理的是Launcher相关的任务</span></span><br><span class="line">    </span><br><span class="line">    ActivityStack mFocusedStack;<span class="comment">// 接收用户输入或者即将启动的Activity</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建ActivityStack</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">createStack</span><span class="params">(<span class="keyword">int</span> stackId, <span class="keyword">boolean</span> onTop)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (stackId) &#123;</span><br><span class="line">                <span class="keyword">case</span> PINNED_STACK_ID:</span><br><span class="line">                    <span class="comment">//PinnedActivityStack是ActivityStack的子类</span></span><br><span class="line">                    <span class="keyword">new</span> PinnedActivityStack(<span class="keyword">this</span>, mRecentTasks, onTop);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//创建一个ActivityStack</span></span><br><span class="line">                    <span class="keyword">new</span> ActivityStack(<span class="keyword">this</span>, mRecentTasks, onTop);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityStackSupervisor内部有两个不同的ActivityStack对象：mHomeStack、mFocusedStack，用来 管理不同的任务。 ActivityStackSupervisor内部包含了创建ActivityStack对象的方法。 AMS初始化时会创建一个ActivityStackSupervisor对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7bd84e74f33a7419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ASS_AS关系.png"></p>
<p><strong>参考资源：</strong></p>
<p>《Android系统源代码情景分析(第三版)》–罗升阳</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title>卡顿监控工具使用说明</title>
    <url>/2021/09/27/%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h4 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1.工具介绍"></a>1.工具介绍</h4><p>当前监控工具可以用于量产监控UI和应用卡顿，但是该工具还没有和数据埋点结合，量产环境下监控暂时没有意义。因此建议各位FO在开发阶段集成该工具，在开发阶段就知道自己应用是否出现卡顿和丢帧，提早发现问题，处理问题。</p>
<p>该工具包括两个部分：</p>
<ul>
<li>UiBlockMonitor :主要监控界面是否有丢帧</li>
<li>AppBlockMonitor :主要监控应用主线程处理事件是否超时，超时会打印堆栈。</li>
</ul>
<h4 id="2-UiBlockMonitor-使用介绍"><a href="#2-UiBlockMonitor-使用介绍" class="headerlink" title="2.UiBlockMonitor 使用介绍"></a>2.UiBlockMonitor 使用介绍</h4><p>该工具主要基于Choreographer的帧回调接口实现的。当收到垂直同步信号，开始绘制的时候就会回调doFrame()接口，在回调中监控到两次回调间隔时间大于16.7ms就说明有丢帧，就会输出一次日志通知开发检查自己界面各个view的绘制时间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-7b58e308c7d22d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丢帧日志.png"></p>
<p><strong>说明：</strong>如果偶尔发现有该日志输出，可以暂时不优化。如果在界面切换的时候或者一直在输出该丢帧log，就需要查看自己代码是否在三大绘制流程中有做过多耗时操作。</p>
<h5 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始监控丢帧</span></span><br><span class="line">UiBlockMonitor.getInstance().start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束监控丢帧</span></span><br><span class="line">UiBlockMonitor.getInstance().stop();</span><br></pre></td></tr></table></figure>


<h4 id="3-AppBlockMonitor"><a href="#3-AppBlockMonitor" class="headerlink" title="3.AppBlockMonitor"></a>3.AppBlockMonitor</h4><p>该工具主要基于Handler消息处理机制，监控消息处理大于阈值的事件。默认是3000ms,可以设置该时间，建议不要操作3000ms, 如果设置成5000ms，可能就无法帮助你监控ANR事件或者应用卡顿了。</p>
<p>如果出现卡顿之后，会报出堆栈日志，此时就需要FO检查代码问题了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-ab7e9166242a8938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用卡顿.png"></p>
<h5 id="3-1-使用方法"><a href="#3-1-使用方法" class="headerlink" title="3.1 使用方法"></a>3.1 使用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppBlockMonitor appMonitor = AppBlockMonitor.getInstance();</span><br><span class="line">appMonitor.setBlockThresholdMillis(<span class="number">3000</span>); <span class="comment">// 可以不填，默认3000ms</span></span><br><span class="line">appMonitor.install();</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>卡顿监控工具</tag>
      </tags>
  </entry>
  <entry>
    <title>优化第一版启动耗时分析</title>
    <url>/2021/10/13/GOS%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%80%E7%89%88%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>说明：</strong></p>
<p>Launcher还没有优化，因此此报告只分析从init启动开始到启动launcher阶段。</p>
<p><strong>加粗字体</strong>是时间戳</p>
<blockquote>
<p>log日志</p>
</blockquote>
<h3 id="Android启动阶段耗时分析"><a href="#Android启动阶段耗时分析" class="headerlink" title="Android启动阶段耗时分析"></a>Android启动阶段耗时分析</h3><h4 id="1-挂载分区-算system和vendor-img的Hash"><a href="#1-挂载分区-算system和vendor-img的Hash" class="headerlink" title="1.挂载分区+算system和vendor img的Hash"></a>1.挂载分区+算system和vendor img的Hash</h4><p>耗时1120ms，AVB相关，方法SetInitAvbVersionInRecovery();</p>
<blockquote>
<p>88 1970/01/01 08:00:07.379247 <strong>0.0034</strong> 133 ECU1 KERN KERN 340 log info verbose 1 Mountpoint-cache hash table entries: 32768 (order: 6, 262144 bytes)<br>89 1970/01/01 08:00:07.379252 <strong>1.1298</strong> 134 ECU1 KERN KERN 340 log warn verbose 1 NOHZ: local_softirq_pending 02<br>613 1970/01/01 08:00:07.383940 <strong>2.7007</strong> 146 ECU1 KERN KERN 340 log info verbose 1 init: init first stage started!</p>
</blockquote>
<h4 id="2-加载Selinux"><a href="#2-加载Selinux" class="headerlink" title="2.加载Selinux"></a>2.加载Selinux</h4><p>耗时170ms，selinux_initialize(true);</p>
<blockquote>
<p>620 1970/01/01 08:00:07.383976 <strong>2.7400</strong> 153 ECU1 KERN KERN 340 log info verbose 1 init: Loading SELinux policy<br>647 1970/01/01 08:00:07.385484 <strong>2.9100</strong> 180 ECU1 KERN KERN 340 log info verbose 1 init: init second stage started!</p>
</blockquote>
<h4 id="3-待确认vendor-init是什么进程"><a href="#3-待确认vendor-init是什么进程" class="headerlink" title="3.待确认vendor_init是什么进程"></a>3.待确认vendor_init是什么进程</h4><p>消耗200ms</p>
<blockquote>
<p>656 1970/01/01 08:00:07.385530 <strong>2.9613</strong> 189 ECU1 KERN KERN 340 log info verbose 1 init: Forked subcontext for ‘u:r:vendor_init:s0’ with pid 224<br>657 1970/01/01 08:00:07.385535 <strong>3.1647</strong> 190 ECU1 KERN KERN 340 log info verbose 1 ueventd: ueventd started!</p>
</blockquote>
<h4 id="4-ueventd启动"><a href="#4-ueventd启动" class="headerlink" title="4.ueventd启动"></a>4.ueventd启动</h4><blockquote>
<p>657 1970/01/01 08:00:07.385535 <strong>3.1647</strong> 190 ECU1 KERN KERN 340 log info verbose 1 ueventd: ueventd started!<br>674 1970/01/01 08:00:07.385628 <strong>3.3700</strong> 207 ECU1 KERN KERN 340 log info verbose 1 ueventd: Coldboot took 0.168 seconds</p>
</blockquote>
<h4 id="5-未知"><a href="#5-未知" class="headerlink" title="5.未知"></a>5.未知</h4><p>消耗200ms</p>
<blockquote>
<p>704 1970/01/01 08:00:07.386071 <strong>4.0833</strong> 237 ECU1 KERN KERN 340 log info verbose 1 msm-dwc3 a600000.ssusb: DWC3 in low power mode SUBSYSTEM=platform DEVICE=+platform:a600000.ssusb<br>705 1970/01/01 08:00:07.386077 <strong>4.2547</strong> 238 ECU1 KERN KERN 340 log warn verbose 1 sa8155-asoc-snd soc:qcom,msm-audio-apr:qcom,q6core-audio:sound-adp-star: ASoC: no DMI vendor name! SUBSYSTEM=platform DEVICE=+platform:soc:qcom,msm-audio-apr:qcom,q6core-audio:sound-adp-star</p>
</blockquote>
<h4 id="6-挂载usb设备相关"><a href="#6-挂载usb设备相关" class="headerlink" title="6.挂载usb设备相关"></a>6.挂载usb设备相关</h4><p>消耗370ms</p>
<blockquote>
<p>708 1970/01/01 08:00:07.386095 <strong>4.2781</strong> 241 ECU1 KERN KERN 340 log info verbose 1 modprobe (236) used greatest stack depth: 11696 bytes left<br>709 1970/01/01 08:00:07.386100 <strong>4.6423</strong> 242 ECU1 KERN KERN 340 log info verbose 1 scsi 0:0:0:0: Direct-Access USB SanDisk 3.2Gen1 1.00 PQ: 0 ANSI: 6 SUBSYSTEM=scsi DEVICE=+scsi:0:0:0:0</p>
</blockquote>
<h4 id="7-创建sda节点"><a href="#7-创建sda节点" class="headerlink" title="7.创建sda节点"></a>7.创建sda节点</h4><p>耗时130ms</p>
<blockquote>
<p>712 1970/01/01 08:00:07.386276 <strong>4.6739</strong> 245 ECU1 KERN KERN 340 log info verbose 1 sda: sda1<br>713 1970/01/01 08:00:07.386281 <strong>4.8029</strong> 246 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (vdd34): recovery complete</p>
</blockquote>
<h4 id="8-挂载data"><a href="#8-挂载data" class="headerlink" title="8.挂载data"></a>8.挂载data</h4><p>耗时870ms</p>
<blockquote>
<p>714 1970/01/01 08:00:07.386286 <strong>4.8058</strong> 247 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (<strong>vdd34</strong>): mounted filesystem with ordered data mode. Opts: errors=remount-ro,nomblk_io_submit<br>715 1970/01/01 08:00:07.386291 <strong>5.6742</strong> 248 ECU1 KERN KERN 340 log info verbose 1 e2fsck: e2fsck 1.43.3 (04-Sep-2016)\x0a</p>
</blockquote>
<h4 id="9-挂载iflytek"><a href="#9-挂载iflytek" class="headerlink" title="9.挂载iflytek"></a>9.挂载iflytek</h4><p>消耗200ms</p>
<blockquote>
<p>733 1970/01/01 08:00:07.386388 <strong>5.9442</strong> 10 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (<strong>vdd25</strong>): mounted filesystem with ordered data mode. Opts: errors=remount-ro,nomblk_io_submit<br>734 1970/01/01 08:00:07.386393 <strong>6.1491</strong> 11 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (vdd25): mounted filesystem with ordered data mode. Opts: (null)</p>
</blockquote>
<h4 id="10-挂载fotadata"><a href="#10-挂载fotadata" class="headerlink" title="10.挂载fotadata"></a>10.挂载fotadata</h4><p>消耗 250ms<br>741 1970/01/01 08:00:07.386426 <strong>6.3614</strong> 18 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (<strong>vdd33</strong>): mounted filesystem with ordered data mode. Opts: errors=remount-ro,nomblk_io_submit<br>742 1970/01/01 08:00:07.386431 <strong>6.6189</strong> 19 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (vdd33): mounted filesystem with ordered data mode. Opts: (null)</p>
<h4 id="11-总共挂载时间"><a href="#11-总共挂载时间" class="headerlink" title="11.总共挂载时间"></a>11.总共挂载时间</h4><p>消耗 4000ms （有主机，副屏和仪表）</p>
<blockquote>
<p>617 1970/01/01 08:00:07.383961 <strong>2.7318</strong> 150 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (<strong>vdd20</strong>): mounted filesystem without journal. Opts: barrier=1,discard<br>754 1970/01/01 08:00:07.386489 <strong>6.7770</strong> 31 ECU1 KERN KERN 340 log info verbose 1 EXT4-fs (vdd23): mounted filesystem with ordered data mode. Opts: barrier=1</p>
</blockquote>
<h5 id="11-1-只有主机mountall"><a href="#11-1-只有主机mountall" class="headerlink" title="11.1 只有主机mountall"></a>11.1 只有主机mountall</h5><p>耗时：2900ms </p>
<h4 id="12-启动守护进程耗时"><a href="#12-启动守护进程耗时" class="headerlink" title="12.启动守护进程耗时"></a>12.启动守护进程耗时</h4><p>(logd,servicemanager,hwservicemanager,vndservicemanager,qseecomd,automotive.vehicle,hardware.boot,getekeeper,keymaster,vehiclelan.proxy,vold,ais_v412_proxy,dlt_daemon,systemlog,netd,iptables-restore,ip6tables-restore)   消耗1300ms</p>
<blockquote>
<p>1133 1970/01/01 08:00:07.440727 <strong>6.0886</strong> 154 ECU1 Serv LOGD 340 log info verbose 1 I/<strong>ServiceManagement</strong>( 294): Removing namespace from process name <a href="mailto:&#x61;&#110;&#100;&#114;&#111;&#x69;&#100;&#x2e;&#104;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#101;&#46;&#103;&#97;&#x74;&#x65;&#107;&#x65;&#101;&#x70;&#101;&#114;&#64;&#x31;&#46;&#x30;&#45;&#115;&#x65;&#114;&#x76;&#x69;&#99;&#101;&#45;&#x71;&#116;&#x69;">&#x61;&#110;&#100;&#114;&#111;&#x69;&#100;&#x2e;&#104;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#101;&#46;&#103;&#97;&#x74;&#x65;&#107;&#x65;&#101;&#x70;&#101;&#114;&#64;&#x31;&#46;&#x30;&#45;&#115;&#x65;&#114;&#x76;&#x69;&#99;&#101;&#45;&#x71;&#116;&#x69;</a> to <a href="mailto:&#x67;&#x61;&#116;&#101;&#107;&#101;&#101;&#112;&#x65;&#x72;&#x40;&#x31;&#x2e;&#x30;&#45;&#x73;&#101;&#114;&#118;&#105;&#x63;&#x65;&#x2d;&#113;&#116;&#105;">&#x67;&#x61;&#116;&#101;&#107;&#101;&#101;&#112;&#x65;&#x72;&#x40;&#x31;&#x2e;&#x30;&#45;&#x73;&#101;&#114;&#118;&#105;&#x63;&#x65;&#x2d;&#113;&#116;&#105;</a>.<br>3079 1970/01/01 08:00:08.728332 <strong>8.0727</strong> 52 ECU1 Serv LOGD 340 log info verbose 1 I/<strong>ServiceManagement</strong>( 599): Removing namespace from process name <a href="mailto:&#97;&#x6e;&#100;&#x72;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x6d;&#x65;&#x64;&#105;&#x61;&#46;&#111;&#x6d;&#120;&#x40;&#x31;&#x2e;&#48;&#x2d;&#x73;&#x65;&#114;&#x76;&#105;&#x63;&#x65;">&#97;&#x6e;&#100;&#x72;&#x6f;&#x69;&#100;&#46;&#x68;&#x61;&#114;&#x64;&#x77;&#x61;&#x72;&#101;&#46;&#x6d;&#x65;&#x64;&#105;&#x61;&#46;&#111;&#x6d;&#120;&#x40;&#x31;&#x2e;&#48;&#x2d;&#x73;&#x65;&#114;&#x76;&#105;&#x63;&#x65;</a> to <a href="mailto:&#x6f;&#109;&#120;&#x40;&#49;&#x2e;&#48;&#x2d;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;">&#x6f;&#109;&#120;&#x40;&#49;&#x2e;&#48;&#x2d;&#x73;&#101;&#114;&#118;&#x69;&#99;&#101;</a>.</p>
</blockquote>
<h4 id="13-启动虚拟机-启动虚拟机，注册JNI函数，然后调用ZygoteInit的main-启动zygote"><a href="#13-启动虚拟机-启动虚拟机，注册JNI函数，然后调用ZygoteInit的main-启动zygote" class="headerlink" title="13.启动虚拟机  启动虚拟机，注册JNI函数，然后调用ZygoteInit的main,启动zygote"></a>13.启动虚拟机  启动虚拟机，注册JNI函数，然后调用ZygoteInit的main,启动zygote</h4><p>消耗1000ms</p>
<blockquote>
<p>2143 1970/01/01 08:00:08.518533 <strong>8.0517</strong> 140 ECU1 Andr LOGD 340 log debug verbose 1 D/AndroidRuntime( 343): &gt;&gt;&gt;&gt;&gt;&gt; START com.android.internal.os.ZygoteInit uid 0 &lt;&lt;&lt;&lt;&lt;&lt;<br>3230 1970/01/01 08:00:09.303995 <strong>9.0301</strong> 203 ECU1 sysu LOGD 340 log info verbose 1 I/sysui_histogram( 344): [boot_zygote_init,9301]</p>
</blockquote>
<p>==============================zygote 进程====================================</p>
<h4 id="14-启动zygote"><a href="#14-启动zygote" class="headerlink" title="14.启动zygote"></a>14.启动zygote</h4><p>zygote32加载资源耗时1000ms   lazy加载消耗6ms。最后fork另一个进程调用SystemServer.main</p>
<blockquote>
<p>3235 1970/01/01 08:00:09.320542 <strong>9.0312</strong> 208 ECU1 Zygo LOGD 340 log debug verbose 1 D/Zygote ( 343): <strong>begin preload</strong><br>3272 1970/01/01 08:00:09.896990 <strong>9.0896</strong> 245 ECU1 Zygo LOGD 340 log debug verbose 1 D/Zygote64Timing( 343): <strong>PreloadClasses</strong> took to complete: 525ms<br>3298 1970/01/01 08:00:09.987205 <strong>9.0981</strong> 15 ECU1 Zygo LOGD 340 log debug verbose 1 D/Zygote64Timing( 343): <strong>PreloadResources</strong> took to complete: 85ms<br>3306 1970/01/01 08:00:10.025590 <strong>10.0024</strong> 23 ECU1 Zygo LOGD 340 log debug verbose 1 D/Zygote ( 343): <strong>end preload</strong></p>
<p>3312 1970/01/01 08:00:10.046181 <strong>10.0045</strong> 29 ECU1 Zygo LOGD 340 log debug verbose 1 D/Zygote64Timing( 343): ZygoteInit took to complete: 733ms</p>
<p>5793 1970/01/01 08:00:12.162046 <strong>12.0160</strong> 206 ECU1 Zygo LOGD 340 log debug verbose 1 D/Zygote ( 344): <strong>begin preload</strong><br>5792 1970/01/01 08:00:12.161982 <strong>12.0160</strong> 205 ECU1 Zygo LOGD 340 log info verbose 1 I/Zygote ( 344): <strong>Lazily preloading resources.</strong><br>8378 2021/10/11 15:55:08.533926 <strong>12.0742</strong> 231 ECU1 Zygo LOGD 340 log debug verbose 1 D/Zygote ( 344): <strong>end preload</strong></p>
</blockquote>
<h4 id="15-启动另一个zygote"><a href="#15-启动另一个zygote" class="headerlink" title="15.启动另一个zygote"></a>15.启动另一个zygote</h4><p>消耗1100ms，此处会sleep 1000ms等待另一个zygote启动。</p>
<blockquote>
<p>10687 2021/10/11 15:55:09.698136 <strong>13.0800</strong> 246 ECU1 Zygo LOGD 340 log warn verbose 1 W/ZygoteProcess( 741): Got error connecting to zygote, retrying. msg= Connection refused</p>
</blockquote>
<h4 id="16-启动WebViewZygoteInit"><a href="#16-启动WebViewZygoteInit" class="headerlink" title="16.启动WebViewZygoteInit"></a>16.启动WebViewZygoteInit</h4><blockquote>
<p>10690 2021/10/11 15:55:09.698159 <strong>13.0806</strong> 249 ECU1 WebV LOGD 340 log info verbose 1 I/WebViewZygoteInit( 1232): Starting WebViewZygoteInit</p>
</blockquote>
<p>==============================SystemServer 进程====================================</p>
<h4 id="17-启动SystemServer-并且加载Contenxt资源"><a href="#17-启动SystemServer-并且加载Contenxt资源" class="headerlink" title="17.启动SystemServer,并且加载Contenxt资源"></a>17.启动SystemServer,并且加载Contenxt资源</h4><p>消耗50ms</p>
<blockquote>
<p>3342 1970/01/01 08:00:10.198152 <strong>10.0197</strong> 59 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): InitBeforeStartServices</p>
<p>3534 1970/01/01 08:00:10.446575 <strong>10.0445</strong> 251 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): StartServices</p>
</blockquote>
<h5 id="17-1-启动引导服务-startBootstrapServices"><a href="#17-1-启动引导服务-startBootstrapServices" class="headerlink" title="17.1 启动引导服务  startBootstrapServices"></a>17.1 启动引导服务  startBootstrapServices</h5><p>消耗1700ms  包括PKMS扫描APK，详情参见附件一</p>
<blockquote>
<p>3534 1970/01/01 08:00:10.446575 <strong>10.0445</strong> 251 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): StartServices</p>
<p>5553 1970/01/01 08:00:12.087488 <strong>12.0086</strong> 222 ECU1 Syst LOGD 340 log debug verbose 1 D/SystemServerTiming( 741): <strong>StartPackageManagerService took to complete: 1494ms</strong></p>
<p>5669 1970/01/01 08:00:12.122919 <strong>12.0101</strong> 82 ECU1 Syst LOGD 340 log debug verbose 1 D/SystemServerInitThreadPool( 741): Finished executing StartSensorService</p>
</blockquote>
<h5 id="17-2-启动核心服务"><a href="#17-2-启动核心服务" class="headerlink" title="17.2 启动核心服务"></a>17.2 启动核心服务</h5><p>消耗 20ms</p>
<blockquote>
<p>5655 1970/01/01 08:00:12.122591 <strong>12.0093</strong> 68 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): StartBatteryService<br>5699 1970/01/01 08:00:12.123745 <strong>12.0117</strong> 112 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): StartBinderCallsStatsService</p>
</blockquote>
<h5 id="17-3-启动其他服务"><a href="#17-3-启动其他服务" class="headerlink" title="17.3 启动其他服务"></a>17.3 启动其他服务</h5><p>消耗2300ms</p>
<blockquote>
<p>5703 1970/01/01 08:00:12.123868 <strong>12.0118</strong> 116 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): SecondaryZygotePreload<br>10419 2021/10/11 15:55:09.416040 <strong>13.0615</strong> 224 ECU1 Acti LOGD 340 log info verbose 1 I/ActivityManager( 741): System now ready   //系统启动结束，下面启动一些自定义的部分服务CoreManagerHelperService，QnxHelperService，systemUi等<br>11684 2021/10/11 15:55:10.211172 <strong>14.0413</strong> 219 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): StartWatchdog<br>11877 2021/10/11 15:55:10.275099 <strong>14.0482</strong> 156 ECU1 Syst LOGD 340 log info verbose 1 I/SystemServer( 741): IncidentDaemonReady  // AMS systemready回调做的最后一件事情。下面开始启动app。</p>
<p>11948 2021/10/11 15:55:10.322878 <strong>14.0532</strong> 227 ECU1 Syst LOGD 340 log debug verbose 1 D/SystemServerTiming( 741): <strong>StartServices took to complete: 4087ms</strong></p>
</blockquote>
<p>启动所有原生服务耗时4087ms。<strong>详情参见附件二</strong></p>
<h5 id="17-4-启动persistent应用"><a href="#17-4-启动persistent应用" class="headerlink" title="17.4 启动persistent应用"></a>17.4 启动persistent应用</h5><p>此处只是调用zygote fork一个进程，然后在其他进程各自执行自己的代码，<strong>只要CPU和IO不block，理论不会影响开机启动速度！</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-041bf7a734382947.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动服务CPU和IO图.png"></p>
<blockquote>
<p>startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);<br>11945 2021/10/11 15:55:10.322580 <strong>14.0531</strong> 224 ECU1 Syst LOGD 340 log debug verbose 1 D/SystemServerTiming( 741): <strong>ActivityManagerStartApps took to complete: 49ms</strong></p>
</blockquote>
<h5 id="17-5-启动setting的fallback-home"><a href="#17-5-启动setting的fallback-home" class="headerlink" title="17.5 启动setting的fallback home"></a>17.5 启动setting的fallback home</h5><p>消耗918ms</p>
<blockquote>
<p>14534 2021/10/11 15:55:11.457145 <strong>15.0413</strong> 253 ECU1 am_a LOGD 340 log info verbose 1 I/am_activity_launch_time( 741): [0,23925135,com.android.settings/.FallbackHome,918,918]**</p>
</blockquote>
<h5 id="17-6-检查解锁，启动16s开始启动launcher"><a href="#17-6-检查解锁，启动16s开始启动launcher" class="headerlink" title="17.6 检查解锁，启动16s开始启动launcher"></a>17.6 检查解锁，启动16s开始启动launcher</h5><blockquote>
<p>18698 2021/01/01 00:00:25.530286 <strong>16.0769</strong> 73 ECU1 Fall LOGD 340 log debug verbose 1 D/FallbackHome( 1716): User unlocked and real home found; let’s go!</p>
</blockquote>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>计算system和vendor的hash值耗时1200ms</p>
</li>
<li><p>挂载各个分区耗时4000ms</p>
</li>
<li><p>启动各个守护进程1300ms</p>
</li>
<li><p>资源加载耗时1000ms</p>
</li>
<li><p>扫描APK耗时1700ms</p>
</li>
<li><p>启动其他服务耗时2300ms</p>
</li>
<li><p>Android启动从启动到Framework启动结束耗时14.05s</p>
</li>
<li><p>设置启动FallbackHome耗时918ms，在15s开始检查是否解锁</p>
</li>
<li><p>检查解锁耗时1s，在启动至16s的时候开启启动Launcher。</p>
</li>
</ul>
<h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>1.裁剪预加载类和资源最多只能获得百毫秒级的提升，但是裁剪之后可能存在字体，语言不支持等异常</p>
<p>2.裁剪其他服务，此处可以获得百毫秒级的提升，但是也存在有依赖失效的风险</p>
<p>3.调整服务等启动顺序，在该车机上理论不会获得启动时间的提升，因为在SystemServer启动服务阶段，CPU和IO都没有跑满，理论上不应该影响启动时间。</p>
<h4 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h4><h5 id="1-项目应用列表"><a href="#1-项目应用列表" class="headerlink" title="1.项目应用列表"></a>1.项目应用列表</h5><p>一共有201个APK。</p>
<p><strong>说明：每一行就是一个apk</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">package:com.android.cts.priv.ctsshim   # tailor</span><br><span class="line">package:com.qualcomm.qti.qms.service.telemetry</span><br><span class="line">package:com.iflytek.autofly.accountcenter</span><br><span class="line">package:com.iflytek.autofly.systemserver</span><br><span class="line">package:com.android.car.messenger</span><br><span class="line">package:com.android.internal.display.cutout.emulation.corner</span><br><span class="line">package:com.gxatek.multiinstanceservice</span><br><span class="line">package:com.qualcomm.qti.improvetouch.service</span><br><span class="line">package:com.android.internal.display.cutout.emulation.double</span><br><span class="line">package:com.android.providers.telephony</span><br><span class="line">package:com.android.providers.calendar # 日历程序支持服务</span><br><span class="line">package:com.iflytek.autofly.naviselect</span><br><span class="line">package:com.gxatek.cockpit.diagnostic</span><br><span class="line">package:com.android.providers.media</span><br><span class="line">package:com.qti.service.colorservice</span><br><span class="line">package:com.android.wallpapercropper # tailor</span><br><span class="line">package:com.android.car.media</span><br><span class="line">package:com.quicinc.cne.CNEService</span><br><span class="line">package:com.android.car.radio</span><br><span class="line">package:com.android.car.trust</span><br><span class="line">package:com.core.system.service</span><br><span class="line">package:com.gxa.car.timesync</span><br><span class="line">package:com.android.protips  # tailor</span><br><span class="line">package:com.gxatek.cockpit.atmospherelampservice</span><br><span class="line">package:com.qiyi.video.pad</span><br><span class="line">package:com.android.documentsui # tailor</span><br><span class="line">package:com.android.externalstorage</span><br><span class="line">package:com.qualcomm.uimremoteclient</span><br><span class="line">package:com.android.htmlviewer # tailor</span><br><span class="line">package:com.gxatek.cockpit.launcher</span><br><span class="line">package:com.android.companiondevicemanager</span><br><span class="line">package:com.android.quicksearchbox # tailor</span><br><span class="line">package:com.android.mms.service  # tailor</span><br><span class="line">package:com.gxa.car.externalkey</span><br><span class="line">package:com.gxa.service.account</span><br><span class="line">package:com.qualcomm.qti.qms.service.connectionsecurity</span><br><span class="line">package:com.android.providers.downloads  # tailor</span><br><span class="line">package:com.gxatek.cockpit.vicelauncher</span><br><span class="line">package:com.desay_svautomotive.svcarinfo</span><br><span class="line">package:com.gxa.car.qnxapp</span><br><span class="line">package:com.gxatek.cockpit.gallery</span><br><span class="line">package:com.android.soundrecorder  # tailor</span><br><span class="line">package:android.car.cluster.loggingrenderer</span><br><span class="line">package:com.gxa.service.carusbupdate</span><br><span class="line">package:com.qualcomm.uimremoteserver</span><br><span class="line">package:com.android.defcontainer  # 应用安装相关的应用，删除可能无法启动</span><br><span class="line">package:com.qti.confuridialer</span><br><span class="line">package:com.desay_svautomotive.service.projectionservice</span><br><span class="line">package:com.android.car.mapsplaceholder</span><br><span class="line">package:com.android.providers.downloads.ui # tailor</span><br><span class="line">package:com.android.pacprocessor</span><br><span class="line">package:com.android.simappdialog   # tailor 插入sim卡的弹窗</span><br><span class="line">package:com.iflytek.cutefly.speechclient.hmi</span><br><span class="line">package:com.android.internal.display.cutout.emulation.tall</span><br><span class="line">package:com.android.certinstaller  # tailor 证书安装</span><br><span class="line">package:com.android.carrierconfig # tailor 可用网络的默认配置</span><br><span class="line">package:android</span><br><span class="line">package:com.android.contacts</span><br><span class="line">package:com.android.camera2</span><br><span class="line">package:com.qualcomm.wfd.service</span><br><span class="line">package:com.gxatek.cockpit.schedule</span><br><span class="line">package:com.android.car.systemupdater</span><br><span class="line">package:com.gxa.car.engineMode</span><br><span class="line">package:com.gxatek.cockpit.msgcenter</span><br><span class="line">package:com.android.car</span><br><span class="line">package:com.android.egg  # tailor 彩蛋</span><br><span class="line">package:com.android.mtp  # ? usb传输协议相关的</span><br><span class="line">package:com.android.nfc  # tailor </span><br><span class="line">package:com.android.stk</span><br><span class="line">package:com.android.backupconfirm</span><br><span class="line">package:com.gxatek.appservice.cluster</span><br><span class="line">package:com.gxa.service.devicemanager</span><br><span class="line">package:com.android.provision #系统初始化引导程序，写入一个DEVICE_PROVISIONED标记</span><br><span class="line">package:com.android.statementservice</span><br><span class="line">package:com.android.settings.intelligence</span><br><span class="line">package:com.android.calendar # tailor日历</span><br><span class="line">package:com.android.systemui.theme.dark</span><br><span class="line">package:com.gxatek.cockpit.carlife</span><br><span class="line">package:com.gxatek.cockpit.carplay</span><br><span class="line">package:com.gxa.car.ncm.overlay</span><br><span class="line">package:com.iflytek.auto.mall.hmi</span><br><span class="line">package:com.android.car.settings</span><br><span class="line">package:com.iflytek.autofly.h5</span><br><span class="line">package:com.qualcomm.qti.dynamicddsservice</span><br><span class="line">package:com.gxa.service.ebcall</span><br><span class="line">package:com.android.car.hvac</span><br><span class="line">package:com.qualcomm.qcrilmsgtunnel</span><br><span class="line">package:com.android.providers.settings</span><br><span class="line">package:com.android.sharedstoragebackup</span><br><span class="line">package:com.gxatek.cockpit.carsettings</span><br><span class="line">package:com.android.printspooler</span><br><span class="line">package:com.qualcomm.qti.improvetouch</span><br><span class="line">package:com.android.dreams.basic</span><br><span class="line">package:com.gxatek.cockpit.applet</span><br><span class="line">package:com.android.webview</span><br><span class="line">package:com.gxatek.cockpit.btcall</span><br><span class="line">package:com.android.se</span><br><span class="line">package:com.android.inputdevices</span><br><span class="line">package:com.android.support.car.lenspicker</span><br><span class="line">package:com.gxa.service.ota</span><br><span class="line">package:com.android.bips</span><br><span class="line">package:com.iflytek.autofly.mediax</span><br><span class="line">package:com.qti.dpmserviceapp</span><br><span class="line">package:com.google.android.car.defaultstoragemonitoringcompanionapp</span><br><span class="line">package:com.android.musicfx  # 原生音效</span><br><span class="line">package:com.gxatek.cockpit.scenesengine</span><br><span class="line">package:com.gxa.car.ncm</span><br><span class="line">package:com.android.cellbroadcastreceiver   # 小区广播</span><br><span class="line">package:android.ext.shared</span><br><span class="line">package:com.android.onetimeinitializer # 首次启动用于装谷歌app的</span><br><span class="line">package:com.android.server.telecom</span><br><span class="line">package:com.android.keychain</span><br><span class="line">package:com.qti.snapdragon.qdcm_ff</span><br><span class="line">package:com.ts.appservice.kanzikotanimationservice</span><br><span class="line">package:com.gxatek.cockpit.weather</span><br><span class="line">package:com.gxa.service.messagecenter</span><br><span class="line">package:com.android.printservice.recommendation</span><br><span class="line">package:com.android.dialer # 原生拨号盘</span><br><span class="line">package:com.android.gallery3d # 相机相框</span><br><span class="line">package:android.ext.services</span><br><span class="line">package:com.desay_svautomotive.multiscreen</span><br><span class="line">package:com.android.calllogbackup #手机通话记录备份工具</span><br><span class="line">package:com.gxatek.cockpit.testcarlife</span><br><span class="line">package:com.gxatek.cockpit.testcarplay</span><br><span class="line">package:com.android.packageinstaller</span><br><span class="line">package:com.android.carrierdefaultapp # 运营商默认流量服务</span><br><span class="line">package:com.gac.cloud.app</span><br><span class="line">package:com.android.car.media.localmediaplayer</span><br><span class="line">package:com.android.proxyhandler  # 自动配置代理</span><br><span class="line">package:com.gxa.car.procmanagement</span><br><span class="line">package:com.android.inputmethod.latin  # 原生输入法</span><br><span class="line">package:com.gxa.appservice.caradapter</span><br><span class="line">package:org.chromium.webview_shell</span><br><span class="line">package:android.car.usb.handler</span><br><span class="line">package:com.gxa.service.cluster</span><br><span class="line">package:com.gxa.service.settings</span><br><span class="line">package:com.android.managedprovisioning #工作组资料设置  ?</span><br><span class="line">package:com.gxa.service.mediacenterservice</span><br><span class="line">package:com.android.dreams.phototable  # PhotoTable屏保</span><br><span class="line">package:com.gxa.cockpit.hvac</span><br><span class="line">package:cn.gaei.appstore</span><br><span class="line">package:com.desaysv.otaservice</span><br><span class="line">package:com.gxa.firewall</span><br><span class="line">package:com.gxatek.cockpit.voicecarctrl</span><br><span class="line">package:com.android.smspush  # 短信推送</span><br><span class="line">package:com.android.wallpaper.livepicker  # 动态墙纸选择器</span><br><span class="line">package:com.gxa.service.weather</span><br><span class="line">package:com.google.android.car.vms.subscriber</span><br><span class="line">package:com.qti.snapdragon.qdcm_mobile</span><br><span class="line">package:com.gxa.appservice.platformadapter.adaptermainservice</span><br><span class="line">package:com.gxa.service.systemui</span><br><span class="line">package:com.android.storagemanager</span><br><span class="line">package:com.android.bookmarkprovider # 书签</span><br><span class="line">package:com.gxatek.cockpit.miniprogram</span><br><span class="line">package:com.android.settings</span><br><span class="line">package:com.qualcomm.qti.sva</span><br><span class="line">package:com.gxatek.cockpit.carservice</span><br><span class="line">package:com.gxatek.cockpit.avdc</span><br><span class="line">package:com.android.calculator2 # 计算器</span><br><span class="line">package:com.gxa.service.bluetooth</span><br><span class="line">package:com.gxatek.cockpit.settings</span><br><span class="line">package:com.android.cts.ctsshim # cts</span><br><span class="line">package:com.gxa.car.audio</span><br><span class="line">package:com.gxa.car.power</span><br><span class="line">package:com.gxa.car.scene</span><br><span class="line">package:com.iflytek.inputmethod</span><br><span class="line">package:com.qti.diagservices</span><br><span class="line">package:com.iflytek.autofly.dms</span><br><span class="line">package:com.android.vpndialogs # VPN</span><br><span class="line">package:com.iflytek.autofly.platformservice</span><br><span class="line">package:com.android.email   # 原生email</span><br><span class="line">package:com.android.music   # 原生music</span><br><span class="line">package:com.android.phone   # 原生phone</span><br><span class="line">package:com.android.shell  # ?</span><br><span class="line">package:com.android.wallpaperbackup # 墙纸备份</span><br><span class="line">package:com.android.providers.blockednumber</span><br><span class="line">package:com.android.providers.userdictionary  # 用户词典Content Provider</span><br><span class="line">package:com.android.emergency  # 急救信息</span><br><span class="line">package:com.gxa.car.wifi.service</span><br><span class="line">package:com.android.location.fused</span><br><span class="line">package:com.android.deskclock  # 自带闹钟</span><br><span class="line">package:com.android.systemui</span><br><span class="line">package:com.android.bluetoothmidiservice</span><br><span class="line">package:com.qualcomm.qti.poweroffalarm</span><br><span class="line">package:com.gxatek.cockpit.vpamultimode</span><br><span class="line">package:com.gxa.permission</span><br><span class="line">package:com.guangqi.chezaiapp</span><br><span class="line">package:com.gxa.car.hardkey</span><br><span class="line">package:com.android.traceur</span><br><span class="line">package:com.gxatek.cockpit.screensaver</span><br><span class="line">package:com.qualcomm.qti.qms.service.trustzoneaccess</span><br><span class="line">package:com.desaysv.ftpserver</span><br><span class="line">package:com.android.bluetooth</span><br><span class="line">package:com.qualcomm.timeservice</span><br><span class="line">package:com.android.providers.contacts</span><br><span class="line">package:com.gxatek.cockpit.dvr</span><br><span class="line">package:com.android.captiveportallogin </span><br><span class="line">package:com.google.android.car.vms.publisher</span><br><span class="line">package:com.gxatek.cockpit.globalsearch</span><br><span class="line">package:org.codeaurora.qti.nrNetworkSettingApp</span><br><span class="line">package:com.gxatek.cockpit.account</span><br></pre></td></tr></table></figure>


<h5 id="2-启动原生服务耗时"><a href="#2-启动原生服务耗时" class="headerlink" title="2.启动原生服务耗时"></a>2.启动原生服务耗时</h5><p><strong>日志说明：每一行就是启动一个服务的耗时，其中也包含加载系统共享资源的耗时统计</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPackageManagerService took to complete: 1371ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOtaDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUserManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitAttributerCache took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetSystemProcess took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOverlayManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartSensorService took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBatteryService took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsageService took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWebViewUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBinderCallsStatsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyAttestationApplicationIdProviderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyChainSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSchedulingPolicyService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelecomLoaderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelephonyRegistry took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEntropyMixer took to complete: 23ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccountManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContentService took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): BeginIcuCachePinning took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InstallSystemProviders took to complete: 84ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDropBoxManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVibratorService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConsumerIrService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAlarmManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWindowManagerService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetWindowManagerService took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WindowManagerServiceOnInitReady took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVrManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartHidlServices took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DisplayManagerWindowManagerAndInputReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBluetoothService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IpConnectivityMetrics took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): NetworkWatchlistService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PinnerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputMethodManagerLifecycle took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccessibilityManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayReady took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUiModeManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): UpdatePackagesIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PerformFstrimIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLockSettingsService took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPersistentDataBlock took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOemLockService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceIdleController took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDevicePolicyManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatusBarManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartClipboardService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartIpSecService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextServicesManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextClassificationManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkScoreService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkStatsService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkPolicyManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifi took to complete: 76ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiScanning took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRttService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiP2P took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEthernet took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConnectivityService took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNsdService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUpdateManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUpdateLockService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNotificationManager took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceMonitor took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLocationManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCountryDetectorService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSearchManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWallpaperManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAudioService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBroadcastRadioService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDockObserver took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWiredAccessoryManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMidiManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsbService took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSerialService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartHardwarePropertiesManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTwilightService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNightDisplay took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJobScheduler took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSoundTrigger took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTrustManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackupManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAppWidgerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVoiceRecognitionManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartGestureLauncher took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSensorNotification took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContextHubSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDiskStatsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkTimeUpdateService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCommonTimeManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): CertBlacklister took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEmergencyAffordanceService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDreamManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): AddGraphicsStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPrintManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCompanionDeviceManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRestrictionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaSessionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaResourceMonitor took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaRouterService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackgroundDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPruneInstantAppsJobService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartShortcutServiceLifecycle took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLauncherAppsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCrossProfileAppsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaProjectionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSliceManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCameraServiceProxy took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatsCompanionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJitCompilation took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMmsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAutoFillService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeVibratorServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadClasses took to complete: 397ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLockSettingsServiceReady took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseLockSettingsReady took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadResources took to complete: 48ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): SecondaryZygotePreload took to complete: 606ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataFixup took to complete: 1158ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseSystemServicesReady took to complete: 908ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeWindowManagerServiceReady took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePowerManagerServiceReady took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePackageManagerServiceReady took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayManagerServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceSpecificServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseDeviceSpecificServicesReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataPrepare took to complete: 509ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManagerReadyPhase took to complete: 87ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartObservingNativeCrashes took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartQnxHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCarServiceHelperService took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCoreManagerHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUI took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): WebViewFactoryPreparation took to complete: 24ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkManagementServiceReady took to complete: 475ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeIpSecServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.Dependency took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.NotificationChannels took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.statusbar.CommandQueue$CommandQueueStart took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyguard.KeyguardViewMediator took to complete: 33ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.recents.Recents took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): VehicleHal.init took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.volume.VolumeUI took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.stackdivider.Divider took to complete: 103ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SystemBars took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.usb.StorageNotification took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.power.PowerUI took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.media.RingtonePlayer took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyboard.KeyboardUI took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.pip.PipUI took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.shortcut.ShortcutKeyDispatcher took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.VendorServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.leak.GarbageMonitor$Service took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.LatencyTester took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.globalactions.GlobalActionsComponent took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.ScreenDecorations took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.fingerprint.FingerprintDialogImpl took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SliceBroadcastRelayHandler took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServices took to complete: 294ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): CarService.initAllServices took to complete: 335ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkStatsServiceReady took to complete: 1088ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeConnectivityServiceReady took to complete: 11ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkPolicyServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseThirdPartyAppsCanStart took to complete: 29ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLocationServiceReady took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCountryDetectionServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkTimeUpdateReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCommonTimeManagementServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeInputManagerServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeTelephonyRegistryReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMediaRouterServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMmsServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IncidentDaemonReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ActivityManagerStartApps took to complete: 59ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseActivityManagerReady took to complete: 1784ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartServices took to complete: 4794ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPackageManagerService took to complete: 1371ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOtaDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUserManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitAttributerCache took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetSystemProcess took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOverlayManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartSensorService took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBatteryService took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsageService took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWebViewUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBinderCallsStatsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyAttestationApplicationIdProviderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyChainSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSchedulingPolicyService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelecomLoaderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelephonyRegistry took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEntropyMixer took to complete: 23ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccountManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContentService took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): BeginIcuCachePinning took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InstallSystemProviders took to complete: 84ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDropBoxManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVibratorService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConsumerIrService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAlarmManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWindowManagerService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetWindowManagerService took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WindowManagerServiceOnInitReady took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVrManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartHidlServices took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DisplayManagerWindowManagerAndInputReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBluetoothService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IpConnectivityMetrics took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): NetworkWatchlistService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PinnerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputMethodManagerLifecycle took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccessibilityManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayReady took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUiModeManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): UpdatePackagesIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PerformFstrimIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLockSettingsService took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPersistentDataBlock took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOemLockService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceIdleController took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDevicePolicyManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatusBarManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartClipboardService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartIpSecService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextServicesManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextClassificationManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkScoreService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkStatsService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkPolicyManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifi took to complete: 76ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiScanning took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRttService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiP2P took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEthernet took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConnectivityService took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNsdService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUpdateManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUpdateLockService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNotificationManager took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceMonitor took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLocationManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPackageManagerService took to complete: 1371ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOtaDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUserManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitAttributerCache took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetSystemProcess took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOverlayManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartSensorService took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBatteryService took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsageService took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWebViewUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBinderCallsStatsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyAttestationApplicationIdProviderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyChainSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSchedulingPolicyService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelecomLoaderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelephonyRegistry took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEntropyMixer took to complete: 23ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccountManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContentService took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): BeginIcuCachePinning took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InstallSystemProviders took to complete: 84ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDropBoxManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVibratorService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConsumerIrService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAlarmManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWindowManagerService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetWindowManagerService took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WindowManagerServiceOnInitReady took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVrManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartHidlServices took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DisplayManagerWindowManagerAndInputReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBluetoothService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IpConnectivityMetrics took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): NetworkWatchlistService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PinnerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputMethodManagerLifecycle took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccessibilityManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayReady took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUiModeManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): UpdatePackagesIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PerformFstrimIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLockSettingsService took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPersistentDataBlock took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOemLockService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceIdleController took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDevicePolicyManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatusBarManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartClipboardService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartIpSecService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextServicesManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextClassificationManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkScoreService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkStatsService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkPolicyManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifi took to complete: 76ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiScanning took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRttService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiP2P took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEthernet took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConnectivityService took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNsdService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUpdateManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUpdateLockService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNotificationManager took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceMonitor took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLocationManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCountryDetectorService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSearchManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWallpaperManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAudioService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBroadcastRadioService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDockObserver took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWiredAccessoryManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMidiManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsbService took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSerialService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartHardwarePropertiesManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTwilightService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNightDisplay took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJobScheduler took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSoundTrigger took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTrustManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackupManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAppWidgerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVoiceRecognitionManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartGestureLauncher took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSensorNotification took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContextHubSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDiskStatsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkTimeUpdateService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCommonTimeManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): CertBlacklister took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEmergencyAffordanceService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDreamManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): AddGraphicsStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPrintManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCompanionDeviceManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRestrictionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaSessionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaResourceMonitor took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaRouterService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackgroundDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPruneInstantAppsJobService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartShortcutServiceLifecycle took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLauncherAppsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCrossProfileAppsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaProjectionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSliceManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCameraServiceProxy took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatsCompanionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJitCompilation took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMmsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAutoFillService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeVibratorServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadClasses took to complete: 397ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLockSettingsServiceReady took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseLockSettingsReady took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadResources took to complete: 48ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): SecondaryZygotePreload took to complete: 606ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataFixup took to complete: 1158ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseSystemServicesReady took to complete: 908ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeWindowManagerServiceReady took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePowerManagerServiceReady took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePackageManagerServiceReady took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayManagerServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceSpecificServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseDeviceSpecificServicesReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataPrepare took to complete: 509ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManagerReadyPhase took to complete: 87ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartObservingNativeCrashes took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartQnxHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCarServiceHelperService took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCoreManagerHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUI took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): WebViewFactoryPreparation took to complete: 24ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkManagementServiceReady took to complete: 475ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeIpSecServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.Dependency took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.NotificationChannels took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.statusbar.CommandQueue$CommandQueueStart took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyguard.KeyguardViewMediator took to complete: 33ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.recents.Recents took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): VehicleHal.init took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.volume.VolumeUI took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.stackdivider.Divider took to complete: 103ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SystemBars took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.usb.StorageNotification took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.power.PowerUI took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.media.RingtonePlayer took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyboard.KeyboardUI took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.pip.PipUI took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.shortcut.ShortcutKeyDispatcher took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.VendorServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.leak.GarbageMonitor$Service took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.LatencyTester took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.globalactions.GlobalActionsComponent took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.ScreenDecorations took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.fingerprint.FingerprintDialogImpl took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SliceBroadcastRelayHandler took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServices took to complete: 294ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): CarService.initAllServices took to complete: 335ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkStatsServiceReady took to complete: 1088ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeConnectivityServiceReady took to complete: 11ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkPolicyServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseThirdPartyAppsCanStart took to complete: 29ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLocationServiceReady took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCountryDetectionServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkTimeUpdateReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCommonTimeManagementServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeInputManagerServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeTelephonyRegistryReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMediaRouterServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMmsServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IncidentDaemonReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ActivityManagerStartApps took to complete: 59ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseActivityManagerReady took to complete: 1784ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartServices took to complete: 4794ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPackageManagerService took to complete: 1371ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOtaDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUserManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitAttributerCache took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetSystemProcess took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOverlayManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartSensorService took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBatteryService took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsageService took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWebViewUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBinderCallsStatsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyAttestationApplicationIdProviderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyChainSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSchedulingPolicyService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelecomLoaderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelephonyRegistry took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEntropyMixer took to complete: 23ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccountManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContentService took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): BeginIcuCachePinning took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InstallSystemProviders took to complete: 84ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDropBoxManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVibratorService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConsumerIrService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAlarmManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWindowManagerService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetWindowManagerService took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WindowManagerServiceOnInitReady took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVrManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartHidlServices took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DisplayManagerWindowManagerAndInputReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBluetoothService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IpConnectivityMetrics took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): NetworkWatchlistService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PinnerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputMethodManagerLifecycle took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccessibilityManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayReady took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUiModeManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): UpdatePackagesIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PerformFstrimIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLockSettingsService took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPersistentDataBlock took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOemLockService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceIdleController took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDevicePolicyManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatusBarManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartClipboardService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartIpSecService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextServicesManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextClassificationManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkScoreService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkStatsService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkPolicyManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifi took to complete: 76ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiScanning took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRttService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiP2P took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEthernet took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConnectivityService took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNsdService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUpdateManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUpdateLockService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNotificationManager took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceMonitor took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLocationManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCountryDetectorService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSearchManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWallpaperManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAudioService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBroadcastRadioService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDockObserver took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWiredAccessoryManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMidiManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsbService took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSerialService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartHardwarePropertiesManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTwilightService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNightDisplay took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJobScheduler took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSoundTrigger took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTrustManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackupManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAppWidgerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVoiceRecognitionManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartGestureLauncher took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSensorNotification took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContextHubSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDiskStatsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkTimeUpdateService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCommonTimeManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): CertBlacklister took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEmergencyAffordanceService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDreamManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): AddGraphicsStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPrintManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCompanionDeviceManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRestrictionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaSessionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaResourceMonitor took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaRouterService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackgroundDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPruneInstantAppsJobService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartShortcutServiceLifecycle took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLauncherAppsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCrossProfileAppsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaProjectionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSliceManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCameraServiceProxy took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatsCompanionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJitCompilation took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMmsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAutoFillService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeVibratorServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadClasses took to complete: 397ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLockSettingsServiceReady took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseLockSettingsReady took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadResources took to complete: 48ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): SecondaryZygotePreload took to complete: 606ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataFixup took to complete: 1158ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseSystemServicesReady took to complete: 908ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeWindowManagerServiceReady took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePowerManagerServiceReady took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePackageManagerServiceReady took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayManagerServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceSpecificServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseDeviceSpecificServicesReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataPrepare took to complete: 509ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManagerReadyPhase took to complete: 87ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartObservingNativeCrashes took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartQnxHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCarServiceHelperService took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCoreManagerHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUI took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): WebViewFactoryPreparation took to complete: 24ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkManagementServiceReady took to complete: 475ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeIpSecServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.Dependency took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.NotificationChannels took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.statusbar.CommandQueue$CommandQueueStart took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyguard.KeyguardViewMediator took to complete: 33ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.recents.Recents took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): VehicleHal.init took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.volume.VolumeUI took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.stackdivider.Divider took to complete: 103ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SystemBars took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.usb.StorageNotification took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.power.PowerUI took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.media.RingtonePlayer took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyboard.KeyboardUI took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.pip.PipUI took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.shortcut.ShortcutKeyDispatcher took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.VendorServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.leak.GarbageMonitor$Service took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.LatencyTester took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.globalactions.GlobalActionsComponent took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.ScreenDecorations took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.fingerprint.FingerprintDialogImpl took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SliceBroadcastRelayHandler took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServices took to complete: 294ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): CarService.initAllServices took to complete: 335ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkStatsServiceReady took to complete: 1088ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeConnectivityServiceReady took to complete: 11ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkPolicyServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseThirdPartyAppsCanStart took to complete: 29ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLocationServiceReady took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCountryDetectionServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkTimeUpdateReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCommonTimeManagementServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeInputManagerServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeTelephonyRegistryReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMediaRouterServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMmsServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IncidentDaemonReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ActivityManagerStartApps took to complete: 59ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseActivityManagerReady took to complete: 1784ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartServices took to complete: 4794ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPackageManagerService took to complete: 1371ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOtaDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPackageManagerService took to complete: 1371ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOtaDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUserManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitAttributerCache took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetSystemProcess took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOverlayManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartSensorService took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBatteryService took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsageService took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWebViewUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBinderCallsStatsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyAttestationApplicationIdProviderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyChainSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSchedulingPolicyService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelecomLoaderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelephonyRegistry took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEntropyMixer took to complete: 23ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccountManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContentService took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): BeginIcuCachePinning took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InstallSystemProviders took to complete: 84ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDropBoxManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVibratorService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConsumerIrService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAlarmManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWindowManagerService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetWindowManagerService took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WindowManagerServiceOnInitReady took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVrManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartHidlServices took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DisplayManagerWindowManagerAndInputReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBluetoothService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IpConnectivityMetrics took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): NetworkWatchlistService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PinnerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputMethodManagerLifecycle took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccessibilityManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayReady took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUiModeManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): UpdatePackagesIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PerformFstrimIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLockSettingsService took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPersistentDataBlock took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOemLockService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceIdleController took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDevicePolicyManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatusBarManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartClipboardService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartIpSecService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextServicesManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextClassificationManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkScoreService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkStatsService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkPolicyManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifi took to complete: 76ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiScanning took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRttService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiP2P took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEthernet took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConnectivityService took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNsdService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUpdateManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUpdateLockService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNotificationManager took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceMonitor took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLocationManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCountryDetectorService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSearchManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWallpaperManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAudioService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBroadcastRadioService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDockObserver took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWiredAccessoryManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMidiManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsbService took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSerialService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartHardwarePropertiesManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTwilightService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNightDisplay took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJobScheduler took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSoundTrigger took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTrustManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackupManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAppWidgerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVoiceRecognitionManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartGestureLauncher took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSensorNotification took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContextHubSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDiskStatsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkTimeUpdateService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCommonTimeManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): CertBlacklister took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEmergencyAffordanceService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDreamManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): AddGraphicsStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPrintManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCompanionDeviceManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRestrictionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaSessionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaResourceMonitor took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaRouterService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackgroundDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPruneInstantAppsJobService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartShortcutServiceLifecycle took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLauncherAppsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCrossProfileAppsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaProjectionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSliceManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCameraServiceProxy took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatsCompanionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJitCompilation took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMmsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAutoFillService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeVibratorServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadClasses took to complete: 397ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLockSettingsServiceReady took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseLockSettingsReady took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadResources took to complete: 48ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): SecondaryZygotePreload took to complete: 606ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataFixup took to complete: 1158ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseSystemServicesReady took to complete: 908ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeWindowManagerServiceReady took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePowerManagerServiceReady took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePackageManagerServiceReady took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayManagerServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceSpecificServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseDeviceSpecificServicesReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataPrepare took to complete: 509ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManagerReadyPhase took to complete: 87ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartObservingNativeCrashes took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartQnxHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCarServiceHelperService took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCoreManagerHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUI took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): WebViewFactoryPreparation took to complete: 24ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkManagementServiceReady took to complete: 475ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeIpSecServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.Dependency took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.NotificationChannels took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.statusbar.CommandQueue$CommandQueueStart took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyguard.KeyguardViewMediator took to complete: 33ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.recents.Recents took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): VehicleHal.init took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.volume.VolumeUI took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.stackdivider.Divider took to complete: 103ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SystemBars took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.usb.StorageNotification took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.power.PowerUI took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.media.RingtonePlayer took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyboard.KeyboardUI took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.pip.PipUI took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.shortcut.ShortcutKeyDispatcher took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.VendorServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.leak.GarbageMonitor$Service took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.LatencyTester took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.globalactions.GlobalActionsComponent took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.ScreenDecorations took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.fingerprint.FingerprintDialogImpl took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SliceBroadcastRelayHandler took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServices took to complete: 294ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): CarService.initAllServices took to complete: 335ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkStatsServiceReady took to complete: 1088ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeConnectivityServiceReady took to complete: 11ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkPolicyServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseThirdPartyAppsCanStart took to complete: 29ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLocationServiceReady took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCountryDetectionServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkTimeUpdateReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCommonTimeManagementServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeInputManagerServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeTelephonyRegistryReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMediaRouterServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMmsServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IncidentDaemonReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ActivityManagerStartApps took to complete: 59ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseActivityManagerReady took to complete: 1784ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartServices took to complete: 4794ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SystemUserUnlock took to complete: 4808ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): PostZygoteInitGC took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote32Timing( <span class="number">346</span>): ZygoteInit took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): BeginIcuCachePinning took to complete: 49ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadClasses took to complete: 530ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PreloadResources took to complete: 80ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygotePreload took to complete: 704ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): PostZygoteInitGC took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/Zygote64Timing( <span class="number">345</span>): ZygoteInit took to complete: 725ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitBeforeStartServices took to complete: 192ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ReadingSystemConfig took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInstaller took to complete: 10ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DeviceIdentifiersPolicyService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManager took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPowerManager took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitPowerManagement took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRecoverySystemService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLightsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSidekickService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDisplayManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WaitForDisplay took to complete: 16ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPackageManagerService took to complete: 1371ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOtaDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUserManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitAttributerCache took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetSystemProcess took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOverlayManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartSensorService took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBatteryService took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsageService took to complete: 20ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWebViewUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBinderCallsStatsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyAttestationApplicationIdProviderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartKeyChainSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSchedulingPolicyService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelecomLoaderService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTelephonyRegistry took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEntropyMixer took to complete: 23ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccountManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContentService took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): BeginIcuCachePinning took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InstallSystemProviders took to complete: 84ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDropBoxManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVibratorService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConsumerIrService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAlarmManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): InitWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWindowManagerService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SetWindowManagerService took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): WindowManagerServiceOnInitReady took to complete: 14ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVrManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): StartHidlServices took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): DisplayManagerWindowManagerAndInputReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBluetoothService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IpConnectivityMetrics took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): NetworkWatchlistService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PinnerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartInputMethodManagerLifecycle took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAccessibilityManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayReady took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageManagerService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStorageStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUiModeManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): UpdatePackagesIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PerformFstrimIfNeeded took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLockSettingsService took to complete: 4ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPersistentDataBlock took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartOemLockService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceIdleController took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDevicePolicyManager took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatusBarManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartClipboardService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartIpSecService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextServicesManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTextClassificationManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkScoreService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkStatsService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkPolicyManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifi took to complete: 76ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiScanning took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRttService took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWifiP2P took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEthernet took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartConnectivityService took to complete: 6ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNsdService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUpdateManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUpdateLockService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNotificationManager took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceMonitor took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLocationManagerService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCountryDetectorService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSearchManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWallpaperManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAudioService took to complete: 19ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBroadcastRadioService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDockObserver took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWiredAccessoryManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMidiManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartUsbService took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSerialService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartHardwarePropertiesManagerService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTwilightService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNightDisplay took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJobScheduler took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSoundTrigger took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartTrustManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackupManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAppWidgerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartVoiceRecognitionManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartGestureLauncher took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSensorNotification took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartContextHubSystemService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDiskStatsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartNetworkTimeUpdateService took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCommonTimeManagementService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): CertBlacklister took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartEmergencyAffordanceService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDreamManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): AddGraphicsStatsService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPrintManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCompanionDeviceManager took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartRestrictionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaSessionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaUpdateService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaResourceMonitor took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaRouterService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBackgroundDexOptService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartPruneInstantAppsJobService took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartShortcutServiceLifecycle took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartLauncherAppsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCrossProfileAppsService took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMediaProjectionManager took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSliceManagerService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCameraServiceProxy took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartStatsCompanionService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartJitCompilation took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartMmsService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartAutoFillService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeVibratorServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadClasses took to complete: 397ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLockSettingsServiceReady took to complete: 15ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseLockSettingsReady took to complete: 7ms</span><br><span class="line"> <span class="number">1</span> D/ZygoteInitTiming_lazy( <span class="number">346</span>): PreloadResources took to complete: 48ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): SecondaryZygotePreload took to complete: 606ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataFixup took to complete: 1158ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseSystemServicesReady took to complete: 908ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeWindowManagerServiceReady took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePowerManagerServiceReady took to complete: 9ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakePackageManagerServiceReady took to complete: 38ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeDisplayManagerServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartDeviceSpecificServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartBootPhaseDeviceSpecificServicesReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): AppDataPrepare took to complete: 509ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartActivityManagerReadyPhase took to complete: 87ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartObservingNativeCrashes took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartQnxHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCarServiceHelperService took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartCoreManagerHelperService took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartSystemUI took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTimingAsync( <span class="number">736</span>): WebViewFactoryPreparation took to complete: 24ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkManagementServiceReady took to complete: 475ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeIpSecServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.Dependency took to complete: 3ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.NotificationChannels took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.statusbar.CommandQueue$CommandQueueStart took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyguard.KeyguardViewMediator took to complete: 33ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.recents.Recents took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): VehicleHal.init took to complete: 110ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.volume.VolumeUI took to complete: 46ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.stackdivider.Divider took to complete: 103ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SystemBars took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.usb.StorageNotification took to complete: 17ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.power.PowerUI took to complete: 5ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.media.RingtonePlayer took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.keyboard.KeyboardUI took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.pip.PipUI took to complete: 13ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.shortcut.ShortcutKeyDispatcher took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.VendorServices took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.util.leak.GarbageMonitor$Service took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.LatencyTester took to complete: 12ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.globalactions.GlobalActionsComponent took to complete: 2ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.ScreenDecorations took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.fingerprint.FingerprintDialogImpl took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServicescom.android.systemui.SliceBroadcastRelayHandler took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemUIBootTiming( <span class="number">1154</span>): StartServices took to complete: 294ms</span><br><span class="line"> <span class="number">1</span> D/VehicleHalTiming( <span class="number">1130</span>): CarService.initAllServices took to complete: 335ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkStatsServiceReady took to complete: 1088ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeConnectivityServiceReady took to complete: 11ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkPolicyServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartWatchdog took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseThirdPartyAppsCanStart took to complete: 29ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeLocationServiceReady took to complete: 8ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCountryDetectionServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeNetworkTimeUpdateReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeCommonTimeManagementServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeInputManagerServiceReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeTelephonyRegistryReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMediaRouterServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): MakeMmsServiceReady took to complete: 0ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): IncidentDaemonReady took to complete: 1ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): ActivityManagerStartApps took to complete: 59ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): PhaseActivityManagerReady took to complete: 1784ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): StartServices took to complete: 4794ms</span><br><span class="line"> <span class="number">1</span> D/SystemServerTiming( <span class="number">736</span>): SystemUserUnlock took to complete: 4808ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Systrace使用说明以及使用场景总结</title>
    <url>/2021/10/15/Systrace%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1.使用说明"></a>1.使用说明</h4><h5 id="1-1-命令用法"><a href="#1-1-命令用法" class="headerlink" title="1.1 命令用法"></a>1.1 命令用法</h5><p><strong>命令行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python systrace.py [options] [category1] [category2] ... [categoryN]</span><br></pre></td></tr></table></figure>


<h5 id="1-2-options"><a href="#1-2-options" class="headerlink" title="1.2 options"></a>1.2 options</h5><p>其中options可取值：</p>
<table>
<thead>
<tr>
<th align="left">options</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-o <code>&lt;FILE</code>&gt;</td>
<td align="left">输出的目标文件</td>
</tr>
<tr>
<td align="left">-t N, –time=N</td>
<td align="left">执行时间，默认5s</td>
</tr>
<tr>
<td align="left">-b N, –buf-size=N</td>
<td align="left">buffer大小（单位kB),用于限制trace总大小，默认无上限</td>
</tr>
<tr>
<td align="left">-k <code>&lt;KFUNCS</code>&gt;，–ktrace=<code>&lt;KFUNCS</code>&gt;</td>
<td align="left">追踪kernel函数，用逗号分隔</td>
</tr>
<tr>
<td align="left">-a <code>&lt;APP_NAME</code>&gt;,–app=<code>&lt;APP_NAME</code>&gt;</td>
<td align="left">追踪应用包名，用逗号分隔</td>
</tr>
<tr>
<td align="left">–from-file=<code>&lt;FROM_FILE</code>&gt;</td>
<td align="left">从文件中创建互动的systrace</td>
</tr>
<tr>
<td align="left">-e <code>&lt;DEVICE_SERIAL</code>&gt;,–serial=<code>&lt;DEVICE_SERIAL</code>&gt;</td>
<td align="left">指定设备</td>
</tr>
<tr>
<td align="left">-l, –list-categories</td>
<td align="left">列举可用的tags</td>
</tr>
</tbody></table>
<h5 id="1-3-category"><a href="#1-3-category" class="headerlink" title="1.3 category"></a>1.3 category</h5><p>category可取值：</p>
<table>
<thead>
<tr>
<th align="left">category</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gfx</td>
<td align="left">Graphics</td>
</tr>
<tr>
<td align="left">input</td>
<td align="left">Input</td>
</tr>
<tr>
<td align="left">view</td>
<td align="left">View System</td>
</tr>
<tr>
<td align="left">webview</td>
<td align="left">WebView</td>
</tr>
<tr>
<td align="left">wm</td>
<td align="left">Window Manager</td>
</tr>
<tr>
<td align="left">am</td>
<td align="left">Activity Manager</td>
</tr>
<tr>
<td align="left">sm</td>
<td align="left">Sync Manager</td>
</tr>
<tr>
<td align="left">audio</td>
<td align="left">Audio</td>
</tr>
<tr>
<td align="left">video</td>
<td align="left">Video</td>
</tr>
<tr>
<td align="left">camera</td>
<td align="left">Camera</td>
</tr>
<tr>
<td align="left">hal</td>
<td align="left">Hardware Modules</td>
</tr>
<tr>
<td align="left">app</td>
<td align="left">Application</td>
</tr>
<tr>
<td align="left">res</td>
<td align="left">Resource Loading</td>
</tr>
<tr>
<td align="left">dalvik</td>
<td align="left">Dalvik VM</td>
</tr>
<tr>
<td align="left">rs</td>
<td align="left">RenderScript</td>
</tr>
<tr>
<td align="left">bionic</td>
<td align="left">Bionic C Library</td>
</tr>
<tr>
<td align="left">power</td>
<td align="left">Power Management</td>
</tr>
<tr>
<td align="left">sched</td>
<td align="left">CPU Scheduling</td>
</tr>
<tr>
<td align="left">irq</td>
<td align="left">IRQ Events</td>
</tr>
<tr>
<td align="left">freq</td>
<td align="left">CPU Frequency</td>
</tr>
<tr>
<td align="left">idle</td>
<td align="left">CPU Idle</td>
</tr>
<tr>
<td align="left">disk</td>
<td align="left">Disk I/O</td>
</tr>
<tr>
<td align="left">mmc</td>
<td align="left">eMMC commands</td>
</tr>
<tr>
<td align="left">load</td>
<td align="left">CPU Load</td>
</tr>
<tr>
<td align="left">sync</td>
<td align="left">Synchronization</td>
</tr>
<tr>
<td align="left">workq</td>
<td align="left">Kernel Workqueues</td>
</tr>
<tr>
<td align="left">memreclaim</td>
<td align="left">Kernel Memory Reclaim</td>
</tr>
<tr>
<td align="left">regulators</td>
<td align="left">Voltage and Current Regulators</td>
</tr>
</tbody></table>
<h5 id="1-4-示例"><a href="#1-4-示例" class="headerlink" title="1.4 示例"></a>1.4 示例</h5><p>例如，在<code>systrace.py</code>所在目录下执行指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python systrace.py -b 32768 -t 5 -o mytrace.html wm gfx input view sched freq</span><br><span class="line">.&#x2F;systrace.py -b 32768 -t 5 -o mytrace.html wm gfx input view sched freq &#x2F;&#x2F;等价</span><br></pre></td></tr></table></figure>
<p>又例如，输出全部的trace信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python systrace.py -b 32768 -t 5 -o mytrace.html gfx input view webview wm am sm audio video camera hal app res dalvik rs bionic power sched irq freq idle disk mmc load sync workq memreclaim regulators</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>收集trace，需要提前安装python，并且一定要注意必须是python 2.x，而不是能3.x，否则可能会出现问题。另外，buffer大小不可过大，否则会出现oom异常。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-9643489773d6e190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="python3_8不支持.png"></p>
<p>出现这种情况可以安装3.8和2.7的两个版本，然后再环境变量中将2.7的目录放在3.8之前，重启cmd运行即可。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d69496c765f7ea9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调整python启动版本.png"></p>
<h4 id="2-图形说明"><a href="#2-图形说明" class="headerlink" title="2.图形说明"></a>2.图形说明</h4><h5 id="2-1-图形化"><a href="#2-1-图形化" class="headerlink" title="2.1 图形化"></a>2.1 图形化</h5><p>横坐标是以时间为单位，纵坐标是以进程-线程的方式来划分，同一进程的线程为一组放在一起，可收缩/展开，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-8dceb8f1905165f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图形化.png"></p>
<h5 id="2-2-Frames"><a href="#2-2-Frames" class="headerlink" title="2.2 Frames"></a>2.2 Frames</h5><p>产生的html格式的trace文件必须使用Google Chrome打开，才能正确地解析并已图标形式展现。上图中红色圈起来的，都是可以点击操作的地方，最上方是搜索栏，往下处是Alerts按钮，再往下是鼠标操作模式。</p>
<p>在每个app进程，都有一个Frames行，正常情况以绿色的圆点表示。当圆点颜色为黄色或者红色时，意味着这一帧超过16.6ms（即发现丢帧），这时需要通过放大那一帧进一步分析问题。对于Android 5.0(API level 21)或者更高的设备，该问题主要聚焦在UI Thread和Render Thread这两个线程当中。对于更早的版本，则所有工作在UI Thread。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-9228693a57d2ac0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="frame图.png"></p>
<h5 id="2-3-Alerts"><a href="#2-3-Alerts" class="headerlink" title="2.3 Alerts"></a>2.3 Alerts</h5><p>Systrace能自动分析trace中的事件，并能自动高亮性能问题作为一个Alerts，建议调试人员下一步该怎么做。</p>
<p>比如对于丢帧是，点击黄色或红色的Frames圆点便会有相关的提示信息；另外，在systrace的最右上方，有一个Alerts tab可以展开，这里记录着所有的的警告提示信息。</p>
<p><strong>注：</strong>本文讲到最新版的systrace，其中sdk 23，chrome版本49.0，部分功能在老版本systrace并没有。</p>
<h4 id="3-快捷操作"><a href="#3-快捷操作" class="headerlink" title="3. 快捷操作"></a>3. 快捷操作</h4><h5 id="3-1-导航操作"><a href="#3-1-导航操作" class="headerlink" title="3.1 导航操作"></a>3.1 导航操作</h5><table>
<thead>
<tr>
<th align="left">导航操作</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">w</td>
<td align="left">放大，[+shift]速度更快</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">缩小，[+shift]速度更快</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">左移，[+shift]速度更快</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">右移，[+shift]速度更快</td>
</tr>
</tbody></table>
<h5 id="3-2-快捷操作"><a href="#3-2-快捷操作" class="headerlink" title="3.2 快捷操作"></a>3.2 快捷操作</h5><table>
<thead>
<tr>
<th align="left">常用操作</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">f</td>
<td align="left"><strong>放大</strong>当前选定区域</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left"><strong>标记</strong>当前选定区域</td>
</tr>
<tr>
<td align="left">v</td>
<td align="left">高亮<strong>VSync</strong></td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">切换是否显示<strong>60hz</strong>的网格线</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">恢复trace到<strong>初始态</strong>，这里是数字0而非字母o</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">一般操作</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">h</td>
<td align="left">切换是否显示详情</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">搜索关键字</td>
</tr>
<tr>
<td align="left">enter</td>
<td align="left">显示搜索结果，可通过← →定位搜索结果</td>
</tr>
<tr>
<td align="left">`</td>
<td align="left">显示/隐藏脚本控制台</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">显示帮助功能</td>
</tr>
</tbody></table>
<p>对于脚本控制台，除了能当做记事本的功能，目前还不清楚有啥功能，或许还在开发中。</p>
<h5 id="3-3-模式切换"><a href="#3-3-模式切换" class="headerlink" title="3.3 模式切换"></a>3.3 模式切换</h5><ol>
<li>Select mode: <strong>双击已选定区</strong>能将所有相同的块高亮选中；（对应数字1）</li>
<li>Pan mode: 拖动平移视图（对应数字2）</li>
<li>Zoom mode:通过上/下拖动鼠标来实现放大/缩小功能；（对应数字3）</li>
<li>Timing mode:拖动来创建或移除时间窗口线。（对应数字4）</li>
</ol>
<p>可通过按数字1~4，用于切换鼠标模式； 另外，按住alt键，再滚动鼠标滚轮能实现放大/缩小功能。</p>
<h4 id="4-使用AndroidStudio调查卡顿"><a href="#4-使用AndroidStudio调查卡顿" class="headerlink" title="4.使用AndroidStudio调查卡顿"></a>4.使用AndroidStudio调查卡顿</h4><h5 id="4-1-选择Trace-System-Call选项采集系统调用"><a href="#4-1-选择Trace-System-Call选项采集系统调用" class="headerlink" title="4.1 选择Trace System Call选项采集系统调用"></a>4.1 选择<code>Trace System Call</code>选项采集系统调用</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-ccbcc510db50e514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择TraceSystemCall.png"></p>
<h5 id="4-2-查看调用栈"><a href="#4-2-查看调用栈" class="headerlink" title="4.2 查看调用栈"></a>4.2 查看调用栈</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-70f6f4aa992ac1ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看调用栈.png"></p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><h5 id="5-1-分析卡顿有用的信息"><a href="#5-1-分析卡顿有用的信息" class="headerlink" title="5.1 分析卡顿有用的信息"></a>5.1 分析卡顿有用的信息</h5><p><code>sched</code>: CPU调度的信息，非常重要；你能看到CPU在每个时间段在运行什么线程；线程调度情况，比如锁信息。<br><code>gfx</code>：Graphic系统的相关信息，包括SerfaceFlinger，VSYNC消息，Texture，RenderThread等；分析卡顿非常依赖这个。<br><code>view</code>: View绘制系统的相关信息，比如onMeasure，onLayout等；对分析卡顿比较有帮助。<br><code>am</code>：ActivityManager调用的相关信息；用来分析Activity的启动过程比较有效。</p>
<h5 id="5-2-指令"><a href="#5-2-指令" class="headerlink" title="5.2 指令"></a>5.2 指令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systrace.py -t 10 -o d:&#x2F;mytrace.html sched gfx view am -a com.example.myapplication</span><br></pre></td></tr></table></figure>


<h5 id="5-3-不同category使用场景"><a href="#5-3-不同category使用场景" class="headerlink" title="5.3 不同category使用场景"></a>5.3 不同category使用场景</h5><blockquote>
<ol>
<li><p>测试列表滑动， 桌面滑动等流畅性问题<br>gfx input view</p>
</li>
<li><p>若在上面的基础上 还需要分析HWUI<br>gfx input view hwui  </p>
</li>
<li><p>测试app启动或者进入某个界面的速度<br>gfx input view am  wm res</p>
</li>
<li><p>怀疑有GC或者是IO导致的卡顿<br>gfx input view dalvik disk </p>
</li>
<li><p>怀疑有power相关的问题<br>gfx input view res am wm power</p>
</li>
</ol>
</blockquote>
<h5 id="5-4-分析卡顿原因"><a href="#5-4-分析卡顿原因" class="headerlink" title="5.4 分析卡顿原因"></a>5.4 分析卡顿原因</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-dfd273696742224a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当前系统线程状态判断卡顿原因.png"></p>
<p>点击frame图，查看线程状态推断卡顿原因，不同颜色代表不同线程状态：</p>
<ul>
<li><p>绿色：运行中<br>作用： 查看Running状态的线程，查看其运行的时间，与竞品做对比，分析快或者慢的原因是否频率不够，问题可能性：</p>
<ul>
<li><p>是否跑在了小核上</p>
</li>
<li><p>是否在Running 与Runnable之间切换？ 为什么？ </p>
</li>
<li><p>是否在Running 与Sleep之间切换？ 为什么？</p>
</li>
</ul>
</li>
<li><p>蓝色：<br>作用：Runnable状态的线程持续时间越长，则表示cpu调度越忙，没有及时处理这个任务</p>
<ul>
<li><p>是否后台有太多的任务在跑</p>
</li>
<li><p>是否频率太低</p>
</li>
<li><p>被限制某个具体的cpuset cpu很满？</p>
</li>
<li><p>此时Running状态的线程是哪个？ 为什么？ </p>
</li>
</ul>
</li>
<li><p>白色：<br>作用： 一般都是在等待事情驱动，在互斥锁上被阻塞</p>
</li>
<li><p>橘色 不可中断的睡眠态？ 一般都是线程在IO上被阻塞 或者等待磁盘操作 IO操作很慢<br>大量的橘色出现 表明 低内存状态</p>
</li>
<li><p>紫色： 可中断的睡眠态</p>
<ul>
<li>线程在另一个内核上被阻塞，有可能是正常的，也有可能是不正常的</li>
</ul>
</li>
</ul>
<p>从上图可以看出每一帧之间存在大量白色色条，说明在等待绘制。因此需要怀疑为什么会等待绘制，例如正在网络或者本地加载数据，三大绘制流程耗时过多？</p>
<h5 id="5-5-Linux-进程状态"><a href="#5-5-Linux-进程状态" class="headerlink" title="5.5 Linux 进程状态"></a>5.5 Linux 进程状态</h5><p>D 无法中断的休眠状态 (IO 进程)<br>R 正在可运行队列中的<br>S 休眠状态<br>T 停止<br>W 内存交换<br>X 死掉的进程<br>Z 僵尸进程</p>
<h5 id="5-6-线程优先级"><a href="#5-6-线程优先级" class="headerlink" title="5.6 线程优先级"></a>5.6 线程优先级</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Process.setThreadPriority()&#x2F; Thread</span><br></pre></td></tr></table></figure>


<blockquote>
<p>thread_priority_display = -4<br>thread_priority_foreground = -2<br>thread_priority_default = 0<br>thread_priority_background = 10<br>thread_priority_lowest = 19</p>
</blockquote>
<h5 id="5-7-调查步骤"><a href="#5-7-调查步骤" class="headerlink" title="5.7 调查步骤"></a>5.7 调查步骤</h5><ul>
<li><p>使用原生设置的<code>Profile GPU Rendering（GPU渲染模式分析）</code>功能，大概看一下柱状图哪些地方丢帧严重</p>
</li>
<li><p>使用Systrace查看丢帧发生的时刻线程状态，缩小调查范围，参考4.4怀疑项。</p>
</li>
<li><p>使用Android Studio查看调用栈，详细分析代码耗时/block原因。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统优化</tag>
        <tag>Systrace</tag>
      </tags>
  </entry>
  <entry>
    <title>重温PackageManagerService-源码分析</title>
    <url>/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>此次blog分析的源码是Android Q的代码，如果在Android Q以前找不到对应的方法，可以同步Android Q代码找找试试。PKMS服务在Android N/O/P三个版本变化不大，升级到Android Q有较大变化，有些方法名字一样，内部实现可能不一样了。</p>
<p>如下是Android Q pm目录下的源码分析笔记：<a href="https://github.com/oujie123/PackageManagerService">PackageManagerService源码跟踪分析笔记传送门</a></p>
<h3 id="1-PKMS概述"><a href="#1-PKMS概述" class="headerlink" title="1.PKMS概述"></a>1.PKMS概述</h3><p>PackageManagerService（简称 PKMS），是 Android 系统中核心服务之一，负责应用程序的<strong>安装，卸载，包信息查询</strong>等工作。</p>
<p>Android系统启动时，会启动（应用程序管理服务器PKMS），此服务负责扫描系统中特定的目录，寻找里面的APK格式的文件，并对这些文件进行解析，然后得到应用程序相关信息，最后完成应用程序的安装。</p>
<p>PKMS在安装应用过程中, 会全面解析应用程序的AndroidManifest.xml文件, 来得到Activity, Service,  BroadcastReceiver, ContextProvider 等信息, 在结合PKMS服务就可以在OS中正常的使用应用程序了。</p>
<p>在Android系统中, 系统启动时由SystemServer启动PKMS服务, 启动该服务后会执行应用程序的安装过程,<br>接下来后就会<strong>重点的分析SystemServer启动PKMS服务的过程, 叙述在Android系统中安装应用程序的过程。</strong></p>
<p>PKMS从大方向上看主要完成以下三大功能：</p>
<ul>
<li>解析AndroidNanifest.xml清单文件，解析清单文件中的所有节点信息</li>
<li>扫描.apk文件，安装系统应用，安装本地应用等</li>
<li>管理本地应用，主要提供安装，卸载，应用信息查询等功能</li>
</ul>
<p>所涉及到的源码如下：</p>
<p><a href="https://github.com/oujie123/PackageManagerService">1.重温PackageManagerService: 1.理解应用安装过程 2.理解签名校验过程 3.理解权限管理 (github.com)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/frameworks/base/core/java/android/app/ApplicationPackageManager.java</span><br><span class="line">/frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.</span><br><span class="line">java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/PackageDexOptimizer.ja</span><br><span class="line">va</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/Installer.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/Settings.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/permission/BasePermiss</span><br><span class="line">ion.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.</span><br><span class="line">java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/permission/DefaultPerm</span><br><span class="line">issionGrantPolicy.java</span><br><span class="line">/frameworks/base/services/core/java/com/android/server/pm/permission/PermissionM</span><br><span class="line">anagerService.java</span><br><span class="line">/frameworks/base/core/java/android/content/pm/IPackageManager.aidl</span><br><span class="line">/frameworks/base/core/java/android/content/pm/PackageManager.java</span><br><span class="line">/frameworks/base/core/java/com/android/server/SystemConfig.java</span><br></pre></td></tr></table></figure>


<h3 id="2-PKMS角色位置"><a href="#2-PKMS角色位置" class="headerlink" title="2.PKMS角色位置"></a>2.PKMS角色位置</h3><p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\PKMS简要架构.png" alt="PKMS简要架构"></p>
<p>各个应用中可以通过Context.getPackageManager()获得ApplicationPackageManager对象, 而mPM指向的是Proxy代理，当调用到mPM.方法后，将会调用到IPackageManager的Proxy代理方法，然后通过Binder机制中的mRemote与服务端PackageManagerService通信 并调用到PackageManagerService的方法；  </p>
<p>PackageManagerService是属于Binder机制的服务端角色 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageManagerService</span> <span class="keyword">extends</span> <span class="title">IPackageManager</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">PackageSender</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-PKMS-启动过程分析"><a href="#3-PKMS-启动过程分析" class="headerlink" title="3.PKMS 启动过程分析"></a>3.PKMS 启动过程分析</h3><p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\PKMS启动流程.png" alt="PKMS启动流程"></p>
<p>PackageManagerService启动是在SystemServer中启动的，启动分为两个阶段，7个过程。如下图</p>
<p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\PackageManagerService启动流程.png" alt="PackageManagerService启动流程"></p>
<h4 id="3-1-startBootstrapServices-启动阶段"><a href="#3-1-startBootstrapServices-启动阶段" class="headerlink" title="3.1 startBootstrapServices 启动阶段"></a>3.1 startBootstrapServices 启动阶段</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartInstaller&quot;</span>);</span><br><span class="line">        <span class="comment">//TODO =====================step1:创建安装器======================================</span></span><br><span class="line">        Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">        traceEnd();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only run &quot;core&quot; apps if we&#x27;re encrypting the device.</span></span><br><span class="line">        <span class="comment">//TODO =====================step2:获取用户是否设置了密码======================================</span></span><br><span class="line">        <span class="comment">// 如果加密了，则mOnlyCore为true，系统只会加载核心服务</span></span><br><span class="line">        String cryptState = VoldProperties.decrypt().orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Detected encryption in progress - only parsing core apps&quot;</span>);</span><br><span class="line">            mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Device encrypted - only parsing core apps&quot;</span>);</span><br><span class="line">            mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the package manager.</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartPackageManagerService&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">&quot;packagemanagermain&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO =====================step3:启动PKMS，实例化PKMS====================================</span></span><br><span class="line">            mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                    mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">&quot;packagemanagermain&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">        mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">        traceEnd();</span><br><span class="line">        <span class="keyword">if</span> (!mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;boot_package_manager_init_ready&quot;</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Manages A/B OTA dexopting. This is a bootstrap service as we need it to rename</span></span><br><span class="line">        <span class="comment">// A/B artifacts after boot, before anything else might touch/need them.</span></span><br><span class="line">        <span class="comment">// Note: this isn&#x27;t needed during decryption (we don&#x27;t have /data anyways).</span></span><br><span class="line">        <span class="comment">//TODO====================step4:如果没有加密，进行OTA dex优化======================</span></span><br><span class="line">        <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> disableOtaDexopt = SystemProperties.getBoolean(<span class="string">&quot;config.disable_otadexopt&quot;</span>,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!disableOtaDexopt) &#123;</span><br><span class="line">                traceBeginAndSlog(<span class="string">&quot;StartOtaDexOptService&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">&quot;moveab&quot;</span>);</span><br><span class="line">                    <span class="comment">// OTADexOpt(OTA下载dex并优化，用于OTA升级)使能时，启动OTA升级服务</span></span><br><span class="line">                    OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    reportWtf(<span class="string">&quot;starting OtaDexOptService&quot;</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">&quot;moveab&quot;</span>);</span><br><span class="line">                    traceEnd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>startBootstrapServices()启动阶段首先启动Installer服务，也就是安装器，随后判断当前的设备是否处于加密状态，如果是则只是解析核心应用，接着调用PackageManagerService的静态方法main来创建pms对象。</p>
<ul>
<li>第一步： 启动Installer服务</li>
<li>第二步： 获取设备是否加密(手机设置密码)，如果设备加密了，则只解析”core”应用</li>
<li>第三步： 调用PKMS main方法初始化PackageManagerService，其中调用PackageManagerService()构造函数创建了PKMS对象</li>
<li>第四步： 如果设备没有加密，操作它。管理A/B OTA dexopting。  </li>
</ul>
<h4 id="3-2-startOtherServices-阶段"><a href="#3-2-startOtherServices-阶段" class="headerlink" title="3.2 startOtherServices()阶段"></a>3.2 startOtherServices()阶段</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;UpdatePackagesIfNeeded&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">&quot;dexopt&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO =========step5：如果设备没有加密，执行performDexOptUpdate完成Dex优化==========</span></span><br><span class="line">            mPackageManagerService.updatePackagesIfNeeded();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;update packages&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">&quot;dexopt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//TODO =========step6：完成磁盘维护============================</span></span><br><span class="line">        mPackageManagerService.performFstrimIfNeeded();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">&quot;performing fstrim&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//TODO ============================step7：PKMS启动完成==============</span></span><br><span class="line">        mPackageManagerService.systemReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在startOtherServices 阶段主要对dex进行优化，然后判断磁盘是否维护，最后通知PMKS准备就绪。</p>
<ul>
<li>第五步： 执行 updatePackagesIfNeeded ，完成dex优化；</li>
<li>第六步： 执行 performFstrimIfNeeded ，完成磁盘维护；</li>
<li>第七步： 调用systemReady，准备就绪。  </li>
</ul>
<h3 id="4-逐步分析PKMS启动过程中完成的任务"><a href="#4-逐步分析PKMS启动过程中完成的任务" class="headerlink" title="4.逐步分析PKMS启动过程中完成的任务"></a>4.逐步分析PKMS启动过程中完成的任务</h3><p>根据第三节看到系统启动阶段，PKMS参与了七项事件。第一项，第二项没什么好说的，为PMKS启动做准备，我们直接从第三步开始分析。</p>
<h4 id="4-1-调用PKMS-main方法初始化PackageManagerService"><a href="#4-1-调用PKMS-main方法初始化PackageManagerService" class="headerlink" title="4.1 调用PKMS main方法初始化PackageManagerService"></a>4.1 调用PKMS main方法初始化PackageManagerService</h4><p>第三步静态调用PackageManagerService的main方法，创建PKMS实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">            boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">        &#x2F;&#x2F; Self-check for initial settings.</span><br><span class="line">        &#x2F;&#x2F;检查编译相关的系统属性</span><br><span class="line">        PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;传入install和onlyCore来实例化PKMS</span><br><span class="line">        PackageManagerService m &#x3D; new PackageManagerService(context, installer,</span><br><span class="line">                factoryTest, onlyCore);</span><br><span class="line">        m.enableSystemUserPackages();</span><br><span class="line">        &#x2F;&#x2F;将PKMS服务增加到SM中</span><br><span class="line">        ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">        final PackageManagerNative pmn &#x3D; m.new PackageManagerNative();</span><br><span class="line">        ServiceManager.addService(&quot;package_native&quot;, pmn);</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面方法中可以看到主要完成三件事情，最重要的是第二步传入install和onlyCore来实例化PKMS。</p>
<p>PKMS构造方法非常长，有1100多行代码，我们先看图，然后逐步分析各个阶段完成的任务。</p>
<p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\PMKS构造方法.png" alt="PMKS构造方法"></p>
<p>总览PKMS构造方法，在构造方法中完成了五个任务，其中还有两把锁需要说明一下。</p>
<blockquote>
<p>两个重要的锁(mInstallLock、mPackages):<br>mInstallLock ：用来保护所有安装apk的访问权限，此操作通常涉及繁重的磁盘数据读写等操作，并且是单线程操作，故有时候会处理很慢,此锁不会在已经持有mPackages锁的情况下获得，反之，在已经持有mInstallLock锁的情况下，立即获取mPackages是安全的。<br>mPackages：用来解析内存中所有apk的package信息及相关状态。  </p>
</blockquote>
<p>下面开始分阶段分析PKMS构造方法。</p>
<h5 id="4-1-1-启动PKMS阶段"><a href="#4-1-1-启动PKMS阶段" class="headerlink" title="4.1.1 启动PKMS阶段"></a>4.1.1 启动PKMS阶段</h5><p>(1) 构造 DisplayMetrics ，保存分辨率等相关信息；<br>(2) 创建Installer对象，与installd交互；<br>(3) 创建mPermissionManager对象，进行权限管理；<br>(4) 构造Settings类，保存安装包信息，清除路径不存在的孤立应用，主要涉及/data/system/目录的<br>packages.xml，packages-backup.xml，packages.list，packages-stopped.xml，packages-stoppedbackup.xml等文件。<br>(5) 构造PackageDexOptimizer及DexManager类，处理dex优化；<br>(6) 创建SystemConfig实例，获取系统配置信息，配置共享lib库；<br>(7) 创建PackageManager的handler线程，循环处理外部安装相关消息。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    LockGuard.installLock(mPackages, LockGuard.INDEX_PACKAGES);</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;create package manager&quot;</span>);</span><br><span class="line">    <span class="comment">//============================第一阶段：启动PKMS================================</span></span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    mContext = context;</span><br><span class="line">    mFactoryTest = factoryTest;</span><br><span class="line">    mOnlyCore = onlyCore;</span><br><span class="line">    <span class="comment">//创建DisplayMetrics保存分辨率相关的信息</span></span><br><span class="line">    mMetrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">    mInstaller = installer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create sub-components that provide services / data. Order here is important.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">// Expose private service for system components to use.</span></span><br><span class="line">        <span class="comment">// 暴露私有服务给系统组件用</span></span><br><span class="line">        LocalServices.addService(</span><br><span class="line">                PackageManagerInternal.class, <span class="keyword">new</span> PackageManagerInternalImpl());</span><br><span class="line">        sUserManager = <span class="keyword">new</span> UserManagerService(context, <span class="keyword">this</span>,</span><br><span class="line">                <span class="keyword">new</span> UserDataPreparer(mInstaller, mInstallLock, mContext, mOnlyCore), mPackages);</span><br><span class="line">        mComponentResolver = <span class="keyword">new</span> ComponentResolver(sUserManager,</span><br><span class="line">                LocalServices.getService(PackageManagerInternal.class),</span><br><span class="line">                mPackages);</span><br><span class="line">        <span class="comment">//创建权限管理器</span></span><br><span class="line">        mPermissionManager = PermissionManagerService.create(context,</span><br><span class="line">                mPackages <span class="comment">/*externalLock*/</span>);</span><br><span class="line">        <span class="comment">// getDefaultPermissionGrantPolicy权限分组，只要用户同意一个权限，就赋予那一组权限。</span></span><br><span class="line">        <span class="comment">// 读取根|vendor|odm|oem|product/etc/default-permissions目录下的xml文件，给应用赋默认权限。</span></span><br><span class="line">        mDefaultPermissionPolicy = mPermissionManager.getDefaultPermissionGrantPolicy();</span><br><span class="line">        <span class="comment">//创建Settings，保存安装包信息，清除路径不存在的孤立应用，主要涉及/data/system/目录的</span></span><br><span class="line">        <span class="comment">//packages.xml，packages-backup.xml，packages.list，packages-stopped.xml，packages-stoppedbackup.</span></span><br><span class="line">        <span class="comment">//xml等文件。</span></span><br><span class="line">        mSettings = <span class="keyword">new</span> Settings(Environment.getDataDirectory(),</span><br><span class="line">                mPermissionManager.getPermissionSettings(), mPackages);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对应的UID赋值保存在settings中</span></span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.system&quot;</span>, Process.SYSTEM_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.phone&quot;</span>, RADIO_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.log&quot;</span>, LOG_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.nfc&quot;</span>, NFC_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.bluetooth&quot;</span>, BLUETOOTH_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.shell&quot;</span>, SHELL_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.se&quot;</span>, SE_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.networkstack&quot;</span>, NETWORKSTACK_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mPackageDexOptimizer = <span class="keyword">new</span> PackageDexOptimizer(installer, mInstallLock, context,</span><br><span class="line">            <span class="string">&quot;*dexopt*&quot;</span>);</span><br><span class="line">    mDexManager = <span class="keyword">new</span> DexManager(mContext, <span class="keyword">this</span>, mPackageDexOptimizer, installer, mInstallLock);</span><br><span class="line">    mArtManagerService = <span class="keyword">new</span> ArtManagerService(mContext, <span class="keyword">this</span>, installer, mInstallLock);</span><br><span class="line">    mMoveCallbacks = <span class="keyword">new</span> MoveCallbacks(FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    mViewCompiler = <span class="keyword">new</span> ViewCompiler(mInstallLock, mInstaller);</span><br><span class="line"></span><br><span class="line">    mOnPermissionChangeListeners = <span class="keyword">new</span> OnPermissionChangeListeners(</span><br><span class="line">            FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    getDefaultDisplayMetrics(context, mMetrics);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;get system config&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建SystemConfig实例，获取系统配置信息，配置共享lib库；</span></span><br><span class="line">    <span class="comment">// 配置文件目录：/etc/sysconfig、/etc/permissions</span></span><br><span class="line">    <span class="comment">//			  /vendor/etc/sysconfig、/vendor/etc/permissions</span></span><br><span class="line">    <span class="comment">//            /odm/etc/sysconfig、/odm/etc/permissions</span></span><br><span class="line">    <span class="comment">//            /oem/etc/sysconfig、/oem/etc/permissions</span></span><br><span class="line">    <span class="comment">//            /product/etc/sysconfig、/product/etc/permissions</span></span><br><span class="line">    SystemConfig systemConfig = SystemConfig.getInstance();</span><br><span class="line">    mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">    mProtectedPackages = <span class="keyword">new</span> ProtectedPackages(mContext);</span><br><span class="line"></span><br><span class="line">    mApexManager = <span class="keyword">new</span> ApexManager(context);</span><br><span class="line">    <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">    <span class="comment">// writer</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">//创建PackageManager的handler线程，循环处理外部安装相关消息。</span></span><br><span class="line">        <span class="comment">//就是一个HandlerThread，在子线程处理事件</span></span><br><span class="line">        mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">                Process.THREAD_PRIORITY_BACKGROUND, <span class="keyword">true</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        <span class="comment">// 应用handler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">        <span class="comment">// 进程记录handler</span></span><br><span class="line">        mProcessLoggingHandler = <span class="keyword">new</span> ProcessLoggingHandler();</span><br><span class="line">        <span class="comment">//将应用处理handler设置一个看门狗，超时时间10分钟，如果超时会重启这个线程，该线程里面会执行应用安装，拷贝，写设置等操作</span></span><br><span class="line">        Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line">        mInstantAppRegistry = <span class="keyword">new</span> InstantAppRegistry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 共享lib库配置,将共享库</span></span><br><span class="line">        ArrayMap&lt;String, SystemConfig.SharedLibraryEntry&gt; libConfig</span><br><span class="line">                = systemConfig.getSharedLibraries();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> builtInLibCount = libConfig.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; builtInLibCount; i++) &#123;</span><br><span class="line">            String name = libConfig.keyAt(i);</span><br><span class="line">            SystemConfig.SharedLibraryEntry entry = libConfig.valueAt(i);</span><br><span class="line">            addBuiltInSharedLibraryLocked(entry.filename, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 读取安装相关SELinux策略</span></span><br><span class="line">        SELinuxMMAC.readInstallPolicy();</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;loadFallbacks&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回栈加载,读取/system/framework/framework-res.apk中的com.android.internal.R.raw.fallback_categories属性</span></span><br><span class="line">        FallbackCategoryProvider.loadFallbacks();</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;read user settings&quot;</span>);</span><br><span class="line">        <span class="comment">//读取并解析/data/system下的XML文件</span></span><br><span class="line">        mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(<span class="keyword">false</span>));</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clean up orphaned packages for which the code path doesn&#x27;t exist</span></span><br><span class="line">        <span class="comment">// and they are an update to a system app - caused by bug/32321269</span></span><br><span class="line">        <span class="comment">// 清理代码路径不存在的孤立软件包</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> packageSettingCount = mSettings.mPackages.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = packageSettingCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!isExternal(ps) &amp;&amp; (ps.codePath == <span class="keyword">null</span> || !ps.codePath.exists())</span><br><span class="line">                    &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mSettings.mPackages.removeAt(i);</span><br><span class="line">                mSettings.enableSystemPackageLPw(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mOnlyCore &amp;&amp; mFirstBoot) &#123;</span><br><span class="line">            <span class="comment">// 如果是首次启动，也不是CORE应用，则拷贝预编译的DEX文件</span></span><br><span class="line">            requestCopyPreoptedFiles();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String customResolverActivityName = Resources.getSystem().getString(</span><br><span class="line">                R.string.config_customResolverActivity);</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(customResolverActivityName)) &#123;</span><br><span class="line">            mCustomResolverComponentName = ComponentName.unflattenFromString(</span><br><span class="line">                    customResolverActivityName);</span><br><span class="line">        &#125;</span><br><span class="line">        ......<span class="comment">// 以下是第二阶段代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看一下主流程中mSettings.readLPw方法，读取上一次系统运行扫描过的包信息。</p>
<p>在看这个方法之前，需要先看看Settings中一些目录配置。首先看看构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Settings(File dataDir, PermissionSettings permission,</span><br><span class="line">        Object lock) &#123;</span><br><span class="line">    mLock = lock;</span><br><span class="line">    mPermissions = permission;</span><br><span class="line">    mRuntimePermissionsPersistence = <span class="keyword">new</span> RuntimePermissionPersistence(mLock);</span><br><span class="line"></span><br><span class="line">    mSystemDir = <span class="keyword">new</span> File(dataDir, <span class="string">&quot;system&quot;</span>);</span><br><span class="line">    mSystemDir.mkdirs();</span><br><span class="line">    FileUtils.setPermissions(mSystemDir.toString(),</span><br><span class="line">            FileUtils.S_IRWXU|FileUtils.S_IRWXG</span><br><span class="line">            |FileUtils.S_IROTH|FileUtils.S_IXOTH,</span><br><span class="line">            -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//读packages.xml</span></span><br><span class="line">    mSettingsFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages.xml&quot;</span>);</span><br><span class="line">    mBackupSettingsFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages-backup.xml&quot;</span>);</span><br><span class="line">    mPackageListFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages.list&quot;</span>);</span><br><span class="line">    FileUtils.setPermissions(mPackageListFilename, <span class="number">0640</span>, SYSTEM_UID, PACKAGE_INFO_GID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File kernelDir = <span class="keyword">new</span> File(<span class="string">&quot;/config/sdcardfs&quot;</span>);</span><br><span class="line">    mKernelMappingFilename = kernelDir.exists() ? kernelDir : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deprecated: Needed for migration</span></span><br><span class="line">    mStoppedPackagesFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages-stopped.xml&quot;</span>);</span><br><span class="line">    mBackupStoppedPackagesFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages-stopped-backup.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到一共有五个文件需要处理：</p>
<blockquote>
<p>（1)  “/data/system/packages.xml” 所有安装app信息<br>（2)  “/data/system/packages-backup.xml” 所有安装app信息之备份的信息记录<br>  (3)  “/data/system/packages.list” 所有安装app信息<br>  (4)  “/data/system/packages-stopped.xml” 所有强制停止app信息<br>  (5)  “/data/system/packages-stopped-backup.xml” 所有强制停止app信息之备份的信息记录  </p>
</blockquote>
<p>以上5个文件共分为三组，简单的作用描述如下：</p>
<ul>
<li>packages.xml：PKMS 扫描完目标文件夹后会创建该文件。当系统进行程序安装、卸载和更新等操作时，均会更新该文件。该文件保存了系统中与 package 相关的一些信息。</li>
<li>packages.list：描述系统中存在的所有非系统自带的 APK 的信息。当这些程序有变动时，PKMS 就会更新该文件。</li>
<li>packages-stopped.xml：从系统自带的设置程序中进入应用程序页面，然后在选择强制停止（ForceStop）某个应用时，系统会将该应用的相关信息记录到此文件中。也就是该文件保存系统中被用户强制停止的 Package 的信息。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readLPw</span><span class="params">(<span class="meta">@NonNull</span> List&lt;UserInfo&gt; users)</span> </span>&#123;</span><br><span class="line">    FileInputStream str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 处理备份package文件，防止package.xml被破坏了解析问题。</span></span><br><span class="line"></span><br><span class="line">    mPendingPackages.clear();</span><br><span class="line">    mPastSignatures.clear();</span><br><span class="line">    mKeySetRefs.clear();</span><br><span class="line">    mInstallerPackages.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确保&quot;/data/system/packages.xml&quot;存在</span></span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mSettingsFilename.exists()) &#123;</span><br><span class="line">                mReadMessages.append(<span class="string">&quot;No settings file found\n&quot;</span>);</span><br><span class="line">                PackageManagerService.reportSettingsProblem(Log.INFO,</span><br><span class="line">                        <span class="string">&quot;No settings file; creating initial state&quot;</span>);</span><br><span class="line">                <span class="comment">// It&#x27;s enough to just touch version details to create them</span></span><br><span class="line">                <span class="comment">// with default values</span></span><br><span class="line">                findOrCreateVersion(StorageManager.UUID_PRIVATE_INTERNAL).forceCurrent();</span><br><span class="line">                findOrCreateVersion(StorageManager.UUID_PRIMARY_PHYSICAL).forceCurrent();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str = <span class="keyword">new</span> FileInputStream(mSettingsFilename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析&quot;/data/system/packages.xml&quot;</span></span><br><span class="line">        XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">        parser.setInput(str, StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line">            <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;package&quot;</span>)) &#123;</span><br><span class="line">                readPackageLPw(parser);  <span class="comment">// 解析package节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;permissions&quot;</span>)) &#123;</span><br><span class="line">                mPermissions.readPermissions(parser);  <span class="comment">// 解析permissions节点，将系统应用权限读到mPermissions中，以后其他应用设置shareduid就可以共享这些权限。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;permission-trees&quot;</span>)) &#123;</span><br><span class="line">                mPermissions.readPermissionTrees(parser);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;shared-user&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//创建 SharedUserSetting 对象并添加到 Settings 的成员变量 mSharedUsers 中，在 Android 系统中，多个 package 通过设置 sharedUserId 属性可以运行在同一个进程，共享同一个 UID</span></span><br><span class="line">                readSharedUserLPw(parser);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;preferred-packages&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// no longer used.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;preferred-activities&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// Upgrading from old single-user implementation;</span></span><br><span class="line">                </span><br><span class="line">             ......  <span class="comment">// 以上都是解析package.xml各个标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the build is setup to drop runtime permissions</span></span><br><span class="line">    <span class="comment">// on update drop the files before loading them.</span></span><br><span class="line">    <span class="comment">// 开发阶段可以将该配置设置成true,取消所有用户的运行时权限校验。</span></span><br><span class="line">    <span class="keyword">if</span> (PackageManagerService.CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE) &#123;</span><br><span class="line">        <span class="keyword">final</span> VersionInfo internal = getInternalVersion();</span><br><span class="line">        <span class="keyword">if</span> (!Build.FINGERPRINT.equals(internal.fingerprint)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (UserInfo user : users) &#123;</span><br><span class="line">                mRuntimePermissionsPersistence.deleteUserRuntimePermissionsFile(user.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make sure all the updated system packages have their shared users</span></span><br><span class="line"><span class="comment">     * associated with them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 确保所有更新的系统包都有与其关联的共享用户</span></span><br><span class="line">    <span class="keyword">final</span> Iterator&lt;PackageSetting&gt; disabledIt = mDisabledSysPackages.values().iterator();</span><br><span class="line">    <span class="keyword">while</span> (disabledIt.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">final</span> PackageSetting disabledPs = disabledIt.next();</span><br><span class="line">        <span class="keyword">final</span> Object id = getSettingLPr(disabledPs.appId);</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id <span class="keyword">instanceof</span> SharedUserSetting) &#123;</span><br><span class="line">            disabledPs.sharedUser = (SharedUserSetting) id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	.......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-1-2-扫描系统中的包"><a href="#4-1-2-扫描系统中的包" class="headerlink" title="4.1.2  扫描系统中的包"></a>4.1.2  扫描系统中的包</h5><p>(1) 从init.rc中获取环境变量BOOTCLASSPATH和SYSTEMSERVERCLASSPATH；<br>(2) 对于旧版本升级的情况，将安装时获取权限变更为运行时申请权限；<br>(3) 扫描system/vendor/product/odm/oem等目录的priv-app、app、overlay包；<br>(4) 清除安装时临时文件以及其他不必要的信息。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录开机扫描时间</span></span><br><span class="line">   <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">//============第二阶段会扫描系统中所有应用，并且加入到对应的列表中============</span></span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">            startTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从init.rc中获取环境变量</span></span><br><span class="line">    <span class="keyword">final</span> String bootClassPath = System.getenv(<span class="string">&quot;BOOTCLASSPATH&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> String systemServerClassPath = System.getenv(<span class="string">&quot;SYSTEMSERVERCLASSPATH&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取system/framework目录</span></span><br><span class="line">    File frameworkDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">&quot;framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内部版本</span></span><br><span class="line">    <span class="keyword">final</span> VersionInfo ver = mSettings.getInternalVersion();</span><br><span class="line">    <span class="comment">// 判断fingerprint是否有更新</span></span><br><span class="line">    mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</span><br><span class="line">    <span class="keyword">if</span> (mIsUpgrade) &#123;</span><br><span class="line">        logCriticalInfo(Log.INFO,</span><br><span class="line">                <span class="string">&quot;Upgrading from &quot;</span> + ver.fingerprint + <span class="string">&quot; to &quot;</span> + Build.FINGERPRINT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when upgrading from pre-M, promote system app permissions from install to runtime</span></span><br><span class="line">    <span class="comment">//对于Android M之前版本升级上来的情况，需将系统应用程序权限从安装升级到运行时</span></span><br><span class="line">    mPromoteSystemApps =</span><br><span class="line">            mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When upgrading from pre-N, we need to handle package extraction like first boot,</span></span><br><span class="line">    <span class="comment">// as there is no profiling data available.</span></span><br><span class="line">    <span class="comment">// 对于Android N之前版本升级上来的情况，需像首次启动一样处理package</span></span><br><span class="line">    mIsPreNUpgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N;</span><br><span class="line"></span><br><span class="line">    mIsPreNMR1Upgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N_MR1;</span><br><span class="line">    mIsPreQUpgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.Q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> preUpgradeSdkVersion = ver.sdkVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save off the names of pre-existing system packages prior to scanning; we don&#x27;t</span></span><br><span class="line">    <span class="comment">// want to automatically grant runtime permissions for new system apps</span></span><br><span class="line">    <span class="comment">// 在扫描之前保存预先存在的系统package的名称，不希望自动为新系统应用授予运行时权限</span></span><br><span class="line">    <span class="keyword">if</span> (mPromoteSystemApps) &#123;</span><br><span class="line">        Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</span><br><span class="line">        <span class="keyword">while</span> (pkgSettingIter.hasNext()) &#123;</span><br><span class="line">            PackageSetting ps = pkgSettingIter.next();</span><br><span class="line">            <span class="keyword">if</span> (isSystemApp(ps)) &#123;</span><br><span class="line">                mExistingSystemPackages.add(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析package的缓存路径</span></span><br><span class="line">    mCacheDir = preparePackageParserCache();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag to monitor and not change apk file paths when</span></span><br><span class="line">    <span class="comment">// scanning install directories.</span></span><br><span class="line">    <span class="comment">// 设置flag，不在扫描安装时更改文件路径</span></span><br><span class="line">    <span class="keyword">int</span> scanFlags = SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line">    <span class="keyword">if</span> (mIsUpgrade || mFirstBoot) &#123;</span><br><span class="line">        scanFlags = scanFlags | SCAN_FIRST_BOOT_OR_UPGRADE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect vendor/product/product_services overlay packages. (Do this before scanning</span></span><br><span class="line">    <span class="comment">// any apps.)</span></span><br><span class="line">    <span class="comment">// For security and version matching reason, only consider overlay packages if they</span></span><br><span class="line">    <span class="comment">// reside in the right directory.</span></span><br><span class="line">    <span class="comment">// 首先扫描vendor/product/product_services的overlay目录下的apk</span></span><br><span class="line">    <span class="comment">// 路径包括：/vendor/overlay、/product/overlay、/product_services/overlay、/odm/overlay、/oem/overlay、 /system/framework、/system/priv-app、/system/app、/vendor/priv-app、/vendor/app、/odm/priv-app、/odm/app、/oem/app、/oem/priv-app、/product/priv-app、/product/app、/product_services/priv-app、/product_services/app、/product_services/priv-app</span></span><br><span class="line">    <span class="comment">//扫描传入目录的所有apk文件</span></span><br><span class="line">    scanDirTracedLI(<span class="keyword">new</span> File(VENDOR_OVERLAY_DIR),</span><br><span class="line">            mDefParseFlags</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">            scanFlags</span><br><span class="line">            | SCAN_AS_SYSTEM</span><br><span class="line">            | SCAN_AS_VENDOR,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    mParallelPackageParserCallback.findStaticOverlayPackages();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find base frameworks (resource packages without code).</span></span><br><span class="line">    <span class="comment">// 扫描fw中的apk,</span></span><br><span class="line">    scanDirTracedLI(frameworkDir,</span><br><span class="line">            mDefParseFlags</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">            scanFlags</span><br><span class="line">            | SCAN_NO_DEX</span><br><span class="line">            | SCAN_AS_SYSTEM</span><br><span class="line">            | SCAN_AS_PRIVILEGED,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mPackages.containsKey(<span class="string">&quot;android&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;Failed to load frameworks package; check log for warnings&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect privileged system packages.</span></span><br><span class="line">    <span class="comment">// 扫描特权目录下的apk，即/system/framework/framework-res.apk，这个包里面全是资源文件，没有代码</span></span><br><span class="line">    <span class="keyword">final</span> File privilegedAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">    scanDirTracedLI(privilegedAppDir,</span><br><span class="line">            mDefParseFlags</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">            scanFlags</span><br><span class="line">            | SCAN_AS_SYSTEM</span><br><span class="line">            | SCAN_AS_PRIVILEGED,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect ordinary system packages.</span></span><br><span class="line">    <span class="comment">//扫描system/app目录下的apk</span></span><br><span class="line">    <span class="keyword">final</span> File systemAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">    scanDirTracedLI(systemAppDir,</span><br><span class="line">            mDefParseFlags</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">            scanFlags</span><br><span class="line">            | SCAN_AS_SYSTEM,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ...... <span class="comment">// 这之间的代码都是扫描上面列出来目录中的apk</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prune any system packages that no longer exist.</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; possiblyDeletedUpdatedSystemApps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Stub packages must either be replaced with full versions in the /data</span></span><br><span class="line">    <span class="comment">// partition or be disabled.</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; stubSystemApps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 删掉不存在的package</span></span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        <span class="comment">// do this first before mucking with mPackages for the &quot;expecting better&quot; case</span></span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;PackageParser.Package&gt; pkgIterator = mPackages.values().iterator();</span><br><span class="line">        <span class="keyword">while</span> (pkgIterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">final</span> PackageParser.Package pkg = pkgIterator.next();</span><br><span class="line">            <span class="keyword">if</span> (pkg.isStub) &#123;</span><br><span class="line">                stubSystemApps.add(pkg.packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">        <span class="keyword">while</span> (psit.hasNext()) &#123;</span><br><span class="line">            PackageSetting ps = psit.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If this is not a system app, it can&#x27;t be a</span></span><br><span class="line"><span class="comment">             * disable system app.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 如果不是系统应用，则不被允许disable</span></span><br><span class="line">            <span class="keyword">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If the package is scanned, it&#x27;s not erased.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 如果应用被扫描，则不允许被删除</span></span><br><span class="line">            <span class="keyword">final</span> PackageParser.Package scannedPkg = mPackages.get(ps.name);</span><br><span class="line">            <span class="keyword">if</span> (scannedPkg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * If the system app is both scanned and in the</span></span><br><span class="line"><span class="comment">                 * disabled packages list, then it must have been</span></span><br><span class="line"><span class="comment">                 * added via OTA. Remove it from the currently</span></span><br><span class="line"><span class="comment">                 * scanned package so the previously user-installed</span></span><br><span class="line"><span class="comment">                 * application can be scanned.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//如果扫描出来的系统apk在禁用列表中，它将从扫描列表中删除，只能通过OTA再次添加进来</span></span><br><span class="line">                <span class="keyword">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                    ....</span><br><span class="line">                    removePackageLI(scannedPkg, <span class="keyword">true</span>);</span><br><span class="line">                    mExpectingBetter.put(ps.name, ps.codePath);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                psit.remove();</span><br><span class="line">                logCriticalInfo(Log.WARN, <span class="string">&quot;System package &quot;</span> + ps.name</span><br><span class="line">                        + <span class="string">&quot; no longer exists; it&#x27;s data will be wiped&quot;</span>);</span><br><span class="line">                <span class="comment">// Actual deletion of code and data will be handled by later</span></span><br><span class="line">                <span class="comment">// reconciliation step</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we still have a disabled system package, but, it still might have</span></span><br><span class="line">                <span class="comment">// been removed. check the code path still exists and check there&#x27;s</span></span><br><span class="line">                <span class="comment">// still a package. the latter can happen if an OTA keeps the same</span></span><br><span class="line">                <span class="comment">// code path, but, changes the package name.</span></span><br><span class="line">                <span class="keyword">final</span> PackageSetting disabledPs =</span><br><span class="line">                        mSettings.getDisabledSystemPkgLPr(ps.name);</span><br><span class="line">                <span class="keyword">if</span> (disabledPs.codePath == <span class="keyword">null</span> || !disabledPs.codePath.exists()</span><br><span class="line">                        || disabledPs.pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果系统应用路径，apk包，代码都不存在的话，就把这个应用加到删除系统应用的列表中</span></span><br><span class="line">                    possiblyDeletedUpdatedSystemApps.add(ps.name);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re expecting that the system app should remain disabled, but add</span></span><br><span class="line">                    <span class="comment">// it to expecting better to recover in case the data version cannot</span></span><br><span class="line">                    <span class="comment">// be scanned.</span></span><br><span class="line">                    <span class="comment">//如果apk还在，希望系统应用程序应该保持禁用状态，但是如果数据版本无法被扫描，则添加到恢复列表中。</span></span><br><span class="line">                    mExpectingBetter.put(disabledPs.name, disabledPs.codePath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete tmp files</span></span><br><span class="line">    <span class="comment">// 删除临时文件</span></span><br><span class="line">    deleteTempPackageFiles();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cachedSystemApps = PackageParser.sCachedPackageReadCount.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any shared userIDs that have no associated packages</span></span><br><span class="line">    <span class="comment">// 删除没有关联的UID标识</span></span><br><span class="line">    mSettings.pruneSharedUsersLPw();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> systemScanTime = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> systemPackagesCount = mPackages.size();</span><br><span class="line">    Slog.i(TAG, <span class="string">&quot;Finished scanning system apps. Time: &quot;</span> + systemScanTime</span><br><span class="line">            + <span class="string">&quot; ms, packageCount: &quot;</span> + systemPackagesCount</span><br><span class="line">            + <span class="string">&quot; , timePerPackage: &quot;</span></span><br><span class="line">            + (systemPackagesCount == <span class="number">0</span> ? <span class="number">0</span> : systemScanTime / systemPackagesCount)</span><br><span class="line">            + <span class="string">&quot; , cached: &quot;</span> + cachedSystemApps);</span><br><span class="line">    <span class="keyword">if</span> (mIsUpgrade &amp;&amp; systemPackagesCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;ota_package_manager_system_app_avg_scan_time&quot;</span>,</span><br><span class="line">                ((<span class="keyword">int</span>) systemScanTime) / systemPackagesCount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......<span class="comment">// 以下代码是第三阶段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-1-3-扫描data目录下的apk"><a href="#4-1-3-扫描data目录下的apk" class="headerlink" title="4.1.3 扫描data目录下的apk"></a>4.1.3 扫描data目录下的apk</h5><p>对于不仅仅解析核心应用的情况下，还处理data目录的应用信息，及时更新，祛除不必要的数据。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        <span class="comment">//=======================第三阶段：扫描data目录下的数据(用户自己安装的apk)扫描/data/app目录</span></span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">        scanDirTracedLI(sAppInstallDir, <span class="number">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove disable package settings for updated system apps that were</span></span><br><span class="line">        <span class="comment">// removed via an OTA. If the update is no longer present, remove the</span></span><br><span class="line">        <span class="comment">// app completely. Otherwise, revoke their system privileges.</span></span><br><span class="line">        <span class="comment">// 这个for循环，移除通过OTA删除的更新系统应用程序的禁用package设置</span></span><br><span class="line">        <span class="comment">// 如果更新不再存在，则完全删除该应用。否则，撤消其系统权限</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = possiblyDeletedUpdatedSystemApps.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">final</span> String packageName = possiblyDeletedUpdatedSystemApps.get(i);</span><br><span class="line">            <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(packageName);</span><br><span class="line">            <span class="keyword">final</span> String msg;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remove from the disabled system list; do this first so any future</span></span><br><span class="line">            <span class="comment">// scans of this package are performed without this state</span></span><br><span class="line">            mSettings.removeDisabledSystemPackageLPw(packageName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// should have found an update, but, we didn&#x27;t; remove everything</span></span><br><span class="line">                msg = <span class="string">&quot;Updated system package &quot;</span> + packageName</span><br><span class="line">                        + <span class="string">&quot; no longer exists; removing its data&quot;</span>;</span><br><span class="line">                <span class="comment">// Actual deletion of code and data will be handled by later</span></span><br><span class="line">                <span class="comment">// reconciliation step</span></span><br><span class="line">                <span class="comment">// 如果进入到这个if语句，说明被更新的APK不存在了，需要清理他的data数据，但是这里原生什么也没做，意思是没有真正删除原来被禁用apk的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// found an update; revoke system privileges</span></span><br><span class="line">                msg = <span class="string">&quot;Updated system package &quot;</span> + packageName</span><br><span class="line">                        + <span class="string">&quot; no longer exists; rescanning package on data&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> We don&#x27;t do anything special if a stub is removed from the</span></span><br><span class="line">                <span class="comment">// system image. But, if we were [like removing the uncompressed</span></span><br><span class="line">                <span class="comment">// version from the /data partition], this is where it&#x27;d be done.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// remove the package from the system and re-scan it without any</span></span><br><span class="line">                <span class="comment">// special privileges</span></span><br><span class="line">                <span class="comment">// 删除应用包，并且重新扫描原来的APK路径</span></span><br><span class="line">                removePackageLI(pkg, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> File codePath = <span class="keyword">new</span> File(pkg.applicationInfo.getCodePath());</span><br><span class="line">                    scanPackageTracedLI(codePath, <span class="number">0</span>, scanFlags, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">&quot;Failed to parse updated, ex-system package: &quot;</span></span><br><span class="line">                            + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// one final check. if we still have a package setting [ie. it was</span></span><br><span class="line">            <span class="comment">// previously scanned and known to the system], but, we don&#x27;t have</span></span><br><span class="line">            <span class="comment">// a package [ie. there was an error scanning it from the /data</span></span><br><span class="line">            <span class="comment">// partition], completely remove the package data.</span></span><br><span class="line">            <span class="comment">// 删除应用包的数据</span></span><br><span class="line">            <span class="keyword">final</span> PackageSetting ps = mSettings.mPackages.get(packageName);</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="keyword">null</span> &amp;&amp; mPackages.get(packageName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                removePackageDataLIF(ps, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            logCriticalInfo(Log.WARN, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Make sure all system apps that we expected to appear on</span></span><br><span class="line"><span class="comment">         * the userdata partition actually showed up. If they never</span></span><br><span class="line"><span class="comment">         * appeared, crawl back and revive the system version.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 确保所有在/data分区的应用都是真实存在的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String packageName = mExpectingBetter.keyAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!mPackages.containsKey(packageName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> File scanFile = mExpectingBetter.valueAt(i);</span><br><span class="line"></span><br><span class="line">                logCriticalInfo(Log.WARN, <span class="string">&quot;Expected better &quot;</span> + packageName</span><br><span class="line">                        + <span class="string">&quot; but never showed up; reverting to system&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="meta">@ParseFlags</span> <span class="keyword">int</span> reparseFlags;</span><br><span class="line">                <span class="keyword">final</span> <span class="meta">@ScanFlags</span> <span class="keyword">int</span> rescanFlags;</span><br><span class="line">                <span class="comment">// 确保检查的apk在如上第二步列出的路径中</span></span><br><span class="line">                <span class="keyword">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</span><br><span class="line">                    reparseFlags =</span><br><span class="line">                            mDefParseFlags |</span><br><span class="line">                            PackageParser.PARSE_IS_SYSTEM_DIR;</span><br><span class="line">                    rescanFlags =</span><br><span class="line">                            scanFlags</span><br><span class="line">                            | SCAN_AS_SYSTEM</span><br><span class="line">                            | SCAN_AS_PRIVILEGED;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FileUtils.contains(systemAppDir, scanFile)) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过以上判断之后，该应用确实真实可用的，然后就把他从不可用列表中移除</span></span><br><span class="line">                mSettings.enableSystemPackageLPw(packageName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//重新扫描这个apk文件</span></span><br><span class="line">                    scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">&quot;Failed to parse original system package: &quot;</span></span><br><span class="line">                            + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Uncompress and install any stubbed system applications.</span></span><br><span class="line">        <span class="comment">// This must be done last to ensure all stubs are replaced or disabled.</span></span><br><span class="line">        <span class="comment">// 解压缩并安装任何存根系统应用程序。这必须最后完成，以确保所有存根被替换或禁用。</span></span><br><span class="line">        installSystemStubPackages(stubSystemApps, scanFlags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cachedNonSystemApps = PackageParser.sCachedPackageReadCount.get()</span><br><span class="line">                        - cachedSystemApps;</span><br><span class="line">        <span class="comment">// 打印扫描所有data分区中APK的时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dataScanTime = SystemClock.uptimeMillis() - systemScanTime - startTime;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dataPackagesCount = mPackages.size() - systemPackagesCount;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Finished scanning non-system apps. Time: &quot;</span> + dataScanTime</span><br><span class="line">                + <span class="string">&quot; ms, packageCount: &quot;</span> + dataPackagesCount</span><br><span class="line">                + <span class="string">&quot; , timePerPackage: &quot;</span></span><br><span class="line">                + (dataPackagesCount == <span class="number">0</span> ? <span class="number">0</span> : dataScanTime / dataPackagesCount)</span><br><span class="line">                + <span class="string">&quot; , cached: &quot;</span> + cachedNonSystemApps);</span><br><span class="line">        <span class="keyword">if</span> (mIsUpgrade &amp;&amp; dataPackagesCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;ota_package_manager_data_app_avg_scan_time&quot;</span>,</span><br><span class="line">                    ((<span class="keyword">int</span>) dataScanTime) / dataPackagesCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mExpectingBetter.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resolve the storage manager.</span></span><br><span class="line">    <span class="comment">// 获取StorageManager的包名</span></span><br><span class="line">    mStorageManagerPackage = getStorageManagerPackageName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resolve protected action filters. Only the setup wizard is allowed to</span></span><br><span class="line">    <span class="comment">// have a high priority filter for these actions.</span></span><br><span class="line">    <span class="comment">// 处理受保护的action过滤器。只允许setup wizard（开机向导）为这些action设置高优先级过滤器</span></span><br><span class="line">    mSetupWizardPackage = getSetupWizardPackageName();</span><br><span class="line">    mComponentResolver.fixProtectedFilterPriorities();</span><br><span class="line"></span><br><span class="line">    mSystemTextClassifierPackage = getSystemTextClassifierPackageName();</span><br><span class="line"></span><br><span class="line">    mWellbeingPackage = getWellbeingPackageName();</span><br><span class="line">    mDocumenterPackage = getDocumenterPackageName();</span><br><span class="line">    mConfiguratorPackage =</span><br><span class="line">            mContext.getString(R.string.config_deviceConfiguratorPackageName);</span><br><span class="line">    mAppPredictionServicePackage = getAppPredictionServicePackageName();</span><br><span class="line">    mIncidentReportApproverPackage = getIncidentReportApproverPackageName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we know all of the shared libraries, update all clients to have</span></span><br><span class="line">    <span class="comment">// the correct library paths.</span></span><br><span class="line">    <span class="comment">// 由于更新了所有共享库，更新所有的应用以确保这些更新库之后运行起没有问题</span></span><br><span class="line">    updateAllSharedLibrariesLocked(<span class="keyword">null</span>, Collections.unmodifiableMap(mPackages));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> We ignore potential failures here during a system scan (like</span></span><br><span class="line">        <span class="comment">// the rest of the commands above) because there&#x27;s precious little we</span></span><br><span class="line">        <span class="comment">// can do about it. A settings error is reported, though.</span></span><br><span class="line">        <span class="comment">// 调整Abis让所有拥有sharedUserId的app都能调用</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; changedAbiCodePath =</span><br><span class="line">                adjustCpuAbisForSharedUserLPw(setting.packages, <span class="keyword">null</span> <span class="comment">/*scannedPackage*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (changedAbiCodePath != <span class="keyword">null</span> &amp;&amp; changedAbiCodePath.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = changedAbiCodePath.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">final</span> String codePathString = changedAbiCodePath.get(i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mInstaller.rmdex(codePathString,</span><br><span class="line">                            getDexCodeInstructionSet(getPreferredInstructionSet()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstallerException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Adjust seInfo to ensure apps which share a sharedUserId are placed in the same</span></span><br><span class="line">        <span class="comment">// SELinux domain.</span></span><br><span class="line">        <span class="comment">// 调整seInfo，确保拥有一个sharedUserId的app属于SeLinux的域中</span></span><br><span class="line">        setting.fixSeInfoLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we know all the packages we are keeping,</span></span><br><span class="line">    <span class="comment">// read and update their last usage times.</span></span><br><span class="line">    <span class="comment">// 更新用户的使用时间，数据埋点功能采集用户使用数据可以用到</span></span><br><span class="line">    mPackageUsage.read(mPackages);</span><br><span class="line">    mCompilerStats.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-1-4-扫描结束，更新package-xml"><a href="#4-1-4-扫描结束，更新package-xml" class="headerlink" title="4.1.4 扫描结束，更新package.xml"></a>4.1.4 扫描结束，更新package.xml</h5><p>(1) sdk版本变更，更新权限；<br>(2) OTA升级后首次启动，清除不必要的缓存数据；<br>(3) 权限等默认项更新完后，清理相关数据；<br>(4) 更新package.xml  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//========================第四阶段：扫描结束，更新package.xml=======================</span></span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">    Slog.i(TAG, <span class="string">&quot;Time to scan packages: &quot;</span></span><br><span class="line">            + ((SystemClock.uptimeMillis()-startTime)/<span class="number">1000f</span>)</span><br><span class="line">            + <span class="string">&quot; seconds&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the platform SDK has changed since the last time we booted,</span></span><br><span class="line">    <span class="comment">// we need to re-grant app permission to catch any new ones that</span></span><br><span class="line">    <span class="comment">// appear.  This is really a hack, and means that apps can in some</span></span><br><span class="line">    <span class="comment">// cases get permissions that the user didn&#x27;t initially explicitly</span></span><br><span class="line">    <span class="comment">// allow...  it would be nice to have some better way to handle</span></span><br><span class="line">    <span class="comment">// this situation.</span></span><br><span class="line">    <span class="comment">// 如果platform sdk从上次启动之后更新了，那需要重新给app更新权限</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sdkUpdated = (ver.sdkVersion != mSdkVersion);</span><br><span class="line">    <span class="keyword">if</span> (sdkUpdated) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Platform changed from &quot;</span> + ver.sdkVersion + <span class="string">&quot; to &quot;</span></span><br><span class="line">                + mSdkVersion + <span class="string">&quot;; regranting permissions for internal storage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新权限</span></span><br><span class="line">    mPermissionManager.updateAllPermissions(</span><br><span class="line">            StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, mPackages.values(),</span><br><span class="line">            mPermissionCallback);</span><br><span class="line">    ver.sdkVersion = mSdkVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is the first boot or an update from pre-M, and it is a normal</span></span><br><span class="line">    <span class="comment">// boot, then we need to initialize the default preferred apps across</span></span><br><span class="line">    <span class="comment">// all defined users.</span></span><br><span class="line">    <span class="comment">// 如果是第一次启动，或者从Android M之前升级上来的系统，并且启动正常。</span></span><br><span class="line">    <span class="comment">// 那需要在所有已定义的用户中初始化默认的首选应用程序</span></span><br><span class="line">    <span class="keyword">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (UserInfo user : sUserManager.getUsers(<span class="keyword">true</span>)) &#123;</span><br><span class="line">            mSettings.applyDefaultPreferredAppsLPw(user.id);</span><br><span class="line">            primeDomainVerificationsLPw(user.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare storage for system user really early during boot,</span></span><br><span class="line">    <span class="comment">// since core system apps like SettingsProvider and SystemUI</span></span><br><span class="line">    <span class="comment">// can&#x27;t wait for user to start</span></span><br><span class="line">    <span class="comment">// 为系统用户准备内存，因为SettingsProvider和SystemUI不可能等待用户去启动</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> storageFlags;</span><br><span class="line">    <span class="keyword">if</span> (StorageManager.isFileEncryptedNativeOrEmulated()) &#123;</span><br><span class="line">        storageFlags = StorageManager.FLAG_STORAGE_DE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is first boot after an OTA, and a normal boot, then</span></span><br><span class="line">    <span class="comment">// we need to clear code cache directories.</span></span><br><span class="line">    <span class="comment">// Note that we do *not* clear the application profiles. These remain valid</span></span><br><span class="line">    <span class="comment">// across OTAs and are used to drive profile verification (post OTA) and</span></span><br><span class="line">    <span class="comment">// profile compilation (without waiting to collect a fresh set of profiles).</span></span><br><span class="line">    <span class="comment">// 如果是在OTA之后首次启动，并且正常启动，那需要清除代码缓存目录，但不清除应用程序配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Build fingerprint changed; clearing code caches&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</span><br><span class="line">                <span class="comment">// No apps are running this early, so no need to freeze</span></span><br><span class="line">                clearAppDataLIF(ps.pkg, UserHandle.USER_ALL,</span><br><span class="line">                        FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL</span><br><span class="line">                                | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ver.fingerprint = Build.FINGERPRINT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grandfather existing (installed before Q) non-system apps to hide</span></span><br><span class="line">    <span class="comment">// their icons in launcher.</span></span><br><span class="line">    <span class="comment">// 安装Android-Q前的非系统应用程序在Launcher中隐藏他们的图标</span></span><br><span class="line">    <span class="keyword">if</span> (!onlyCore &amp;&amp; mIsPreQUpgrade) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Whitelisting all existing apps to hide their icons&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> size = mSettings.mPackages.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ps.disableComponentLPw(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME,</span><br><span class="line">                    UserHandle.USER_SYSTEM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear only after permissions and other defaults have been updated</span></span><br><span class="line">    <span class="comment">// mExistingSystemPackages是在收到OTA之前跟踪现有的系统包列表，他将被清空，当权限和默认设置被更新处理完成之后</span></span><br><span class="line">    mExistingSystemPackages.clear();</span><br><span class="line">    mPromoteSystemApps = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All the changes are done during package scanning.</span></span><br><span class="line">    ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// can downgrade to reader</span></span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;write settings&quot;</span>);</span><br><span class="line">    <span class="comment">// 将settings中的数据写回到package.xml中</span></span><br><span class="line">    mSettings.writeLPr();</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-1-5-GC回收内存"><a href="#4-1-5-GC回收内存" class="headerlink" title="4.1.5 GC回收内存"></a>4.1.5 GC回收内存</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//=========================第五阶段：GC回收内存================================</span></span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">            mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();</span><br><span class="line">            mRequiredInstallerPackage = getRequiredInstallerLPr();</span><br><span class="line">            mRequiredUninstallerPackage = getRequiredUninstallerLPr();</span><br><span class="line">            mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</span><br><span class="line">            <span class="keyword">if</span> (mIntentFilterVerifierComponent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mIntentFilterVerifier = <span class="keyword">new</span> IntentVerifierProxy(mContext,</span><br><span class="line">                        mIntentFilterVerifierComponent);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mIntentFilterVerifier = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(</span><br><span class="line">                    PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES,</span><br><span class="line">                    SharedLibraryInfo.VERSION_UNDEFINED);</span><br><span class="line">            mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr(</span><br><span class="line">                    PackageManager.SYSTEM_SHARED_LIBRARY_SHARED,</span><br><span class="line">                    SharedLibraryInfo.VERSION_UNDEFINED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRequiredVerifierPackage = <span class="keyword">null</span>;</span><br><span class="line">            mRequiredInstallerPackage = <span class="keyword">null</span>;</span><br><span class="line">            mRequiredUninstallerPackage = <span class="keyword">null</span>;</span><br><span class="line">            mIntentFilterVerifierComponent = <span class="keyword">null</span>;</span><br><span class="line">            mIntentFilterVerifier = <span class="keyword">null</span>;</span><br><span class="line">            mServicesSystemSharedLibraryPackageName = <span class="keyword">null</span>;</span><br><span class="line">            mSharedSystemSharedLibraryPackageName = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PermissionController hosts default permission granting and role management, so it&#x27;s a</span></span><br><span class="line">        <span class="comment">// critical part of the core system.</span></span><br><span class="line">        <span class="comment">// PermissionController主持这授予默认权限和角色管理，他是系统的关键组成部分</span></span><br><span class="line">        mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize InstantAppRegistry&#x27;s Instant App list for all users.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] userIds = UserManagerService.getInstance().getUserIds();</span><br><span class="line">        <span class="keyword">for</span> (PackageParser.Package pkg : mPackages.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pkg.isSystem()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> userId : userIds) &#123;</span><br><span class="line">                <span class="keyword">final</span> PackageSetting ps = (PackageSetting) pkg.mExtras;</span><br><span class="line">                <span class="keyword">if</span> (ps == <span class="keyword">null</span> || !ps.getInstantApp(userId) || !ps.getInstalled(userId)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mInstantAppRegistry.addInstantAppLPw(userId, ps.appId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstallerService = <span class="keyword">new</span> PackageInstallerService(context, <span class="keyword">this</span>, mApexManager);</span><br><span class="line">        <span class="keyword">final</span> Pair&lt;ComponentName, String&gt; instantAppResolverComponent =</span><br><span class="line">                getInstantAppResolverLPr();</span><br><span class="line">        <span class="keyword">if</span> (instantAppResolverComponent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_INSTANT) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">&quot;Set ephemeral resolver: &quot;</span> + instantAppResolverComponent);</span><br><span class="line">            &#125;</span><br><span class="line">            mInstantAppResolverConnection = <span class="keyword">new</span> InstantAppResolverConnection(</span><br><span class="line">                    mContext, instantAppResolverComponent.first,</span><br><span class="line">                    instantAppResolverComponent.second);</span><br><span class="line">            mInstantAppResolverSettingsComponent =</span><br><span class="line">                    getInstantAppResolverSettingsLPr(instantAppResolverComponent.first);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstantAppResolverConnection = <span class="keyword">null</span>;</span><br><span class="line">            mInstantAppResolverSettingsComponent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        updateInstantAppInstallerLocked(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read and update the usage of dex files.</span></span><br><span class="line">        <span class="comment">// Do this at the end of PM init so that all the packages have their</span></span><br><span class="line">        <span class="comment">// data directory reconciled.</span></span><br><span class="line">        <span class="comment">// At this point we know the code paths of the packages, so we can validate</span></span><br><span class="line">        <span class="comment">// the disk file and build the internal cache.</span></span><br><span class="line">        <span class="comment">// The usage file is expected to be small so loading and verifying it</span></span><br><span class="line">        <span class="comment">// should take a fairly small time compare to the other activities (e.g. package</span></span><br><span class="line">        <span class="comment">// scanning).</span></span><br><span class="line">        <span class="comment">// 阅读并更新dex文件的用法</span></span><br><span class="line">        <span class="comment">// 在PM init结束时执行此操作，以便所有程序包都已协调其数据目录</span></span><br><span class="line">        <span class="comment">// 此时知道了包的代码路径，因此可以验证磁盘文件并构建内部缓存</span></span><br><span class="line">        <span class="comment">// 使用文件预计很小，因此与其他活动（例如包扫描）相比，加载和验证它应该花费相当小的时间</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, List&lt;PackageInfo&gt;&gt; userPackages = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> userId : userIds) &#123;</span><br><span class="line">            userPackages.put(userId, getInstalledPackages(<span class="comment">/*flags*/</span> <span class="number">0</span>, userId).getList());</span><br><span class="line">        &#125;</span><br><span class="line">        mDexManager.load(userPackages);</span><br><span class="line">        <span class="keyword">if</span> (mIsUpgrade) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">&quot;ota_package_manager_init_time&quot;</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) (SystemClock.uptimeMillis() - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// synchronized (mPackages)</span></span><br><span class="line">    &#125; <span class="comment">// synchronized (mInstallLock)</span></span><br><span class="line"></span><br><span class="line">    mModuleInfoProvider = <span class="keyword">new</span> ModuleInfoProvider(mContext, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now after opening every single application zip, make sure they</span></span><br><span class="line">    <span class="comment">// are all flushed.  Not really needed, but keeps things nice and</span></span><br><span class="line">    <span class="comment">// tidy.</span></span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;GC&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开应用之后，及时回收处理</span></span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The initial scanning above does many calls into installd while</span></span><br><span class="line">    <span class="comment">// holding the mPackages lock, but we&#x27;re mostly interested in yelling</span></span><br><span class="line">    <span class="comment">// once we have a booted system.</span></span><br><span class="line">    <span class="comment">// 上面的初始扫描在持有mPackage锁的同时对installd进行了多次调用</span></span><br><span class="line">    mInstaller.setWarnIfHeld(mPackages);</span><br><span class="line"></span><br><span class="line">    PackageParser.readConfigUseRoundIcon(mContext.getResources());</span><br><span class="line"></span><br><span class="line">    mServiceStartWithDelay = SystemClock.uptimeMillis() + (<span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-2-APK的扫描"><a href="#4-2-APK的扫描" class="headerlink" title="4.2 APK的扫描"></a>4.2 APK的扫描</h4><p>PKMS的构造函数中调用了 scanDirTracedLI方法 来扫描某个目录的apk文件。  </p>
<p>Android10.0 和 其他低版本扫描的路径是不一样的：Android 10.0中，PKMS主要扫描以下路径的APK信息：  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vendor/overlay 系统的APP类别</span><br><span class="line">/product/overlay 系统的APP类别</span><br><span class="line">/product_services/overlay 系统的APP类别</span><br><span class="line">/odm/overlay 系统的APP类别</span><br><span class="line">/oem/overlay 系统的APP类别</span><br><span class="line">/system/framework 系统的APP类别</span><br><span class="line">/system/priv-app 系统的APP类别</span><br><span class="line">/system/app 系统的APP类别</span><br><span class="line">/vendor/priv-app 系统的APP类别</span><br><span class="line">/vendor/app 系统的APP类别</span><br><span class="line">/odm/priv-app 系统的APP类别</span><br><span class="line">/odm/app 系统的APP类别</span><br><span class="line">/oem/app 系统的APP类别</span><br><span class="line">/oem/priv-app 系统的APP类别</span><br><span class="line">/product/priv-app 系统的APP类别</span><br><span class="line">/product/app 系统的APP类别</span><br><span class="line">/product_services/priv-app 系统的APP类别</span><br><span class="line">/product_services/app 系统的APP类别</span><br><span class="line">/product_services/priv-app 系统的APP类别</span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\APK扫描.png" alt="APK扫描"></p>
<p>扫描包的流程如上图所示，通过扫描apk，最终将扫描过的apk封装成Package对象。下面我们来看一下PKMS是如何完成扫描的。</p>
<h5 id="4-2-1-scanDirLI"><a href="#4-2-1-scanDirLI" class="headerlink" title="4.2.1 scanDirLI"></a>4.2.1 scanDirLI</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirTracedLI</span><span class="params">(File scanDir, <span class="keyword">final</span> <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;scanDir [&quot;</span> + scanDir.getAbsolutePath() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 透传调用</span></span><br><span class="line">            scanDirLI(scanDir, parseFlags, scanFlags, currentTime);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File scanDir, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建并行扫描解析器</span></span><br><span class="line">        <span class="keyword">try</span> (ParallelPackageParser parallelPackageParser = <span class="keyword">new</span> ParallelPackageParser(</span><br><span class="line">                mSeparateProcesses, mOnlyCore, mMetrics, mCacheDir,</span><br><span class="line">                mParallelPackageParserCallback)) &#123;</span><br><span class="line">            <span class="comment">// Submit files for parsing in parallel</span></span><br><span class="line">            <span class="keyword">int</span> fileCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line">                        &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">                <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">                    <span class="comment">// Ignore entries which are not packages</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将APK文件交给submit准备解析</span></span><br><span class="line">                parallelPackageParser.submit(file, parseFlags);</span><br><span class="line">                fileCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process results one by one</span></span><br><span class="line">            <span class="keyword">for</span> (; fileCount &gt; <span class="number">0</span>; fileCount--) &#123;</span><br><span class="line">                ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();</span><br><span class="line">                Throwable throwable = parseResult.throwable;</span><br><span class="line">                <span class="keyword">int</span> errorCode = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// TODO(toddke): move lower in the scan chain</span></span><br><span class="line">                    <span class="comment">// Static shared libraries have synthetic package names</span></span><br><span class="line">                    <span class="keyword">if</span> (parseResult.pkg.applicationInfo.isStaticSharedLibrary()) &#123;</span><br><span class="line">                        renameStaticSharedLibraryPackage(parseResult.pkg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用 scanPackageChildLI 方法扫描一个特定的 apk 文件</span></span><br><span class="line">						<span class="comment">// 该类的实例代表一个 APK 文件，所以它就是和 apk 文件对应的数据结构</span></span><br><span class="line">                        scanPackageChildLI(parseResult.pkg, parseFlags, scanFlags,</span><br><span class="line">                                currentTime, <span class="keyword">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">                        errorCode = e.error;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Failed to scan &quot;</span> + parseResult.scanFile + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> PackageParser.PackageParserException) &#123;</span><br><span class="line">                    PackageParser.PackageParserException e = (PackageParser.PackageParserException)</span><br><span class="line">                            throwable;</span><br><span class="line">                    errorCode = e.error;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed to parse &quot;</span> + parseResult.scanFile + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected exception occurred while parsing &quot;</span></span><br><span class="line">                            + parseResult.scanFile, throwable);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Delete invalid userdata apps</span></span><br><span class="line">                <span class="comment">// 如果是非系统 apk 并且解析失败</span></span><br><span class="line">                <span class="keyword">if</span> ((scanFlags &amp; SCAN_AS_SYSTEM) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        errorCode != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                    logCriticalInfo(Log.WARN,</span><br><span class="line">                            <span class="string">&quot;Deleting invalid package at &quot;</span> + parseResult.scanFile);</span><br><span class="line">                    <span class="comment">// 非系统 Package 扫描失败，删除文件</span></span><br><span class="line">                    removeCodePathLI(parseResult.scanFile);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-2-parallelPackageParser-submit"><a href="#4-2-2-parallelPackageParser-submit" class="headerlink" title="4.2.2 parallelPackageParser.submit"></a>4.2.2 parallelPackageParser.submit</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags)</span> </span>&#123;</span><br><span class="line">        mService.submit(() -&gt; &#123;</span><br><span class="line">            ParseResult pr = <span class="keyword">new</span> ParseResult();</span><br><span class="line">            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;parallel parsePackage [&quot;</span> + scanFile + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PackageParser pp = <span class="keyword">new</span> PackageParser();</span><br><span class="line">                pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">                pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">                pp.setDisplayMetrics(mMetrics);</span><br><span class="line">                pp.setCacheDir(mCacheDir);</span><br><span class="line">                pp.setCallback(mPackageParserCallback);</span><br><span class="line">                pr.scanFile = scanFile;</span><br><span class="line">                <span class="comment">// 解析APK</span></span><br><span class="line">                <span class="comment">// 并把parsePackage()与pp 赋值ParseResult，用于后面的调用</span></span><br><span class="line">                pr.pkg = parsePackage(pp, scanFile, parseFlags);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                pr.throwable = e;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 把扫描路径中的APK等内容，放入队列mQueue</span></span><br><span class="line">                mQueue.put(pr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="comment">// Propagate result to callers of take().</span></span><br><span class="line">                <span class="comment">// This is helpful to prevent main thread from getting stuck waiting on</span></span><br><span class="line">                <span class="comment">// ParallelPackageParser to finish in case of interruption</span></span><br><span class="line">                mInterruptedInThread = Thread.currentThread().getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> PackageParser.<span class="function">Package <span class="title">parsePackage</span><span class="params">(PackageParser packageParser, File scanFile,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parseFlags)</span> <span class="keyword">throws</span> PackageParser.PackageParserException </span>&#123;</span><br><span class="line">    	<span class="comment">// 解析package</span></span><br><span class="line">        <span class="keyword">return</span> packageParser.parsePackage(scanFile, parseFlags, <span class="keyword">true</span> <span class="comment">/* useCaches */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>把扫描路径中的APK等内容，放入队列mQueue，并把parsePackage() pp 赋给ParseResult，用于后面的调用。</p>
<p>通过 PackageParser.parsePackage 进行apk解析：</p>
<ul>
<li>如果传入的packageFile是目录， 调用parseClusterPackage()解析</li>
<li>如果传入的packageFile是APK文件， 调用parseMonolithicPackage()解析  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parsePackage</span><span class="params">(File packageFile, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> useCaches)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">        Package parsed = useCaches ? getCachedResult(packageFile, flags) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (parsed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> parsed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (packageFile.isDirectory()) &#123;</span><br><span class="line">            parsed = parseClusterPackage(packageFile, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//去解析manifest了</span></span><br><span class="line">            parsed = parseMonolithicPackage(packageFile, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cacheResult(packageFile, flags, parsed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parsed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-3-parseMonolithicPackage解析manifest"><a href="#4-2-3-parseMonolithicPackage解析manifest" class="headerlink" title="4.2.3 parseMonolithicPackage解析manifest"></a>4.2.3 parseMonolithicPackage解析manifest</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parseMonolithicPackage</span><span class="params">(File apkFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AssetManager assets = newConfiguredAssetManager();</span><br><span class="line">        <span class="comment">// 里面会收集签名信息</span></span><br><span class="line">        <span class="keyword">final</span> PackageLite lite = parseMonolithicPackageLite(apkFile, flags);</span><br><span class="line">        <span class="keyword">if</span> (mOnlyCoreApps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lite.coreApp) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,</span><br><span class="line">                        <span class="string">&quot;Not a coreApp: &quot;</span> + apkFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//解析Manifest</span></span><br><span class="line">            <span class="keyword">final</span> Package pkg = parseBaseApk(apkFile, assets, flags);</span><br><span class="line">            pkg.setCodePath(apkFile.getAbsolutePath());</span><br><span class="line">            pkg.setUse32bitAbi(lite.use32bitAbi);</span><br><span class="line">            <span class="keyword">return</span> pkg;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(assets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>4.2.3.1 收集签名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PackageLite <span class="title">parseMonolithicPackageLite</span><span class="params">(File packageFile, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;parseApkLite&quot;</span>);</span><br><span class="line">        <span class="comment">//在parseApkLite这个方法里面解析manifest</span></span><br><span class="line">        <span class="keyword">final</span> ApkLite baseApk = parseApkLite(packageFile, flags);</span><br><span class="line">        <span class="keyword">final</span> String packagePath = packageFile.getAbsolutePath();</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PackageLite(packagePath, baseApk, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApkLite <span class="title">parseApkLite</span><span class="params">(File apkFile, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Signature[] signatures;</span><br><span class="line">            <span class="keyword">final</span> Certificate[][] certificates;</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; PARSE_COLLECT_CERTIFICATES) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> factor signature related items out of Package object</span></span><br><span class="line">                <span class="keyword">final</span> Package tempPkg = <span class="keyword">new</span> Package((String) <span class="keyword">null</span>);</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;collectCertificates&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 收集签名信息,将证书和签名保存再tempPkg中</span></span><br><span class="line">                    collectCertificates(tempPkg, apkFile, flags);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">                &#125;</span><br><span class="line">                signatures = tempPkg.mSignatures;</span><br><span class="line">                certificates = tempPkg.mCertificates;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                signatures = <span class="keyword">null</span>;</span><br><span class="line">                certificates = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> AttributeSet attrs = parser;</span><br><span class="line">            <span class="keyword">return</span> parseApkLite(apkPath, parser, attrs, flags, signatures, certificates);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException | IOException | RuntimeException e) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>4.2.3.2 parseBaseApk解析manifest</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApk</span><span class="params">(File apkFile, AssetManager assets, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String apkPath = apkFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">        String volumeUuid = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (apkPath.startsWith(MNT_EXPAND)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> end = apkPath.indexOf(<span class="string">&#x27;/&#x27;</span>, MNT_EXPAND.length());</span><br><span class="line">            volumeUuid = apkPath.substring(MNT_EXPAND.length(), end);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mParseError = android.content.pm.PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">        mArchiveSourcePath = apkFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_JAR) Slog.d(TAG, <span class="string">&quot;Scanning base APK: &quot;</span> + apkPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载Apk到AssetManager中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cookie = loadApkIntoAssetManager(assets, apkPath, flags);</span><br><span class="line"></span><br><span class="line">        Resources res = <span class="keyword">null</span>;</span><br><span class="line">        XmlResourceParser parser = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            res = <span class="keyword">new</span> Resources(assets, mMetrics, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 获得一个 XML 资源解析对象，该对象解析的是 APK 中的 AndroidManifest.xml 文件。</span></span><br><span class="line">            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String[] outError = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">           <span class="comment">//再调用重载函数parseBaseApk()最终到parseBaseApkCommon()，解析AndroidManifest.xml后得到一个Package对象。</span></span><br><span class="line">            <span class="keyword">final</span> Package pkg = parseBaseApk(apkPath, res, parser, flags, outError);</span><br><span class="line">            <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(mParseError,</span><br><span class="line">                        apkPath + <span class="string">&quot; (at &quot;</span> + parser.getPositionDescription() + <span class="string">&quot;): &quot;</span> + outError[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pkg.setVolumeUuid(volumeUuid);</span><br><span class="line">            pkg.setApplicationVolumeUuid(volumeUuid);</span><br><span class="line">            pkg.setBaseCodePath(apkPath);</span><br><span class="line">            pkg.setSignatures(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pkg;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageParserException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION,</span><br><span class="line">                    <span class="string">&quot;Failed to read manifest from &quot;</span> + apkPath, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(parser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>PackageParser.parseBaseApkCommon 从AndroidManifest.xml中获取标签名，解析标签中的各个item的内容，存入Package对象中。例如：获取标签 “application”、”permission”、”package”、”manifest”  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApkCommon</span><span class="params">(Package pkg, Set&lt;String&gt; acceptedTags, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">            XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException,</span></span><br><span class="line"><span class="function">            IOException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到AndroidManifest.xml 中的sharedUserId, 一般情况下有“android.uid.system”等信息</span></span><br><span class="line">        String str = sa.getNonConfigurationString(</span><br><span class="line">                com.android.internal.R.styleable.AndroidManifest_sharedUserId, <span class="number">0</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//通过tagName一个一个解析标签里面的内容</span></span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">			<span class="comment">//如果读到AndroidManifest.xml中的tag是&quot;application&quot;,执行parseBaseApplication()进行解析</span></span><br><span class="line">            <span class="keyword">if</span> (tagName.equals(TAG_APPLICATION)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (foundApp) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (RIGID_PARSER) &#123;</span><br><span class="line">                        outError[<span class="number">0</span>] = <span class="string">&quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;</span>;</span><br><span class="line">                        mParseError = android.content.pm.PackageManager. INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;</span>);</span><br><span class="line">                        XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                foundApp = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 解析四大组件，解析完成了之后交给package对象</span></span><br><span class="line">                <span class="comment">// 解析&quot;application&quot;的信息，赋值给pkg</span></span><br><span class="line">                <span class="keyword">if</span> (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(TAG_PERMISSION)) &#123;</span><br><span class="line">                <span class="comment">// 找到权限标签，进行&quot;permission&quot;的解析</span></span><br><span class="line">                <span class="keyword">if</span> (!parsePermission(pkg, res, parser, outError)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面解析AndroidManifest.xml，会得到 “application”、”overlay”、”permission”、”usespermission” 等信息 。</p>
<p>我们下面就针对”application”进行展开分析一下，进入 PackageParser.parseBaseApplication()函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseBaseApplication</span><span class="params">(Package owner, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">            XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">		<span class="comment">// 解析各个android:xxx标志位</span></span><br><span class="line">        ......</span><br><span class="line">			<span class="comment">// 获取&quot;application&quot;子标签的标签内容</span></span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line">            <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;activity&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 解析activity标签</span></span><br><span class="line">                Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">false</span>,</span><br><span class="line">                        owner.baseHardwareAccelerated);</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mParseError = android.content.pm.PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 接入到Package的activities列表中。</span></span><br><span class="line">                owner.activities.add(a);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;receiver&quot;</span>)) &#123;</span><br><span class="line">                Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mParseError = android.content.pm.PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.receivers.add(a);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;service&quot;</span>)) &#123;</span><br><span class="line">                Service s = parseService(owner, res, parser, flags, outError);</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mParseError = android.content.pm.PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.services.add(s);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;provider&quot;</span>)) &#123;</span><br><span class="line">                Provider p = parseProvider(owner, res, parser, flags, outError);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mParseError = android.content.pm.PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.providers.add(p);</span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">    	    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 PackageParser 扫描完一个 APK 后，此时系统已经根据该 APK 中 AndroidManifest.xml，创建了一个完整的 Package 对象。</p>
<h5 id="4-2-3-APK扫描小结"><a href="#4-2-3-APK扫描小结" class="headerlink" title="4.2.3 APK扫描小结"></a>4.2.3 APK扫描小结</h5><p>第一步：扫描APK，解析AndroidManifest.xml文件，得到清单文件各个标签内容<br>第二步：解析清单文件到的信息由 Package 保存。从该类的成员变量可看出，和 Android 四大组件相关的信息分别由 activites、receivers、providers、services 保存，由于一个 APK 可声明多个组件，因此activites 和 receivers等均声明为 ArrayList 。</p>
<h4 id="4-3-APK的安装"><a href="#4-3-APK的安装" class="headerlink" title="4.3 APK的安装"></a>4.3 APK的安装</h4><p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\APK安装流程.png" alt="APK安装流程"></p>
<p>Apk的安装分为三个步骤：</p>
<ul>
<li>把Apk的信息通过IO流的形式写入到PackageInstaller.Session中</li>
<li>调用PackageInstaller.Session的commit方法, 把Apk的信息交给PKMS处理</li>
<li>进行Apk的Copy操作, 进行安装  </li>
</ul>
<p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\Apk安装时序图.png" alt="Apk安装时序图"></p>
<p>当用户点击xxx.apk之后，APK的安装时序图如上，主要涉及到PackageInstaller.apk和PKMS交互。需要做包安装拦截就是在PackageInstaller里面做。</p>
<p>点击一个apk后，会弹出安装界面，点击确定按钮后，会进入PackageInstallerActivity 的 bindUi() 中的mAlert点击事件, 弹出的安装界面底部显示的是一个diaglog，主要由bindUi构成，上面有 ”取消“ 和 ”安装“ 两个按钮，点击安装后 调用startInstall()进行安装:  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages/apps/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java</span></span><br><span class="line"><span class="comment">//安装还是取消安装</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindUi</span><span class="params">(<span class="keyword">int</span> layout, <span class="keyword">boolean</span> enableOk)</span> </span>&#123;</span><br><span class="line">    setContentView(layout);</span><br><span class="line"></span><br><span class="line">    mOk = (Button) findViewById(R.id.ok_button);</span><br><span class="line">    mCancel = (Button)findViewById(R.id.cancel_button);</span><br><span class="line">    mOk.setOnClickListener(<span class="keyword">this</span>);   <span class="comment">//回调中调用开始安装</span></span><br><span class="line">    mCancel.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mEnableOk = enableOk;</span><br><span class="line">    mOk.setEnabled(enableOk);</span><br><span class="line"></span><br><span class="line">    PackageUtil.initSnippetForNewApp(<span class="keyword">this</span>, mAppSnippet, R.id.app_snippet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == mOk) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOk.isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOkCanInstall || mScrollView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSessionId != -<span class="number">1</span>) &#123;</span><br><span class="line">                    mInstaller.setPermissionsResult(mSessionId, <span class="keyword">true</span>);</span><br><span class="line">                    finish();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 开始安装</span></span><br><span class="line">                    startInstall();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mScrollView.pageScroll(View.FOCUS_DOWN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Start subactivity to actually install the application</span></span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,</span><br><span class="line">            mPkgInfo.applicationInfo);</span><br><span class="line">    newIntent.setData(mPackageURI);</span><br><span class="line">    <span class="comment">// 设置Intent中的class为 InstallInstalling，用来进行Activity跳转</span></span><br><span class="line">    <span class="comment">// class InstallInstalling extends AlertActivity,下面会分析InstallInstalling</span></span><br><span class="line">    newIntent.setClass(<span class="keyword">this</span>, InstallInstalling.class);</span><br><span class="line">    String installerPackageName = getIntent().getStringExtra(</span><br><span class="line">            Intent.EXTRA_INSTALLER_PACKAGE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (mOriginatingURI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mReferrerURI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOriginatingUid != PackageInstaller.SessionParams.UID_UNKNOWN) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (installerPackageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME,</span><br><span class="line">                installerPackageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, <span class="keyword">true</span>);</span><br><span class="line">        newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(localLOGV) Log.i(TAG, <span class="string">&quot;downloaded app uri=&quot;</span>+mPackageURI);</span><br><span class="line">    <span class="comment">// 启动android.intent.extra.INSTALLER_PACKAGE_NAME   InstallInstalling Activity</span></span><br><span class="line">    startActivity(newIntent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳到InstallInstalling这个activity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages/apps/PackageInstaller/src/com/android/packageinstaller/InstallInstalling.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.install_installing);</span><br><span class="line"></span><br><span class="line">        ApplicationInfo appInfo = getIntent()</span><br><span class="line">                .getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);</span><br><span class="line">        mPackageURI = getIntent().getData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(mPackageURI.getScheme())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getPackageManager().installExistingPackage(appInfo.packageName);</span><br><span class="line">                launchSuccess();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据mPackageURI创建一个对应的File</span></span><br><span class="line">            <span class="keyword">final</span> File sourceFile = <span class="keyword">new</span> File(mPackageURI.getPath());</span><br><span class="line">            PackageUtil.initSnippetForNewApp(<span class="keyword">this</span>, PackageUtil.getAppSnippet(<span class="keyword">this</span>, appInfo,</span><br><span class="line">                    sourceFile), R.id.app_snippet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一步.如果savedInstanceState不为null，获取此前保存的mSessionId和mInstallId，其中mSessionId是安装包的会话id，mInstallId是等待的安装事件id</span></span><br><span class="line">            <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mSessionId = savedInstanceState.getInt(SESSION_ID);</span><br><span class="line">                mInstallId = savedInstanceState.getInt(INSTALL_ID);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reregister for result; might instantly call back if result was delivered while</span></span><br><span class="line">                <span class="comment">// activity was destroyed</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 第二步.根据mInstallId向InstallEventReceiver注册一个观察者，launchFinishBasedOnResult会接收到安装事件的回调，</span></span><br><span class="line">					<span class="comment">//无论安装成功或者失败都会关闭当前的Activity(InstallInstalling)。如果savedInstanceState为null，代码的逻辑也是类似的</span></span><br><span class="line">                    InstallEventReceiver.addObserver(<span class="keyword">this</span>, mInstallId,</span><br><span class="line">                            <span class="keyword">this</span>::launchFinishBasedOnResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (EventResultPersister.OutOfIdsException e) &#123;</span><br><span class="line">                    <span class="comment">// Does not happen</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第三步.创建SessionParams，它用来代表安装会话的参数,组装params</span></span><br><span class="line">                PackageInstaller.SessionParams params = <span class="keyword">new</span> PackageInstaller.SessionParams(</span><br><span class="line">                        PackageInstaller.SessionParams.MODE_FULL_INSTALL);</span><br><span class="line">                params.installFlags = PackageManager.INSTALL_FULL_APP;</span><br><span class="line">                params.referrerUri = getIntent().getParcelableExtra(Intent.EXTRA_REFERRER);</span><br><span class="line">                params.originatingUri = getIntent()</span><br><span class="line">                        .getParcelableExtra(Intent.EXTRA_ORIGINATING_URI);</span><br><span class="line">                params.originatingUid = getIntent().getIntExtra(Intent.EXTRA_ORIGINATING_UID,</span><br><span class="line">                        UID_UNKNOWN);</span><br><span class="line">                params.installerPackageName =</span><br><span class="line">                        getIntent().getStringExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第四步.根据mPackageUri对包（APK）进行轻量级的解析，并将解析的参数赋值给SessionParams</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(mPackageURI.getPath());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    PackageParser.PackageLite pkg = PackageParser.parsePackageLite(file, <span class="number">0</span>);</span><br><span class="line">                    params.setAppPackageName(pkg.packageName);</span><br><span class="line">                    params.setInstallLocation(pkg.installLocation);</span><br><span class="line">                    params.setSize(</span><br><span class="line">                            PackageHelper.calculateInstalledSize(pkg, <span class="keyword">false</span>, params.abiOverride));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PackageParser.PackageParserException e) &#123;</span><br><span class="line">                    Log.e(LOG_TAG, <span class="string">&quot;Cannot parse package &quot;</span> + file + <span class="string">&quot;. Assuming defaults.&quot;</span>);</span><br><span class="line">                    Log.e(LOG_TAG,</span><br><span class="line">                            <span class="string">&quot;Cannot calculate installed size &quot;</span> + file + <span class="string">&quot;. Try only apk size.&quot;</span>);</span><br><span class="line">                    params.setSize(file.length());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.e(LOG_TAG,</span><br><span class="line">                            <span class="string">&quot;Cannot calculate installed size &quot;</span> + file + <span class="string">&quot;. Try only apk size.&quot;</span>);</span><br><span class="line">                    params.setSize(file.length());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 第五步.向InstallEventReceiver注册一个观察者返回一个新的mInstallId，</span></span><br><span class="line">					<span class="comment">// 其中InstallEventReceiver继承自BroadcastReceiver，用于接收安装事件并回调给EventResultPersister。</span></span><br><span class="line">                    mInstallId = InstallEventReceiver</span><br><span class="line">                            .addObserver(<span class="keyword">this</span>, EventResultPersister.GENERATE_NEW_ID,</span><br><span class="line">                                    <span class="keyword">this</span>::launchFinishBasedOnResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (EventResultPersister.OutOfIdsException e) &#123;</span><br><span class="line">                    launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 第六步.PackageInstaller的createSession方法内部会通过IPackageInstaller与PackageInstallerService进行进程间通信，</span></span><br><span class="line">					<span class="comment">//最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId</span></span><br><span class="line">                    mSessionId = getPackageManager().getPackageInstaller().createSession(params);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCancelButton = (Button) findViewById(R.id.cancel_button);</span><br><span class="line"></span><br><span class="line">            mCancelButton.setOnClickListener(view -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInstallingTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstallingTask.cancel(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mSessionId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    getPackageManager().getPackageInstaller().abandonSession(mSessionId);</span><br><span class="line">                    mSessionId = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                setResult(RESULT_CANCELED);</span><br><span class="line">                finish();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            mSessionCallback = <span class="keyword">new</span> InstallSessionCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上第六步是重点 PackageInstaller 的 createSession()内部会通过IPackageInstaller与PackageInstallerService进行进程间通信，最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId 。</p>
<p>InstallInstalling.onResume方法中，调用onPostExecute()方法，将APK的信息通过IO流的形式写入到PackageInstaller.Session中  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is the first onResume in a single life of the activity</span></span><br><span class="line">        <span class="keyword">if</span> (mInstallingTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            PackageInstaller installer = getPackageManager().getPackageInstaller();</span><br><span class="line">            PackageInstaller.SessionInfo sessionInfo = installer.getSessionInfo(mSessionId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sessionInfo != <span class="keyword">null</span> &amp;&amp; !sessionInfo.isActive()) &#123;</span><br><span class="line">                <span class="comment">// 在AsyncTask中将APK以流的方式提交到session中然后会调用PackageInstaller.Session.commit()</span></span><br><span class="line">                <span class="comment">// 最终会通过AIDL 调到PackageInstallerSession.commit()中</span></span><br><span class="line">                mInstallingTask = <span class="keyword">new</span> InstallingAsyncTask();</span><br><span class="line">                mInstallingTask.execute();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we will receive a broadcast when the install is finished</span></span><br><span class="line">                mCancelButton.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">                setFinishOnTouchOutside(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallingAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>,</span></span><br><span class="line"><span class="class">            <span class="title">PackageInstaller</span>.<span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> isDone;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> PackageInstaller.<span class="function">Session <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">            PackageInstaller.Session session;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session = getPackageManager().getPackageInstaller().openSession(mSessionId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            session.setStagingProgress(<span class="number">0</span>);</span><br><span class="line">			<span class="comment">// 第一步： doInBackground()会根据包(APK)的Uri，将APK的信息通过IO流的形式写入到PackageInstaller.Session中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File file = <span class="keyword">new</span> File(mPackageURI.getPath());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(file)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> sizeBytes = file.length();</span><br><span class="line">                    <span class="keyword">try</span> (OutputStream out = session</span><br><span class="line">                            .openWrite(<span class="string">&quot;PackageInstaller&quot;</span>, <span class="number">0</span>, sizeBytes)) &#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> numRead = in.read(buffer);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (numRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                                session.fsync(out);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                                session.close();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">							<span class="comment">//将APK的信息通过IO流的形式写入到PackageInstaller.Session中</span></span><br><span class="line">                            out.write(buffer, <span class="number">0</span>, numRead);</span><br><span class="line">                            <span class="keyword">if</span> (sizeBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">float</span> fraction = ((<span class="keyword">float</span>) numRead / (<span class="keyword">float</span>) sizeBytes);</span><br><span class="line">                                session.addProgress(fraction);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> session;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | SecurityException e) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">&quot;Could not write package&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">                session.close();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    isDone = <span class="keyword">true</span>;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(PackageInstaller.Session session)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 第二步：最后在onPostExecute()中 调用PackageInstaller.Session的commit方法，进行安装</span></span><br><span class="line">                Intent broadcastIntent = <span class="keyword">new</span> Intent(BROADCAST_ACTION);</span><br><span class="line">                broadcastIntent.setPackage(</span><br><span class="line">                        getPackageManager().getPermissionControllerPackageName());</span><br><span class="line">                broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId);</span><br><span class="line"></span><br><span class="line">                PendingIntent pendingIntent = PendingIntent.getBroadcast(</span><br><span class="line">                        InstallInstalling.<span class="keyword">this</span>,</span><br><span class="line">                        mInstallId,</span><br><span class="line">                        broadcastIntent,</span><br><span class="line">                        PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">				<span class="comment">// 提交意图</span></span><br><span class="line">                <span class="comment">// 调用PackageInstaller.Session的commit方法，进行安装</span></span><br><span class="line">                session.commit(pendingIntent.getIntentSender());</span><br><span class="line">                mCancelButton.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">                setFinishOnTouchOutside(<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                getPackageManager().getPackageInstaller().abandonSession(mSessionId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">                    launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/content/pm/PackageInstaller.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="meta">@NonNull</span> IntentSender statusReceiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// mSession的类型为IPackageInstallerSession，这说明要通过IPackageInstallerSession来进行进程间的通信，最终会调用PackageInstallerSession的commit方法，这样代码逻辑就到了Java框架层的。</span></span><br><span class="line">		<span class="comment">// 调用IPackageInstallerSession的commit方法, 跨进程调用到PackageInstallerSession.commit()</span></span><br><span class="line">        mSession.commit(statusReceiver, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="meta">@NonNull</span> IntentSender statusReceiver, <span class="keyword">boolean</span> forTransfer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsPerfLockAcquired &amp;&amp; mPerfBoostInstall != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPerfBoostInstall.perfLockRelease();</span><br><span class="line">        mIsPerfLockAcquired = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasParentSessionId()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;Session &quot;</span> + sessionId + <span class="string">&quot; is a child of multi-package session &quot;</span></span><br><span class="line">                        + mParentSessionId +  <span class="string">&quot; and may not be committed directly.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// markAsCommitted检测session是否传输结束，传输结束了将包进行封存，不让修改了。</span></span><br><span class="line">    <span class="keyword">if</span> (!markAsCommitted(statusReceiver, forTransfer)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMultiPackage()) &#123;</span><br><span class="line">        <span class="keyword">final</span> SparseIntArray remainingSessions = mChildSessionIds.clone();</span><br><span class="line">        <span class="keyword">final</span> IntentSender childIntentSender =</span><br><span class="line">                <span class="keyword">new</span> ChildStatusIntentReceiver(remainingSessions, statusReceiver)</span><br><span class="line">                        .getIntentSender();</span><br><span class="line">        RuntimeException commitException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> commitFailed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mChildSessionIds.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childSessionId = mChildSessionIds.keyAt(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// commit all children, regardless if any of them fail; we&#x27;ll throw/return</span></span><br><span class="line">                <span class="comment">// as appropriate once all children have been processed</span></span><br><span class="line">                <span class="keyword">if</span> (!mSessionProvider.getSession(childSessionId)</span><br><span class="line">                        .markAsCommitted(childIntentSender, forTransfer)) &#123;</span><br><span class="line">                    commitFailed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                commitException = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (commitException != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> commitException;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (commitFailed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送MSG_COMMIT消息，处理此次commit的session</span></span><br><span class="line">    mHandler.obtainMessage(MSG_COMMIT).sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">     <span class="keyword">case</span> MSG_COMMIT:</span><br><span class="line">         handleCommit();  <span class="comment">// 处理commit</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For a multiPackage session, read the child sessions</span></span><br><span class="line">        <span class="comment">// outside of the lock, because reading the child</span></span><br><span class="line">        <span class="comment">// sessions with the lock held could lead to deadlock</span></span><br><span class="line">        <span class="comment">// (b/123391593).</span></span><br><span class="line">        List&lt;PackageInstallerSession&gt; childSessions = getChildSessions();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="comment">//最终调用installStage()，进入PKMS</span></span><br><span class="line">                commitNonStagedLocked(childSessions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitNonStagedLocked</span><span class="params">(List&lt;PackageInstallerSession&gt; childSessions)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PackageManagerService.ActiveInstallSession committingSession =</span><br><span class="line">                makeSessionActiveLocked();</span><br><span class="line">        <span class="keyword">if</span> (committingSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">            <span class="comment">// 提交session到PKMS中</span></span><br><span class="line">            mPm.installStage(committingSession);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过跨进程进入到PKMS中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installStage</span><span class="params">(ActiveInstallSession activeInstallSession)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建了类型为INIT_COPY的消息</span></span><br><span class="line">        <span class="keyword">final</span> Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line">    	<span class="comment">// 创建InstallParams，它对应于包的安装数据</span></span><br><span class="line">        <span class="keyword">final</span> InstallParams params = <span class="keyword">new</span> InstallParams(activeInstallSession);</span><br><span class="line">        params.setTraceMethod(<span class="string">&quot;installStage&quot;</span>).setTraceCookie(System.identityHashCode(params));</span><br><span class="line">        msg.obj = params;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将InstallParams通过消息发送出去。</span></span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INIT_COPY: &#123;</span><br><span class="line">            HandlerParams params = (HandlerParams) msg.obj;</span><br><span class="line">            <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ......</span><br><span class="line">                <span class="comment">// HandlerParams.startCopy方法，完成apk拷贝工作</span></span><br><span class="line">                params.startCopy();</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span></span><br><span class="line"><span class="comment">// HandlerParams是PackageManagerService内部抽象类，具体实现类是MultiPackageInstallParams</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerParams</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** User handle for the user requesting the information or installation. */</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="string">&quot;startCopy &quot;</span> + mUser + <span class="string">&quot;: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">            handleStartCopy();   <span class="comment">// 开始拷贝</span></span><br><span class="line">            handleReturnCode();  <span class="comment">// 处理拷贝结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleStartCopy</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleReturnCode</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiPackageInstallParams</span> <span class="keyword">extends</span> <span class="title">HandlerParams</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mRet = INSTALL_SUCCEEDED;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;InstallParams&gt; mChildParams;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;InstallArgs, Integer&gt; mCurrentState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handleStartCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (InstallParams params : mChildParams) &#123;</span><br><span class="line">                <span class="comment">// 调用InstallParams来调用远程方法以获取包信息并安装位置值。</span></span><br><span class="line">                <span class="comment">// 如果需要，基于默认策略覆盖安装位置，然后基于安装位置创建安装参数。</span></span><br><span class="line">                params.handleStartCopy();</span><br><span class="line">                <span class="keyword">if</span> (params.mRet != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                    mRet = params.mRet;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handleReturnCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (InstallParams params : mChildParams) &#123;</span><br><span class="line">                <span class="comment">// 找到安装的位置之后，完成拷贝</span></span><br><span class="line">                params.handleReturnCode();</span><br><span class="line">                <span class="keyword">if</span> (params.mRet != INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                    mRet = params.mRet;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstallParams</span> <span class="keyword">extends</span> <span class="title">HandlerParams</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读APK包，然后解析apk部分信息</span></span><br><span class="line">        pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(mContext,</span><br><span class="line">                origin.resolvedPath, installFlags, packageAbiOverride);</span><br><span class="line"></span><br><span class="line">        ...... <span class="comment">// 各种标志位判断</span></span><br><span class="line">        </span><br><span class="line">                <span class="comment">// Override with defaults if needed.</span></span><br><span class="line">            	<span class="comment">// 获取推荐的安装位置</span></span><br><span class="line">                loc = installLocationPolicy(pkgLite);</span><br><span class="line">                <span class="keyword">if</span> (loc == PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE) &#123;</span><br><span class="line">                    ret = PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;</span><br><span class="line">               ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">   		<span class="comment">// 创建安装参数</span></span><br><span class="line">        <span class="keyword">final</span> InstallArgs args = createInstallArgs(<span class="keyword">this</span>);</span><br><span class="line">        mVerificationCompleted = <span class="keyword">true</span>;</span><br><span class="line">        mEnableRollbackCompleted = <span class="keyword">true</span>;</span><br><span class="line">        mArgs = args;   <span class="comment">// 此处注意赋值给全局变量mArgs，待会儿处理返回参数方法会用到这个参数</span></span><br><span class="line"></span><br><span class="line">        ...... <span class="comment">// 根据apk结果，设置返回参数，到时候处理返回结果会用到这个参数</span></span><br><span class="line">        mRet = ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">handleReturnCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mVerificationCompleted &amp;&amp; mEnableRollbackCompleted) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (mRet == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                mRet = mArgs.copyApk();  <span class="comment">// 拷贝apk</span></span><br><span class="line">            &#125;</span><br><span class="line">            processPendingInstall(mArgs, mRet);  <span class="comment">// 处理拷贝结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们可以看到涉及到APK安装最核心的几个步骤：</p>
<ul>
<li>1.根据策略找到安装位置</li>
<li>2.拷贝apk到指定位子</li>
<li>3.处理拷贝结果，主要是分析安装状态，扫描apk包，验证apk包，提交和更新系统状态。</li>
</ul>
<p>上面在handleStartCopy()方法中找到了安装的推荐位置。下面我们来看看<code>apk拷贝过程</code>和<code>apk验证过程</code>。</p>
<p><strong>4.3.1 apk拷贝过程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java 内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileInstallArgs</span> <span class="keyword">extends</span> <span class="title">InstallArgs</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">copyApk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;copyApk&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doCopyApk();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doCopyApk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">		<span class="comment">// 通过读流的方式拷贝package到目标位置，即/data/app</span></span><br><span class="line">        <span class="keyword">int</span> ret = PackageManagerServiceUtils.copyPackage(</span><br><span class="line">            origin.file.getAbsolutePath(), codeFile);</span><br><span class="line">        <span class="keyword">if</span> (ret != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Failed to copy package&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>4.3.2 处理拷贝结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// processPendingInstall -&gt; processInstallRequestsAsync -&gt; installPackagesTracedLI -&gt; installPackagesLI</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installPackagesLI</span><span class="params">(List&lt;InstallRequest&gt; requests)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">                    <span class="comment">// 准备阶段：分析安装结果，解析包，并且做一些包验证相关的初始化操作</span></span><br><span class="line">                    prepareResult = preparePackageLI(request.args, request.installResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PrepareFailure prepareFailure) &#123;</span><br><span class="line">                   ......</span><br><span class="line">                    <span class="comment">// 扫描阶段：根据准备阶段收集的上下文查询已解析的包</span></span><br><span class="line">                    <span class="keyword">final</span> List&lt;ScanResult&gt; scanResults = scanPackageTracedLI(</span><br><span class="line">                            prepareResult.packageToScan, prepareResult.parseFlags,</span><br><span class="line">                            prepareResult.scanFlags, System.currentTimeMillis(),</span><br><span class="line">                            request.args.user);</span><br><span class="line">                   ......</span><br><span class="line">                    <span class="comment">// 协调阶段：验证扫描包的上下文和系统的状态，确保安装成功</span></span><br><span class="line">                    reconciledPackages = reconcilePackagesLocked(</span><br><span class="line">                            reconcileRequest, mSettings.mKeySetManagerService);</span><br><span class="line">               ......</span><br><span class="line">                    <span class="comment">// 提交结果阶段：提交所有扫描的包并更新系统状态。这是安装流程中唯一可以修改系统状态的地方，在此阶段之前必须确定所有可预测的错误。</span></span><br><span class="line">                    commitPackagesLocked(commitRequest);</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 成功安装后，在提交完成并释放包锁.</span></span><br><span class="line">            executePostCommitSteps(commitRequest);</span><br><span class="line">        &#125; </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>executePostCommitSteps 安装APK,并为新的代码路径准备应用程序配置文件,并再次检查是否需要dex优化。</p>
<p>如果是直接安装新包，会为新的代码路径准备应用程序配置文件。<br>如果是替换安装：其主要过程为更新设置，清除原有的某些APP数据，重新生成相关的app数据目录等步骤，同时要区分系统应用替换和非系统应用替换。而安装新包：则直接更新设置，生成APP数据即可。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executePostCommitSteps</span><span class="params">(CommitRequest commitRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ReconciledPackage reconciledPkg : commitRequest.reconciledPackages.values()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> instantApp = ((reconciledPkg.scanResult.request.scanFlags</span><br><span class="line">                            &amp; PackageManagerService.SCAN_AS_INSTANT_APP) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> PackageParser.Package pkg = reconciledPkg.pkgSetting.pkg;</span><br><span class="line">            <span class="keyword">final</span> String packageName = pkg.packageName;</span><br><span class="line">            <span class="comment">//1)进行安装</span></span><br><span class="line">            prepareAppDataAfterInstallLIF(pkg);</span><br><span class="line">            <span class="comment">//2)如果需要替换安装，则需要清楚原有的APP数据</span></span><br><span class="line">            <span class="keyword">if</span> (reconciledPkg.prepareResult.clearCodeCache) &#123;</span><br><span class="line">                clearAppDataLIF(pkg, UserHandle.USER_ALL, FLAG_STORAGE_DE | FLAG_STORAGE_CE</span><br><span class="line">                        | FLAG_STORAGE_EXTERNAL | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reconciledPkg.prepareResult.replace) &#123;</span><br><span class="line">                mDexManager.notifyPackageUpdated(pkg.packageName,</span><br><span class="line">                        pkg.baseCodePath, pkg.splitCodePaths);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the application profiles for the new code paths.</span></span><br><span class="line">            <span class="comment">// This needs to be done before invoking dexopt so that any install-time profile</span></span><br><span class="line">            <span class="comment">// can be used for optimizations.</span></span><br><span class="line">            <span class="comment">//3)为新的代码路径准备应用程序配置文件。这需要在调用dexopt之前完成，以便任何安装时配置文件都可以用于优化。</span></span><br><span class="line">            mArtManagerService.prepareAppProfiles(</span><br><span class="line">                    pkg,</span><br><span class="line">                    resolveUserIds(reconciledPkg.installArgs.user.getIdentifier()),</span><br><span class="line">                    <span class="comment">/* updateReferenceProfileContent= */</span> <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check whether we need to dexopt the app.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> it is IMPORTANT to call dexopt:</span></span><br><span class="line">            <span class="comment">//   - after doRename which will sync the package data from PackageParser.Package and</span></span><br><span class="line">            <span class="comment">//     its corresponding ApplicationInfo.</span></span><br><span class="line">            <span class="comment">//   - after installNewPackageLIF or replacePackageLIF which will update result with the</span></span><br><span class="line">            <span class="comment">//     uid of the application (pkg.applicationInfo.uid).</span></span><br><span class="line">            <span class="comment">//     This update happens in place!</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// We only need to dexopt if the package meets ALL of the following conditions:</span></span><br><span class="line">            <span class="comment">//   1) it is not an instant app or if it is then dexopt is enabled via gservices.</span></span><br><span class="line">            <span class="comment">//   2) it is not debuggable.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that we do not dexopt instant apps by default. dexopt can take some time to</span></span><br><span class="line">            <span class="comment">// complete, so we skip this step during installation. Instead, we&#x27;ll take extra time</span></span><br><span class="line">            <span class="comment">// the first time the instant app starts. It&#x27;s preferred to do it this way to provide</span></span><br><span class="line">            <span class="comment">// continuous progress to the useur instead of mysteriously blocking somewhere in the</span></span><br><span class="line">            <span class="comment">// middle of running an instant app. The default behaviour can be overridden</span></span><br><span class="line">            <span class="comment">// via gservices.</span></span><br><span class="line">            <span class="comment">//4)执行dex优化。只有不是instant app和debug app才做dex优化。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> performDexopt =</span><br><span class="line">                    (!instantApp || Global.getInt(mContext.getContentResolver(),</span><br><span class="line">                    Global.INSTANT_APP_DEXOPT_ENABLED, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">                    &amp;&amp; ((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (performDexopt) &#123;</span><br><span class="line">                <span class="comment">// Compile the layout resources.</span></span><br><span class="line">                <span class="keyword">if</span> (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;compileLayouts&quot;</span>);</span><br><span class="line">                    mViewCompiler.compileLayouts(pkg);</span><br><span class="line">                    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;dexopt&quot;</span>);</span><br><span class="line">                <span class="comment">// Do not run PackageDexOptimizer through the local performDexOpt</span></span><br><span class="line">                <span class="comment">// method because `pkg` may not be in `mPackages` yet.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Also, don&#x27;t fail application installs if the dexopt step fails.</span></span><br><span class="line">                DexoptOptions dexoptOptions = <span class="keyword">new</span> DexoptOptions(packageName,</span><br><span class="line">                        REASON_INSTALL,</span><br><span class="line">                        DexoptOptions.DEXOPT_BOOT_COMPLETE</span><br><span class="line">                                | DexoptOptions.DEXOPT_INSTALL_WITH_DEX_METADATA_FILE);</span><br><span class="line">                <span class="comment">// 执行dex优化</span></span><br><span class="line">                mPackageDexOptimizer.performDexOpt(pkg,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* instructionSets */</span>,</span><br><span class="line">                        getOrCreateCompilerPackageStats(pkg),</span><br><span class="line">                        mDexManager.getPackageUseInfoOrDefault(packageName),</span><br><span class="line">                        dexoptOptions);</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify BackgroundDexOptService that the package has been changed.</span></span><br><span class="line">            <span class="comment">// If this is an update of a package which used to fail to compile,</span></span><br><span class="line">            <span class="comment">// BackgroundDexOptService will remove it from its blacklist.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Layering violation</span></span><br><span class="line">            BackgroundDexOptService.notifyPackageChanged(packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过一系列的调用，最终会调用到[Installer.java] createAppData()进行安装，交给installed进程进行APK的安装</span></span><br><span class="line">调用栈如下：</span><br><span class="line">prepareAppDataAfterInstallLIF() -&gt; prepareAppDataLIF() -&gt; prepareAppDataLeafLIF() -&gt; [Installer.java]</span><br><span class="line">createAppData()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAppDataAfterInstallLIF</span><span class="params">(PackageParser.Package pkg)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    UserManagerInternal umInternal = getUserManagerInternal();</span><br><span class="line">    <span class="keyword">for</span> (UserInfo user : um.getUsers(<span class="keyword">false</span> <span class="comment">/* excludeDying */</span>)) &#123;</span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">if</span> (ps.getInstalled(user.id)) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> when user data is locked, mark that we&#x27;re still dirty</span></span><br><span class="line">            prepareAppDataLIF(pkg, user.id, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证目录是否存在，以及所有已安装应用的所有权和标签是否正确。如果所有权不匹配，将尝试通过擦除数据恢复系统应用程序；第三方应用程序数据保持不变。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAppDataLIF</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> userId, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Package was null!&quot;</span>, <span class="keyword">new</span> Throwable());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prepareAppDataLeafLIF(pkg, userId, flags);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = (pkg.childPackages != <span class="keyword">null</span>) ? pkg.childPackages.size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            prepareAppDataLeafLIF(pkg.childPackages.get(i), userId, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAppDataLeafLIF</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> userId, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Installd守护进程的入口</span></span><br><span class="line">        ceDataInode = mInstaller.createAppData(volumeUuid, packageName, userId, flags,</span><br><span class="line">                appId, seInfo, app.targetSdkVersion);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstallerException e) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">	<span class="comment">// 创建native库符号链接</span></span><br><span class="line">    prepareAppDataContentsLeafLIF(pkg, userId, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Installer.createAppData 收尾工作，安装完成后，更新设置，更新安装锁等：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/Installer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">createAppData</span><span class="params">(String uuid, String packageName, <span class="keyword">int</span> userId, <span class="keyword">int</span> flags, <span class="keyword">int</span> appId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, <span class="keyword">int</span> targetSdkVersion)</span> <span class="keyword">throws</span> InstallerException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkBeforeRemote()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mInstalld.createAppData(uuid, packageName, userId, flags, appId, seInfo,</span><br><span class="line">                    targetSdkVersion);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> InstallerException.from(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>4.3.3 APK安装小结</strong></p>
<p><img src="/2021/10/19/%E9%87%8D%E6%B8%A9PackageManagerService-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/blog\source_posts\重温PackageManagerService-源码分析\安装原理.png" alt="安装原理"></p>
<h3 id="5-Dex优化"><a href="#5-Dex优化" class="headerlink" title="5 Dex优化"></a>5 Dex优化</h3><p>在SystemServer启动引导服务的时候，如果不是核心服务应用，就会查看应用是否需要dex优化。</p>
<p>如果是系统更新，会将InstallerD优化后的dex文件拷贝到ab分区的对应目录。</p>
<h4 id="5-1-拷贝包到AB分区对应目录"><a href="#5-1-拷贝包到AB分区对应目录" class="headerlink" title="5.1 拷贝包到AB分区对应目录"></a>5.1 拷贝包到AB分区对应目录</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> disableOtaDexopt = SystemProperties.getBoolean(<span class="string">&quot;config.disable_otadexopt&quot;</span>,</span><br><span class="line">                <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!disableOtaDexopt) &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartOtaDexOptService&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">&quot;moveab&quot;</span>);</span><br><span class="line">                <span class="comment">// OTADexOpt(空中下载dex并优化，用于OTA升级)使能时，启动OTA升级服务</span></span><br><span class="line">                OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">&quot;starting OtaDexOptService&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">&quot;moveab&quot;</span>);</span><br><span class="line">                traceEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;    </span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/OtaDexoptService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OtaDexoptService <span class="title">main</span><span class="params">(Context context,PackageManagerService packageManagerService)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 构建OtaDexoptService并且加入到SM中</span></span><br><span class="line">        OtaDexoptService ota = <span class="keyword">new</span> OtaDexoptService(context, packageManagerService);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;otadexopt&quot;</span>, ota);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now it&#x27;s time to check whether we need to move any A/B artifacts.</span></span><br><span class="line">    	<span class="comment">// 检查是否需要优化</span></span><br><span class="line">        ota.moveAbArtifacts(packageManagerService.mInstaller);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ota;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveAbArtifacts</span><span class="params">(Installer installer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDexoptCommands != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Should not be ota-dexopting when trying to move.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 如果没有升级，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!mPackageManagerService.isUpgrade()) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">&quot;No upgrade, skipping A/B artifacts check.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Look into all packages.</span></span><br><span class="line">        Collection&lt;PackageParser.Package&gt; pkgs = mPackageManagerService.getPackages();</span><br><span class="line">        <span class="keyword">int</span> packagePaths = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pathsSuccessful = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PackageParser.Package pkg : pkgs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Does the package have code? If not, there won&#x27;t be any artifacts.</span></span><br><span class="line">            <span class="comment">// 如果apk只是资源文件，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!PackageDexOptimizer.canOptimizePackage(pkg)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pkg.codePath == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Package &quot;</span> + pkg + <span class="string">&quot; can be optimized but has null codePath&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the path is in /system, /vendor or /product, ignore. It will have been</span></span><br><span class="line">            <span class="comment">// ota-dexopted into /data/ota and moved into the dalvik-cache already.</span></span><br><span class="line">            <span class="comment">// 如果是/system、/vendor、/product目录下的应用不用做优化，因为已经在系统预编译的时候，编译到/data/dalvik-cache中了。</span></span><br><span class="line">            <span class="keyword">if</span> (pkg.codePath.startsWith(<span class="string">&quot;/system&quot;</span>) || pkg.codePath.startsWith(<span class="string">&quot;/vendor&quot;</span>)</span><br><span class="line">                    || pkg.codePath.startsWith(<span class="string">&quot;/product&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String[] instructionSets = getAppDexInstructionSets(pkg.applicationInfo);</span><br><span class="line">            <span class="comment">// 获取代码的目录</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;String&gt; paths = pkg.getAllCodePathsExcludingResourceOnly();</span><br><span class="line">            <span class="keyword">final</span> String[] dexCodeInstructionSets = getDexCodeInstructionSets(instructionSets);</span><br><span class="line">            <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">                    String oatDir = PackageDexOptimizer.getOatDir(<span class="keyword">new</span> File(pkg.codePath)).</span><br><span class="line">                            getAbsolutePath();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Check first whether there is an artifact, to save the roundtrip time.</span></span><br><span class="line"></span><br><span class="line">                    packagePaths++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 将代码的目录转移到oatDir中。</span></span><br><span class="line">                        installer.moveAb(path, dexCodeInstructionSet, oatDir);</span><br><span class="line">                        pathsSuccessful++;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstallerException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Moved &quot;</span> + pathsSuccessful + <span class="string">&quot;/&quot;</span> + packagePaths);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-2-dex优化"><a href="#5-2-dex优化" class="headerlink" title="5.2 dex优化"></a>5.2 dex优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// startOtherServices()中</span></span><br><span class="line"><span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">    traceBeginAndSlog(<span class="string">&quot;UpdatePackagesIfNeeded&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mPackageManagerService.updatePackagesIfNeeded();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">&quot;update packages&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h3 id="6-磁盘维护"><a href="#6-磁盘维护" class="headerlink" title="6 磁盘维护"></a>6 磁盘维护</h3><h3 id="7-PKMS之权限扫描"><a href="#7-PKMS之权限扫描" class="headerlink" title="7 PKMS之权限扫描"></a>7 PKMS之权限扫描</h3>]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Framework</tag>
        <tag>PKMS</tag>
      </tags>
  </entry>
  <entry>
    <title>聚媒体应用卡顿分析</title>
    <url>/2021/10/15/%E8%81%9A%E5%AA%92%E4%BD%93%E5%BA%94%E7%94%A8%E5%8D%A1%E9%A1%BF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>下文中提到的耗时都是大于16ms的耗时，比较低的耗时没有列出。</p>
<h4 id="1-卡顿调查"><a href="#1-卡顿调查" class="headerlink" title="1.卡顿调查"></a>1.卡顿调查</h4><p>使用原生设置的<code>Profile GPU Rendering GPU渲染模式分析</code>工具，粗略查看丢帧情况，看哪些界面丢帧严重。</p>
<p><strong>绿色线是16.7ms的界面刷新线</strong>。</p>
<h5 id="1-1-应用启动"><a href="#1-1-应用启动" class="headerlink" title="1.1 应用启动"></a>1.1 应用启动</h5><p>可以看出当聚媒体启动的时候，会有一段事件丢帧特别严重，如下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6fec513f9373c12d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动丢帧.jpg"></p>
<h5 id="1-2-界面滑动"><a href="#1-2-界面滑动" class="headerlink" title="1.2 界面滑动"></a>1.2 界面滑动</h5><p>可以看出当界面滑动的时候，资源加载也会出现比较严重的丢帧情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-8bc457a502223bcb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载资源丢帧.jpg"></p>
<h5 id="1-3-资源缓存"><a href="#1-3-资源缓存" class="headerlink" title="1.3 资源缓存"></a>1.3 资源缓存</h5><p>当界面来回跳转的时候，部分界面会存在没有缓存，或者缓存数据不够的情况，也有丢帧情况。</p>
<p>此类场景需要兼顾考虑内存和丢帧的折中选择。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-6357867bd92c8905.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重复加载资源.jpg"></p>
<h4 id="2-Systrace调查丢帧时系统情况"><a href="#2-Systrace调查丢帧时系统情况" class="headerlink" title="2. Systrace调查丢帧时系统情况"></a>2. Systrace调查丢帧时系统情况</h4><p>可以看出在滑动的时候，加载的一秒多时间内，有很多丢帧的情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-66efbe55271192ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑动丢帧情况.png"></p>
<p>查看线程情况，UI线程处于sleeping状态。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-d1b4c2e6db62db26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当前系统线程状态判断卡顿原因.png"></p>
<p>可以看到Render线程在调用Drawframe()正在渲染一帧数据，然而可以看到此次渲染花了很长时间，接下来我们就需要看一下为什么那么耗时了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-14b06b62824e6bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Render渲染.png"></p>
<h4 id="3-主界面丢帧分析"><a href="#3-主界面丢帧分析" class="headerlink" title="3.主界面丢帧分析"></a>3.主界面丢帧分析</h4><h5 id="3-1-启动引发的背景思考"><a href="#3-1-启动引发的背景思考" class="headerlink" title="3.1 启动引发的背景思考"></a>3.1 启动引发的背景思考</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-83820de251ce519e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityStart耗时.png"></p>
<p>启动activity总共耗时357ms，其中比较耗时的有两部分：</p>
<ul>
<li>加载主题图片(55ms)w</li>
<li>加载布局资源(171ms)</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-bf22d4b0a242460c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载主题.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-42ae23cca36475fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加载布局.png"></p>
<p><strong>优化建议：</strong></p>
<p><strong>1.去掉重复背景</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// common/src/main/res/values/styles.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.Light.NoActionBar&quot;</span>&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowAnimationStyle&quot;</span>&gt;</span>@style/Animation<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>#0080ff<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  &lt;-- 此行删除掉，因为下面背景图(mediax_theme)已经是全屏</span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 设置无标题 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--设置透明主题--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@mipmap/mediax_theme<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--  &lt;item name=&quot;android:windowFullscreen&quot;&gt;?android:windowNoTitle&lt;/item&gt;--&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>优化后</strong>，该页背景加载优化耗时25.86ms, 优化47%。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-4faf7fccb93bbab4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闪屏页删除背景效果.png"></p>
<p><strong>2.小播放器背景加载</strong></p>
<p>关于背景的加载，源代码中是加载的png图片，我们来看一下加载png、加载webp和加载xml的耗时对比。</p>
<ul>
<li>使用png加载</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-80df44628f0ace7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用png加载.png"></p>
<ul>
<li>使用webp加载</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-099aa9af2537d8e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用webp加载.png"></p>
<ul>
<li>使用xml加载</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c22e2e10855cc6c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用xml加载.png"></p>
<p>使用png图片加载背景耗时最长，webp次之，xml耗时最少。但是经过我多轮测试，png和webp两种方式加载图片耗时优化不是很稳定，有时候webp耗时会少一点，有时候会少比较多。但是<strong>xml和以上两种耗时比较稳定，使用xml当背景加载耗时会少20%左右</strong>。</p>
<p>因此，背景图加载建议如下：</p>
<ul>
<li>如果采用纯色作为背景，图像比较简单的情况下，<strong>建议使用xml作为背景图来加载</strong>。</li>
<li>虽然webp图片比png图片加载耗时没有明确稳定的优化，但是webp图片体积很小，对于小图片的加载建议都使用webp图片。以<code>小播放器背景</code>图片为例，原png图<strong>479Kb</strong>，webp图<strong>265Kb</strong>。</li>
</ul>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>1.从第一点可以看出背景图重复会直接成<strong>倍数</strong>增加加载耗时，而且会导致UI卡顿。因此自行检查重复背景图情况。目前检查到<strong>有嫌疑</strong>背景重叠的布局有如下，如果不重复可以忽略：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">program/src/main/res/layout/mediax_fragment_dialog_program_select.xml</span><br><span class="line">app/src/main/res/layout/fragment_news_playing.xml  //使用xml加载纯黑背景</span><br><span class="line">app/src/main/res/layout/mediax_fragment_dialog_himalaya_login.xml   //如果是为了自定义一个dialog可以忽略</span><br><span class="line">app/src/main/res/layout/layout_accout_bind.xml</span><br><span class="line">app/src/main/res/layout/mediax_fragment_dialog_kw_unbind.xml  //如果是为了自定义一个dialog可以忽略</span><br><span class="line">app/src/main/res/layout/fragment_program_playing_new.xml // 是否和外层容器的背景重合了？</span><br><span class="line">app/src/main/res/layout/fragment_speaker_dialog.xml   // 是否和外层容器的背景重合了？</span><br><span class="line">app/src/main/res/layout/fragment_media.xml  //tabIndicatorColor重合了，是否可以取消？</span><br><span class="line">app/src/main/res/layout/fragment_search.xml //RecyclerView背景色是否和外部重合？</span><br><span class="line">app/src/main/res/layout/layout_similar_song_play_list_small_player.xml // 背景是否和外部重合？</span><br><span class="line">app/src/main/res/layout/fragment_player_news.xml // 背景是否和外部重合？</span><br><span class="line">app/src/main/res/layout/fragment_player.xml  // 点击播放列表显示出来是否需要隐藏掉后面的界面？</span><br><span class="line">app/src/main/res/layout/fragment_soundhound.xml // 背景是否和最外层背景重复？</span><br><span class="line">app/src/main/res/layout/fragment_music_playing_new.xml  // 背景是否重合</span><br><span class="line">app/src/main/res/layout/fragment_player_program_new.xml  // 背景是否重合可以复用</span><br><span class="line">app/src/main/res/layout/fragment_music_qq.xml  // 外层有白色背景，子空间的背景是否可以取消掉</span><br><span class="line">app/src/main/res/layout/fragment_player_program.xml // 背景是否重合是否可以复用，取消子空间背景</span><br><span class="line">app/src/main/res/layout/fragment_speed_dialog.xml // 背景是否可以重用</span><br><span class="line">app/src/main/res/layout/adapter_music_rank_item.xml  // 有图片了，背景是否可以取消</span><br><span class="line">app/src/main/res/layout/fragment_kw_alipay.xml  // 是否有必要多一层ConstraintLayout</span><br><span class="line">app/src/main/res/layout/fragment_player_news_new.xml  // 背景是否可以重用</span><br><span class="line">app/src/main/res/layout/my_local_radio_item.xml  // 背景是否可以重用</span><br></pre></td></tr></table></figure>
<p>上面列出的布局请重点看一下布局的背景是否可以延用外部的背景，尽量避免重绘。</p>
<p>2.控件选择加载了图片就取消背景颜色，能用xml来填充背景的尽量用xml来绘制。</p>
<h5 id="3-2-加载第一帧耗时分析"><a href="#3-2-加载第一帧耗时分析" class="headerlink" title="3.2 加载第一帧耗时分析"></a>3.2 加载第一帧耗时分析</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-681f7442cb5a5d57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动_绘制第一帧耗时.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-42c6c879c1837dde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动_第一帧测量耗时.png"></p>
<p>从图中可以看到启动主界面Choreographer绘制第一帧耗时637ms，其中测量耗时530ms,占了绝大多数的时间。自检一下自定义view中onMeasure是否有耗时操作。如果确实是空间比较多耗时可以暂时不优化。但是从下图可以看出加载布局只消耗了150ms, <strong>其他370ms需要媒体FO定位哪里耗时了</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f57c6a938c8618ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一帧measure测量.png"></p>
<h5 id="3-3-加载RecycleView布局"><a href="#3-3-加载RecycleView布局" class="headerlink" title="3.3 加载RecycleView布局"></a>3.3 加载RecycleView布局</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-44eefc8129a19dc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动_RecycleView Item.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-c718a56d7b7902ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动_RecycleView Item_topdown.png"></p>
<p>在启动阶段加载RecycleView耗时492ms, 其中onMeasure()耗时465ms，创建item和绑定View耗时300ms左右，请FO看此处是否还有优化空间，如果没有可以暂时不优化。</p>
<h5 id="3-4-滑动"><a href="#3-4-滑动" class="headerlink" title="3.4 滑动"></a>3.4 滑动</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-40223cd824bc3d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主界面滑动分析.png"></p>
<p>图中放大可以看到在主界面滑动到最底部的过程中，<strong>几乎没有丢帧</strong>。原因应该是在加载主界面的时候，将所有数据全部加载出来了，导致在滑动的时候基本不用加载数据，所以没有丢帧。</p>
<p><strong>建议：</strong>从上面两个小结看，加载RecycleView界面和数据比较耗时，因此是否可以考虑将上面部分数据的加载实现懒加载，用户看不见的界面数据不加载，或者等启动完成之后再加载。我看<strong>主界面RecycleView的下面有两行半是隐藏的，可以将下半部分未显示的布局和数据延迟加载？</strong></p>
<h5 id="3-5-布局优化"><a href="#3-5-布局优化" class="headerlink" title="3.5 布局优化"></a>3.5 布局优化</h5><h5 id="3-5-1-冗余view"><a href="#3-5-1-冗余view" class="headerlink" title="3.5.1 冗余view"></a>3.5.1 冗余view</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-b53ceb765602576b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主界面多余的view.png"></p>
<p><strong>建议：</strong>此处没有内容多余的view是否可以去掉?</p>
<h5 id="3-5-2-冗余布局"><a href="#3-5-2-冗余布局" class="headerlink" title="3.5.2 冗余布局"></a>3.5.2 冗余布局</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-24de02b80073f3de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主界面冗余布局.png"></p>
<p><strong>建议：</strong>此处只有一个view,是否可以取消掉该ConstraintLayout？</p>
<h4 id="4-酷我音乐界面丢帧分析"><a href="#4-酷我音乐界面丢帧分析" class="headerlink" title="4.酷我音乐界面丢帧分析"></a>4.酷我音乐界面丢帧分析</h4><h5 id="4-1-进入酷我音乐界面"><a href="#4-1-进入酷我音乐界面" class="headerlink" title="4.1 进入酷我音乐界面"></a>4.1 进入酷我音乐界面</h5><h5 id="4-1-1-复盘启动酷我音乐界面"><a href="#4-1-1-复盘启动酷我音乐界面" class="headerlink" title="4.1.1 复盘启动酷我音乐界面"></a>4.1.1 复盘启动酷我音乐界面</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-939f7d8fad2686c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="酷我音乐界面复盘.png"></p>
<p>调到酷我界面，从Trace文件中可以看到一共分为5个部分加载整个fragment的，分别耗时如下：</p>
<ul>
<li>第一部分：耗时<strong>68ms</strong>，测量耗时33ms, 绘制耗时26ms。此部分主要耗时在加载各种titile。</li>
<li>第二部分：耗时<strong>118ms</strong>，测量耗时99ms, 绘制耗时16ms。此部分主要耗时在加载<code>翻唱``网络</code>这个RecycleView。</li>
<li>第三部分：耗时<strong>471ms</strong>，测量耗时140ms,布局耗时318ms, 此部分主要耗时在加载<code>音乐歌单</code>这个fagment。</li>
<li>第四部分：耗时<strong>197ms</strong>，布局耗时186ms, 此部分主要耗时在加载<code>音乐榜单</code>这个fragment。</li>
<li>第五部分：耗时<strong>352ms</strong>，布局耗时340ms，此部分主要耗时在加载<code>音乐电台</code>这个fragment</li>
</ul>
<p>以上多个阶段耗时点来看，该界面主要存在懒加载问题。</p>
<p><strong>建议：</strong></p>
<p>使用ViewPager2实现懒加载。<strong>此处由于我不清楚该工程内部数据加载逻辑，请FO适配一下数据加载部分的到各fragment的逻辑。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// mediax\app\src\main\res\layout\fragment_music_qq.xml</span><br><span class="line">&lt;androidx.viewpager2.widget.ViewPager2        &lt;&lt;---- 修改成ViewPager2即可</span><br><span class="line">            android:id=&quot;@+id/view_pager&quot;</span><br><span class="line">            associatedViewId=&quot;@&#123;R.id.music_tab_layout&#125;&quot;</span><br><span class="line">            fragmentList=&quot;@&#123;vm.fragmentList&#125;&quot;</span><br><span class="line">            fragmentManager=&quot;@&#123;vm.fragmentManagerLiveData&#125;&quot;</span><br><span class="line">            initPageIndex=&quot;@&#123;vm.initPageIndex&#125;&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;0dp&quot;</span><br><span class="line">            android:layout_marginTop=&quot;@dimen/x20&quot;</span><br><span class="line">            android:fadingEdgeLength=&quot;50dp&quot;</span><br><span class="line">            android:requiresFadingEdge=&quot;horizontal&quot;</span><br><span class="line">            android:scrollbars=&quot;none&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf=&quot;@+id/music_tab_layout&quot; /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mediax\app\src\main\java\com\iflytek\autofly\mediax\ui\page\QQMusicFragment.java</span></span><br><span class="line"></span><br><span class="line">FragmentMusicQqBinding fragmentMusicQqBinding = (FragmentMusicQqBinding) getBinding();</span><br><span class="line">fragmentMusicQqBinding.viewPager.setOffscreenPageLimit(<span class="number">1</span>);  <span class="comment">// 增加此行</span></span><br><span class="line"><span class="comment">// 修改注册回调方法</span></span><br><span class="line">fragmentMusicQqBinding.viewPager.registerOnPageChangeCallback(<span class="keyword">new</span> ViewPager2.OnPageChangeCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fragments.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == position) &#123;</span><br><span class="line">                getChildFragmentManager().beginTransaction().show(fragments.get(i)).commit();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                getChildFragmentManager().beginTransaction().hide(fragments.get(i)).commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);	</span><br></pre></td></tr></table></figure>


<p><strong>优化后的启动时间:</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-dff5e591378a3a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="酷我音乐界面复盘_优化后.png"></p>
<p>从图中可以看到使用ViewPager2，将setOffscreenPageLimit()为1之后，只会加载一个界面的内容，耗时44ms。因此从该界面的大方向来说，可以优化掉<code>音乐榜单``音乐电台</code>这两个fragment的加载耗时，此处可以优化<strong>550ms</strong>左右。</p>
<h5 id="4-1-2-界面布局优化"><a href="#4-1-2-界面布局优化" class="headerlink" title="4.1.2 界面布局优化"></a>4.1.2 界面布局优化</h5><p><strong>4.1.2.1 内嵌ViewPager优化</strong></p>
<p>该界面从大方向优化之后，针对<code>音乐歌单</code>,<code>音乐榜单</code>,<code>音乐电台</code>这三个Fragment, 在<strong>布局方面</strong>还有优化空间。见如下分析。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-f298c5097fa5cc00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="音乐歌单界面懒加载.png"></p>
<p>在<code>音乐歌单</code>界面还内嵌了两个ViewPager，<strong>优化方向参照4.1.1小节</strong>使用ViewPager2懒加载布局，此处有不少tab, 启动耗时在<strong>471ms左右</strong>，应该还有很大优化空间空间。</p>
<p><strong>4.1.2.2 空间使用合理性</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13838098-b31453fcc3b93636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="酷我音乐_viewpager_refresh布局.png"></p>
<p><strong>建议：</strong></p>
<ul>
<li>此处需要考虑一个界面是否使用ViewPager是否合理？</li>
<li>此处需要考虑一下界面是否确有刷新功能需求？</li>
</ul>
<h5 id="4-2-滑动RecycleView加载"><a href="#4-2-滑动RecycleView加载" class="headerlink" title="4.2 滑动RecycleView加载"></a>4.2 滑动RecycleView加载</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-60071f50ce78ee93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="酷我音乐滑动优化.png"></p>
<p>滑动<code>音乐歌单</code>界面，可以看出滑动两次，界面几乎没有丢帧，说明数据早已加载，此处我们重点思考的方向是<strong>是否数据缓存过多，导致启动该界面变慢。</strong></p>
<p><strong>建议：</strong>由于当前项目<code>音乐歌单</code>界面用户一次性可见的item默认是10个item, 滑动过程中会有15个item,因此是否可以设置RecycleView加载item的个数，将加载item内容分散到各个滑动环节，减少首次加载过多item引起的耗时。</p>
<h5 id="4-3-滑动RecycleView回收复用"><a href="#4-3-滑动RecycleView回收复用" class="headerlink" title="4.3 滑动RecycleView回收复用"></a>4.3 滑动RecycleView回收复用</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-b26e0728297787b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="酷我音乐界面RecycleView复用调查.png"></p>
<p>上图的操作步骤：在<code>音乐歌单</code>界面向下滑动三次，然后向上滑动两次。从该图可以看出向上滑动几乎没有丢帧，说明RecycleView默认缓存了以上几次滑动的所有数据。</p>
<p><strong>建议：</strong>我们知道缓存bitmap对象一方面很吃内存资源，另一方面缓存过多item也会影响首次加载耗时。此处的优化建议如上一项，<strong>合理利用RecycleView的回收复用机制</strong>，均衡一下缓存item的量。</p>
<h4 id="5-喜马拉雅丢帧分析"><a href="#5-喜马拉雅丢帧分析" class="headerlink" title="5.喜马拉雅丢帧分析"></a>5.喜马拉雅丢帧分析</h4><h5 id="5-1-启动"><a href="#5-1-启动" class="headerlink" title="5.1 启动"></a>5.1 启动</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-3b25fd7db69559df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="喜马拉雅界面_启动.png"></p>
<p>从上图中可以看到喜马拉雅界面还是和酷我界面存在同样的问题，喜马拉雅有<code>分类节目``在线节目</code>两个fragment,问题是在启动的时候，两个fragment的布局和数据都加载了，导致启动该界面加载<code>分类节目</code>界面耗时689ms，加载<code>在线节目</code>耗时396ms。</p>
<p><strong>建议:</strong></p>
<p>使用ViewPager2实现懒加载，只加载一个界面的内容。</p>
<h5 id="5-2-RecycleView缓存"><a href="#5-2-RecycleView缓存" class="headerlink" title="5.2 RecycleView缓存"></a>5.2 RecycleView缓存</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-e74685d53a9ae6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="喜马拉雅界面_缓存.png"></p>
<p><strong>优化建议</strong>见4.2小节，合理控制RecycleView缓存的item数目。</p>
<h4 id="6-整体性能参数分析"><a href="#6-整体性能参数分析" class="headerlink" title="6.整体性能参数分析"></a>6.整体性能参数分析</h4><p><strong>说明：</strong></p>
<ul>
<li><p>测试场景：测试同学正常测试各个功能。</p>
</li>
<li><p>以下监控的性能数据是测试2750个采集周期，每个采集周期10s，7.64小时的数据。</p>
</li>
<li><p>内存图横坐标是采集周期，单位：个；纵坐标是内存占用，单位：M</p>
</li>
<li><p>CPU图横坐标是采集周期，单位：个；纵坐标是CPU占用，单位：%</p>
</li>
<li><p>View图横坐标是采集周期，单位：个；纵坐标是当次采集界面中view的个数，单位：个</p>
</li>
</ul>
<h5 id="6-1-Mediax-内存占用分析"><a href="#6-1-Mediax-内存占用分析" class="headerlink" title="6.1 Mediax 内存占用分析"></a>6.1 Mediax 内存占用分析</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-296a958fe10979c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存.png"></p>
<p>从内存方面来看:</p>
<ul>
<li>MediaX应用内存占用，最高内存<strong>385M</strong>，平均内存<strong>295M</strong></li>
<li>在监控周期内存在<strong>明显内存抖动</strong>！</li>
<li>在监控周期内存在<strong>内存泄露</strong>！</li>
</ul>
<h5 id="6-2-Mediax-CPU占用分析"><a href="#6-2-Mediax-CPU占用分析" class="headerlink" title="6.2 Mediax CPU占用分析"></a>6.2 Mediax CPU占用分析</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-4c337eeeb5413c7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU.png"></p>
<p>从CPU方面来看：</p>
<ul>
<li>最大CPU占用46%</li>
<li>平均CPU占用4.4%</li>
</ul>
<h5 id="6-3-Mediax-View占用分析"><a href="#6-3-Mediax-View占用分析" class="headerlink" title="6.3 Mediax View占用分析"></a>6.3 Mediax View占用分析</h5><p><img src="https://upload-images.jianshu.io/upload_images/13838098-05782afbf3009f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="界面View个数.png"></p>
<p>从mediax应用加载View个数来看：</p>
<ul>
<li>最多View个数：1308个</li>
<li>平均View个数：485个</li>
</ul>
<h5 id="6-4-整体性能参数小结"><a href="#6-4-整体性能参数小结" class="headerlink" title="6.4 整体性能参数小结"></a>6.4 整体性能参数小结</h5><p>从内存和View图可以看出Mediax应用存在大量图片加载和频繁<em>mirror</em>  GC的情况。此处数据也应证了第3-5章分析的RecycleView过度加载View的分析。</p>
<h4 id="7-优化方向总结"><a href="#7-优化方向总结" class="headerlink" title="7.优化方向总结"></a>7.优化方向总结</h4><ul>
<li>使用ViewPager2懒加载Fragment，不用到的Fragment不主动加载。</li>
<li>合理使用RecycleView的回收复用机制，控制Item预加载个数。</li>
<li>合理使用布局控件，合理使用ConstraintLayout，减少不必要的布局嵌套。</li>
<li>有图片的控件的View不要设置<code>android:background</code>选项，否则导致界面重叠，重绘造成界面卡顿。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统优化</tag>
        <tag>卡顿分析</tag>
      </tags>
  </entry>
  <entry>
    <title>聚媒体内存问题分析</title>
    <url>/2021/10/25/%E8%81%9A%E5%AA%92%E4%BD%93%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>从<a href="http://jackou.top/2021/10/20/GOS%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/">《GOS项目车机整体内存性能问题分析报告》</a>中可以看到媒体应用是比较消耗内存的应用，并且确实存在一定内存问题，因此此报告主要针对聚媒体应用的宏观测出的内存问题，细节分析存在问题点和优化方案。</p>
<p>从报告中取出聚媒体的内存现状如下：</p>
<p><img src="https://img-blog.csdnimg.cn/32e8dc910f09478f8b6e8eb3863577ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2媒体"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>383M</td>
<td>145M</td>
<td>295M</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<p>因此，我们从如下三个方面来看看聚媒体如何优化：</p>
<ul>
<li>大内存分配</li>
<li>内存抖动</li>
<li>内存泄露</li>
</ul>
<h3 id="1-大内存分配与内存抖动"><a href="#1-大内存分配与内存抖动" class="headerlink" title="1.大内存分配与内存抖动"></a>1.大内存分配与内存抖动</h3><h4 id="1-1-APP静止状态内存"><a href="#1-1-APP静止状态内存" class="headerlink" title="1.1 APP静止状态内存"></a>1.1 APP静止状态内存</h4><p><strong>静止状态内存</strong>可以粗略理解成媒体应用非界面运行所消耗的内存，也可以理解成运行后台服务消耗的内存。</p>
<p><img src="https://img-blog.csdnimg.cn/4f6bfadf0bf04d1bb629335e09d2f25d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="媒体静止内存"></p>
<p>媒体应用静止情况下占用内存166.4M，其中Native消耗99.3M，Code消耗51.6M，java消耗12.4M。</p>
<ul>
<li><p><strong>Native</strong>：从 C 或 C++ 代码分配的对象的内存。</p>
<p>即使您的应用中不使用 C++，您也可能会看到此处使用了一些原生内存，因为即使您编写的代码采用 Java 或 Kotlin 语言，Android 框架仍使用原生内存代表您处理各种任务，如处理图像资源和其他图形。</p>
</li>
<li><p><strong>Code</strong>：您的应用用于处理代码和资源（如 dex 字节码、经过优化或编译的 dex 代码、.so 库和字体）的内存。</p>
</li>
</ul>
<ul>
<li><strong>Java</strong>：从 Java 或 Kotlin 代码分配的对象的内存。</li>
</ul>
<p>如下对象需要FO调查一下是否分配合理，针对多次调用的场景是否可以复用。</p>
<h5 id="1-1-1-SegValue对象"><a href="#1-1-1-SegValue对象" class="headerlink" title="1.1.1 SegValue对象"></a>1.1.1 SegValue对象</h5><p><img src="https://img-blog.csdnimg.cn/9dfe7f8a6adc4efda13eb64ad6c2f72f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="静止SegValue"></p>
<p>在静止状态媒体应用会创建4812个SegValue对象，需要FO看一下是否用到，我在代码中没有grep到对应的引用。</p>
<h5 id="1-1-2-RadioInfo对象"><a href="#1-1-2-RadioInfo对象" class="headerlink" title="1.1.2 RadioInfo对象"></a>1.1.2 RadioInfo对象</h5><p><img src="https://img-blog.csdnimg.cn/765ba12dc3934cc684de2065e2725089.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="静止RadioInfo"></p>
<p>在静止状态媒体应用当扫描到电台频段的时候，会创建一个RadioInfo()对象，从图中可以看出，在此轮扫描中创建了914个对象。此处请使用<code>对象池</code>来添加对象。</p>
<p>PS: 代码中还有创建RadioInfo()对象的地方，请调查一下使用对象池。</p>
<p><strong>优化建议：</strong></p>
<p>示例如下，<strong>经过如下修复之后，可以减少大对象创建所消耗的内存和减少内存抖动。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mediax\common\src\main\java\com\gxatek\mediax\common\usecase\RadioScanUseCase.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScanFrequency</span><span class="params">(<span class="keyword">int</span> frequency, <span class="keyword">boolean</span> valid)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">        RadioInfo findRadioInfo = <span class="keyword">new</span> RadioInfo();   <span class="comment">// 此处从对象池中获取一个对象</span></span><br><span class="line">    	<span class="comment">// RadioInfo findRadioInfo = mPool.acquire();</span></span><br><span class="line">        findRadioInfo.setFrequency(String.valueOf(frequency));</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 对对象进行操作    </span></span><br><span class="line">        ......</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (!validRadioInfosPart.contains(findRadioInfo)) &#123;</span><br><span class="line">            validRadioInfosPart.add(Math.max(searchIndex, <span class="number">0</span>), findRadioInfo); <span class="comment">// 把对象加入列表</span></span><br><span class="line">            <span class="comment">// 释放对象</span></span><br><span class="line">            <span class="comment">// mPool.release(findRadioInfo);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getUseCaseCallback().onSuccess(</span><br><span class="line">                <span class="keyword">new</span> ResponseValue&lt;&gt;(<span class="keyword">new</span> Pair&lt;&gt;(validRadioInfosPart, searchIndex),</span><br><span class="line">                        <span class="keyword">new</span> ResponseStatus(ResponseCode.DATA_IS_VALID, <span class="keyword">true</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="1-1-3-Gson的TypeToken"><a href="#1-1-3-Gson的TypeToken" class="headerlink" title="1.1.3 Gson的TypeToken"></a>1.1.3 Gson的TypeToken</h5><p><img src="https://img-blog.csdnimg.cn/2568b03da3304e799d3be406f8054dff.png#pic_center" alt="静止GsonType复用"></p>
<p>代码中大量用到Gson解析json字段，在解析之前都创建了一个TypeToken对象，请FO查看该对象是否可以缓存下来复用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码举例</span></span><br><span class="line"><span class="comment">// mediax\common\src\main\java\com\gxatek\mediax\common\usecase\ResumePlayRadioUseCase.java</span></span><br><span class="line"><span class="keyword">switch</span> (requestValues.radioType) &#123;</span><br><span class="line">    <span class="keyword">case</span> RadioServiceCons.RadioType.FM:</span><br><span class="line">        <span class="comment">// 如下两个TypeToken的Type是一样的，请复用Type</span></span><br><span class="line">        mHistoryRadioList = GsonUtil.fromJson(SPUtil.getInstance().getString(Configs.HISTORY_FM_RADIO_LIST), <span class="keyword">new</span> TypeToken&lt;List&lt;RadioInfo&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RadioServiceCons.RadioType.AM:</span><br><span class="line">        <span class="comment">// 如下两个TypeToken的Type是一样的，请复用Type</span></span><br><span class="line">        mHistoryRadioList = GsonUtil.fromJson(SPUtil.getInstance().getString(Configs.HISTORY_AM_RADIO_LIST), <span class="keyword">new</span> TypeToken&lt;List&lt;RadioInfo&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-2-媒体库主界面"><a href="#1-2-媒体库主界面" class="headerlink" title="1.2 媒体库主界面"></a>1.2 媒体库主界面</h4><p><img src="https://img-blog.csdnimg.cn/0ddd0ce701f244ac98c260555fdcb341.png#pic_center" alt="媒体加载主界面内存"></p>
<table>
<thead>
<tr>
<th></th>
<th>Total</th>
<th>Native</th>
<th>Code</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td>静止状态</td>
<td>166.4M</td>
<td>99.3M</td>
<td>51.6M</td>
<td>12.4M</td>
</tr>
<tr>
<td>主界面</td>
<td>231.8M</td>
<td>157.9M</td>
<td>53.7M</td>
<td>14.4M</td>
</tr>
</tbody></table>
<p>从静止状态到进入主界面，内存消耗<strong>增加65.4M</strong>，其中主要是Native消耗了内存，<strong>占用58.6M</strong></p>
<p>因此，从宏观上，主界面增长的内存主要是Native消耗了，根据经验，主要是加载Bitmap消耗了，接下来，我们来调查Bitmap消耗的内存情况。</p>
<p><img src="https://img-blog.csdnimg.cn/9b9dc97512af4fe8a6cc5bc7a46001fb.png#pic_center" alt="主界面Bitmap内存消耗"></p>
<p>可以从图中看到主界面加载了38个Bitmap对象，消耗24M内存，逆向推导，查看bitmap加载的方法。从代码中可以看到主界面的图片是使用Glide加载的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  mediax\common\src\main\java\com\gxatek\mediax\common\binding_adapter\ImageBindingAdapter.java</span></span><br><span class="line">Glide.with(view)</span><br><span class="line">    .load(imageUrl)</span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.RESOURCE)</span><br><span class="line">    .error(error_resId)</span><br><span class="line">    .placeholder(place_resId)</span><br><span class="line">    .error(error_resId)</span><br><span class="line">    .apply(options)</span><br><span class="line">    .into(view);</span><br></pre></td></tr></table></figure>
<p>Glide是一个非常优秀的图片加载框架，但是使用Glide来加载图片会依赖于云端给的图片大小，如果云端给的图片特别大，而我们使用的空间比较小，就会出现过度加载的情况，因此推荐在使用Glide加载图片的时候，使用<code>override</code>方法来对图片进行按照空间的尺寸压缩。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(view)</span><br><span class="line">    .load(imageUrl)</span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.RESOURCE)</span><br><span class="line">    .error(error_resId)</span><br><span class="line">    .placeholder(place_resId)</span><br><span class="line">    .error(error_resId) </span><br><span class="line">    .override(<span class="number">200</span>, <span class="number">200</span>)   <span class="comment">// 控件大小为200 * 200，加载图片大小自己控制，不受制于云端。</span></span><br><span class="line">    .apply(options)</span><br><span class="line">    .into(view);</span><br></pre></td></tr></table></figure>


<h4 id="1-3-酷我音乐界面"><a href="#1-3-酷我音乐界面" class="headerlink" title="1.3 酷我音乐界面"></a>1.3 酷我音乐界面</h4><p><img src="https://img-blog.csdnimg.cn/592b8b01f5be4d85af1bb3b13a6b64d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="酷我音乐界面内存"></p>
<table>
<thead>
<tr>
<th></th>
<th>Total</th>
<th>Native</th>
<th>Code</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td>主界面</td>
<td>224.9M</td>
<td>150.7M</td>
<td>54.9M</td>
<td>13.1M</td>
</tr>
<tr>
<td>酷我音乐界面</td>
<td>257.7M</td>
<td>174.9M</td>
<td>54.9M</td>
<td>18.9M</td>
</tr>
</tbody></table>
<p>从主界面进入酷我音乐界面，内存消耗<strong>增加32.8M</strong>，其中主要是Native消耗了内存，<strong>占用24.2M</strong>。</p>
<p>酷我音乐界面创建了124个Bitmap对象，占用34M内存。</p>
<h5 id="1-3-1-背景图片重复加载"><a href="#1-3-1-背景图片重复加载" class="headerlink" title="1.3.1 背景图片重复加载"></a>1.3.1 背景图片重复加载</h5><p><img src="https://img-blog.csdnimg.cn/d4f8bcfd023b4abf810453a30a73d63f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="酷我音乐背景图片占用大内存"></p>
<p>图中可以看到有两个1080*1920尺寸的图片加载，此处怀疑是<strong>该界面有两层背景图片！</strong>一张图片暂用8M左右内存。</p>
<p><strong>PS：</strong>主界面，酷我音乐界面，喜马拉雅界面都需要看一下是否有重复加载背景图片的情况。</p>
<h5 id="1-3-2-过度加载bitmap"><a href="#1-3-2-过度加载bitmap" class="headerlink" title="1.3.2 过度加载bitmap"></a>1.3.2 过度加载bitmap</h5><p><img src="https://img-blog.csdnimg.cn/e666f796caf84fd492d94d1f88b23869.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="酷我音乐界面"></p>
<p>从图中看到RecycleView中<strong>不滑动只显示10个图片，滑动也最多显示15个图片</strong>，实际上该界面加载了<strong>124个Bitmap</strong>，需要FO对该RecycleView加载的内容数做限制。</p>
<h4 id="1-4-喜马拉雅听界面"><a href="#1-4-喜马拉雅听界面" class="headerlink" title="1.4 喜马拉雅听界面"></a>1.4 喜马拉雅听界面</h4><p><img src="https://img-blog.csdnimg.cn/9068f1582dda4956a9e01e99e1777c01.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="喜马拉雅FM界面内存"></p>
<table>
<thead>
<tr>
<th></th>
<th>Total</th>
<th>Native</th>
<th>Code</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td>主界面</td>
<td>217.5M</td>
<td>141.4M</td>
<td>54.9M</td>
<td>14.4M</td>
</tr>
<tr>
<td>酷我音乐界面</td>
<td>315.4M</td>
<td>186.3M</td>
<td>55.1M</td>
<td>65.6M</td>
</tr>
</tbody></table>
<p>从主界面进入喜马拉雅FM界面，内存消耗<strong>增加97.9M</strong>，其中主要是Native消耗了内存，<strong>占用44.9M</strong>。</p>
<p>喜马拉雅FM界面创建Bitmap对象91个，消耗内存31.4M。</p>
<h5 id="1-4-1-Bitmap内存占用问题"><a href="#1-4-1-Bitmap内存占用问题" class="headerlink" title="1.4.1 Bitmap内存占用问题"></a>1.4.1 Bitmap内存占用问题</h5><p><img src="https://img-blog.csdnimg.cn/b430a4be1879424499f7c15ad8328534.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="喜马拉雅FM图片占用大内存"></p>
<p>从上图中可以看出问题和酷我音乐界面一样</p>
<ul>
<li><strong>背景加载了两次</strong></li>
<li><strong>节目图片加载过多，需要按需加载。</strong></li>
</ul>
<h5 id="1-4-2-自定义图片加载工具"><a href="#1-4-2-自定义图片加载工具" class="headerlink" title="1.4.2 自定义图片加载工具"></a>1.4.2 自定义图片加载工具</h5><p>从代码中可以找到两个自定义的图片加载工具，分别是<code>BitmapUtil</code>和<code>FrameBitmapUtil</code>，在这两个工具中加载图片环节都有一点点小问题：<strong>就是没有根据控件大小，对图片进行压缩加载，给进来的图片多大就加载多大，站在内存资源的角度上看，对于大图片加载在小控件上，属于资源浪费。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mediax\localmusic\src\main\java\com\iflytek\autofly\localmusic\utils\BitmapUtil.java</span></span><br><span class="line"><span class="comment">// mediax\app\src\main\java\com\iflytek\autofly\mediax\utils\FrameBitmapUtil.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">loadBitmap</span><span class="params">(String drawableResPath)</span> </span>&#123;</span><br><span class="line">        Bitmap frameBitmap = <span class="keyword">null</span>;</span><br><span class="line">        BufferedSource bufferedSource = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> InputStream frameInputStream = ENT.I.getContext().getAssets().open(drawableResPath);</span><br><span class="line">            bufferedSource = Okio.buffer(Okio.source(frameInputStream));</span><br><span class="line">            <span class="keyword">byte</span>[] imageBytes = bufferedSource.readByteArray();</span><br><span class="line">            BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">            options.inSampleSize = <span class="number">1</span>;<span class="comment">// 从这两个工具类的加载图片方法中都看到直接把inSampleSize写死设置成1，不进行缩放。</span></span><br><span class="line">            <span class="keyword">if</span> (isReusableBitmap) &#123;</span><br><span class="line">                options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">                BitmapFactory.decodeByteArray(imageBytes, <span class="number">0</span>, imageBytes.length, options);</span><br><span class="line">                options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">                addInBitmapOptions(options);</span><br><span class="line">            &#125;</span><br><span class="line">            frameBitmap = BitmapFactory.decodeByteArray(imageBytes, <span class="number">0</span>, imageBytes.length, options);</span><br><span class="line">            <span class="keyword">if</span> (isReusableBitmap) &#123;</span><br><span class="line">                reuseBitmap(frameBitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != bufferedSource) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedSource.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> frameBitmap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上方法可能在我们当前项目中不会存在问题，因为当前项目给的切图都是按照需求大小给的，在供给侧已经解决了<code>大图片加载在小控件的问题</code>。但是我还是建议<strong>把这个方法做一点扩展，加上根据控件大小缩放图片的功能。</strong>代码见<code>4.2 自定义Bitmap加载类</code>。</p>
<h3 id="2-内存溢出调查"><a href="#2-内存溢出调查" class="headerlink" title="2.内存溢出调查"></a>2.内存溢出调查</h3><h4 id="2-1-调查过程"><a href="#2-1-调查过程" class="headerlink" title="2.1 调查过程"></a>2.1 调查过程</h4><p>在内存优化场景中，我们使用三个工具全方位的定位，解决问题。使用lint先把明显的问题查出来，然后使用leakcanary查看Activity，Fragment等内存泄露，通常Leakcanary都能将内存泄露发生的引用链打出来，而且可以动态监控内存泄漏，可以消除绝大多数内存泄漏点。对于比较麻烦不容易观察的，可以借助MAT工具，分析Incoming和Outgoing References，画引用关系图来定位泄漏点。</p>
<p>另外，还可以使用指令粗略观看是否有泄露。</p>
<h4 id="2-1-0-产生内存泄露测试手顺："><a href="#2-1-0-产生内存泄露测试手顺：" class="headerlink" title="2.1.0 产生内存泄露测试手顺："></a>2.1.0 产生内存泄露测试手顺：</h4><ul>
<li>在不同的 Activity 状态下，先将设备从纵向旋转为横向，再将其旋转回来，这样反复旋转多次。旋转设备经常会使应用泄漏 <code>Activity</code>、<code>Context</code> 或 <code>View</code> 对象，因为系统会重新创建 <code>Activity</code>，而如果您的应用在其他地方保持对这些对象其中一个的引用，系统将无法对其进行垃圾回收。</li>
<li>在不同的 Activity 状态下，在您的应用与其他应用之间切换（导航到主屏幕，然后返回到您的应用）。</li>
</ul>
<h4 id="2-1-1-指令粗略查看"><a href="#2-1-1-指令粗略查看" class="headerlink" title="2.1.1 指令粗略查看"></a>2.1.1 指令粗略查看</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dumpsys meminfo -a &lt;pid&gt;</span><br><span class="line">// pid为待查看应用的进程id</span><br></pre></td></tr></table></figure>
<p><strong>测试前</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/b3f7fe5534264517acfe2974a035ba3d.png#pic_center" alt="指令媒体主界面对象分配情况"></p>
<p><strong>使用2.1.0手顺猛切换测试后：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/25dc1651337544da801e790678d7ecc3.png#pic_center" alt="指令媒体本地电台对象泄露情况"></p>
<p>可以看出本地电台界面存在内存泄露，此方法只能大致定位是否存在泄露，调用栈需要结合leakcanary或者MAT。</p>
<h4 id="2-1-2-集成lint"><a href="#2-1-2-集成lint" class="headerlink" title="2.1.2 集成lint"></a>2.1.2 集成lint</h4><p>Android Lint 是Android自带的代码检查工具，它能帮助我们识别很多潜在的错误。对于大功能能够将明显的问题帮忙扫描出来。</p>
<blockquote>
<p>lint可以检测出如下几类问题：</p>
<p>Correctness 不够完美的编码，比如硬编码、使用过时 API 等<br>Performance 对性能有影响的编码，比如：静态引用，循环引用等<br>Internationalization 国际化，直接使用汉字，没有使用资源引用等<br>Security 不安全的编码，比如在 WebView 中允许使用 JavaScriptInterface 等<br>Usability 可用的，有更好的替换的 比如排版、图标格式建议.png格式 等<br>Accessibility 辅助选项，比如ImageView的contentDescription往往建议在属性中定义 等</p>
</blockquote>
<p>针对性能问题，直接选择Performance这项，根据提示修复。</p>
<p><strong>2.1.2.1 内存抖动</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mediax\app\src\main\java\com\iflytek\autofly\mediax\ui\view\lyric\LrcView.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.clipRect(<span class="keyword">new</span> Rect(getPaddingLeft(), <span class="number">0</span>, getWidth() - getPaddingRight(),</span><br><span class="line">                Integer.MAX_VALUE), Region.Op.INTERSECT);  <span class="comment">// 禁止在三大绘制流程中创建对象</span></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onMeasure()，onLayout()，onDraw()三大绘制的回调方法会大量被调用，在这三个方法中创建对象，一定会出现内存抖动，禁止在三大绘制流程中创建对象。</p>
<p><strong>2.1.2.2  ImageView+TextView合并</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// mediax\app\src\main\res\layout\media_group_qqmusic_recommend_view_stub_layout.xml</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_marginEnd=&quot;@dimen/x40&quot;</span><br><span class="line">    android:onClick=&quot;@&#123;()-&gt;click.replaceRecommendMusic()&#125;&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;</span><br><span class="line">    android:visibility=&quot;@&#123;showMusicReplacementButton ? View.VISIBLE : View.GONE&#125;&quot;</span><br><span class="line">    app:layout_constraintBottom_toBottomOf=&quot;@+id/tv_music_recommend&quot;</span><br><span class="line">    app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">    app:layout_constraintTop_toTopOf=&quot;@+id/tv_music_recommend&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:src=&quot;@drawable/library_icon_refresh&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginStart=&quot;4dp&quot;</span><br><span class="line">        android:contentDescription=&quot;@string/visible_to_say_kw_music_recommend_change&quot;</span><br><span class="line">        android:text=&quot;@string/change_tip&quot;</span><br><span class="line">        android:textColor=&quot;@color/c_e6000000&quot;</span><br><span class="line">        android:textSize=&quot;@dimen/s28&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此布局会涉及到3个view(LinearLayout、ImageView、TextView)的加载，然后只做了<code>一个旋转图片和文字的展示</code>，此布局文件可以优化成一个view，代码参考如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:id=&quot;@+id/tv_handler&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:drawableLeft=&quot;@drawable/library_icon_refresh&quot;    // 将图片放在文字左边即可</span><br><span class="line">    android:text=&quot;换一换&quot;</span><br><span class="line">    android:textColor=&quot;@color/white&quot;</span><br><span class="line">    android:textSize=&quot;28sp&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>以上优化可以将三个view优化到一个view加载，FO根据需求调整以下边界距离即可。</p>
<p><strong>2.1.2.3 过度绘制</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// mediax\app\src\main\res\layout\fragment_player_empty_new.xml</span><br><span class="line">&lt;FrameLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;@dimen/x520&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;@mipmap/default_bg&quot;&gt;   // 此处背景过度绘制</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// mediax\app\src\main\res\layout\layout_accout_bind.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/dialog_white_bg&quot;</span>&gt;</span>  // 此处背景过度绘制</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// mediax\app\src\main\res\layout\layout_accout_unbind.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/dialog_white_bg&quot;</span>&gt;</span>    // 此处背景过度绘制</span><br></pre></td></tr></table></figure>


<p><strong>2.1.2.4 内存泄露</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mediax\app\src\main\java\com\iflytek\autofly\mediax\gvoice\soundhound\Recorder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span> <span class="keyword">implements</span> <span class="title">IIRecListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Recorder mInstance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mediax\app\src\main\java\com\iflytek\autofly\mediax\voice\soundhound\Recorder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span> <span class="keyword">implements</span> <span class="title">IIRecListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Recorder mInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态单例中传入Context，可能产生内存泄露，如果代码中没有使用到，请移除该代码。</p>
<p><strong>2.1.2.5 布局层级冗余</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// mediax\app\src\main\res\layout\refresh_header.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>   // 该布局</span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;bottom&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span>         // 该布局</span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/listview_header_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingTop</span>=<span class="string">&quot;10dip&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        &lt;LinearLayout</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:minWidth=&quot;100dip&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:orientation=&quot;vertical&quot;</span><br><span class="line">            android:id=&quot;@+id/listview_header_text&quot;&gt;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id=&quot;@+id/listview_header_arrow&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginLeft=&quot;35dp&quot;</span><br><span class="line">            android:layout_marginRight=&quot;10dp&quot;</span><br><span class="line">            android:layout_toLeftOf=&quot;@+id/listview_header_text&quot;</span><br><span class="line">            android:src=&quot;@mipmap/ic_pulltorefresh_arrow&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;com.iflytek.autofly.mediax.ui.view.xrecyclerview.SimpleViewSwitcher</span><br><span class="line">            android:id=&quot;@+id/listview_header_progressbar&quot;</span><br><span class="line">            android:layout_width=&quot;30dip&quot;</span><br><span class="line">            android:layout_height=&quot;30dip&quot;</span><br><span class="line">            android:layout_toLeftOf=&quot;@+id/listview_header_text&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginLeft=&quot;40dp&quot;</span><br><span class="line">            android:layout_marginRight=&quot;10dp&quot;</span><br><span class="line">            android:visibility=&quot;invisible&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上两个布局可以取消一个，要么取消LinearLayout，要么取消RelativeLayout。</p>
<p><strong>2.1.2.6 移除没有使用到的布局文件和资源</strong></p>
<p>此优化可以根据后期是否会用到，考虑是否删除，建议没用到的都删除，以后要用到再回退出来，此优化可以优化apk大小和内存中code大小。</p>
<p>以下文件都有没有引用到的资源：</p>
<p><img src="https://img-blog.csdnimg.cn/bb4c415272c84a86bac8e7a11a04732f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="lint没有引用到的资源布局和资源文件"></p>
<h4 id="2-1-3-集成leakcanary"><a href="#2-1-3-集成leakcanary" class="headerlink" title="2.1.3 集成leakcanary"></a>2.1.3 集成leakcanary</h4><p>Leakcanary是一个检查内存泄露的工具，能够动态，大范围地锁定内存泄露问题。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在app模块的build.gradle中添加依赖，重新烧APK，使用2.1.0猛切换界面，如果有泄露会有日志和堆栈打出</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.7&#x27;</span></span><br></pre></td></tr></table></figure>


<p><strong>2.1.3.1 Leakcanary泄露警告</strong></p>
<p><img src="https://img-blog.csdnimg.cn/113600a8d37946f097596e283ef0e0db.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="leakcanary泄露报告"></p>
<p>在使用<code>本地电台</code>界面，leakcanary报出了泄露问题。</p>
<p><strong>2.1.3.2 泄露日志调用栈</strong></p>
<p><img src="https://img-blog.csdnimg.cn/27d56b9ef3c94ef9bd1897ac572635d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="泄露调用栈"></p>
<p><strong>2.1.3.3 Leakcanary界面版调用栈</strong></p>
<p><img src="https://img-blog.csdnimg.cn/5bfb048b04ca4194838710b096a987c1.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="leakcanary调用栈"></p>
<p><strong>2.1.3.4 leakcanary小结</strong></p>
<p>基于以上调用栈基本可以定位问题了，接下来就是查看源码，修复问题即可。但是为了演示比较难的泄露调查过程，下面会结合MAT分析细节分析引用情况。</p>
<h4 id="2-1-4-使用MAT分析对象引用情况"><a href="#2-1-4-使用MAT分析对象引用情况" class="headerlink" title="2.1.4 使用MAT分析对象引用情况"></a>2.1.4 使用MAT分析对象引用情况</h4><p><strong>2.1.4.1 leakcanary产生的dump日志</strong></p>
<p>以上leakcanary产生的dump文件默认存在：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/storage/emulated/0/Download/leakcanary-com.iflytek.autofly.mediax/2021-10-26_11-21-58_522.hprof</span><br></pre></td></tr></table></figure>


<p><strong>2.1.4.2 自己手动打印堆栈信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动采集heap dump文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">createDumpFile</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;start to dump heap....&quot;</span>);</span><br><span class="line">        String LOG_PATH = <span class="string">&quot;/dump.gc/&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">false</span>;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd_HH.mm.ssss&quot;</span>);</span><br><span class="line">        String createTime = sdf.format(<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">        String state = Environment.getExternalStorageState();</span><br><span class="line">        <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory().getPath() + LOG_PATH);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            String hprofPath = file.getAbsolutePath();</span><br><span class="line">            <span class="keyword">if</span> (!hprofPath.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                hprofPath += <span class="string">&quot;/&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hprofPath += createTime + <span class="string">&quot;.hprof&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Debug.dumpHprofData(hprofPath);</span><br><span class="line">                ret = <span class="keyword">true</span>;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;createDumpFile: done!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;NO SDCARD&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><strong>2.1.4.3 转化hropf文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hprof-conv heap-original.hprof heap-converted.hprof</span><br></pre></td></tr></table></figure>


<p><strong>2.1.4.4 MAT分析对象无法释放</strong></p>
<p><img src="https://img-blog.csdnimg.cn/70bc3f9a8d784624aeecd696d4557048.png#pic_center" alt="怀疑项_Handler泄露"></p>
<p>FrequencyPickerView创建了四个对象，因此看看该对象被哪些对象持有。</p>
<p><img src="https://img-blog.csdnimg.cn/675c5b10bfe647f18f7a0726c1beb96f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="MAT_incoming"></p>
<p>从Incoming图中可以看到SimpleWeakHandler持有FrequencyPickerView对象。下面2.1.5小节结合代码分析泄露原因和修复方法。</p>
<h4 id="2-1-5-部分泄露点举例"><a href="#2-1-5-部分泄露点举例" class="headerlink" title="2.1.5 部分泄露点举例"></a>2.1.5 部分泄露点举例</h4><p><strong>1.Handler泄露解决方案</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2ce1d3e384354f3aabcdeea2de47602f.png#pic_center" alt="怀疑项_Handler泄露"></p>
<p>通过上图可以看到深堆量比较大，因此怀疑内存泄露，查看对应代码，发现问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleWeakHandler</span> <span class="keyword">extends</span> <span class="title">WeakHandler</span>&lt;<span class="title">FrequencyPickerView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleWeakHandler</span><span class="params">(FrequencyPickerView owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NotNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        FrequencyPickerView view = getOwner();</span><br><span class="line">        <span class="keyword">if</span> (view.mScrollX &gt; mSpeed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mSelectListener != <span class="keyword">null</span>) &#123;   <span class="comment">// 此处引用外部类对象，持有外部view对象！</span></span><br><span class="line">                mSelectListener.onIsTuning(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            move2NextSpeed(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (offsetAngle % ITEM_ANGLE == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (view.mTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    view.mTask.cancel();</span><br><span class="line">                    view.mTask = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mPressedChangeFre) &#123;    <span class="comment">// 此处引用外部类对象，持有外部view对象！</span></span><br><span class="line">                        view.performSelect();</span><br><span class="line">                        mPressedChangeFre = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mSelectListener != <span class="keyword">null</span>) &#123;   <span class="comment">// 此处引用外部类对象，持有外部view对象！</span></span><br><span class="line">                    mSelectListener.onIsTuning(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(offsetAngle) % ITEM_ANGLE &gt;= ITEM_ANGLE / NUMBER_2) &#123;</span><br><span class="line">                    move2NextFreqPoint(view, offsetAngle);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(view.mMoveTotalX) % view.mItemWidth &lt; view.mItemWidth / NUMBER_2) &#123;</span><br><span class="line">                    move2PrevFreqPoint(view, offsetAngle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        view.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<p>从代码可以看到，其实该小伙伴是有考虑Handler内存泄露问题的，自己封装了一个WeakHandler，但是使用方法有一点问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的WeakHandler，此类自定义没问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;T&gt; mOwner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakHandler</span><span class="params">(T owner)</span> </span>&#123;</span><br><span class="line">        mOwner = <span class="keyword">new</span> WeakReference&lt;T&gt;(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题出在上面的SimpleWeakHandler</strong>，在该handler中直接引用了外部view的成员变量。</p>
<p><strong>代码修复建议：</strong></p>
<ul>
<li>使用static修饰class，防止内部类直接引用外部类成员变量</li>
<li>使用WeakReference包裹对象，当被回收之后，就不操作该对象了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleWeakHandler</span> <span class="keyword">extends</span> <span class="title">WeakHandler</span>&lt;<span class="title">FrequencyPickerView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleWeakHandler</span><span class="params">(FrequencyPickerView owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NotNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        FrequencyPickerView view = getOwner();</span><br><span class="line">        <span class="keyword">if</span>(view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;    <span class="comment">// 如果被回收了就啥也不干</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面需要操作外部view对象的成员变量，都通过view对象来引用，例如：view.xxx = xxx;</span></span><br><span class="line">        <span class="comment">//========================================</span></span><br><span class="line">        view.xxx = xxx;   <span class="comment">//运算view</span></span><br><span class="line">        view.invalidate();</span><br><span class="line">        <span class="comment">//========================================</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>PS：以上代码只是一个案例，请FO遍历工程代码，排查Handler内存泄露问题。另外解决内存泄露的handler写法可以参考模板代码4.3。</strong></p>
<p><strong>2.静态类持有Activity对象</strong></p>
<p>此问题和上面view泄露没有本质区别，但是还是此小节分析一下Activity泄露。因此我看应用整个工程的架构是MVVM，采用MVVM可能存在的泄露点就是当界面被销毁之后，没有注销监听者。下面我们来看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mediax\localradio\src\main\java\com\iflytek\autofly\localradio\ui\MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;LR_MainActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> MainViewModel mMainViewModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ActivityUtils.getInstance().addActivity(<span class="keyword">this</span>);</span><br><span class="line">        LRSingleLiveData.getInstance().observe(<span class="keyword">this</span>, messageEvent -&gt; processExtraData()); <span class="comment">//注册数据监听</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        ActivityUtils.getInstance().removeActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中看到该Activity在onCreate中注册了数据监听者，但是在onDestroy()中没有注销监听者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* LiveData keeps a strong reference to the observer and the owner as <span class="keyword">long</span> as the</span><br><span class="line">   * given LifecycleOwner is not destroyed. When it is destroyed, LiveData removes references to</span><br><span class="line">   * the observer &amp;amp; the owner.</span><br><span class="line">  <span class="comment">// LiveData持有observer和owner强引用，需要在Activity销毁之后，注销监听者</span></span><br><span class="line">  <span class="meta">@MainThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p><strong>优化建议</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LRSingleLiveData.java重写以下这两个方法，在onDestroy()中释放observer和owner。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">&quot;removeObserver&quot;</span>);</span><br><span class="line">        ObserverWrapper removed = mObservers.remove(observer);</span><br><span class="line">        <span class="keyword">if</span> (removed == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        removed.detachObserver();</span><br><span class="line">        removed.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObservers</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        assertMainThread(<span class="string">&quot;removeObservers&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt; entry : mObservers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue().isAttachedTo(owner)) &#123;</span><br><span class="line">                removeObserver(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h4 id="2-2-Android内存泄漏常见场景以及解决方案"><a href="#2-2-Android内存泄漏常见场景以及解决方案" class="headerlink" title="2.2 Android内存泄漏常见场景以及解决方案"></a>2.2 Android内存泄漏常见场景以及解决方案</h4><h5 id="2-2-1、资源性对象未关闭"><a href="#2-2-1、资源性对象未关闭" class="headerlink" title="2.2.1、资源性对象未关闭"></a>2.2.1、资源性对象未关闭</h5><p>对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后再置为null。例如Bitmap等资源未关闭会造成内存泄漏，此时我们应该在Activity销毁时及时关闭。</p>
<h5 id="2-2-2、注册对象未注销"><a href="#2-2-2、注册对象未注销" class="headerlink" title="2.2.2、注册对象未注销"></a>2.2.2、注册对象未注销</h5><p>例如BraodcastReceiver、EventBus未注销造成的内存泄漏，我们应该在Activity销毁时及时注销。</p>
<h5 id="2-2-3、类的静态变量持有大数据对象"><a href="#2-2-3、类的静态变量持有大数据对象" class="headerlink" title="2.2.3、类的静态变量持有大数据对象"></a>2.2.3、类的静态变量持有大数据对象</h5><p>尽量避免使用静态变量存储数据，特别是大数据对象，建议使用数据库存储。</p>
<h5 id="2-2-4、单例造成的内存泄漏"><a href="#2-2-4、单例造成的内存泄漏" class="headerlink" title="2.2.4、单例造成的内存泄漏"></a>2.2.4、单例造成的内存泄漏</h5><p>优先使用Application的Context，如需使用Activity的Context，可以在传入Context时使用弱引用进行封装，然后，在使用到的地方从弱引用中获取Context，如果获取不到，则直接return即可。</p>
<h5 id="2-2-5、非静态内部类的静态实例"><a href="#2-2-5、非静态内部类的静态实例" class="headerlink" title="2.2.5、非静态内部类的静态实例"></a>2.2.5、非静态内部类的静态实例</h5><p>该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。此时，我们可以将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。</p>
<h5 id="2-2-6、Handler临时性内存泄漏"><a href="#2-2-6、Handler临时性内存泄漏" class="headerlink" title="2.2.6、Handler临时性内存泄漏"></a>2.2.6、Handler临时性内存泄漏</h5><p>Message发出之后存储在MessageQueue中，在Message中存在一个target，它是Handler的一个引用，Message在Queue中存在的时间过长，就会导致Handler无法被回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。并且消息队列是在一个Looper线程中不断地轮询处理消息，当这个Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中的Message持有Handler实例的引用，Handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。解决方案如下所示：</p>
<ul>
<li>1、使用一个静态Handler内部类，然后对Handler持有的对象（一般是Activity）使用弱引用，这样在回收时，也可以回收Handler持有的对象。</li>
<li>2、在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。</li>
</ul>
<p>需要注意的是，AsyncTask内部也是Handler机制，同样存在内存泄漏风险，但其一般是临时性的。对于类似AsyncTask或是线程造成的内存泄漏，我们也可以将AsyncTask和Runnable类独立出来或者使用静态内部类。</p>
<h5 id="2-2-7、容器中的对象没清理造成的内存泄漏"><a href="#2-2-7、容器中的对象没清理造成的内存泄漏" class="headerlink" title="2.2.7、容器中的对象没清理造成的内存泄漏"></a>2.2.7、容器中的对象没清理造成的内存泄漏</h5><p>在退出程序之前，将集合里的东西clear，然后置为null，再退出程序</p>
<h5 id="2-2-8、WebView"><a href="#2-2-8、WebView" class="headerlink" title="2.2.8、WebView"></a>2.2.8、WebView</h5><p>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。我们可以为WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。</p>
<h5 id="2-2-9、使用ListView时造成的内存泄漏"><a href="#2-2-9、使用ListView时造成的内存泄漏" class="headerlink" title="2.2.9、使用ListView时造成的内存泄漏"></a>2.2.9、使用ListView时造成的内存泄漏</h5><p>在构造Adapter时，使用缓存的convertView。</p>
<h3 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3.参考文献"></a>3.参考文献</h3><p><a href="https://github.com/lykhonis/ObjectPool">1.lykhonis/ObjectPool: Object pool for Android (github.com)</a></p>
<p><a href="https://github.com/oujie123/BlockMonitor/commit/589b062b616fc5a2a9d34b20fb06d547146a998a">2.添加bitmap相关的操作和工具</a></p>
<p><a href="https://developer.android.google.cn/studio/profile/memory-profiler">3.使用内存性能分析器查看应用的内存使用情况  | Android 开发者  | Android Developers (google.cn)</a></p>
<p><a href="https://blog.csdn.net/m0_48342140/article/details/111579761?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">4.JVM 内存分析工具 MAT 的深度讲解与实践——入门篇</a></p>
<h3 id="4-参考代码"><a href="#4-参考代码" class="headerlink" title="4.参考代码"></a>4.参考代码</h3><h4 id="4-1-对象池代码"><a href="#4-1-对象池代码" class="headerlink" title="4.1 对象池代码"></a>4.1 对象池代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：在需要使用对象池的地方创建一个对象池，TestBean为对象池内存放的对象</span></span><br><span class="line"><span class="comment">// 默认对象池容量为4个，不建议修改为太大的值。</span></span><br><span class="line"><span class="keyword">private</span> ObjectPool mPool = <span class="keyword">new</span> ObjectPool() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TestBean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：从对象池获取一个对象，并且使用</span></span><br><span class="line">TestBean tmp = mPool.acquire();</span><br><span class="line">tmp.setAge(<span class="number">18</span>);</span><br><span class="line">tmp.setName(<span class="string">&quot;JackOu&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步：释放临时对象</span></span><br><span class="line">mPool.release(tmp);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectPool.java 对象池类代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.collection.SimpleArrayMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object Pool is thread-safe pattern to simplify access and reuse common objects. Particular object</span></span><br><span class="line"><span class="comment"> * pool supports creation of object by using factory pattern as well as multiple type of object sets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_INITIAL_CAPACITY = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt; DEFAULT_TYPE = DefaultClass.class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SimpleArrayMap&lt;Class&lt;?&gt;, Object[]&gt; mPool;</span><br><span class="line">    Object[] mInuse;</span><br><span class="line">    Factory mFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create empty thread-safe object pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create empty thread-safe object pool</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory Factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectPool</span><span class="params">(Factory factory)</span> </span>&#123;</span><br><span class="line">        mFactory = factory;</span><br><span class="line">        mPool = <span class="keyword">new</span> SimpleArrayMap&lt;&gt;(POOL_INITIAL_CAPACITY);</span><br><span class="line">        mInuse = <span class="keyword">new</span> Object[POOL_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquire object in pool or create new if does not exist</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Type of object set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object from set type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">acquire</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPool) &#123;</span><br><span class="line">            Object[] pool = mPool.get(type);</span><br><span class="line">            <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPool.put(type, pool = <span class="keyword">new</span> Object[POOL_INITIAL_CAPACITY]);</span><br><span class="line">            &#125;</span><br><span class="line">            Object object = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> size = pool.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    object = pool[i];</span><br><span class="line">                    pool[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (object == <span class="keyword">null</span> &amp;&amp; (object = create(type)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Create has to return non-null object!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            size = mInuse.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInuse[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) (mInuse[i] = object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mInuse = grow(mInuse, idealObjectArraySize(size * <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">return</span> (T) (mInuse[size] = object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inuse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object object : mInuse) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object != <span class="keyword">null</span>) size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sizeDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(DEFAULT_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        Object[] pool = mPool.get(type);</span><br><span class="line">        <span class="keyword">if</span> (pool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object object : pool) &#123;</span><br><span class="line">                <span class="keyword">if</span> (object != <span class="keyword">null</span>) size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all objects of set type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Type of object set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPool) &#123;</span><br><span class="line">            Object[] pool = mPool.get(type);</span><br><span class="line">            <span class="keyword">if</span> (pool != <span class="keyword">null</span>) clear(pool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all objects and sets</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPool) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = mPool.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Object[] pool = mPool.valueAt(i);</span><br><span class="line">                <span class="keyword">if</span> (pool != <span class="keyword">null</span>) clear(pool);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquire object in pool or create new if does not exist</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object from set type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) acquire(DEFAULT_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release object acquired from pool back</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object Object to release back to pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPool) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = indexOf(mInuse, object);</span><br><span class="line">            <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mInuse[index] = <span class="keyword">null</span>;</span><br><span class="line">                Class&lt;?&gt; type = object.getClass();</span><br><span class="line">                <span class="keyword">if</span> (!mPool.containsKey(type)) type = DEFAULT_TYPE;</span><br><span class="line">                Object[] pool = mPool.get(type);</span><br><span class="line">                <span class="keyword">int</span> size = pool.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pool[i] = object;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pool = grow(pool, idealObjectArraySize(size * <span class="number">2</span>));</span><br><span class="line">                pool[size] = object;</span><br><span class="line">                mPool.put(type, pool);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create new object for type set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Type of object set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Non-null object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFactory == <span class="keyword">null</span> ? <span class="keyword">null</span> : mFactory.create(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Factory to create objects for pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Create new object for type set</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> type Type of object set</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> Non-null object</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">Object <span class="title">create</span><span class="params">(Class&lt;?&gt; type)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object[] array, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == object) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Object[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            array[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object[] grow(Object[] array, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, result, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">idealObjectArraySize</span><span class="params">(<span class="keyword">int</span> need)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idealByteArraySize(need * <span class="number">4</span>) / <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">idealByteArraySize</span><span class="params">(<span class="keyword">int</span> need)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (need &lt;= (<span class="number">1</span> &lt;&lt; i) - <span class="number">12</span>)</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; i) - <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-2-自定义Bitmap加载类"><a href="#4-2-自定义Bitmap加载类" class="headerlink" title="4.2 自定义Bitmap加载类"></a>4.2 自定义Bitmap加载类</h4><p>关于bitmap相关的一些操作，详见《参考文献3.2》,仅供相互交流参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapLoadTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//======================从本地（SDcard）文件读取=======================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缩放后的本地图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width    宽</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height   高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">readBitmapFromFile</span><span class="params">(String filePath, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeFile(filePath, options);</span><br><span class="line">        <span class="keyword">float</span> srcWidth = options.outWidth;</span><br><span class="line">        <span class="keyword">float</span> srcHeight = options.outHeight;</span><br><span class="line">        <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (srcHeight &gt; height || srcWidth &gt; width) &#123;</span><br><span class="line">            <span class="keyword">if</span> (srcWidth &gt; srcHeight) &#123;</span><br><span class="line">                inSampleSize = Math.round(srcHeight / height);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inSampleSize = Math.round(srcWidth / width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        options.inSampleSize = inSampleSize;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeFile(filePath, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缩放后的本地图片</span></span><br><span class="line"><span class="comment">     * readBitmapFromFileDescriptor()效率高于readBitmapFromFile()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width    宽</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height   高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">readBitmapFromFileDescriptor</span><span class="params">(String filePath, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">            BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">            options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">            BitmapFactory.decodeFileDescriptor(fis.getFD(), <span class="keyword">null</span>, options);</span><br><span class="line">            <span class="keyword">float</span> srcWidth = options.outWidth;</span><br><span class="line">            <span class="keyword">float</span> srcHeight = options.outHeight;</span><br><span class="line">            <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (srcHeight &gt; height || srcWidth &gt; width) &#123;</span><br><span class="line">                <span class="keyword">if</span> (srcWidth &gt; srcHeight) &#123;</span><br><span class="line">                    inSampleSize = Math.round(srcHeight / height);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    inSampleSize = Math.round(srcWidth / width);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">            options.inSampleSize = inSampleSize;</span><br><span class="line">            <span class="keyword">return</span> BitmapFactory.decodeFileDescriptor(fis.getFD(), <span class="keyword">null</span>,</span><br><span class="line">                    options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//======================从输入流中读取文件（网络加载）=======================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缩放后的本地图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ins    输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width  宽</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">readBitmapFromInputStream</span><span class="params">(InputStream ins, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeStream(ins, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="keyword">float</span> srcWidth = options.outWidth;</span><br><span class="line">        <span class="keyword">float</span> srcHeight = options.outHeight;</span><br><span class="line">        <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (srcHeight &gt; height || srcWidth &gt; width) &#123;</span><br><span class="line">            <span class="keyword">if</span> (srcWidth &gt; srcHeight) &#123;</span><br><span class="line">                inSampleSize = Math.round(srcHeight / height);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inSampleSize = Math.round(srcWidth / width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        options.inSampleSize = inSampleSize;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeStream(ins, <span class="keyword">null</span>, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//======================Resource资源加载=======================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用decodeResource()相对比较消耗内存，建议用decodeStream()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resources</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resourcesId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">readBitmapFromResourceUsingDecodeResource</span><span class="params">(Resources resources, <span class="keyword">int</span> resourcesId, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeResource(resources, resourcesId, options);</span><br><span class="line">        <span class="keyword">float</span> srcWidth = options.outWidth;</span><br><span class="line">        <span class="keyword">float</span> srcHeight = options.outHeight;</span><br><span class="line">        <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (srcHeight &gt; height || srcWidth &gt; width) &#123;</span><br><span class="line">            <span class="keyword">if</span> (srcWidth &gt; srcHeight) &#123;</span><br><span class="line">                inSampleSize = Math.round(srcHeight / height);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inSampleSize = Math.round(srcWidth / width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        options.inSampleSize = inSampleSize;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeResource(resources, resourcesId, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">readBitmapFromResourceUsingDecodeStream</span><span class="params">(Resources resources, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">            resourcesId, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        InputStream ins = resources.openRawResource(resourcesId);</span><br><span class="line">        BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeStream(ins, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="keyword">float</span> srcWidth = options.outWidth;</span><br><span class="line">        <span class="keyword">float</span> srcHeight = options.outHeight;</span><br><span class="line">        <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (srcHeight &gt; height || srcWidth &gt; width) &#123;</span><br><span class="line">            <span class="keyword">if</span> (srcWidth &gt; srcHeight) &#123;</span><br><span class="line">                inSampleSize = Math.round(srcHeight / height);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inSampleSize = Math.round(srcWidth / width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        options.inSampleSize = inSampleSize;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeStream(ins, <span class="keyword">null</span>, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//======================Assets资源加载方式=======================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缩放后的本地图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径,即文件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">readBitmapFromAssetsFile</span><span class="params">(Context context, String</span></span></span><br><span class="line"><span class="function"><span class="params">            filePath)</span> </span>&#123;</span><br><span class="line">        Bitmap image = <span class="keyword">null</span>;</span><br><span class="line">        AssetManager am = context.getResources().getAssets();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = am.open(filePath);</span><br><span class="line">            image = BitmapFactory.decodeStream(is);</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//======================从二进制数据读取图片=======================</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">readBitmapFromByteArray</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">        BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length, options);</span><br><span class="line">        <span class="keyword">float</span> srcWidth = options.outWidth;</span><br><span class="line">        <span class="keyword">float</span> srcHeight = options.outHeight;</span><br><span class="line">        <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (srcHeight &gt; height || srcWidth &gt; width) &#123;</span><br><span class="line">            <span class="keyword">if</span> (srcWidth &gt; srcHeight) &#123;</span><br><span class="line">                inSampleSize = Math.round(srcHeight / height);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inSampleSize = Math.round(srcWidth / width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">        options.inSampleSize = inSampleSize;</span><br><span class="line">        <span class="keyword">return</span> BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-3-Handler解决内存泄露的模板写法"><a href="#4-3-Handler解决内存泄露的模板写法" class="headerlink" title="4.3 Handler解决内存泄露的模板写法"></a>4.3 Handler解决内存泄露的模板写法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivityLeak</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TextView mTextView;</span><br><span class="line">    MyHandler mMyHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main_leak);</span><br><span class="line">        mTextView = findViewById(R.id.tv_handler);</span><br><span class="line">        mMyHandler = <span class="keyword">new</span> MyHandler(MainActivityLeak.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用static修饰类，防止内部类直接引用外部类成员变量</span></span><br><span class="line">    <span class="comment">// WeakReference修饰外部类对象，如果被回收了，就取消操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;MainActivityLeak&gt; mWeakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivityLeak activity)</span> </span>&#123;</span><br><span class="line">            mWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            MainActivityLeak mainActivity = mWeakReference.get();</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (mainActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mainActivity.mTextView.setText(msg.obj + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统优化</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title>GOS项目整体应用性能问题</title>
    <url>/2021/10/20/GOS%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h4><p>0.声明</p>
<p>1.背景</p>
<p>2.内存监控数据分析</p>
<p>3.车机内存性能问题总结</p>
<p>4.优化建议</p>
<p>5.参考文献</p>
<h3 id="0-声明"><a href="#0-声明" class="headerlink" title="0.声明"></a>0.声明</h3><p><strong>说明：</strong></p>
<ul>
<li>测试场景：测试同学正常测试各个功能，采集周期起始点并非重新开机。</li>
<li>以下监控的性能数据是测试2750个采集周期，每个采集周期10s，7.64小时的数据。</li>
<li>内存图横坐标是采集周期，单位：个；纵坐标是内存占用，单位：M</li>
<li>CPU图横坐标是采集周期，单位：个；纵坐标是CPU占用，单位：%</li>
<li>View图横坐标是采集周期，单位：个；纵坐标是当次采集界面中view的个数，单位：个</li>
<li>可用内存图横坐标是采集周期，单位：个；纵坐标是当前系统可用内存，单位：kb</li>
</ul>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>在以上测试周期日志中，发现有一次lowmemorykiller（LMK）杀进程的记录，通过杀oom_score_adj为906的进程来回收了约300M内存。从此项指标可以看出我们当前的系统长时间运行过程之后，会导致可用内存越来越少，最后触发LMK来回收内存资源。因此，此报告主要分析当前项目中各个应用暴露出来的内存问题。</p>
<p><img src="https://img-blog.csdnimg.cn/b09b45853f45406fa4e4b7ab79982c3b.png#pic_center" alt="lmk杀进程"></p>
<h3 id="2-内存监控数据分析"><a href="#2-内存监控数据分析" class="headerlink" title="2.内存监控数据分析"></a>2.内存监控数据分析</h3><h4 id="2-1-车机整体内存情况"><a href="#2-1-车机整体内存情况" class="headerlink" title="2.1 车机整体内存情况"></a>2.1 车机整体内存情况</h4><h5 id="2-1-1-系统总体可用内存"><a href="#2-1-1-系统总体可用内存" class="headerlink" title="2.1.1 系统总体可用内存"></a>2.1.1 系统总体可用内存</h5><p><img src="https://img-blog.csdnimg.cn/5cdcbabab87041c9b6bd09038fab56a2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="系统总共可用内存"></p>
<p>系统总体可用物理内存：<strong>5754876kb ≈ 5.49G</strong></p>
<h5 id="2-1-2-系统总体可用剩余物理内存"><a href="#2-1-2-系统总体可用剩余物理内存" class="headerlink" title="2.1.2 系统总体可用剩余物理内存"></a>2.1.2 系统总体可用剩余物理内存</h5><p><img src="https://img-blog.csdnimg.cn/d288d415deab4bbea0153915a5085f65.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="系统可用内存"></p>
<ul>
<li><p>采集周期起始点所剩内存：2718080kb ≈ 2.59G</p>
</li>
<li><p>采集周期内最低所剩内存：724644 ≈ 690M</p>
<p> (说明：此值是LMK回收后的所剩内存值。当系统内存少于315M时，系统就会自动把<code>/proc/&lt;pid&gt;/oom_score_adj</code>中oom_score_adj的值大于900，少于1000的进程杀掉)</p>
</li>
<li><p>从图中可以看出可用内存<strong>在监控周期内持续降低</strong>，出现这种情况有两个原因：</p>
<ul>
<li>一是启动了新应用，重新分配了内存导致可用内存下降。</li>
<li>二是应用<strong>内存泄露</strong>，导致内存持续无法回收。初步判断可用内存持续降低会和内存泄露有关系，因为当前项目几乎全部应用都使用了平台签名，属于系统应用，oom_adj值比较低，正常情况下，所剩内存低于126M才会触发杀这些进程。所以可以近似认为系统应用进程是保活的，所以初步断定可用内存持续下降和应用内存泄露，内存持续无法被回收有关系。</li>
</ul>
</li>
<li><p>从图中可以看出可用内存在<strong>一些时刻有突然陡降的现象</strong>，出现这种情况有两种可能：</p>
<ul>
<li>一是某些应用启动加载过多资源，导致内存在短时间内消耗过多，建议应用用时再初始化加载资源。</li>
<li>二是有进程崩溃或者被杀掉，释放出部分内存。</li>
</ul>
</li>
</ul>
<h5 id="2-1-3-系统活跃-非活跃内存"><a href="#2-1-3-系统活跃-非活跃内存" class="headerlink" title="2.1.3 系统活跃/非活跃内存"></a>2.1.3 系统活跃/非活跃内存</h5><blockquote>
<p>Active : 最近使用的内存量，除非绝对必要，否则通常不会回收(以kb为单位)。</p>
<p>Inactive : 最近使用较少且更有资格回收用于其他目的的内存量(以kb为单位)。</p>
<p>ActiveFile: 自上次系统回收内存以来，处于活动使用状态或处于活动使用状态的文件缓存内存量（以kb为单位）</p>
<p>InactiveFile：从磁盘新加载的文件缓存内存量，或者是要回收的候选文件缓存内存量。（以kb为单位）</p>
</blockquote>
<p><strong>2.1.3.1 Active图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/ba74213068824c7aa938db3519062ed0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="系统总共Active内存"></p>
<p>从Active内存图可以看出系统所有进程在整个监控周期内平均消耗：3571792kb ≈ 3.41G，总共可用内存5.49G，平均使用率：<strong>62%</strong></p>
<p><strong>2.1.3.2 Inactive 图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/d93c57884fc44b1c8a107f78d44599d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="系统总共Inactive内存"></p>
<p>从Inactive图中可以看出系统在监控周期内空闲的内存大小平均为：492299kb ≈ 469M，空闲内存率：8.5%，此参数说明系统在特别需要内存的时候可以分配的内存。</p>
<p><strong>2.1.3.3 Active file图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c71327a864e94da486f3a45eca91ae99.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="ActiveFile图"></p>
<p>从Active file图中可以看出系统在监控周期内,系统回收后剩余的内存越来越少，并且存在比较大的抖动。</p>
<p>缓存活跃文件内存最大：815492kb ≈ 778M；最小：105736kb ≈ 100.8M；平均：429188kb ≈ 409.3M。可以看出在整个监控周期内，系统在持续压缩缓存文件的大小，并且期间存在进程崩溃情况。</p>
<p><strong>2.1.3.4 InActive file图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/81d0c099177341378e5f193b6b46a756.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="InactiveFile图"></p>
<p>从Inactive file图中可以看出系统中在前期有1626812kb ≈ 1.55G <strong>从磁盘新加载的文件缓存内存量，或者有待系统回收的内存！</strong>此处需要调查哪些应用启动会加载过多过大文件到内存。</p>
<h4 id="2-2-应用内存消耗分析"><a href="#2-2-应用内存消耗分析" class="headerlink" title="2.2 应用内存消耗分析"></a>2.2 应用内存消耗分析</h4><h5 id="2-2-1-内存优化方向与目标"><a href="#2-2-1-内存优化方向与目标" class="headerlink" title="2.2.1 内存优化方向与目标"></a>2.2.1 内存优化方向与目标</h5><p>应用内存优化目标有四个方向：</p>
<ul>
<li>无内存泄露</li>
<li>无内存抖动，小范围内存抖动可接受</li>
<li>不存在阶梯内存(稳定性)</li>
<li>降低内存消耗</li>
</ul>
<p>下面给出<strong>GOS一期</strong>应用内存监控结果，作为优化目标方向。</p>
<p>以下是腾讯系应用内存占用情况：</p>
<p><img src="https://img-blog.csdnimg.cn/a364a7d743794ff8977441b0725fee25.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="腾讯语音"></p>
<p><img src="https://img-blog.csdnimg.cn/9937482b44194b11b6debcee5b3e9145.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="腾讯新闻"></p>
<p><img src="https://img-blog.csdnimg.cn/03b6321a25eb40479f50a829a69b4f34.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="腾讯地图"></p>
<p><img src="https://img-blog.csdnimg.cn/d8e3de4cb621407495ab105f56643319.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="腾讯基础库"></p>
<p><img src="https://img-blog.csdnimg.cn/58ba2d080ec349dc8250f1e2d852f6f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="腾讯音乐"></p>
<p>以下是高德系内存占用情况：</p>
<p><img src="https://img-blog.csdnimg.cn/61ef853e8e344172bdc9493cf85544e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="高德地图"></p>
<p><img src="https://img-blog.csdnimg.cn/58a8c389b9504ec0ad430439318245eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="高德定位服务"></p>
<p>以下是中科创达系内存占用情况：</p>
<p><img src="https://img-blog.csdnimg.cn/278893264da143fe90c5d55e0b327d89.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="智联助手"></p>
<p><img src="https://img-blog.csdnimg.cn/afe6a55d63cd499bb485374c03b7fc53.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="倒车"></p>
<p><img src="https://img-blog.csdnimg.cn/098f44976dde439d8cba2d3e9d0512bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="语音适配器"></p>
<p><img src="https://img-blog.csdnimg.cn/37ef56c941914731aa3fa8d50ad98729.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="USB升级"></p>
<p><strong>小结:</strong></p>
<p>从上面图中可以看出在监控期间，腾讯系的应用内存最稳定，高德和创达的应用存在小幅波动，在可接受范围内。三家公司的应用总体内存消耗都比较低。</p>
<h5 id="2-2-2-当前应用内存消耗现状"><a href="#2-2-2-当前应用内存消耗现状" class="headerlink" title="2.2.2 当前应用内存消耗现状"></a>2.2.2 当前应用内存消耗现状</h5><p><strong>2.2.2.1 语音助理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/a9beca6943244d23a8fd65bb4f208c13.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2语音助理"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>436M</td>
<td>356M</td>
<td>390M</td>
<td>存在</td>
<td>少量</td>
<td>少量</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>降低内存使用</li>
<li>增加对象复用，减少内存抖动</li>
</ul>
<p><strong>2.2.2.2 媒体</strong></p>
<p><img src="https://img-blog.csdnimg.cn/3e3e09daae654da2bbe588036c7cc24a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2媒体"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>383M</td>
<td>145M</td>
<td>295M</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>控制对象创建个数，建立对象池实现对象复用</li>
<li>调查不能释放的内存</li>
<li>资源按需加载、调查加载占用大内存的资源原因，bitmap对象是否按空间尺寸压缩加载，预置图片资源放在适合屏幕尺寸的目录中。</li>
<li>看过之前卡顿分析报告，内存暂用大主要还是存在加载缓存bitmap过多所致。</li>
</ul>
<p><strong>2.2.2.3 主屏Launcher</strong></p>
<p><img src="https://img-blog.csdnimg.cn/309b3a2a911244f29537e1f0fc38c253.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2Launcher"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>432M</td>
<td>118M</td>
<td>282M</td>
<td>存在</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>出现阶梯内存，需要<strong>单独跑monkey</strong>调查崩溃原因，保证稳定性</li>
<li>存在内存抖动需要调查对象分配和复用情况</li>
</ul>
<p><strong>2.2.2.4 Avatar</strong></p>
<p><img src="https://img-blog.csdnimg.cn/79f72a18c6af4e2d94d210b1275cdb43.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2Avatar"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>609M</td>
<td>33M</td>
<td>242M</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>存在<strong>严重内存泄露</strong>，调查不能释放的对象</li>
<li>每次加载对象都在<strong>50-100M</strong>，需要调查为什么一次性需要加载那么多资源，bitmap对象是否按空间尺寸压缩加载</li>
</ul>
<p><strong>2.2.2.5 讯飞输入法</strong></p>
<p><img src="https://img-blog.csdnimg.cn/a658643fdb9c41148d48627bf9b2c67c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2输入法"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>229M</td>
<td>194M</td>
<td>211M</td>
<td>少量</td>
<td>暂无</td>
<td>少量</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查部分对象创建使用完了就被回收的原因，建议对象复用减少内存抖动</li>
<li>是否可以减少部分资源的加载，输入法应用总体暂用内存比较高</li>
</ul>
<p><strong>2.2.2.6 系统设置</strong></p>
<p><img src="https://img-blog.csdnimg.cn/61b588b840c54a4f9f3cf889db8893d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2设置"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>330M</td>
<td>47M</td>
<td>155M</td>
<td>少量</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>存在<strong>严重内存泄露</strong>，调查不能释放的对象</li>
<li>有部分<strong>分配大内存</strong>迹象需要调查</li>
</ul>
<p><strong>2.2.2.7 车辆设置</strong></p>
<p><img src="https://img-blog.csdnimg.cn/0c953d2976c34df39b9be28843c6a4ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="车辆设置"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>178M</td>
<td>34M</td>
<td>121M</td>
<td>少量</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>存在<strong>严重内存泄露</strong>，调查不能释放的对象</li>
<li>有部分<strong>分配大内存</strong>迹象需要调查</li>
</ul>
<p><strong>2.2.2.8 空调</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/a3c7f95f05c64b91a3f039d4db3bc658.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2空调"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>185M</td>
<td>99M</td>
<td>106M</td>
<td>否</td>
<td>否</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查开始阶段是否crash了，需要单独monkey测试稳定性</li>
</ul>
<p><strong>2.2.2.9 空调服务</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2f42082249fb4866a5d1dee52de0ea54.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2空调服务"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>94M</td>
<td>85M</td>
<td>86M</td>
<td>否</td>
<td>否</td>
<td>少量</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查部分分配大内存情况</li>
</ul>
<p><strong>2.2.2.10 SystemUi</strong></p>
<p><img src="https://img-blog.csdnimg.cn/fb336774fa224293b486f8a374194939.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2SystemUi"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>93M</td>
<td>65M</td>
<td>78M</td>
<td>少量</td>
<td>否</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>监控前期出现内存陡增情况，需要调查原因</li>
</ul>
<p><strong>2.2.2.11 账号</strong></p>
<p><img src="https://img-blog.csdnimg.cn/15fa6f1095434149be82f1bf583c06cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2账号"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>121M</td>
<td>14M</td>
<td>56M</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>存在内存抖动需要调查内存复用</li>
<li>从两端内存图可以看出有内存泄露情况</li>
<li>出现严重阶梯，需要单独monkey测试稳定性</li>
</ul>
<p><strong>2.2.2.12 AVDC</strong></p>
<p><img src="https://img-blog.csdnimg.cn/323e9499f603455e96729ac5bd57d3a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2AVDC"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>61M</td>
<td>36M</td>
<td>43M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>需要单独monkey调查该应用稳定性</li>
</ul>
<p><strong>2.2.2.13 DVR</strong></p>
<p><img src="https://img-blog.csdnimg.cn/f6e18b4b51b84a5da4c1627035745ba1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2DVR"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>55M</td>
<td>21M</td>
<td>40M</td>
<td>存在</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查对象分配和回收，尽量对象复用</li>
<li>存在<strong>严重内存泄露</strong>，调查不能释放的对象</li>
</ul>
<p><strong>2.2.2.14 副屏launcher</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c78534814ffc4f3c957251816c91613a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2副屏Launcher"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>41M</td>
<td>32M</td>
<td>33M</td>
<td>少量</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查局部出现大对象分配场景</li>
</ul>
<p><strong>2.2.2.15 btcall</strong></p>
<p><img src="https://img-blog.csdnimg.cn/6fc1bb839dbb41619da229216244508c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2btcall"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>32M</td>
<td>23M</td>
<td>30M</td>
<td>否</td>
<td>否</td>
<td>少量</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查早期内存阶梯上升原因，如果因为启动应用，可以忽略。</li>
</ul>
<p><strong>2.2.2.16 场景引擎</strong></p>
<p><img src="https://img-blog.csdnimg.cn/cb3127db15bd4c35a53ea03947c1b292.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2场景引擎"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>38M</td>
<td>16M</td>
<td>29M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查大对象分配场景</li>
<li>对于常用的对象采用对象复用机制</li>
</ul>
<p><strong>2.2.2.17 schedule</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/a5db1e8b23b44f3c9a7de1c7dc885338.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2日程"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>39M</td>
<td>14M</td>
<td>29M</td>
<td>少量</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>需要调查出现阶梯内存原因是进程被杀还是分配了大对象，从上图看，更像进程被杀的现象，建议先单独跑monkey查看稳定性</li>
</ul>
<p><strong>2.2.2.18 媒体子进程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/ea5a30d22f1b41deb5be25083010530b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2媒体子进程"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>50M</td>
<td>10M</td>
<td>28M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查是否有大资源加载，中间有加载了又被回收的表象，建议按需加载资源</li>
</ul>
<p><strong>2.2.2.19 GCS</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2128ab65759949a7bf3698544b3df4a4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2GCS"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>40M</td>
<td>14M</td>
<td>28M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>数据埋点模块加载数据上报的对象是否可以复用</li>
<li>账号模块的Bean对象是否可以复用</li>
<li>调查大对象创建和回收时机，尽量复用对象。</li>
</ul>
<p><strong>2.2.2.20 消息中心</strong></p>
<p><img src="https://img-blog.csdnimg.cn/a8c1b25fd76c406aaacfae761aada4f5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2消息中心"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>58M</td>
<td>17M</td>
<td>27M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查大对象创建情况，实现对象复用机制</li>
</ul>
<p><strong>2.2.2.21 讯飞账号中心</strong></p>
<p><img src="https://img-blog.csdnimg.cn/795ab0f2fc6c466aa2931f1d245c1f5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2账号中心"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>35M</td>
<td>11M</td>
<td>24M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li><p>调查大对象分配与释放场景</p>
</li>
<li><p>复用内存减少内存抖动</p>
</li>
</ul>
<p><strong>2.2.2.22 讯飞SystemServer</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c952e6c34dc8493497a593cbaeeea062.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2讯飞SystemServer"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>37M</td>
<td>16M</td>
<td>22M</td>
<td>少量</td>
<td>少量</td>
<td>少量</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查大对象创建场景是否在循环中创建对象，此对象是否可以new一个复用。</li>
</ul>
<p><strong>2.2.2.23 讯飞aiangela</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/3e7b4824a81642948b87766838e37f0c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2讯飞Aianglela"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>25M</td>
<td>7M</td>
<td>17M</td>
<td>少量</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>单独跑monkey,检测应用稳定性</li>
</ul>
<p><strong>2.2.2.24 扩展service</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e48ec4bec7bd4636a7c44d27f9efc94a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2扩展服务"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>30M</td>
<td>12M</td>
<td>17M</td>
<td>存在</td>
<td>不存在</td>
<td>少量</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查大对象创建场景</li>
</ul>
<p><strong>2.2.2.25 carplay</strong></p>
<p><img src="https://img-blog.csdnimg.cn/abaf0252160346eb8cc3588b957c29c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarPlay"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>22M</td>
<td>13M</td>
<td>16M</td>
<td>少量可以接受</td>
<td>少量可接受</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.26 hardkey</strong></p>
<p><img src="https://img-blog.csdnimg.cn/18a7e4b1969f4a0f8e59bc6fb5c6e6e2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2硬按键"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>8M</td>
<td>15M</td>
<td>少量可接受</td>
<td>少量可接受</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查监控前期突然升高是否是启动服务，如果是可以暂时不优化。</li>
</ul>
<p><strong>2.2.2.27 讯飞平台服务</strong></p>
<p><img src="https://img-blog.csdnimg.cn/b53b0d421911491cadb781b89726fe14.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2平台适配器"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>8M</td>
<td>15M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查监控前期突然升高是否是启动服务，如果是可以暂时不优化。</li>
</ul>
<p><strong>2.2.2.28 账号服务端</strong></p>
<p><img src="https://img-blog.csdnimg.cn/9c7c580a68cb40328b52ef93832f401b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2账号服务端"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>22M</td>
<td>11M</td>
<td>15M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.29 媒体中心服务</strong></p>
<p><img src="https://img-blog.csdnimg.cn/3966b395856343bf87555a9f75a06aa7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2媒体中心服务端"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>9M</td>
<td>15M</td>
<td>少量</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>存在少量内存突然抖动场景，需要调查一下发生场景</li>
<li>内存图后半部分出现阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.30 Power</strong></p>
<p><img src="https://img-blog.csdnimg.cn/3c7adb43a588413e826aa4ee29ddf529.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarPower"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>10M</td>
<td>15M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到大量阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.31 screensaver</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/95c21b89c05b4c9aa9a289babf78f6c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2屏保"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>9M</td>
<td>15M</td>
<td>少量</td>
<td>少量可接受</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.32 Car.hvac</strong></p>
<p><img src="https://img-blog.csdnimg.cn/a9faa6402f2a4b18aa075171f68c7b1e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2Car空调"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>16M</td>
<td>8M</td>
<td>14M</td>
<td>少量可接受</td>
<td>少量可接受</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.33 platformservice.Services</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/2e19ff7bb34b45b3b1e01b0e6c37b016.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2平台服务"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>23M</td>
<td>11M</td>
<td>14M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>需要调查是稳定性还是在某些场景创建了大对象。</li>
</ul>
<p><strong>2.2.2.34 miniprogram</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/f76a70d257bf486a8fd4f953a0d156c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2小程序"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>79M</td>
<td>10M</td>
<td>13M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p>2.2.2.35 caradapter </p>
<p><img src="https://img-blog.csdnimg.cn/5df09633c03a4535902e22f46f38fa8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarAdapter"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>19M</td>
<td>10M</td>
<td>13M</td>
<td>少量可接受</td>
<td>少量可接受</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
<li>调查某些场面分配大对象</li>
</ul>
<p><strong>2.2.2.36 externalkey</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/52f8bb7be12f4834b0f40d7b2a5452fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2扩展按键"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>9M</td>
<td>13M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.37 procmanagement</strong></p>
<p><img src="https://img-blog.csdnimg.cn/ded982d08e2a401db16c17d36111b265.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2进程管理"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>8M</td>
<td>13M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p>2.2.2.38 原生CAR</p>
<p><img src="https://img-blog.csdnimg.cn/78c3e4e6d5d343f8baf8133eac75e2e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2Car"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>21M</td>
<td>11M</td>
<td>13M</td>
<td>少量</td>
<td>少量可接受</td>
<td>暂无</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查分配大对象场景</li>
</ul>
<p><strong>2.2.2.39 设置服务端</strong></p>
<p><img src="https://img-blog.csdnimg.cn/17af6e95e7424a54b784db3ae65c732c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2设置服务端"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>9M</td>
<td>13M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.40 carlife</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/a92196692b914d2790f1bf6a0472ff13.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2Carlife"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>9M</td>
<td>12M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.41 engineMode</strong></p>
<p><img src="https://img-blog.csdnimg.cn/13bb1c8095894d60be1c4ed458d7e7c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2能量管理"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>10M</td>
<td>12M</td>
<td>暂无</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.42 氛围灯</strong></p>
<p><img src="https://img-blog.csdnimg.cn/6e90c8fe79e646e4ae5c8ba681f6716d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2氛围灯"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>9M</td>
<td>12M</td>
<td>少量可接受</td>
<td>少量可接受</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.43 devicemanager</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/fac7fe9ecb324d0ebcddaf6cc1992339.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2设备管理"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>10M</td>
<td>11M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
<li>调查部分场景分配大内存情况</li>
</ul>
<p><strong>2.2.2.44 adaptermainservice</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/ddad4a710c424d57b0f055b35857ab25.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2平台适配器old"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>9M</td>
<td>11M</td>
<td>少量</td>
<td>暂无</td>
<td>暂无</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查部分场景分配大内存情况</li>
</ul>
<p><strong>2.2.2.45 vpamultimode</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/dbc7bd55cf3d4d6f90bd1850d17581b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2VPA"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>9M</td>
<td>11M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
<li>调查部分场景分配大内存情况</li>
</ul>
<p><strong>2.2.2.46 消息中心服务端</strong></p>
<p><img src="https://img-blog.csdnimg.cn/58f6fd19570f4957bce0de8da5fe1551.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2消息中心服务端"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>18M</td>
<td>9M</td>
<td>11M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
<li>调查部分场景分配大内存情况</li>
</ul>
<p><strong>2.2.2.47 时钟同步</strong></p>
<p><img src="https://img-blog.csdnimg.cn/0c9f93e20d264c0f9967da0e3f40904d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2时钟同步"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>16M</td>
<td>8M</td>
<td>11M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.48 德赛ftpserver</strong></p>
<p><img src="https://img-blog.csdnimg.cn/6c4dfc01ac05474e99634fef16ab44c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2德赛ftpserver"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>14M</td>
<td>6M</td>
<td>11M</td>
<td>存在</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性（已经提单稳定性问题）</li>
</ul>
<p><strong>2.2.2.49 防火墙</strong></p>
<p><img src="https://img-blog.csdnimg.cn/5ca53abf53a6464dbe08b2f33d00c9b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2防火墙"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>13M</td>
<td>4M</td>
<td>11M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>需要调查图中前期的阶梯是否在启动服务</li>
</ul>
<p><strong>2.2.2.50 权限管理服务</strong></p>
<p><img src="https://img-blog.csdnimg.cn/ccb1bd38bb8543388b03184dfd4db339.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2权限管理服务"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>12M</td>
<td>5M</td>
<td>11M</td>
<td>少量可接受</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>需要调查图中前期的阶梯是否在启动服务</li>
</ul>
<p><strong>2.2.2.51 蓝牙服务</strong></p>
<p><img src="https://img-blog.csdnimg.cn/5297b10570eb4a4ab839f1cc86563e2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2蓝牙服务"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>15M</td>
<td>7M</td>
<td>10M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.52 CarAudio</strong></p>
<p><img src="https://img-blog.csdnimg.cn/f33d59c0fafc411089239727962ff970.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarAudio"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>13M</td>
<td>5M</td>
<td>10M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.53 CarScene</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20e7ad6c67bc4fdbba72a1a7faafb65a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarScene"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>14M</td>
<td>4M</td>
<td>10M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.54 Wifi服务端</strong></p>
<p><img src="https://img-blog.csdnimg.cn/dc92721d382a430bb9756e2f87daf0f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2Wifi服务端"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>12M</td>
<td>4M</td>
<td>10M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.55  CarService</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c7882a61e6a54bf9907f81aeba917102.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarService"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>17M</td>
<td>7M</td>
<td>9M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.56 DMS</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e97dda755ffa4065a779272c82519f4f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2DMS"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>14M</td>
<td>6M</td>
<td>9M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.57 GCS证书管理</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e66e55097bd24b0d9a5364d651715bb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2GCS证书管理"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>13M</td>
<td>5M</td>
<td>8M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>不上此部分代码，此部分功能由pkisdk完成</li>
</ul>
<p><strong>2.2.2.58 CarMessager</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20bd7ec3ecc4468a85ce805cdfdddf06.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarMessager"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>11M</td>
<td>3M</td>
<td>8M</td>
<td>暂无</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.59 仪表服务</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2a2ce4f7c0734534bf6e3e2593bc9506.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2仪表服务"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>15M</td>
<td>4M</td>
<td>8M</td>
<td>存在</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>调查大对象申请情况，实现对象复用</li>
</ul>
<p><strong>2.2.2.60 CarNcm</strong></p>
<p><img src="https://img-blog.csdnimg.cn/32d946368560430287d0bc96394ad82c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2CarNcm"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>12M</td>
<td>3M</td>
<td>7M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.61 德赛QnxApp</strong></p>
<p><img src="https://img-blog.csdnimg.cn/855daf404c3841a496f59fab2c81d0e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2QnxApp"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>12M</td>
<td>4M</td>
<td>7M</td>
<td>少量</td>
<td>暂无</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>图中看到存在阶梯内存，需要单独跑monkey验证稳定性</li>
</ul>
<p><strong>2.2.2.62 讯飞applist</strong></p>
<p><img src="https://img-blog.csdnimg.cn/53ca4401ca4140cdb5897da5170501d6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2讯飞applist"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>48M</td>
<td>0M</td>
<td>4M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>需要调查该应用实现什么功能，是否可以合并到其他应用中。疑似此进程用完就被杀了</li>
</ul>
<p><strong>2.2.2.63 商城</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c886df8dd0cc4e3e941f3e263acae52e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmFja091MTExMA==,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="GOS2Mall"></p>
<table>
<thead>
<tr>
<th>最大内存</th>
<th>最小内存</th>
<th>平均内存</th>
<th>内存抖动状态</th>
<th>是否内存泄露</th>
<th>是否阶梯内存</th>
</tr>
</thead>
<tbody><tr>
<td>41M</td>
<td>0M</td>
<td>3M</td>
<td>存在</td>
<td>少量</td>
<td>存在</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<ul>
<li>需要调查该应用实现什么功能，是否可以合并到其他应用中。疑似此进程用完就被杀了</li>
</ul>
<h3 id="3-车机内存性能问题总结"><a href="#3-车机内存性能问题总结" class="headerlink" title="3 车机内存性能问题总结"></a>3 车机内存性能问题总结</h3><p>从以上系统整体性能与各应用内存性能分析可以发现如下几个问题：</p>
<ul>
<li>系统总体内存在随车机运行时间加长，剩余内存逐步降低，最后触发了LMK杀进程机制</li>
<li>大部分应用内存存在内存抖动</li>
<li>大部分应用内存存在内存泄露</li>
<li>部分应用存在阶梯内存，存在稳定性问题</li>
<li>部分应用存在大内存分配情况</li>
<li>部分应用自身总体内存占用比较高</li>
</ul>
<h3 id="4-优化建议"><a href="#4-优化建议" class="headerlink" title="4.优化建议"></a>4.优化建议</h3><p>针对以上问题，请各FO参考自身应用内存图情况，选择对应的工具进行调查，修复内存问题。针对不同问题，监控调查工具建议如下：</p>
<ul>
<li><p>针对有界面的应用可以使用LeakCanary，动态检测应用是否由内存泄露</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在build.gradle中添加以下依赖即可，也可以看看参考文献3和4</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.7&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>针对内存抖动和大内存分配调查，可以使用Android Studio的Profile中memory模块来检测。使用方法见<strong>参考文献5</strong></p>
</li>
<li><p>针对服务和LeakCanary检测不出来的，可以使用MAT（Memory Analyzer Tools, MAT）,工具下载见<strong>参考文献6</strong></p>
</li>
<li><p>针对阶梯内存，存在稳定性情况，可以使用monkey, 晚上针对单个应用跑monkey</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p参数后面填入自己应用的包名</span></span><br><span class="line">monkey -p com.timanetwork.appstore --throttle 500 --bugreport --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --ignore-native-crashes --monitor-native-crashes -v -v -v 300000 1 &gt;&gt; /mnt/sdcard/Stability_base_20211023.log 2&gt;&gt; /mnt/sdcard/Stability_base_err_20211023.log &amp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h4><p><a href="https://stackoverflow.com/questions/45487506/what-is-inactivefile-and-activefile-in-proc-meminfo">1. linux - what is Inactive(file) and Active(file) in /proc/meminfo? - Stack Overflow</a></p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/s2-proc-meminfo">2. /PROC/MEMINFO description</a></p>
<p><a href="https://square.github.io/leakcanary/getting_started/">3.Getting Started - LeakCanary (square.github.io)</a></p>
<p><a href="https://github.com/square/leakcanary">4.square/leakcanary: A memory leak detection library for Android. (github.com)</a></p>
<p><a href="https://developer.android.google.cn/studio/profile/memory-profiler">5.使用内存性能分析器查看应用的内存使用情况  | Android 开发者  | Android Developers (google.cn)</a></p>
<p><a href="http://www.eclipse.org/mat/downloads.php">6.Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统优化</tag>
        <tag>整体性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm激活方法</title>
    <url>/2021/10/22/Pycharm%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-现状"><a href="#1-现状" class="headerlink" title="1.现状"></a>1.现状</h4><p><img src="https://upload-images.jianshu.io/upload_images/13838098-225902394d9aedc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="现状.jpg"></p>
<h4 id="2-先使用激活码进入软件"><a href="#2-先使用激活码进入软件" class="headerlink" title="2.先使用激活码进入软件"></a>2.先使用激活码进入软件</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">9H1390TRAK-eyJsaWNlbnNlSWQiOiI5SDEzOTBUUkFLIiwibGljZW5zZWVOYW1lIjoi5rC45LmF5r+A5rS7IHd3d8K3YWppaHVvwrdjb20iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDIxLTExLTIxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTQyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDIxLTExLTIxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIxLTExLTIxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1YiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDIxLTExLTIxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDIxLTExLTIxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUEMiLCJwYWlkVXBUbyI6IjIwMjEtMTEtMjEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwicGFpZFVwVG8iOiIyMDIxLTExLTIxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTVyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJSUyIsInBhaWRVcFRvIjoiMjAyMS0xMS0yMSIsImV4dGVuZGVkIjp0cnVlfV0sIm1ldGFkYXRhIjoiMDEyMDIxMTAyMlBQQU0wMDAwMDUiLCJoYXNoIjoiMjcxODgyMjQvMDotMTMwNTc4MjA4IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-DtQy86KmJg6qPS3qOZbmfRIQdMAZU0elaPliJSQh2JvfdB+pONnKzeLaJIXqffuYadc1/grZtXlxzS0zRr5Z2Q7v6tQiVldNPGNG3b+RHgLOC/noE9065+VMCNlGFXEYvVzCvNkOC11JWcLJiElcC4mdzMWCEGtCvV98mUP/gm6nFcMT4APLeonaTSms5FwbA22WoikNYqlsnbw/QqIoN2cPtAzFLCYryog1hwIaBnBNYiyRTD54SGZSYObpTUOa4V+CRJyl0zrO2R7dUhk/nM1tYGP2x4QXNGbxw0N3NcU6IVpaOqhpQ0n1eARcfMhDHTQEwKpOzpGigRE4QKfRFw==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCP4uk4SlVdA5nuA3DQC+NsEnZS9npFnO0zrmMWcz1++q2UWJNuGTh0rwi+3fUJIArfvVh7gNtIp93rxjtrQAuf4/Fa6sySp4c32MeFACfC0q+oUoWebhOIaYTYUxm4LAZ355vzt8YeDPmvWKxA81udqEk4gU9NNAOz1Um5/8LyR8SGsSc4EDBRSjcMWMwMkYSauGqGcEUK8WhfplsyF61lKSOFA6VmfUmeDK15rUWWLbOMKgn2cxFA98A+s74T9Oo96CU7rp/umDXvhnyhAXSukw/qCGOVhwKR8B6aeDtoBWQgjnvMtPgOUPRTPkPGbwPwwDkvAHYiuKJ7Bd2wH7rAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/wi9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD</span><br></pre></td></tr></table></figure>


<h4 id="3-之后见post文档"><a href="#3-之后见post文档" class="headerlink" title="3.之后见post文档"></a>3.之后见post文档</h4><p>主要配置FineAgent.jar</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// C:\Users\81566\AppData\Roaming\JetBrains\PyCharm2021.2\pycharm64.exe.vmoptions</span><br><span class="line">-javaagent:D:\\FineAgent.jar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>工具集</tag>
        <tag>Python IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>解决语音助理无法打开空调应用问题</title>
    <url>/2021/11/01/%E8%A7%A3%E5%86%B3%E8%AF%AD%E9%9F%B3%E5%8A%A9%E7%90%86%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%A9%BA%E8%B0%83%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>应用开发报<code>【车服务】语音“空调怎么使用”，播报的时候语音“空调怎么打开”，继续播报未跳转到“空调怎么打开”</code>问题，必现。</p>
<p>初步诊断界面或者应用拉不起来，调查方向：</p>
<ul>
<li>开发方法使用是否正确（错误可能性小，发广播方法调错的可能稍微大一点，启界面可能性小）</li>
<li>权限问题</li>
</ul>
<h3 id="2-调查"><a href="#2-调查" class="headerlink" title="2.调查"></a>2.调查</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">在NLPService接收到语助传来的数据之后，一定概率发生调用startActivity方法时报错，报错信息如下：</span><br><span class="line">2021-10-29 14:57:16.019 9414-11984/com.gxatek.cockpit.carservice W/ContextImpl: Calling a method in the system process without a qualified user: android.app.ContextImpl.startActivity:887 android.content.ContextWrapper.startActivity:379 com.gxatek.cockpit.carservice.answer.action.AnswerAction.handleAnwser:59 com.gxatek.cockpit.carservice.NLPService.onHandleIntent:135 android.app.IntentService$ServiceHandler.handleMessage:76</span><br><span class="line">2021-10-29 14:57:16.019 9414-11984/com.gxatek.cockpit.carservice W/ContextImpl: Calling a method in the system process without a qualified user: android.app.ContextImpl.startActivity:899 android.app.ContextImpl.startActivity:888 android.content.ContextWrapper.startActivity:379 com.gxatek.cockpit.carservice.answer.action.AnswerAction.handleAnwser:59 com.gxatek.cockpit.carservice.NLPService.onHandleIntent:135</span><br></pre></td></tr></table></figure>
<p>从上面日志可以看出车服务应用是一个系统应用，调用startactivity()没有资格。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">该错误信息显示，当前进程不是合法用户，此时使用命令：adb shell ps|findstr carservice查看车服务进程信息如下：</span><br><span class="line">system 9414 340 4674056 346192 ep_poll 0 S com.gxatek.cockpit.carservice</span><br></pre></td></tr></table></figure>
<p>查看carservice进程用户也是System。</p>
<p>调查方向只能追源码，看是哪里报的异常日志了。</p>
<h4 id="2-1-源码追踪"><a href="#2-1-源码追踪" class="headerlink" title="2.1 源码追踪"></a>2.1 源码追踪</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">warnIfCallingFromSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Process.myUid() == Process.SYSTEM_UID) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Calling a method in the system process without a qualified user: &quot;</span></span><br><span class="line">                    + Debug.getCallers(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityAsUser</span><span class="params">(Intent intent, UserHandle user)</span> </span>&#123;</span><br><span class="line">    startActivityAsUser(intent, <span class="keyword">null</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在启动界面的时候会调用<code>warnIfCallingFromSystemProcess()</code>去检查当前apk的用户是不是系统用户。</p>
<p>因此，需要检查CarService这个服务是不是配置了系统应用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:sharedUserId=<span class="string">&quot;android.uid.system&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先检查Manifest是否配置sharedUserId。</p>
</li>
<li><p>然后检查调用的api是否是对的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityAsUser</span><span class="params">(Intent intent, UserHandle user)</span> </span>&#123;</span><br><span class="line">    startActivityAsUser(intent, <span class="keyword">null</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><p>Android从4.2开始加入了多用户支持，在系统应用的调用中添加了用户校验，考虑到安全方面原因，限制了各个用户之间的交互内容，因此在系统应用之间调用的时候，需要指明具体的用户范围。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>问题集</tag>
        <tag>用户权限</tag>
      </tags>
  </entry>
</search>
